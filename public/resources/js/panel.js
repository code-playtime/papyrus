/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@editorjs/code/dist/code.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@editorjs/code/dist/code.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ d)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(\".ce-code__textarea{min-height:200px;font-family:Menlo,Monaco,Consolas,Courier New,monospace;color:#41314e;line-height:1.6em;font-size:12px;background:#f8f7fa;border:1px solid #f1f1f4;box-shadow:none;white-space:pre;word-wrap:normal;overflow-x:auto;resize:vertical}\")),document.head.appendChild(e)}}catch(o){console.error(\"vite-plugin-css-injected-by-js\",o)}})();\nfunction c(l, t) {\n  let a = \"\";\n  for (; a !== `\n` && t > 0; )\n    t = t - 1, a = l.substr(t, 1);\n  return a === `\n` && (t += 1), t;\n}\nconst h = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 8L5 12L9 16\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M15 8L19 12L15 16\"/></svg>';\n/**\n * CodeTool for Editor.js\n * @version 2.0.0\n * @license MIT\n */\nclass d {\n  /**\n   * Notify core that read-only mode is supported\n   * @returns true if read-only mode is supported\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Allows pressing Enter key to create line breaks inside the CodeTool textarea\n   * This enables multi-line input within the code editor.\n   * @returns true if line breaks are allowed in the textarea\n   */\n  static get enableLineBreaks() {\n    return !0;\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   * @param options - tool constricting options\n   * @param options.data — previously saved plugin code\n   * @param options.config - user config for Tool\n   * @param options.api - Editor.js API\n   * @param options.readOnly - read only mode flag\n   */\n  constructor({ data: t, config: e, api: a, readOnly: r }) {\n    this.api = a, this.readOnly = r, this.placeholder = this.api.i18n.t(e.placeholder || d.DEFAULT_PLACEHOLDER), this.CSS = {\n      baseClass: this.api.styles.block,\n      input: this.api.styles.input,\n      wrapper: \"ce-code\",\n      textarea: \"ce-code__textarea\"\n    }, this.nodes = {\n      holder: null,\n      textarea: null\n    }, this.data = {\n      code: t.code ?? \"\"\n    }, this.nodes.holder = this.drawView();\n  }\n  /**\n   * Return Tool's view\n   * @returns this.nodes.holder - Code's wrapper\n   */\n  render() {\n    return this.nodes.holder;\n  }\n  /**\n   * Extract Tool's data from the view\n   * @param codeWrapper - CodeTool's wrapper, containing textarea with code\n   * @returns - saved plugin code\n   */\n  save(t) {\n    return {\n      code: t.querySelector(\"textarea\").value\n    };\n  }\n  /**\n   * onPaste callback fired from Editor`s core\n   * @param event - event with pasted content\n   */\n  onPaste(t) {\n    const e = t.detail;\n    if (\"data\" in e) {\n      const a = e.data;\n      this.data = {\n        code: a || \"\"\n      };\n    }\n  }\n  /**\n   * Returns Tool`s data from private property\n   * @returns\n   */\n  get data() {\n    return this._data;\n  }\n  /**\n   * Set Tool`s data to private property and update view\n   * @param data - saved tool data\n   */\n  set data(t) {\n    this._data = t, this.nodes.textarea && (this.nodes.textarea.value = t.code);\n  }\n  /**\n   * Get Tool toolbox settings.\n   * Provides the icon and title to display in the toolbox for the CodeTool.\n   * @returns An object containing:\n   * - icon: SVG representation of the Tool's icon\n   * - title: Title to show in the toolbox\n   */\n  static get toolbox() {\n    return {\n      icon: h,\n      title: \"Code\"\n    };\n  }\n  /**\n   * Default placeholder for CodeTool's textarea\n   * @returns\n   */\n  static get DEFAULT_PLACEHOLDER() {\n    return \"Enter a code\";\n  }\n  /**\n   *  Used by Editor.js paste handling API.\n   *  Provides configuration to handle CODE tag.\n   * @returns\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"pre\"]\n    };\n  }\n  /**\n   * Automatic sanitize config\n   * @returns\n   */\n  static get sanitize() {\n    return {\n      code: !0\n      // Allow HTML tags\n    };\n  }\n  /**\n   * Handles Tab key pressing (adds/removes indentations)\n   * @param event - keydown\n   */\n  tabHandler(t) {\n    t.stopPropagation(), t.preventDefault();\n    const e = t.target, a = t.shiftKey, r = e.selectionStart, s = e.value, n = \"  \";\n    let i;\n    if (!a)\n      i = r + n.length, e.value = s.substring(0, r) + n + s.substring(r);\n    else {\n      const o = c(s, r);\n      if (s.substr(o, n.length) !== n)\n        return;\n      e.value = s.substring(0, o) + s.substring(o + n.length), i = r - n.length;\n    }\n    e.setSelectionRange(i, i);\n  }\n  /**\n   * Create Tool's view\n   * @returns\n   */\n  drawView() {\n    const t = document.createElement(\"div\"), e = document.createElement(\"textarea\");\n    return t.classList.add(this.CSS.baseClass, this.CSS.wrapper), e.classList.add(this.CSS.textarea, this.CSS.input), e.value = this.data.code, e.placeholder = this.placeholder, this.readOnly && (e.disabled = !0), t.appendChild(e), e.addEventListener(\"keydown\", (a) => {\n      switch (a.code) {\n        case \"Tab\":\n          this.tabHandler(a);\n          break;\n      }\n    }), this.nodes.textarea = e, t;\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2NvZGUvZGlzdC9jb2RlLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsWUFBWSxhQUFhLElBQUksd0JBQXdCLHNDQUFzQywwREFBMEQsaUJBQWlCLHdEQUF3RCxjQUFjLGtCQUFrQixlQUFlLG1CQUFtQix5QkFBeUIsZ0JBQWdCLGdCQUFnQixpQkFBaUIsZ0JBQWdCLGdCQUFnQixrQ0FBa0MsU0FBUyxtREFBbUQ7QUFDeGU7QUFDQTtBQUNBLFNBQVM7QUFDVCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUNBQXlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vbm9kZV9tb2R1bGVzL0BlZGl0b3Jqcy9jb2RlL2Rpc3QvY29kZS5tanM/YmUzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt0cnl7aWYodHlwZW9mIGRvY3VtZW50PFwidVwiKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7ZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIi5jZS1jb2RlX190ZXh0YXJlYXttaW4taGVpZ2h0OjIwMHB4O2ZvbnQtZmFtaWx5Ok1lbmxvLE1vbmFjbyxDb25zb2xhcyxDb3VyaWVyIE5ldyxtb25vc3BhY2U7Y29sb3I6IzQxMzE0ZTtsaW5lLWhlaWdodDoxLjZlbTtmb250LXNpemU6MTJweDtiYWNrZ3JvdW5kOiNmOGY3ZmE7Ym9yZGVyOjFweCBzb2xpZCAjZjFmMWY0O2JveC1zaGFkb3c6bm9uZTt3aGl0ZS1zcGFjZTpwcmU7d29yZC13cmFwOm5vcm1hbDtvdmVyZmxvdy14OmF1dG87cmVzaXplOnZlcnRpY2FsfVwiKSksZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChlKX19Y2F0Y2gobyl7Y29uc29sZS5lcnJvcihcInZpdGUtcGx1Z2luLWNzcy1pbmplY3RlZC1ieS1qc1wiLG8pfX0pKCk7XG5mdW5jdGlvbiBjKGwsIHQpIHtcbiAgbGV0IGEgPSBcIlwiO1xuICBmb3IgKDsgYSAhPT0gYFxuYCAmJiB0ID4gMDsgKVxuICAgIHQgPSB0IC0gMSwgYSA9IGwuc3Vic3RyKHQsIDEpO1xuICByZXR1cm4gYSA9PT0gYFxuYCAmJiAodCArPSAxKSwgdDtcbn1cbmNvbnN0IGggPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNOSA4TDUgMTJMOSAxNlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNSA4TDE5IDEyTDE1IDE2XCIvPjwvc3ZnPic7XG4vKipcbiAqIENvZGVUb29sIGZvciBFZGl0b3IuanNcbiAqIEB2ZXJzaW9uIDIuMC4wXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuY2xhc3MgZCB7XG4gIC8qKlxuICAgKiBOb3RpZnkgY29yZSB0aGF0IHJlYWQtb25seSBtb2RlIGlzIHN1cHBvcnRlZFxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHJlYWQtb25seSBtb2RlIGlzIHN1cHBvcnRlZFxuICAgKi9cbiAgc3RhdGljIGdldCBpc1JlYWRPbmx5U3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIHByZXNzaW5nIEVudGVyIGtleSB0byBjcmVhdGUgbGluZSBicmVha3MgaW5zaWRlIHRoZSBDb2RlVG9vbCB0ZXh0YXJlYVxuICAgKiBUaGlzIGVuYWJsZXMgbXVsdGktbGluZSBpbnB1dCB3aXRoaW4gdGhlIGNvZGUgZWRpdG9yLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIGxpbmUgYnJlYWtzIGFyZSBhbGxvd2VkIGluIHRoZSB0ZXh0YXJlYVxuICAgKi9cbiAgc3RhdGljIGdldCBlbmFibGVMaW5lQnJlYWtzKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgICogUmVuZGVyIHBsdWdpbmBzIG1haW4gRWxlbWVudCBhbmQgZmlsbCBpdCB3aXRoIHNhdmVkIGRhdGFcbiAgICogQHBhcmFtIG9wdGlvbnMgLSB0b29sIGNvbnN0cmljdGluZyBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLmRhdGEg4oCUIHByZXZpb3VzbHkgc2F2ZWQgcGx1Z2luIGNvZGVcbiAgICogQHBhcmFtIG9wdGlvbnMuY29uZmlnIC0gdXNlciBjb25maWcgZm9yIFRvb2xcbiAgICogQHBhcmFtIG9wdGlvbnMuYXBpIC0gRWRpdG9yLmpzIEFQSVxuICAgKiBAcGFyYW0gb3B0aW9ucy5yZWFkT25seSAtIHJlYWQgb25seSBtb2RlIGZsYWdcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgZGF0YTogdCwgY29uZmlnOiBlLCBhcGk6IGEsIHJlYWRPbmx5OiByIH0pIHtcbiAgICB0aGlzLmFwaSA9IGEsIHRoaXMucmVhZE9ubHkgPSByLCB0aGlzLnBsYWNlaG9sZGVyID0gdGhpcy5hcGkuaTE4bi50KGUucGxhY2Vob2xkZXIgfHwgZC5ERUZBVUxUX1BMQUNFSE9MREVSKSwgdGhpcy5DU1MgPSB7XG4gICAgICBiYXNlQ2xhc3M6IHRoaXMuYXBpLnN0eWxlcy5ibG9jayxcbiAgICAgIGlucHV0OiB0aGlzLmFwaS5zdHlsZXMuaW5wdXQsXG4gICAgICB3cmFwcGVyOiBcImNlLWNvZGVcIixcbiAgICAgIHRleHRhcmVhOiBcImNlLWNvZGVfX3RleHRhcmVhXCJcbiAgICB9LCB0aGlzLm5vZGVzID0ge1xuICAgICAgaG9sZGVyOiBudWxsLFxuICAgICAgdGV4dGFyZWE6IG51bGxcbiAgICB9LCB0aGlzLmRhdGEgPSB7XG4gICAgICBjb2RlOiB0LmNvZGUgPz8gXCJcIlxuICAgIH0sIHRoaXMubm9kZXMuaG9sZGVyID0gdGhpcy5kcmF3VmlldygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVG9vbCdzIHZpZXdcbiAgICogQHJldHVybnMgdGhpcy5ub2Rlcy5ob2xkZXIgLSBDb2RlJ3Mgd3JhcHBlclxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmhvbGRlcjtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdCBUb29sJ3MgZGF0YSBmcm9tIHRoZSB2aWV3XG4gICAqIEBwYXJhbSBjb2RlV3JhcHBlciAtIENvZGVUb29sJ3Mgd3JhcHBlciwgY29udGFpbmluZyB0ZXh0YXJlYSB3aXRoIGNvZGVcbiAgICogQHJldHVybnMgLSBzYXZlZCBwbHVnaW4gY29kZVxuICAgKi9cbiAgc2F2ZSh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IHQucXVlcnlTZWxlY3RvcihcInRleHRhcmVhXCIpLnZhbHVlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogb25QYXN0ZSBjYWxsYmFjayBmaXJlZCBmcm9tIEVkaXRvcmBzIGNvcmVcbiAgICogQHBhcmFtIGV2ZW50IC0gZXZlbnQgd2l0aCBwYXN0ZWQgY29udGVudFxuICAgKi9cbiAgb25QYXN0ZSh0KSB7XG4gICAgY29uc3QgZSA9IHQuZGV0YWlsO1xuICAgIGlmIChcImRhdGFcIiBpbiBlKSB7XG4gICAgICBjb25zdCBhID0gZS5kYXRhO1xuICAgICAgdGhpcy5kYXRhID0ge1xuICAgICAgICBjb2RlOiBhIHx8IFwiXCJcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIFRvb2xgcyBkYXRhIGZyb20gcHJpdmF0ZSBwcm9wZXJ0eVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBUb29sYHMgZGF0YSB0byBwcml2YXRlIHByb3BlcnR5IGFuZCB1cGRhdGUgdmlld1xuICAgKiBAcGFyYW0gZGF0YSAtIHNhdmVkIHRvb2wgZGF0YVxuICAgKi9cbiAgc2V0IGRhdGEodCkge1xuICAgIHRoaXMuX2RhdGEgPSB0LCB0aGlzLm5vZGVzLnRleHRhcmVhICYmICh0aGlzLm5vZGVzLnRleHRhcmVhLnZhbHVlID0gdC5jb2RlKTtcbiAgfVxuICAvKipcbiAgICogR2V0IFRvb2wgdG9vbGJveCBzZXR0aW5ncy5cbiAgICogUHJvdmlkZXMgdGhlIGljb24gYW5kIHRpdGxlIHRvIGRpc3BsYXkgaW4gdGhlIHRvb2xib3ggZm9yIHRoZSBDb2RlVG9vbC5cbiAgICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmc6XG4gICAqIC0gaWNvbjogU1ZHIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBUb29sJ3MgaWNvblxuICAgKiAtIHRpdGxlOiBUaXRsZSB0byBzaG93IGluIHRoZSB0b29sYm94XG4gICAqL1xuICBzdGF0aWMgZ2V0IHRvb2xib3goKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGljb246IGgsXG4gICAgICB0aXRsZTogXCJDb2RlXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBEZWZhdWx0IHBsYWNlaG9sZGVyIGZvciBDb2RlVG9vbCdzIHRleHRhcmVhXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBzdGF0aWMgZ2V0IERFRkFVTFRfUExBQ0VIT0xERVIoKSB7XG4gICAgcmV0dXJuIFwiRW50ZXIgYSBjb2RlXCI7XG4gIH1cbiAgLyoqXG4gICAqICBVc2VkIGJ5IEVkaXRvci5qcyBwYXN0ZSBoYW5kbGluZyBBUEkuXG4gICAqICBQcm92aWRlcyBjb25maWd1cmF0aW9uIHRvIGhhbmRsZSBDT0RFIHRhZy5cbiAgICogQHJldHVybnNcbiAgICovXG4gIHN0YXRpYyBnZXQgcGFzdGVDb25maWcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZ3M6IFtcInByZVwiXVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEF1dG9tYXRpYyBzYW5pdGl6ZSBjb25maWdcbiAgICogQHJldHVybnNcbiAgICovXG4gIHN0YXRpYyBnZXQgc2FuaXRpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6ICEwXG4gICAgICAvLyBBbGxvdyBIVE1MIHRhZ3NcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIFRhYiBrZXkgcHJlc3NpbmcgKGFkZHMvcmVtb3ZlcyBpbmRlbnRhdGlvbnMpXG4gICAqIEBwYXJhbSBldmVudCAtIGtleWRvd25cbiAgICovXG4gIHRhYkhhbmRsZXIodCkge1xuICAgIHQuc3RvcFByb3BhZ2F0aW9uKCksIHQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBlID0gdC50YXJnZXQsIGEgPSB0LnNoaWZ0S2V5LCByID0gZS5zZWxlY3Rpb25TdGFydCwgcyA9IGUudmFsdWUsIG4gPSBcIiAgXCI7XG4gICAgbGV0IGk7XG4gICAgaWYgKCFhKVxuICAgICAgaSA9IHIgKyBuLmxlbmd0aCwgZS52YWx1ZSA9IHMuc3Vic3RyaW5nKDAsIHIpICsgbiArIHMuc3Vic3RyaW5nKHIpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbyA9IGMocywgcik7XG4gICAgICBpZiAocy5zdWJzdHIobywgbi5sZW5ndGgpICE9PSBuKVxuICAgICAgICByZXR1cm47XG4gICAgICBlLnZhbHVlID0gcy5zdWJzdHJpbmcoMCwgbykgKyBzLnN1YnN0cmluZyhvICsgbi5sZW5ndGgpLCBpID0gciAtIG4ubGVuZ3RoO1xuICAgIH1cbiAgICBlLnNldFNlbGVjdGlvblJhbmdlKGksIGkpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgVG9vbCdzIHZpZXdcbiAgICogQHJldHVybnNcbiAgICovXG4gIGRyYXdWaWV3KCkge1xuICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xuICAgIHJldHVybiB0LmNsYXNzTGlzdC5hZGQodGhpcy5DU1MuYmFzZUNsYXNzLCB0aGlzLkNTUy53cmFwcGVyKSwgZS5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLnRleHRhcmVhLCB0aGlzLkNTUy5pbnB1dCksIGUudmFsdWUgPSB0aGlzLmRhdGEuY29kZSwgZS5wbGFjZWhvbGRlciA9IHRoaXMucGxhY2Vob2xkZXIsIHRoaXMucmVhZE9ubHkgJiYgKGUuZGlzYWJsZWQgPSAhMCksIHQuYXBwZW5kQ2hpbGQoZSksIGUuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGEpID0+IHtcbiAgICAgIHN3aXRjaCAoYS5jb2RlKSB7XG4gICAgICAgIGNhc2UgXCJUYWJcIjpcbiAgICAgICAgICB0aGlzLnRhYkhhbmRsZXIoYSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSksIHRoaXMubm9kZXMudGV4dGFyZWEgPSBlLCB0O1xuICB9XG59XG5leHBvcnQge1xuICBkIGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@editorjs/code/dist/code.mjs\n\n}");

/***/ }),

/***/ "./node_modules/@editorjs/delimiter/dist/delimiter.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@editorjs/delimiter/dist/delimiter.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ n)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode('.ce-delimiter{line-height:1.6em;width:100%;text-align:center}.ce-delimiter:before{display:inline-block;content:\"***\";font-size:30px;line-height:65px;height:30px;letter-spacing:.2em}')),document.head.appendChild(e)}}catch(t){console.error(\"vite-plugin-css-injected-by-js\",t)}})();\nconst r = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><line x1=\"6\" x2=\"10\" y1=\"12\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"14\" x2=\"18\" y1=\"12\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/></svg>';\n/**\n * Delimiter Block for the Editor.js.\n *\n * @author CodeX (team@ifmo.su)\n * @copyright CodeX 2018\n * @license The MIT License (MIT)\n * @version 2.0.0\n */\nclass n {\n  /**\n   * Notify core that read-only mode is supported\n   * @return {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Allow Tool to have no content\n   * @return {boolean}\n   */\n  static get contentless() {\n    return !0;\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {{data: DelimiterData, config: object, api: object}}\n   *   data — previously saved data\n   *   config - user config for Tool\n   *   api - Editor.js API\n   */\n  constructor({ data: t, config: s, api: e }) {\n    this.api = e, this._CSS = {\n      block: this.api.styles.block,\n      wrapper: \"ce-delimiter\"\n    }, this._element = this.drawView(), this.data = t;\n  }\n  /**\n   * Create Tool's view\n   * @return {HTMLDivElement}\n   * @private\n   */\n  drawView() {\n    let t = document.createElement(\"div\");\n    return t.classList.add(this._CSS.wrapper, this._CSS.block), t;\n  }\n  /**\n   * Return Tool's view\n   * @returns {HTMLDivElement}\n   * @public\n   */\n  render() {\n    return this._element;\n  }\n  /**\n   * Extract Tool's data from the view\n   * @param {HTMLDivElement} toolsContent - Paragraph tools rendered view\n   * @returns {DelimiterData} - saved data\n   * @public\n   */\n  save(t) {\n    return {};\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   *\n   * @return {{icon: string, title: string}}\n   */\n  static get toolbox() {\n    return {\n      icon: r,\n      title: \"Delimiter\"\n    };\n  }\n  /**\n   * Delimiter onPaste configuration\n   *\n   * @public\n   */\n  static get pasteConfig() {\n    return { tags: [\"HR\"] };\n  }\n  /**\n   * On paste callback that is fired from Editor\n   *\n   * @param {PasteEvent} event - event with pasted data\n   */\n  onPaste(t) {\n    this.data = {};\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2RlbGltaXRlci9kaXN0L2RlbGltaXRlci5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFlBQVksYUFBYSxJQUFJLHdCQUF3QixzQ0FBc0MscURBQXFELGtCQUFrQixXQUFXLGtCQUFrQixxQkFBcUIscUJBQXFCLGNBQWMsZUFBZSxpQkFBaUIsWUFBWSxvQkFBb0Isa0NBQWtDLFNBQVMsbURBQW1EO0FBQ3JaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vbm9kZV9tb2R1bGVzL0BlZGl0b3Jqcy9kZWxpbWl0ZXIvZGlzdC9kZWxpbWl0ZXIubWpzP2EzNzEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dHJ5e2lmKHR5cGVvZiBkb2N1bWVudDxcInVcIil7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO2UuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJy5jZS1kZWxpbWl0ZXJ7bGluZS1oZWlnaHQ6MS42ZW07d2lkdGg6MTAwJTt0ZXh0LWFsaWduOmNlbnRlcn0uY2UtZGVsaW1pdGVyOmJlZm9yZXtkaXNwbGF5OmlubGluZS1ibG9jaztjb250ZW50OlwiKioqXCI7Zm9udC1zaXplOjMwcHg7bGluZS1oZWlnaHQ6NjVweDtoZWlnaHQ6MzBweDtsZXR0ZXItc3BhY2luZzouMmVtfScpKSxkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGUpfX1jYXRjaCh0KXtjb25zb2xlLmVycm9yKFwidml0ZS1wbHVnaW4tY3NzLWluamVjdGVkLWJ5LWpzXCIsdCl9fSkoKTtcbmNvbnN0IHIgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGxpbmUgeDE9XCI2XCIgeDI9XCIxMFwiIHkxPVwiMTJcIiB5Mj1cIjEyXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PGxpbmUgeDE9XCIxNFwiIHgyPVwiMThcIiB5MT1cIjEyXCIgeTI9XCIxMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIvPjwvc3ZnPic7XG4vKipcbiAqIERlbGltaXRlciBCbG9jayBmb3IgdGhlIEVkaXRvci5qcy5cbiAqXG4gKiBAYXV0aG9yIENvZGVYICh0ZWFtQGlmbW8uc3UpXG4gKiBAY29weXJpZ2h0IENvZGVYIDIwMThcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogQHZlcnNpb24gMi4wLjBcbiAqL1xuY2xhc3MgbiB7XG4gIC8qKlxuICAgKiBOb3RpZnkgY29yZSB0aGF0IHJlYWQtb25seSBtb2RlIGlzIHN1cHBvcnRlZFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGdldCBpc1JlYWRPbmx5U3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgICogQWxsb3cgVG9vbCB0byBoYXZlIG5vIGNvbnRlbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgY29udGVudGxlc3MoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXIgcGx1Z2luYHMgbWFpbiBFbGVtZW50IGFuZCBmaWxsIGl0IHdpdGggc2F2ZWQgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge3tkYXRhOiBEZWxpbWl0ZXJEYXRhLCBjb25maWc6IG9iamVjdCwgYXBpOiBvYmplY3R9fVxuICAgKiAgIGRhdGEg4oCUIHByZXZpb3VzbHkgc2F2ZWQgZGF0YVxuICAgKiAgIGNvbmZpZyAtIHVzZXIgY29uZmlnIGZvciBUb29sXG4gICAqICAgYXBpIC0gRWRpdG9yLmpzIEFQSVxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBkYXRhOiB0LCBjb25maWc6IHMsIGFwaTogZSB9KSB7XG4gICAgdGhpcy5hcGkgPSBlLCB0aGlzLl9DU1MgPSB7XG4gICAgICBibG9jazogdGhpcy5hcGkuc3R5bGVzLmJsb2NrLFxuICAgICAgd3JhcHBlcjogXCJjZS1kZWxpbWl0ZXJcIlxuICAgIH0sIHRoaXMuX2VsZW1lbnQgPSB0aGlzLmRyYXdWaWV3KCksIHRoaXMuZGF0YSA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBUb29sJ3Mgdmlld1xuICAgKiBAcmV0dXJuIHtIVE1MRGl2RWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRyYXdWaWV3KCkge1xuICAgIGxldCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICByZXR1cm4gdC5jbGFzc0xpc3QuYWRkKHRoaXMuX0NTUy53cmFwcGVyLCB0aGlzLl9DU1MuYmxvY2spLCB0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVG9vbCdzIHZpZXdcbiAgICogQHJldHVybnMge0hUTUxEaXZFbGVtZW50fVxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3QgVG9vbCdzIGRhdGEgZnJvbSB0aGUgdmlld1xuICAgKiBAcGFyYW0ge0hUTUxEaXZFbGVtZW50fSB0b29sc0NvbnRlbnQgLSBQYXJhZ3JhcGggdG9vbHMgcmVuZGVyZWQgdmlld1xuICAgKiBAcmV0dXJucyB7RGVsaW1pdGVyRGF0YX0gLSBzYXZlZCBkYXRhXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNhdmUodCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICAvKipcbiAgICogR2V0IFRvb2wgdG9vbGJveCBzZXR0aW5nc1xuICAgKiBpY29uIC0gVG9vbCBpY29uJ3MgU1ZHXG4gICAqIHRpdGxlIC0gdGl0bGUgdG8gc2hvdyBpbiB0b29sYm94XG4gICAqXG4gICAqIEByZXR1cm4ge3tpY29uOiBzdHJpbmcsIHRpdGxlOiBzdHJpbmd9fVxuICAgKi9cbiAgc3RhdGljIGdldCB0b29sYm94KCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiByLFxuICAgICAgdGl0bGU6IFwiRGVsaW1pdGVyXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBEZWxpbWl0ZXIgb25QYXN0ZSBjb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHN0YXRpYyBnZXQgcGFzdGVDb25maWcoKSB7XG4gICAgcmV0dXJuIHsgdGFnczogW1wiSFJcIl0gfTtcbiAgfVxuICAvKipcbiAgICogT24gcGFzdGUgY2FsbGJhY2sgdGhhdCBpcyBmaXJlZCBmcm9tIEVkaXRvclxuICAgKlxuICAgKiBAcGFyYW0ge1Bhc3RlRXZlbnR9IGV2ZW50IC0gZXZlbnQgd2l0aCBwYXN0ZWQgZGF0YVxuICAgKi9cbiAgb25QYXN0ZSh0KSB7XG4gICAgdGhpcy5kYXRhID0ge307XG4gIH1cbn1cbmV4cG9ydCB7XG4gIG4gYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@editorjs/delimiter/dist/delimiter.mjs\n\n}");

/***/ }),

/***/ "./node_modules/@editorjs/editorjs/dist/editorjs.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@editorjs/editorjs/dist/editorjs.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Aa)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(\".ce-hint--align-start{text-align:left}.ce-hint--align-center{text-align:center}.ce-hint__description{opacity:.6;margin-top:3px}\")),document.head.appendChild(e)}}catch(t){console.error(\"vite-plugin-css-injected-by-js\",t)}})();\nvar Ce = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction Ke(n) {\n  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, \"default\") ? n.default : n;\n}\nfunction Xn(n) {\n  if (n.__esModule)\n    return n;\n  var e = n.default;\n  if (typeof e == \"function\") {\n    var t = function o() {\n      return this instanceof o ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);\n    };\n    t.prototype = e.prototype;\n  } else\n    t = {};\n  return Object.defineProperty(t, \"__esModule\", { value: !0 }), Object.keys(n).forEach(function(o) {\n    var i = Object.getOwnPropertyDescriptor(n, o);\n    Object.defineProperty(t, o, i.get ? i : {\n      enumerable: !0,\n      get: function() {\n        return n[o];\n      }\n    });\n  }), t;\n}\nfunction ot() {\n}\nObject.assign(ot, {\n  default: ot,\n  register: ot,\n  revert: function() {\n  },\n  __esModule: !0\n});\nElement.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(n) {\n  const e = (this.document || this.ownerDocument).querySelectorAll(n);\n  let t = e.length;\n  for (; --t >= 0 && e.item(t) !== this; )\n    ;\n  return t > -1;\n});\nElement.prototype.closest || (Element.prototype.closest = function(n) {\n  let e = this;\n  if (!document.documentElement.contains(e))\n    return null;\n  do {\n    if (e.matches(n))\n      return e;\n    e = e.parentElement || e.parentNode;\n  } while (e !== null);\n  return null;\n});\nElement.prototype.prepend || (Element.prototype.prepend = function(e) {\n  const t = document.createDocumentFragment();\n  Array.isArray(e) || (e = [e]), e.forEach((o) => {\n    const i = o instanceof Node;\n    t.appendChild(i ? o : document.createTextNode(o));\n  }), this.insertBefore(t, this.firstChild);\n});\nElement.prototype.scrollIntoViewIfNeeded || (Element.prototype.scrollIntoViewIfNeeded = function(n) {\n  n = arguments.length === 0 ? !0 : !!n;\n  const e = this.parentNode, t = window.getComputedStyle(e, null), o = parseInt(t.getPropertyValue(\"border-top-width\")), i = parseInt(t.getPropertyValue(\"border-left-width\")), s = this.offsetTop - e.offsetTop < e.scrollTop, r = this.offsetTop - e.offsetTop + this.clientHeight - o > e.scrollTop + e.clientHeight, a = this.offsetLeft - e.offsetLeft < e.scrollLeft, l = this.offsetLeft - e.offsetLeft + this.clientWidth - i > e.scrollLeft + e.clientWidth, c = s && !r;\n  (s || r) && n && (e.scrollTop = this.offsetTop - e.offsetTop - e.clientHeight / 2 - o + this.clientHeight / 2), (a || l) && n && (e.scrollLeft = this.offsetLeft - e.offsetLeft - e.clientWidth / 2 - i + this.clientWidth / 2), (s || r || a || l) && !n && this.scrollIntoView(c);\n});\nwindow.requestIdleCallback = window.requestIdleCallback || function(n) {\n  const e = Date.now();\n  return setTimeout(function() {\n    n({\n      didTimeout: !1,\n      timeRemaining: function() {\n        return Math.max(0, 50 - (Date.now() - e));\n      }\n    });\n  }, 1);\n};\nwindow.cancelIdleCallback = window.cancelIdleCallback || function(n) {\n  clearTimeout(n);\n};\nlet Vn = (n = 21) => crypto.getRandomValues(new Uint8Array(n)).reduce((e, t) => (t &= 63, t < 36 ? e += t.toString(36) : t < 62 ? e += (t - 26).toString(36).toUpperCase() : t > 62 ? e += \"-\" : e += \"_\", e), \"\");\nvar Lo = /* @__PURE__ */ ((n) => (n.VERBOSE = \"VERBOSE\", n.INFO = \"INFO\", n.WARN = \"WARN\", n.ERROR = \"ERROR\", n))(Lo || {});\nconst y = {\n  BACKSPACE: 8,\n  TAB: 9,\n  ENTER: 13,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  ESC: 27,\n  SPACE: 32,\n  LEFT: 37,\n  UP: 38,\n  DOWN: 40,\n  RIGHT: 39,\n  DELETE: 46,\n  META: 91,\n  SLASH: 191\n}, qn = {\n  LEFT: 0,\n  WHEEL: 1,\n  RIGHT: 2,\n  BACKWARD: 3,\n  FORWARD: 4\n};\nfunction Ie(n, e, t = \"log\", o, i = \"color: inherit\") {\n  if (!(\"console\" in window) || !window.console[t])\n    return;\n  const s = [\"info\", \"log\", \"warn\", \"error\"].includes(t), r = [];\n  switch (Ie.logLevel) {\n    case \"ERROR\":\n      if (t !== \"error\")\n        return;\n      break;\n    case \"WARN\":\n      if (![\"error\", \"warn\"].includes(t))\n        return;\n      break;\n    case \"INFO\":\n      if (!s || n)\n        return;\n      break;\n  }\n  o && r.push(o);\n  const a = \"Editor.js 2.31.0-rc.7\", l = `line-height: 1em;\n            color: #006FEA;\n            display: inline-block;\n            font-size: 11px;\n            line-height: 1em;\n            background-color: #fff;\n            padding: 4px 9px;\n            border-radius: 30px;\n            border: 1px solid rgba(56, 138, 229, 0.16);\n            margin: 4px 5px 4px 0;`;\n  n && (s ? (r.unshift(l, i), e = `%c${a}%c ${e}`) : e = `( ${a} )${e}`);\n  try {\n    s ? o ? console[t](`${e} %o`, ...r) : console[t](e, ...r) : console[t](e);\n  } catch {\n  }\n}\nIe.logLevel = \"VERBOSE\";\nfunction Zn(n) {\n  Ie.logLevel = n;\n}\nconst S = Ie.bind(window, !1), X = Ie.bind(window, !0);\nfunction le(n) {\n  return Object.prototype.toString.call(n).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n}\nfunction A(n) {\n  return le(n) === \"function\" || le(n) === \"asyncfunction\";\n}\nfunction D(n) {\n  return le(n) === \"object\";\n}\nfunction te(n) {\n  return le(n) === \"string\";\n}\nfunction Gn(n) {\n  return le(n) === \"boolean\";\n}\nfunction yo(n) {\n  return le(n) === \"number\";\n}\nfunction wo(n) {\n  return le(n) === \"undefined\";\n}\nfunction V(n) {\n  return n ? Object.keys(n).length === 0 && n.constructor === Object : !0;\n}\nfunction Po(n) {\n  return n > 47 && n < 58 || // number keys\n  n === 32 || n === 13 || // Space bar & return key(s)\n  n === 229 || // processing key input for certain languages — Chinese, Japanese, etc.\n  n > 64 && n < 91 || // letter keys\n  n > 95 && n < 112 || // Numpad keys\n  n > 185 && n < 193 || // ;=,-./` (in order)\n  n > 218 && n < 223;\n}\nasync function Qn(n, e = () => {\n}, t = () => {\n}) {\n  async function o(i, s, r) {\n    try {\n      await i.function(i.data), await s(wo(i.data) ? {} : i.data);\n    } catch {\n      r(wo(i.data) ? {} : i.data);\n    }\n  }\n  return n.reduce(async (i, s) => (await i, o(s, e, t)), Promise.resolve());\n}\nfunction No(n) {\n  return Array.prototype.slice.call(n);\n}\nfunction Fe(n, e) {\n  return function() {\n    const t = this, o = arguments;\n    window.setTimeout(() => n.apply(t, o), e);\n  };\n}\nfunction Jn(n) {\n  return n.name.split(\".\").pop();\n}\nfunction ei(n) {\n  return /^[-\\w]+\\/([-+\\w]+|\\*)$/.test(n);\n}\nfunction Eo(n, e, t) {\n  let o;\n  return (...i) => {\n    const s = this, r = () => {\n      o = null, t || n.apply(s, i);\n    }, a = t && !o;\n    window.clearTimeout(o), o = window.setTimeout(r, e), a && n.apply(s, i);\n  };\n}\nfunction dt(n, e, t = void 0) {\n  let o, i, s, r = null, a = 0;\n  t || (t = {});\n  const l = function() {\n    a = t.leading === !1 ? 0 : Date.now(), r = null, s = n.apply(o, i), r || (o = i = null);\n  };\n  return function() {\n    const c = Date.now();\n    !a && t.leading === !1 && (a = c);\n    const u = e - (c - a);\n    return o = this, i = arguments, u <= 0 || u > e ? (r && (clearTimeout(r), r = null), a = c, s = n.apply(o, i), r || (o = i = null)) : !r && t.trailing !== !1 && (r = setTimeout(l, u)), s;\n  };\n}\nfunction ti() {\n  const n = {\n    win: !1,\n    mac: !1,\n    x11: !1,\n    linux: !1\n  }, e = Object.keys(n).find((t) => window.navigator.appVersion.toLowerCase().indexOf(t) !== -1);\n  return e && (n[e] = !0), n;\n}\nfunction je(n) {\n  return n[0].toUpperCase() + n.slice(1);\n}\nfunction ut(n, ...e) {\n  if (!e.length)\n    return n;\n  const t = e.shift();\n  if (D(n) && D(t))\n    for (const o in t)\n      D(t[o]) ? (n[o] || Object.assign(n, { [o]: {} }), ut(n[o], t[o])) : Object.assign(n, { [o]: t[o] });\n  return ut(n, ...e);\n}\nfunction vt(n) {\n  const e = ti();\n  return n = n.replace(/shift/gi, \"⇧\").replace(/backspace/gi, \"⌫\").replace(/enter/gi, \"⏎\").replace(/up/gi, \"↑\").replace(/left/gi, \"→\").replace(/down/gi, \"↓\").replace(/right/gi, \"←\").replace(/escape/gi, \"⎋\").replace(/insert/gi, \"Ins\").replace(/delete/gi, \"␡\").replace(/\\+/gi, \" + \"), e.mac ? n = n.replace(/ctrl|cmd/gi, \"⌘\").replace(/alt/gi, \"⌥\") : n = n.replace(/cmd/gi, \"Ctrl\").replace(/windows/gi, \"WIN\"), n;\n}\nfunction oi(n) {\n  try {\n    return new URL(n).href;\n  } catch {\n  }\n  return n.substring(0, 2) === \"//\" ? window.location.protocol + n : window.location.origin + n;\n}\nfunction ni() {\n  return Vn(10);\n}\nfunction ii(n) {\n  window.open(n, \"_blank\");\n}\nfunction si(n = \"\") {\n  return `${n}${Math.floor(Math.random() * 1e8).toString(16)}`;\n}\nfunction ht(n, e, t) {\n  const o = `«${e}» is deprecated and will be removed in the next major release. Please use the «${t}» instead.`;\n  n && X(o, \"warn\");\n}\nfunction me(n, e, t) {\n  const o = t.value ? \"value\" : \"get\", i = t[o], s = `#${e}Cache`;\n  if (t[o] = function(...r) {\n    return this[s] === void 0 && (this[s] = i.apply(this, ...r)), this[s];\n  }, o === \"get\" && t.set) {\n    const r = t.set;\n    t.set = function(a) {\n      delete n[s], r.apply(this, a);\n    };\n  }\n  return t;\n}\nconst Ro = 650;\nfunction be() {\n  return window.matchMedia(`(max-width: ${Ro}px)`).matches;\n}\nconst pt = typeof window < \"u\" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === \"MacIntel\" && window.navigator.maxTouchPoints > 1);\nfunction ri(n, e) {\n  const t = Array.isArray(n) || D(n), o = Array.isArray(e) || D(e);\n  return t || o ? JSON.stringify(n) === JSON.stringify(e) : n === e;\n}\nclass d {\n  /**\n   * Check if passed tag has no closed tag\n   *\n   * @param {HTMLElement} tag - element to check\n   * @returns {boolean}\n   */\n  static isSingleTag(e) {\n    return e.tagName && [\n      \"AREA\",\n      \"BASE\",\n      \"BR\",\n      \"COL\",\n      \"COMMAND\",\n      \"EMBED\",\n      \"HR\",\n      \"IMG\",\n      \"INPUT\",\n      \"KEYGEN\",\n      \"LINK\",\n      \"META\",\n      \"PARAM\",\n      \"SOURCE\",\n      \"TRACK\",\n      \"WBR\"\n    ].includes(e.tagName);\n  }\n  /**\n   * Check if element is BR or WBR\n   *\n   * @param {HTMLElement} element - element to check\n   * @returns {boolean}\n   */\n  static isLineBreakTag(e) {\n    return e && e.tagName && [\n      \"BR\",\n      \"WBR\"\n    ].includes(e.tagName);\n  }\n  /**\n   * Helper for making Elements with class name and attributes\n   *\n   * @param  {string} tagName - new Element tag name\n   * @param  {string[]|string} [classNames] - list or name of CSS class name(s)\n   * @param  {object} [attributes] - any attributes\n   * @returns {HTMLElement}\n   */\n  static make(e, t = null, o = {}) {\n    const i = document.createElement(e);\n    if (Array.isArray(t)) {\n      const s = t.filter((r) => r !== void 0);\n      i.classList.add(...s);\n    } else\n      t && i.classList.add(t);\n    for (const s in o)\n      Object.prototype.hasOwnProperty.call(o, s) && (i[s] = o[s]);\n    return i;\n  }\n  /**\n   * Creates Text Node with the passed content\n   *\n   * @param {string} content - text content\n   * @returns {Text}\n   */\n  static text(e) {\n    return document.createTextNode(e);\n  }\n  /**\n   * Append one or several elements to the parent\n   *\n   * @param  {Element|DocumentFragment} parent - where to append\n   * @param  {Element|Element[]|DocumentFragment|Text|Text[]} elements - element or elements list\n   */\n  static append(e, t) {\n    Array.isArray(t) ? t.forEach((o) => e.appendChild(o)) : e.appendChild(t);\n  }\n  /**\n   * Append element or a couple to the beginning of the parent elements\n   *\n   * @param {Element} parent - where to append\n   * @param {Element|Element[]} elements - element or elements list\n   */\n  static prepend(e, t) {\n    Array.isArray(t) ? (t = t.reverse(), t.forEach((o) => e.prepend(o))) : e.prepend(t);\n  }\n  /**\n   * Swap two elements in parent\n   *\n   * @param {HTMLElement} el1 - from\n   * @param {HTMLElement} el2 - to\n   * @deprecated\n   */\n  static swap(e, t) {\n    const o = document.createElement(\"div\"), i = e.parentNode;\n    i.insertBefore(o, e), i.insertBefore(e, t), i.insertBefore(t, o), i.removeChild(o);\n  }\n  /**\n   * Selector Decorator\n   *\n   * Returns first match\n   *\n   * @param {Element} el - element we searching inside. Default - DOM Document\n   * @param {string} selector - searching string\n   * @returns {Element}\n   */\n  static find(e = document, t) {\n    return e.querySelector(t);\n  }\n  /**\n   * Get Element by Id\n   *\n   * @param {string} id - id to find\n   * @returns {HTMLElement | null}\n   */\n  static get(e) {\n    return document.getElementById(e);\n  }\n  /**\n   * Selector Decorator.\n   *\n   * Returns all matches\n   *\n   * @param {Element|Document} el - element we searching inside. Default - DOM Document\n   * @param {string} selector - searching string\n   * @returns {NodeList}\n   */\n  static findAll(e = document, t) {\n    return e.querySelectorAll(t);\n  }\n  /**\n   * Returns CSS selector for all text inputs\n   */\n  static get allInputsSelector() {\n    return \"[contenteditable=true], textarea, input:not([type]), \" + [\"text\", \"password\", \"email\", \"number\", \"search\", \"tel\", \"url\"].map((t) => `input[type=\"${t}\"]`).join(\", \");\n  }\n  /**\n   * Find all contenteditable, textarea and editable input elements passed holder contains\n   *\n   * @param holder - element where to find inputs\n   */\n  static findAllInputs(e) {\n    return No(e.querySelectorAll(d.allInputsSelector)).reduce((t, o) => d.isNativeInput(o) || d.containsOnlyInlineElements(o) ? [...t, o] : [...t, ...d.getDeepestBlockElements(o)], []);\n  }\n  /**\n   * Search for deepest node which is Leaf.\n   * Leaf is the vertex that doesn't have any child nodes\n   *\n   * @description Method recursively goes throw the all Node until it finds the Leaf\n   * @param {Node} node - root Node. From this vertex we start Deep-first search\n   *                      {@link https://en.wikipedia.org/wiki/Depth-first_search}\n   * @param {boolean} [atLast] - find last text node\n   * @returns - it can be text Node or Element Node, so that caret will able to work with it\n   *            Can return null if node is Document or DocumentFragment, or node is not attached to the DOM\n   */\n  static getDeepestNode(e, t = !1) {\n    const o = t ? \"lastChild\" : \"firstChild\", i = t ? \"previousSibling\" : \"nextSibling\";\n    if (e && e.nodeType === Node.ELEMENT_NODE && e[o]) {\n      let s = e[o];\n      if (d.isSingleTag(s) && !d.isNativeInput(s) && !d.isLineBreakTag(s))\n        if (s[i])\n          s = s[i];\n        else if (s.parentNode[i])\n          s = s.parentNode[i];\n        else\n          return s.parentNode;\n      return this.getDeepestNode(s, t);\n    }\n    return e;\n  }\n  /**\n   * Check if object is DOM node\n   *\n   * @param {*} node - object to check\n   * @returns {boolean}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isElement(e) {\n    return yo(e) ? !1 : e && e.nodeType && e.nodeType === Node.ELEMENT_NODE;\n  }\n  /**\n   * Check if object is DocumentFragment node\n   *\n   * @param {object} node - object to check\n   * @returns {boolean}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isFragment(e) {\n    return yo(e) ? !1 : e && e.nodeType && e.nodeType === Node.DOCUMENT_FRAGMENT_NODE;\n  }\n  /**\n   * Check if passed element is contenteditable\n   *\n   * @param {HTMLElement} element - html element to check\n   * @returns {boolean}\n   */\n  static isContentEditable(e) {\n    return e.contentEditable === \"true\";\n  }\n  /**\n   * Checks target if it is native input\n   *\n   * @param {*} target - HTML element or string\n   * @returns {boolean}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isNativeInput(e) {\n    const t = [\n      \"INPUT\",\n      \"TEXTAREA\"\n    ];\n    return e && e.tagName ? t.includes(e.tagName) : !1;\n  }\n  /**\n   * Checks if we can set caret\n   *\n   * @param {HTMLElement} target - target to check\n   * @returns {boolean}\n   */\n  static canSetCaret(e) {\n    let t = !0;\n    if (d.isNativeInput(e))\n      switch (e.type) {\n        case \"file\":\n        case \"checkbox\":\n        case \"radio\":\n        case \"hidden\":\n        case \"submit\":\n        case \"button\":\n        case \"image\":\n        case \"reset\":\n          t = !1;\n          break;\n      }\n    else\n      t = d.isContentEditable(e);\n    return t;\n  }\n  /**\n   * Checks node if it is empty\n   *\n   * @description Method checks simple Node without any childs for emptiness\n   * If you have Node with 2 or more children id depth, you better use {@link Dom#isEmpty} method\n   * @param {Node} node - node to check\n   * @param {string} [ignoreChars] - char or substring to treat as empty\n   * @returns {boolean} true if it is empty\n   */\n  static isNodeEmpty(e, t) {\n    let o;\n    return this.isSingleTag(e) && !this.isLineBreakTag(e) ? !1 : (this.isElement(e) && this.isNativeInput(e) ? o = e.value : o = e.textContent.replace(\"​\", \"\"), t && (o = o.replace(new RegExp(t, \"g\"), \"\")), o.length === 0);\n  }\n  /**\n   * checks node if it is doesn't have any child nodes\n   *\n   * @param {Node} node - node to check\n   * @returns {boolean}\n   */\n  static isLeaf(e) {\n    return e ? e.childNodes.length === 0 : !1;\n  }\n  /**\n   * breadth-first search (BFS)\n   * {@link https://en.wikipedia.org/wiki/Breadth-first_search}\n   *\n   * @description Pushes to stack all DOM leafs and checks for emptiness\n   * @param {Node} node - node to check\n   * @param {string} [ignoreChars] - char or substring to treat as empty\n   * @returns {boolean}\n   */\n  static isEmpty(e, t) {\n    const o = [e];\n    for (; o.length > 0; )\n      if (e = o.shift(), !!e) {\n        if (this.isLeaf(e) && !this.isNodeEmpty(e, t))\n          return !1;\n        e.childNodes && o.push(...Array.from(e.childNodes));\n      }\n    return !0;\n  }\n  /**\n   * Check if string contains html elements\n   *\n   * @param {string} str - string to check\n   * @returns {boolean}\n   */\n  static isHTMLString(e) {\n    const t = d.make(\"div\");\n    return t.innerHTML = e, t.childElementCount > 0;\n  }\n  /**\n   * Return length of node`s text content\n   *\n   * @param {Node} node - node with content\n   * @returns {number}\n   */\n  static getContentLength(e) {\n    return d.isNativeInput(e) ? e.value.length : e.nodeType === Node.TEXT_NODE ? e.length : e.textContent.length;\n  }\n  /**\n   * Return array of names of block html elements\n   *\n   * @returns {string[]}\n   */\n  static get blockElements() {\n    return [\n      \"address\",\n      \"article\",\n      \"aside\",\n      \"blockquote\",\n      \"canvas\",\n      \"div\",\n      \"dl\",\n      \"dt\",\n      \"fieldset\",\n      \"figcaption\",\n      \"figure\",\n      \"footer\",\n      \"form\",\n      \"h1\",\n      \"h2\",\n      \"h3\",\n      \"h4\",\n      \"h5\",\n      \"h6\",\n      \"header\",\n      \"hgroup\",\n      \"hr\",\n      \"li\",\n      \"main\",\n      \"nav\",\n      \"noscript\",\n      \"ol\",\n      \"output\",\n      \"p\",\n      \"pre\",\n      \"ruby\",\n      \"section\",\n      \"table\",\n      \"tbody\",\n      \"thead\",\n      \"tr\",\n      \"tfoot\",\n      \"ul\",\n      \"video\"\n    ];\n  }\n  /**\n   * Check if passed content includes only inline elements\n   *\n   * @param {string|HTMLElement} data - element or html string\n   * @returns {boolean}\n   */\n  static containsOnlyInlineElements(e) {\n    let t;\n    te(e) ? (t = document.createElement(\"div\"), t.innerHTML = e) : t = e;\n    const o = (i) => !d.blockElements.includes(i.tagName.toLowerCase()) && Array.from(i.children).every(o);\n    return Array.from(t.children).every(o);\n  }\n  /**\n   * Find and return all block elements in the passed parent (including subtree)\n   *\n   * @param {HTMLElement} parent - root element\n   * @returns {HTMLElement[]}\n   */\n  static getDeepestBlockElements(e) {\n    return d.containsOnlyInlineElements(e) ? [e] : Array.from(e.children).reduce((t, o) => [...t, ...d.getDeepestBlockElements(o)], []);\n  }\n  /**\n   * Helper for get holder from {string} or return HTMLElement\n   *\n   * @param {string | HTMLElement} element - holder's id or holder's HTML Element\n   * @returns {HTMLElement}\n   */\n  static getHolder(e) {\n    return te(e) ? document.getElementById(e) : e;\n  }\n  /**\n   * Returns true if element is anchor (is A tag)\n   *\n   * @param {Element} element - element to check\n   * @returns {boolean}\n   */\n  static isAnchor(e) {\n    return e.tagName.toLowerCase() === \"a\";\n  }\n  /**\n   * Return element's offset related to the document\n   *\n   * @todo handle case when editor initialized in scrollable popup\n   * @param el - element to compute offset\n   */\n  static offset(e) {\n    const t = e.getBoundingClientRect(), o = window.pageXOffset || document.documentElement.scrollLeft, i = window.pageYOffset || document.documentElement.scrollTop, s = t.top + i, r = t.left + o;\n    return {\n      top: s,\n      left: r,\n      bottom: s + t.height,\n      right: r + t.width\n    };\n  }\n}\nfunction ai(n) {\n  return !/[^\\t\\n\\r ]/.test(n);\n}\nfunction li(n) {\n  const e = window.getComputedStyle(n), t = parseFloat(e.fontSize), o = parseFloat(e.lineHeight) || t * 1.2, i = parseFloat(e.paddingTop), s = parseFloat(e.borderTopWidth), r = parseFloat(e.marginTop), a = t * 0.8, l = (o - t) / 2;\n  return r + s + i + l + a;\n}\nfunction Do(n) {\n  n.dataset.empty = d.isEmpty(n) ? \"true\" : \"false\";\n}\nconst ci = {\n  blockTunes: {\n    toggler: {\n      \"Click to tune\": \"\",\n      \"or drag to move\": \"\"\n    }\n  },\n  inlineToolbar: {\n    converter: {\n      \"Convert to\": \"\"\n    }\n  },\n  toolbar: {\n    toolbox: {\n      Add: \"\"\n    }\n  },\n  popover: {\n    Filter: \"\",\n    \"Nothing found\": \"\",\n    \"Convert to\": \"\"\n  }\n}, di = {\n  Text: \"\",\n  Link: \"\",\n  Bold: \"\",\n  Italic: \"\"\n}, ui = {\n  link: {\n    \"Add a link\": \"\"\n  },\n  stub: {\n    \"The block can not be displayed correctly.\": \"\"\n  }\n}, hi = {\n  delete: {\n    Delete: \"\",\n    \"Click to delete\": \"\"\n  },\n  moveUp: {\n    \"Move up\": \"\"\n  },\n  moveDown: {\n    \"Move down\": \"\"\n  }\n}, Fo = {\n  ui: ci,\n  toolNames: di,\n  tools: ui,\n  blockTunes: hi\n}, jo = class he {\n  /**\n   * Type-safe translation for internal UI texts:\n   * Perform translation of the string by namespace and a key\n   *\n   * @example I18n.ui(I18nInternalNS.ui.blockTunes.toggler, 'Click to tune')\n   * @param internalNamespace - path to translated string in dictionary\n   * @param dictKey - dictionary key. Better to use default locale original text\n   */\n  static ui(e, t) {\n    return he._t(e, t);\n  }\n  /**\n   * Translate for external strings that is not presented in default dictionary.\n   * For example, for user-specified tool names\n   *\n   * @param namespace - path to translated string in dictionary\n   * @param dictKey - dictionary key. Better to use default locale original text\n   */\n  static t(e, t) {\n    return he._t(e, t);\n  }\n  /**\n   * Adjust module for using external dictionary\n   *\n   * @param dictionary - new messages list to override default\n   */\n  static setDictionary(e) {\n    he.currentDictionary = e;\n  }\n  /**\n   * Perform translation both for internal and external namespaces\n   * If there is no translation found, returns passed key as a translated message\n   *\n   * @param namespace - path to translated string in dictionary\n   * @param dictKey - dictionary key. Better to use default locale original text\n   */\n  static _t(e, t) {\n    const o = he.getNamespace(e);\n    return !o || !o[t] ? t : o[t];\n  }\n  /**\n   * Find messages section by namespace path\n   *\n   * @param namespace - path to section\n   */\n  static getNamespace(e) {\n    return e.split(\".\").reduce((o, i) => !o || !Object.keys(o).length ? {} : o[i], he.currentDictionary);\n  }\n};\njo.currentDictionary = Fo;\nlet z = jo;\nclass Ho extends Error {\n}\nclass Oe {\n  constructor() {\n    this.subscribers = {};\n  }\n  /**\n   * Subscribe any event on callback\n   *\n   * @param eventName - event name\n   * @param callback - subscriber\n   */\n  on(e, t) {\n    e in this.subscribers || (this.subscribers[e] = []), this.subscribers[e].push(t);\n  }\n  /**\n   * Subscribe any event on callback. Callback will be called once and be removed from subscribers array after call.\n   *\n   * @param eventName - event name\n   * @param callback - subscriber\n   */\n  once(e, t) {\n    e in this.subscribers || (this.subscribers[e] = []);\n    const o = (i) => {\n      const s = t(i), r = this.subscribers[e].indexOf(o);\n      return r !== -1 && this.subscribers[e].splice(r, 1), s;\n    };\n    this.subscribers[e].push(o);\n  }\n  /**\n   * Emit callbacks with passed data\n   *\n   * @param eventName - event name\n   * @param data - subscribers get this data when they were fired\n   */\n  emit(e, t) {\n    V(this.subscribers) || !this.subscribers[e] || this.subscribers[e].reduce((o, i) => {\n      const s = i(o);\n      return s !== void 0 ? s : o;\n    }, t);\n  }\n  /**\n   * Unsubscribe callback from event\n   *\n   * @param eventName - event name\n   * @param callback - event handler\n   */\n  off(e, t) {\n    if (this.subscribers[e] === void 0) {\n      console.warn(`EventDispatcher .off(): there is no subscribers for event \"${e.toString()}\". Probably, .off() called before .on()`);\n      return;\n    }\n    for (let o = 0; o < this.subscribers[e].length; o++)\n      if (this.subscribers[e][o] === t) {\n        delete this.subscribers[e][o];\n        break;\n      }\n  }\n  /**\n   * Destroyer\n   * clears subscribers list\n   */\n  destroy() {\n    this.subscribers = {};\n  }\n}\nfunction J(n) {\n  Object.setPrototypeOf(this, {\n    /**\n     * Block id\n     *\n     * @returns {string}\n     */\n    get id() {\n      return n.id;\n    },\n    /**\n     * Tool name\n     *\n     * @returns {string}\n     */\n    get name() {\n      return n.name;\n    },\n    /**\n     * Tool config passed on Editor's initialization\n     *\n     * @returns {ToolConfig}\n     */\n    get config() {\n      return n.config;\n    },\n    /**\n     * .ce-block element, that wraps plugin contents\n     *\n     * @returns {HTMLElement}\n     */\n    get holder() {\n      return n.holder;\n    },\n    /**\n     * True if Block content is empty\n     *\n     * @returns {boolean}\n     */\n    get isEmpty() {\n      return n.isEmpty;\n    },\n    /**\n     * True if Block is selected with Cross-Block selection\n     *\n     * @returns {boolean}\n     */\n    get selected() {\n      return n.selected;\n    },\n    /**\n     * Set Block's stretch state\n     *\n     * @param {boolean} state — state to set\n     */\n    set stretched(t) {\n      n.stretched = t;\n    },\n    /**\n     * True if Block is stretched\n     *\n     * @returns {boolean}\n     */\n    get stretched() {\n      return n.stretched;\n    },\n    /**\n     * True if Block has inputs to be focused\n     */\n    get focusable() {\n      return n.focusable;\n    },\n    /**\n     * Call Tool method with errors handler under-the-hood\n     *\n     * @param {string} methodName - method to call\n     * @param {object} param - object with parameters\n     * @returns {unknown}\n     */\n    call(t, o) {\n      return n.call(t, o);\n    },\n    /**\n     * Save Block content\n     *\n     * @returns {Promise<void|SavedData>}\n     */\n    save() {\n      return n.save();\n    },\n    /**\n     * Validate Block data\n     *\n     * @param {BlockToolData} data - data to validate\n     * @returns {Promise<boolean>}\n     */\n    validate(t) {\n      return n.validate(t);\n    },\n    /**\n     * Allows to say Editor that Block was changed. Used to manually trigger Editor's 'onChange' callback\n     * Can be useful for block changes invisible for editor core.\n     */\n    dispatchChange() {\n      n.dispatchChange();\n    },\n    /**\n     * Tool could specify several entries to be displayed at the Toolbox (for example, \"Heading 1\", \"Heading 2\", \"Heading 3\")\n     * This method returns the entry that is related to the Block (depended on the Block data)\n     */\n    getActiveToolboxEntry() {\n      return n.getActiveToolboxEntry();\n    }\n  });\n}\nclass _e {\n  constructor() {\n    this.allListeners = [];\n  }\n  /**\n   * Assigns event listener on element and returns unique identifier\n   *\n   * @param {EventTarget} element - DOM element that needs to be listened\n   * @param {string} eventType - event type\n   * @param {Function} handler - method that will be fired on event\n   * @param {boolean|AddEventListenerOptions} options - useCapture or {capture, passive, once}\n   */\n  on(e, t, o, i = !1) {\n    const s = si(\"l\"), r = {\n      id: s,\n      element: e,\n      eventType: t,\n      handler: o,\n      options: i\n    };\n    if (!this.findOne(e, t, o))\n      return this.allListeners.push(r), e.addEventListener(t, o, i), s;\n  }\n  /**\n   * Removes event listener from element\n   *\n   * @param {EventTarget} element - DOM element that we removing listener\n   * @param {string} eventType - event type\n   * @param {Function} handler - remove handler, if element listens several handlers on the same event type\n   * @param {boolean|AddEventListenerOptions} options - useCapture or {capture, passive, once}\n   */\n  off(e, t, o, i) {\n    const s = this.findAll(e, t, o);\n    s.forEach((r, a) => {\n      const l = this.allListeners.indexOf(s[a]);\n      l > -1 && (this.allListeners.splice(l, 1), r.element.removeEventListener(r.eventType, r.handler, r.options));\n    });\n  }\n  /**\n   * Removes listener by id\n   *\n   * @param {string} id - listener identifier\n   */\n  offById(e) {\n    const t = this.findById(e);\n    t && t.element.removeEventListener(t.eventType, t.handler, t.options);\n  }\n  /**\n   * Finds and returns first listener by passed params\n   *\n   * @param {EventTarget} element - event target\n   * @param {string} [eventType] - event type\n   * @param {Function} [handler] - event handler\n   * @returns {ListenerData|null}\n   */\n  findOne(e, t, o) {\n    const i = this.findAll(e, t, o);\n    return i.length > 0 ? i[0] : null;\n  }\n  /**\n   * Return all stored listeners by passed params\n   *\n   * @param {EventTarget} element - event target\n   * @param {string} eventType - event type\n   * @param {Function} handler - event handler\n   * @returns {ListenerData[]}\n   */\n  findAll(e, t, o) {\n    let i;\n    const s = e ? this.findByEventTarget(e) : [];\n    return e && t && o ? i = s.filter((r) => r.eventType === t && r.handler === o) : e && t ? i = s.filter((r) => r.eventType === t) : i = s, i;\n  }\n  /**\n   * Removes all listeners\n   */\n  removeAll() {\n    this.allListeners.map((e) => {\n      e.element.removeEventListener(e.eventType, e.handler, e.options);\n    }), this.allListeners = [];\n  }\n  /**\n   * Module cleanup on destruction\n   */\n  destroy() {\n    this.removeAll();\n  }\n  /**\n   * Search method: looks for listener by passed element\n   *\n   * @param {EventTarget} element - searching element\n   * @returns {Array} listeners that found on element\n   */\n  findByEventTarget(e) {\n    return this.allListeners.filter((t) => {\n      if (t.element === e)\n        return t;\n    });\n  }\n  /**\n   * Search method: looks for listener by passed event type\n   *\n   * @param {string} eventType - event type\n   * @returns {ListenerData[]} listeners that found on element\n   */\n  findByType(e) {\n    return this.allListeners.filter((t) => {\n      if (t.eventType === e)\n        return t;\n    });\n  }\n  /**\n   * Search method: looks for listener by passed handler\n   *\n   * @param {Function} handler - event handler\n   * @returns {ListenerData[]} listeners that found on element\n   */\n  findByHandler(e) {\n    return this.allListeners.filter((t) => {\n      if (t.handler === e)\n        return t;\n    });\n  }\n  /**\n   * Returns listener data found by id\n   *\n   * @param {string} id - listener identifier\n   * @returns {ListenerData}\n   */\n  findById(e) {\n    return this.allListeners.find((t) => t.id === e);\n  }\n}\nclass E {\n  /**\n   * @class\n   * @param options - Module options\n   * @param options.config - Module config\n   * @param options.eventsDispatcher - Common event bus\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    if (this.nodes = {}, this.listeners = new _e(), this.readOnlyMutableListeners = {\n      /**\n       * Assigns event listener on DOM element and pushes into special array that might be removed\n       *\n       * @param {EventTarget} element - DOM Element\n       * @param {string} eventType - Event name\n       * @param {Function} handler - Event handler\n       * @param {boolean|AddEventListenerOptions} options - Listening options\n       */\n      on: (o, i, s, r = !1) => {\n        this.mutableListenerIds.push(\n          this.listeners.on(o, i, s, r)\n        );\n      },\n      /**\n       * Clears all mutable listeners\n       */\n      clearAll: () => {\n        for (const o of this.mutableListenerIds)\n          this.listeners.offById(o);\n        this.mutableListenerIds = [];\n      }\n    }, this.mutableListenerIds = [], new.target === E)\n      throw new TypeError(\"Constructors for abstract class Module are not allowed.\");\n    this.config = e, this.eventsDispatcher = t;\n  }\n  /**\n   * Editor modules setter\n   *\n   * @param {EditorModules} Editor - Editor's Modules\n   */\n  set state(e) {\n    this.Editor = e;\n  }\n  /**\n   * Remove memorized nodes\n   */\n  removeAllNodes() {\n    for (const e in this.nodes) {\n      const t = this.nodes[e];\n      t instanceof HTMLElement && t.remove();\n    }\n  }\n  /**\n   * Returns true if current direction is RTL (Right-To-Left)\n   */\n  get isRtl() {\n    return this.config.i18n.direction === \"rtl\";\n  }\n}\nclass b {\n  constructor() {\n    this.instance = null, this.selection = null, this.savedSelectionRange = null, this.isFakeBackgroundEnabled = !1, this.commandBackground = \"backColor\", this.commandRemoveFormat = \"removeFormat\";\n  }\n  /**\n   * Editor styles\n   *\n   * @returns {{editorWrapper: string, editorZone: string}}\n   */\n  static get CSS() {\n    return {\n      editorWrapper: \"codex-editor\",\n      editorZone: \"codex-editor__redactor\"\n    };\n  }\n  /**\n   * Returns selected anchor\n   * {@link https://developer.mozilla.org/ru/docs/Web/API/Selection/anchorNode}\n   *\n   * @returns {Node|null}\n   */\n  static get anchorNode() {\n    const e = window.getSelection();\n    return e ? e.anchorNode : null;\n  }\n  /**\n   * Returns selected anchor element\n   *\n   * @returns {Element|null}\n   */\n  static get anchorElement() {\n    const e = window.getSelection();\n    if (!e)\n      return null;\n    const t = e.anchorNode;\n    return t ? d.isElement(t) ? t : t.parentElement : null;\n  }\n  /**\n   * Returns selection offset according to the anchor node\n   * {@link https://developer.mozilla.org/ru/docs/Web/API/Selection/anchorOffset}\n   *\n   * @returns {number|null}\n   */\n  static get anchorOffset() {\n    const e = window.getSelection();\n    return e ? e.anchorOffset : null;\n  }\n  /**\n   * Is current selection range collapsed\n   *\n   * @returns {boolean|null}\n   */\n  static get isCollapsed() {\n    const e = window.getSelection();\n    return e ? e.isCollapsed : null;\n  }\n  /**\n   * Check current selection if it is at Editor's zone\n   *\n   * @returns {boolean}\n   */\n  static get isAtEditor() {\n    return this.isSelectionAtEditor(b.get());\n  }\n  /**\n   * Check if passed selection is at Editor's zone\n   *\n   * @param selection - Selection object to check\n   */\n  static isSelectionAtEditor(e) {\n    if (!e)\n      return !1;\n    let t = e.anchorNode || e.focusNode;\n    t && t.nodeType === Node.TEXT_NODE && (t = t.parentNode);\n    let o = null;\n    return t && t instanceof Element && (o = t.closest(`.${b.CSS.editorZone}`)), o ? o.nodeType === Node.ELEMENT_NODE : !1;\n  }\n  /**\n   * Check if passed range at Editor zone\n   *\n   * @param range - range to check\n   */\n  static isRangeAtEditor(e) {\n    if (!e)\n      return;\n    let t = e.startContainer;\n    t && t.nodeType === Node.TEXT_NODE && (t = t.parentNode);\n    let o = null;\n    return t && t instanceof Element && (o = t.closest(`.${b.CSS.editorZone}`)), o ? o.nodeType === Node.ELEMENT_NODE : !1;\n  }\n  /**\n   * Methods return boolean that true if selection exists on the page\n   */\n  static get isSelectionExists() {\n    return !!b.get().anchorNode;\n  }\n  /**\n   * Return first range\n   *\n   * @returns {Range|null}\n   */\n  static get range() {\n    return this.getRangeFromSelection(this.get());\n  }\n  /**\n   * Returns range from passed Selection object\n   *\n   * @param selection - Selection object to get Range from\n   */\n  static getRangeFromSelection(e) {\n    return e && e.rangeCount ? e.getRangeAt(0) : null;\n  }\n  /**\n   * Calculates position and size of selected text\n   *\n   * @returns {DOMRect | ClientRect}\n   */\n  static get rect() {\n    let e = document.selection, t, o = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n    if (e && e.type !== \"Control\")\n      return e = e, t = e.createRange(), o.x = t.boundingLeft, o.y = t.boundingTop, o.width = t.boundingWidth, o.height = t.boundingHeight, o;\n    if (!window.getSelection)\n      return S(\"Method window.getSelection is not supported\", \"warn\"), o;\n    if (e = window.getSelection(), e.rangeCount === null || isNaN(e.rangeCount))\n      return S(\"Method SelectionUtils.rangeCount is not supported\", \"warn\"), o;\n    if (e.rangeCount === 0)\n      return o;\n    if (t = e.getRangeAt(0).cloneRange(), t.getBoundingClientRect && (o = t.getBoundingClientRect()), o.x === 0 && o.y === 0) {\n      const i = document.createElement(\"span\");\n      if (i.getBoundingClientRect) {\n        i.appendChild(document.createTextNode(\"​\")), t.insertNode(i), o = i.getBoundingClientRect();\n        const s = i.parentNode;\n        s.removeChild(i), s.normalize();\n      }\n    }\n    return o;\n  }\n  /**\n   * Returns selected text as String\n   *\n   * @returns {string}\n   */\n  static get text() {\n    return window.getSelection ? window.getSelection().toString() : \"\";\n  }\n  /**\n   * Returns window SelectionUtils\n   * {@link https://developer.mozilla.org/ru/docs/Web/API/Window/getSelection}\n   *\n   * @returns {Selection}\n   */\n  static get() {\n    return window.getSelection();\n  }\n  /**\n   * Set focus to contenteditable or native input element\n   *\n   * @param element - element where to set focus\n   * @param offset - offset of cursor\n   */\n  static setCursor(e, t = 0) {\n    const o = document.createRange(), i = window.getSelection();\n    return d.isNativeInput(e) ? d.canSetCaret(e) ? (e.focus(), e.selectionStart = e.selectionEnd = t, e.getBoundingClientRect()) : void 0 : (o.setStart(e, t), o.setEnd(e, t), i.removeAllRanges(), i.addRange(o), o.getBoundingClientRect());\n  }\n  /**\n   * Check if current range exists and belongs to container\n   *\n   * @param container - where range should be\n   */\n  static isRangeInsideContainer(e) {\n    const t = b.range;\n    return t === null ? !1 : e.contains(t.startContainer);\n  }\n  /**\n   * Adds fake cursor to the current range\n   */\n  static addFakeCursor() {\n    const e = b.range;\n    if (e === null)\n      return;\n    const t = d.make(\"span\", \"codex-editor__fake-cursor\");\n    t.dataset.mutationFree = \"true\", e.collapse(), e.insertNode(t);\n  }\n  /**\n   * Check if passed element contains a fake cursor\n   *\n   * @param el - where to check\n   */\n  static isFakeCursorInsideContainer(e) {\n    return d.find(e, \".codex-editor__fake-cursor\") !== null;\n  }\n  /**\n   * Removes fake cursor from a container\n   *\n   * @param container - container to look for\n   */\n  static removeFakeCursor(e = document.body) {\n    const t = d.find(e, \".codex-editor__fake-cursor\");\n    t && t.remove();\n  }\n  /**\n   * Removes fake background\n   */\n  removeFakeBackground() {\n    this.isFakeBackgroundEnabled && (this.isFakeBackgroundEnabled = !1, document.execCommand(this.commandRemoveFormat));\n  }\n  /**\n   * Sets fake background\n   */\n  setFakeBackground() {\n    document.execCommand(this.commandBackground, !1, \"#a8d6ff\"), this.isFakeBackgroundEnabled = !0;\n  }\n  /**\n   * Save SelectionUtils's range\n   */\n  save() {\n    this.savedSelectionRange = b.range;\n  }\n  /**\n   * Restore saved SelectionUtils's range\n   */\n  restore() {\n    if (!this.savedSelectionRange)\n      return;\n    const e = window.getSelection();\n    e.removeAllRanges(), e.addRange(this.savedSelectionRange);\n  }\n  /**\n   * Clears saved selection\n   */\n  clearSaved() {\n    this.savedSelectionRange = null;\n  }\n  /**\n   * Collapse current selection\n   */\n  collapseToEnd() {\n    const e = window.getSelection(), t = document.createRange();\n    t.selectNodeContents(e.focusNode), t.collapse(!1), e.removeAllRanges(), e.addRange(t);\n  }\n  /**\n   * Looks ahead to find passed tag from current selection\n   *\n   * @param  {string} tagName       - tag to found\n   * @param  {string} [className]   - tag's class name\n   * @param  {number} [searchDepth] - count of tags that can be included. For better performance.\n   * @returns {HTMLElement|null}\n   */\n  findParentTag(e, t, o = 10) {\n    const i = window.getSelection();\n    let s = null;\n    return !i || !i.anchorNode || !i.focusNode ? null : ([\n      /** the Node in which the selection begins */\n      i.anchorNode,\n      /** the Node in which the selection ends */\n      i.focusNode\n    ].forEach((a) => {\n      let l = o;\n      for (; l > 0 && a.parentNode && !(a.tagName === e && (s = a, t && a.classList && !a.classList.contains(t) && (s = null), s)); )\n        a = a.parentNode, l--;\n    }), s);\n  }\n  /**\n   * Expands selection range to the passed parent node\n   *\n   * @param {HTMLElement} element - element which contents should be selected\n   */\n  expandToTag(e) {\n    const t = window.getSelection();\n    t.removeAllRanges();\n    const o = document.createRange();\n    o.selectNodeContents(e), t.addRange(o);\n  }\n}\nfunction pi(n, e) {\n  const { type: t, target: o, addedNodes: i, removedNodes: s } = n;\n  return n.type === \"attributes\" && n.attributeName === \"data-empty\" ? !1 : !!(e.contains(o) || t === \"childList\" && (Array.from(i).some((l) => l === e) || Array.from(s).some((l) => l === e)));\n}\nconst ft = \"redactor dom changed\", $o = \"block changed\", zo = \"fake cursor is about to be toggled\", Uo = \"fake cursor have been set\", Te = \"editor mobile layout toggled\";\nfunction gt(n, e) {\n  if (!n.conversionConfig)\n    return !1;\n  const t = n.conversionConfig[e];\n  return A(t) || te(t);\n}\nfunction He(n, e) {\n  return gt(n.tool, e);\n}\nfunction Wo(n, e) {\n  return Object.entries(n).some(([t, o]) => e[t] && ri(e[t], o));\n}\nasync function Yo(n, e) {\n  const o = (await n.save()).data, i = e.find((s) => s.name === n.name);\n  return i !== void 0 && !gt(i, \"export\") ? [] : e.reduce((s, r) => {\n    if (!gt(r, \"import\") || r.toolbox === void 0)\n      return s;\n    const a = r.toolbox.filter((l) => {\n      if (V(l) || l.icon === void 0)\n        return !1;\n      if (l.data !== void 0) {\n        if (Wo(l.data, o))\n          return !1;\n      } else if (r.name === n.name)\n        return !1;\n      return !0;\n    });\n    return s.push({\n      ...r,\n      toolbox: a\n    }), s;\n  }, []);\n}\nfunction xo(n, e) {\n  return n.mergeable ? n.name === e.name ? !0 : He(e, \"export\") && He(n, \"import\") : !1;\n}\nfunction fi(n, e) {\n  const t = e == null ? void 0 : e.export;\n  return A(t) ? t(n) : te(t) ? n[t] : (t !== void 0 && S(\"Conversion «export» property must be a string or function. String means key of saved data object to export. Function should export processed string to export.\"), \"\");\n}\nfunction Bo(n, e, t) {\n  const o = e == null ? void 0 : e.import;\n  return A(o) ? o(n, t) : te(o) ? {\n    [o]: n\n  } : (o !== void 0 && S(\"Conversion «import» property must be a string or function. String means key of tool data to import. Function accepts a imported string and return composed tool data.\"), {});\n}\nvar _ = /* @__PURE__ */ ((n) => (n.Default = \"default\", n.Separator = \"separator\", n.Html = \"html\", n))(_ || {}), ee = /* @__PURE__ */ ((n) => (n.APPEND_CALLBACK = \"appendCallback\", n.RENDERED = \"rendered\", n.MOVED = \"moved\", n.UPDATED = \"updated\", n.REMOVED = \"removed\", n.ON_PASTE = \"onPaste\", n))(ee || {});\nclass R extends Oe {\n  /**\n   * @param options - block constructor options\n   * @param [options.id] - block's id. Will be generated if omitted.\n   * @param options.data - Tool's initial data\n   * @param options.tool — block's tool\n   * @param options.api - Editor API module for pass it to the Block Tunes\n   * @param options.readOnly - Read-Only flag\n   * @param [eventBus] - Editor common event bus. Allows to subscribe on some Editor events. Could be omitted when \"virtual\" Block is created. See BlocksAPI@composeBlockData.\n   */\n  constructor({\n    id: e = ni(),\n    data: t,\n    tool: o,\n    readOnly: i,\n    tunesData: s\n  }, r) {\n    super(), this.cachedInputs = [], this.toolRenderedElement = null, this.tunesInstances = /* @__PURE__ */ new Map(), this.defaultTunesInstances = /* @__PURE__ */ new Map(), this.unavailableTunesData = {}, this.inputIndex = 0, this.editorEventBus = null, this.handleFocus = () => {\n      this.dropInputsCache(), this.updateCurrentInput();\n    }, this.didMutated = (a = void 0) => {\n      const l = a === void 0, c = a instanceof InputEvent;\n      !l && !c && this.detectToolRootChange(a);\n      let u;\n      l || c ? u = !0 : u = !(a.length > 0 && a.every((p) => {\n        const { addedNodes: g, removedNodes: f, target: v } = p;\n        return [\n          ...Array.from(g),\n          ...Array.from(f),\n          v\n        ].some((T) => (d.isElement(T) || (T = T.parentElement), T && T.closest('[data-mutation-free=\"true\"]') !== null));\n      })), u && (this.dropInputsCache(), this.updateCurrentInput(), this.toggleInputsEmptyMark(), this.call(\n        \"updated\"\n        /* UPDATED */\n      ), this.emit(\"didMutated\", this));\n    }, this.name = o.name, this.id = e, this.settings = o.settings, this.config = o.settings.config || {}, this.editorEventBus = r || null, this.blockAPI = new J(this), this.tool = o, this.toolInstance = o.create(t, this.blockAPI, i), this.tunes = o.tunes, this.composeTunes(s), this.holder = this.compose(), window.requestIdleCallback(() => {\n      this.watchBlockMutations(), this.addInputEvents(), this.toggleInputsEmptyMark();\n    });\n  }\n  /**\n   * CSS classes for the Block\n   *\n   * @returns {{wrapper: string, content: string}}\n   */\n  static get CSS() {\n    return {\n      wrapper: \"ce-block\",\n      wrapperStretched: \"ce-block--stretched\",\n      content: \"ce-block__content\",\n      selected: \"ce-block--selected\",\n      dropTarget: \"ce-block--drop-target\"\n    };\n  }\n  /**\n   * Find and return all editable elements (contenteditable and native inputs) in the Tool HTML\n   */\n  get inputs() {\n    if (this.cachedInputs.length !== 0)\n      return this.cachedInputs;\n    const e = d.findAllInputs(this.holder);\n    return this.inputIndex > e.length - 1 && (this.inputIndex = e.length - 1), this.cachedInputs = e, e;\n  }\n  /**\n   * Return current Tool`s input\n   * If Block doesn't contain inputs, return undefined\n   */\n  get currentInput() {\n    return this.inputs[this.inputIndex];\n  }\n  /**\n   * Set input index to the passed element\n   *\n   * @param element - HTML Element to set as current input\n   */\n  set currentInput(e) {\n    const t = this.inputs.findIndex((o) => o === e || o.contains(e));\n    t !== -1 && (this.inputIndex = t);\n  }\n  /**\n   * Return first Tool`s input\n   * If Block doesn't contain inputs, return undefined\n   */\n  get firstInput() {\n    return this.inputs[0];\n  }\n  /**\n   * Return first Tool`s input\n   * If Block doesn't contain inputs, return undefined\n   */\n  get lastInput() {\n    const e = this.inputs;\n    return e[e.length - 1];\n  }\n  /**\n   * Return next Tool`s input or undefined if it doesn't exist\n   * If Block doesn't contain inputs, return undefined\n   */\n  get nextInput() {\n    return this.inputs[this.inputIndex + 1];\n  }\n  /**\n   * Return previous Tool`s input or undefined if it doesn't exist\n   * If Block doesn't contain inputs, return undefined\n   */\n  get previousInput() {\n    return this.inputs[this.inputIndex - 1];\n  }\n  /**\n   * Get Block's JSON data\n   *\n   * @returns {object}\n   */\n  get data() {\n    return this.save().then((e) => e && !V(e.data) ? e.data : {});\n  }\n  /**\n   * Returns tool's sanitizer config\n   *\n   * @returns {object}\n   */\n  get sanitize() {\n    return this.tool.sanitizeConfig;\n  }\n  /**\n   * is block mergeable\n   * We plugin have merge function then we call it mergeable\n   *\n   * @returns {boolean}\n   */\n  get mergeable() {\n    return A(this.toolInstance.merge);\n  }\n  /**\n   * If Block contains inputs, it is focusable\n   */\n  get focusable() {\n    return this.inputs.length !== 0;\n  }\n  /**\n   * Check block for emptiness\n   *\n   * @returns {boolean}\n   */\n  get isEmpty() {\n    const e = d.isEmpty(this.pluginsContent, \"/\"), t = !this.hasMedia;\n    return e && t;\n  }\n  /**\n   * Check if block has a media content such as images, iframe and other\n   *\n   * @returns {boolean}\n   */\n  get hasMedia() {\n    const e = [\n      \"img\",\n      \"iframe\",\n      \"video\",\n      \"audio\",\n      \"source\",\n      \"input\",\n      \"textarea\",\n      \"twitterwidget\"\n    ];\n    return !!this.holder.querySelector(e.join(\",\"));\n  }\n  /**\n   * Set selected state\n   * We don't need to mark Block as Selected when it is empty\n   *\n   * @param {boolean} state - 'true' to select, 'false' to remove selection\n   */\n  set selected(e) {\n    var i, s;\n    this.holder.classList.toggle(R.CSS.selected, e);\n    const t = e === !0 && b.isRangeInsideContainer(this.holder), o = e === !1 && b.isFakeCursorInsideContainer(this.holder);\n    (t || o) && ((i = this.editorEventBus) == null || i.emit(zo, { state: e }), t ? b.addFakeCursor() : b.removeFakeCursor(this.holder), (s = this.editorEventBus) == null || s.emit(Uo, { state: e }));\n  }\n  /**\n   * Returns True if it is Selected\n   *\n   * @returns {boolean}\n   */\n  get selected() {\n    return this.holder.classList.contains(R.CSS.selected);\n  }\n  /**\n   * Set stretched state\n   *\n   * @param {boolean} state - 'true' to enable, 'false' to disable stretched state\n   */\n  set stretched(e) {\n    this.holder.classList.toggle(R.CSS.wrapperStretched, e);\n  }\n  /**\n   * Return Block's stretched state\n   *\n   * @returns {boolean}\n   */\n  get stretched() {\n    return this.holder.classList.contains(R.CSS.wrapperStretched);\n  }\n  /**\n   * Toggle drop target state\n   *\n   * @param {boolean} state - 'true' if block is drop target, false otherwise\n   */\n  set dropTarget(e) {\n    this.holder.classList.toggle(R.CSS.dropTarget, e);\n  }\n  /**\n   * Returns Plugins content\n   *\n   * @returns {HTMLElement}\n   */\n  get pluginsContent() {\n    return this.toolRenderedElement;\n  }\n  /**\n   * Calls Tool's method\n   *\n   * Method checks tool property {MethodName}. Fires method with passes params If it is instance of Function\n   *\n   * @param {string} methodName - method to call\n   * @param {object} params - method argument\n   */\n  call(e, t) {\n    if (A(this.toolInstance[e])) {\n      e === \"appendCallback\" && S(\n        \"`appendCallback` hook is deprecated and will be removed in the next major release. Use `rendered` hook instead\",\n        \"warn\"\n      );\n      try {\n        this.toolInstance[e].call(this.toolInstance, t);\n      } catch (o) {\n        S(`Error during '${e}' call: ${o.message}`, \"error\");\n      }\n    }\n  }\n  /**\n   * Call plugins merge method\n   *\n   * @param {BlockToolData} data - data to merge\n   */\n  async mergeWith(e) {\n    await this.toolInstance.merge(e);\n  }\n  /**\n   * Extracts data from Block\n   * Groups Tool's save processing time\n   *\n   * @returns {object}\n   */\n  async save() {\n    const e = await this.toolInstance.save(this.pluginsContent), t = this.unavailableTunesData;\n    [\n      ...this.tunesInstances.entries(),\n      ...this.defaultTunesInstances.entries()\n    ].forEach(([s, r]) => {\n      if (A(r.save))\n        try {\n          t[s] = r.save();\n        } catch (a) {\n          S(`Tune ${r.constructor.name} save method throws an Error %o`, \"warn\", a);\n        }\n    });\n    const o = window.performance.now();\n    let i;\n    return Promise.resolve(e).then((s) => (i = window.performance.now(), {\n      id: this.id,\n      tool: this.name,\n      data: s,\n      tunes: t,\n      time: i - o\n    })).catch((s) => {\n      S(`Saving process for ${this.name} tool failed due to the ${s}`, \"log\", \"red\");\n    });\n  }\n  /**\n   * Uses Tool's validation method to check the correctness of output data\n   * Tool's validation method is optional\n   *\n   * @description Method returns true|false whether data passed the validation or not\n   * @param {BlockToolData} data - data to validate\n   * @returns {Promise<boolean>} valid\n   */\n  async validate(e) {\n    let t = !0;\n    return this.toolInstance.validate instanceof Function && (t = await this.toolInstance.validate(e)), t;\n  }\n  /**\n   * Returns data to render in Block Tunes menu.\n   * Splits block tunes into 2 groups: block specific tunes and common tunes\n   */\n  getTunes() {\n    const e = [], t = [], o = typeof this.toolInstance.renderSettings == \"function\" ? this.toolInstance.renderSettings() : [];\n    return d.isElement(o) ? e.push({\n      type: _.Html,\n      element: o\n    }) : Array.isArray(o) ? e.push(...o) : e.push(o), [\n      ...this.tunesInstances.values(),\n      ...this.defaultTunesInstances.values()\n    ].map((s) => s.render()).forEach((s) => {\n      d.isElement(s) ? t.push({\n        type: _.Html,\n        element: s\n      }) : Array.isArray(s) ? t.push(...s) : t.push(s);\n    }), {\n      toolTunes: e,\n      commonTunes: t\n    };\n  }\n  /**\n   * Update current input index with selection anchor node\n   */\n  updateCurrentInput() {\n    this.currentInput = d.isNativeInput(document.activeElement) || !b.anchorNode ? document.activeElement : b.anchorNode;\n  }\n  /**\n   * Allows to say Editor that Block was changed. Used to manually trigger Editor's 'onChange' callback\n   * Can be useful for block changes invisible for editor core.\n   */\n  dispatchChange() {\n    this.didMutated();\n  }\n  /**\n   * Call Tool instance destroy method\n   */\n  destroy() {\n    this.unwatchBlockMutations(), this.removeInputEvents(), super.destroy(), A(this.toolInstance.destroy) && this.toolInstance.destroy();\n  }\n  /**\n   * Tool could specify several entries to be displayed at the Toolbox (for example, \"Heading 1\", \"Heading 2\", \"Heading 3\")\n   * This method returns the entry that is related to the Block (depended on the Block data)\n   */\n  async getActiveToolboxEntry() {\n    const e = this.tool.toolbox;\n    if (e.length === 1)\n      return Promise.resolve(this.tool.toolbox[0]);\n    const t = await this.data, o = e;\n    return o == null ? void 0 : o.find((i) => Wo(i.data, t));\n  }\n  /**\n   * Exports Block data as string using conversion config\n   */\n  async exportDataAsString() {\n    const e = await this.data;\n    return fi(e, this.tool.conversionConfig);\n  }\n  /**\n   * Make default Block wrappers and put Tool`s content there\n   *\n   * @returns {HTMLDivElement}\n   */\n  compose() {\n    const e = d.make(\"div\", R.CSS.wrapper), t = d.make(\"div\", R.CSS.content), o = this.toolInstance.render();\n    e.setAttribute(\"data-cy\", \"block-wrapper\"), e.dataset.id = this.id, this.toolRenderedElement = o, t.appendChild(this.toolRenderedElement);\n    let i = t;\n    return [...this.tunesInstances.values(), ...this.defaultTunesInstances.values()].forEach((s) => {\n      if (A(s.wrap))\n        try {\n          i = s.wrap(i);\n        } catch (r) {\n          S(`Tune ${s.constructor.name} wrap method throws an Error %o`, \"warn\", r);\n        }\n    }), e.appendChild(i), e;\n  }\n  /**\n   * Instantiate Block Tunes\n   *\n   * @param tunesData - current Block tunes data\n   * @private\n   */\n  composeTunes(e) {\n    Array.from(this.tunes.values()).forEach((t) => {\n      (t.isInternal ? this.defaultTunesInstances : this.tunesInstances).set(t.name, t.create(e[t.name], this.blockAPI));\n    }), Object.entries(e).forEach(([t, o]) => {\n      this.tunesInstances.has(t) || (this.unavailableTunesData[t] = o);\n    });\n  }\n  /**\n   * Adds focus event listeners to all inputs and contenteditable\n   */\n  addInputEvents() {\n    this.inputs.forEach((e) => {\n      e.addEventListener(\"focus\", this.handleFocus), d.isNativeInput(e) && e.addEventListener(\"input\", this.didMutated);\n    });\n  }\n  /**\n   * removes focus event listeners from all inputs and contenteditable\n   */\n  removeInputEvents() {\n    this.inputs.forEach((e) => {\n      e.removeEventListener(\"focus\", this.handleFocus), d.isNativeInput(e) && e.removeEventListener(\"input\", this.didMutated);\n    });\n  }\n  /**\n   * Listen common editor Dom Changed event and detect mutations related to the  Block\n   */\n  watchBlockMutations() {\n    var e;\n    this.redactorDomChangedCallback = (t) => {\n      const { mutations: o } = t;\n      o.some((s) => pi(s, this.toolRenderedElement)) && this.didMutated(o);\n    }, (e = this.editorEventBus) == null || e.on(ft, this.redactorDomChangedCallback);\n  }\n  /**\n   * Remove redactor dom change event listener\n   */\n  unwatchBlockMutations() {\n    var e;\n    (e = this.editorEventBus) == null || e.off(ft, this.redactorDomChangedCallback);\n  }\n  /**\n   * Sometimes Tool can replace own main element, for example H2 -> H4 or UL -> OL\n   * We need to detect such changes and update a link to tools main element with the new one\n   *\n   * @param mutations - records of block content mutations\n   */\n  detectToolRootChange(e) {\n    e.forEach((t) => {\n      if (Array.from(t.removedNodes).includes(this.toolRenderedElement)) {\n        const i = t.addedNodes[t.addedNodes.length - 1];\n        this.toolRenderedElement = i;\n      }\n    });\n  }\n  /**\n   * Clears inputs cached value\n   */\n  dropInputsCache() {\n    this.cachedInputs = [];\n  }\n  /**\n   * Mark inputs with 'data-empty' attribute with the empty state\n   */\n  toggleInputsEmptyMark() {\n    this.inputs.forEach(Do);\n  }\n}\nclass gi extends E {\n  constructor() {\n    super(...arguments), this.insert = (e = this.config.defaultBlock, t = {}, o = {}, i, s, r, a) => {\n      const l = this.Editor.BlockManager.insert({\n        id: a,\n        tool: e,\n        data: t,\n        index: i,\n        needToFocus: s,\n        replace: r\n      });\n      return new J(l);\n    }, this.composeBlockData = async (e) => {\n      const t = this.Editor.Tools.blockTools.get(e);\n      return new R({\n        tool: t,\n        api: this.Editor.API,\n        readOnly: !0,\n        data: {},\n        tunesData: {}\n      }).data;\n    }, this.update = async (e, t, o) => {\n      const { BlockManager: i } = this.Editor, s = i.getBlockById(e);\n      if (s === void 0)\n        throw new Error(`Block with id \"${e}\" not found`);\n      const r = await i.update(s, t, o);\n      return new J(r);\n    }, this.convert = async (e, t, o) => {\n      var h, p;\n      const { BlockManager: i, Tools: s } = this.Editor, r = i.getBlockById(e);\n      if (!r)\n        throw new Error(`Block with id \"${e}\" not found`);\n      const a = s.blockTools.get(r.name), l = s.blockTools.get(t);\n      if (!l)\n        throw new Error(`Block Tool with type \"${t}\" not found`);\n      const c = ((h = a == null ? void 0 : a.conversionConfig) == null ? void 0 : h.export) !== void 0, u = ((p = l.conversionConfig) == null ? void 0 : p.import) !== void 0;\n      if (c && u) {\n        const g = await i.convert(r, t, o);\n        return new J(g);\n      } else {\n        const g = [\n          c ? !1 : je(r.name),\n          u ? !1 : je(t)\n        ].filter(Boolean).join(\" and \");\n        throw new Error(`Conversion from \"${r.name}\" to \"${t}\" is not possible. ${g} tool(s) should provide a \"conversionConfig\"`);\n      }\n    }, this.insertMany = (e, t = this.Editor.BlockManager.blocks.length - 1) => {\n      this.validateIndex(t);\n      const o = e.map(({ id: i, type: s, data: r }) => this.Editor.BlockManager.composeBlock({\n        id: i,\n        tool: s || this.config.defaultBlock,\n        data: r\n      }));\n      return this.Editor.BlockManager.insertMany(o, t), o.map((i) => new J(i));\n    };\n  }\n  /**\n   * Available methods\n   *\n   * @returns {Blocks}\n   */\n  get methods() {\n    return {\n      clear: () => this.clear(),\n      render: (e) => this.render(e),\n      renderFromHTML: (e) => this.renderFromHTML(e),\n      delete: (e) => this.delete(e),\n      swap: (e, t) => this.swap(e, t),\n      move: (e, t) => this.move(e, t),\n      getBlockByIndex: (e) => this.getBlockByIndex(e),\n      getById: (e) => this.getById(e),\n      getCurrentBlockIndex: () => this.getCurrentBlockIndex(),\n      getBlockIndex: (e) => this.getBlockIndex(e),\n      getBlocksCount: () => this.getBlocksCount(),\n      getBlockByElement: (e) => this.getBlockByElement(e),\n      stretchBlock: (e, t = !0) => this.stretchBlock(e, t),\n      insertNewBlock: () => this.insertNewBlock(),\n      insert: this.insert,\n      insertMany: this.insertMany,\n      update: this.update,\n      composeBlockData: this.composeBlockData,\n      convert: this.convert\n    };\n  }\n  /**\n   * Returns Blocks count\n   *\n   * @returns {number}\n   */\n  getBlocksCount() {\n    return this.Editor.BlockManager.blocks.length;\n  }\n  /**\n   * Returns current block index\n   *\n   * @returns {number}\n   */\n  getCurrentBlockIndex() {\n    return this.Editor.BlockManager.currentBlockIndex;\n  }\n  /**\n   * Returns the index of Block by id;\n   *\n   * @param id - block id\n   */\n  getBlockIndex(e) {\n    const t = this.Editor.BlockManager.getBlockById(e);\n    if (!t) {\n      X(\"There is no block with id `\" + e + \"`\", \"warn\");\n      return;\n    }\n    return this.Editor.BlockManager.getBlockIndex(t);\n  }\n  /**\n   * Returns BlockAPI object by Block index\n   *\n   * @param {number} index - index to get\n   */\n  getBlockByIndex(e) {\n    const t = this.Editor.BlockManager.getBlockByIndex(e);\n    if (t === void 0) {\n      X(\"There is no block at index `\" + e + \"`\", \"warn\");\n      return;\n    }\n    return new J(t);\n  }\n  /**\n   * Returns BlockAPI object by Block id\n   *\n   * @param id - id of block to get\n   */\n  getById(e) {\n    const t = this.Editor.BlockManager.getBlockById(e);\n    return t === void 0 ? (X(\"There is no block with id `\" + e + \"`\", \"warn\"), null) : new J(t);\n  }\n  /**\n   * Get Block API object by any child html element\n   *\n   * @param element - html element to get Block by\n   */\n  getBlockByElement(e) {\n    const t = this.Editor.BlockManager.getBlock(e);\n    if (t === void 0) {\n      X(\"There is no block corresponding to element `\" + e + \"`\", \"warn\");\n      return;\n    }\n    return new J(t);\n  }\n  /**\n   * Call Block Manager method that swap Blocks\n   *\n   * @param {number} fromIndex - position of first Block\n   * @param {number} toIndex - position of second Block\n   * @deprecated — use 'move' instead\n   */\n  swap(e, t) {\n    S(\n      \"`blocks.swap()` method is deprecated and will be removed in the next major release. Use `block.move()` method instead\",\n      \"info\"\n    ), this.Editor.BlockManager.swap(e, t);\n  }\n  /**\n   * Move block from one index to another\n   *\n   * @param {number} toIndex - index to move to\n   * @param {number} fromIndex - index to move from\n   */\n  move(e, t) {\n    this.Editor.BlockManager.move(e, t);\n  }\n  /**\n   * Deletes Block\n   *\n   * @param {number} blockIndex - index of Block to delete\n   */\n  delete(e = this.Editor.BlockManager.currentBlockIndex) {\n    try {\n      const t = this.Editor.BlockManager.getBlockByIndex(e);\n      this.Editor.BlockManager.removeBlock(t);\n    } catch (t) {\n      X(t, \"warn\");\n      return;\n    }\n    this.Editor.BlockManager.blocks.length === 0 && this.Editor.BlockManager.insert(), this.Editor.BlockManager.currentBlock && this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock, this.Editor.Caret.positions.END), this.Editor.Toolbar.close();\n  }\n  /**\n   * Clear Editor's area\n   */\n  async clear() {\n    await this.Editor.BlockManager.clear(!0), this.Editor.InlineToolbar.close();\n  }\n  /**\n   * Fills Editor with Blocks data\n   *\n   * @param {OutputData} data — Saved Editor data\n   */\n  async render(e) {\n    if (e === void 0 || e.blocks === void 0)\n      throw new Error(\"Incorrect data passed to the render() method\");\n    this.Editor.ModificationsObserver.disable(), await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(e.blocks), this.Editor.ModificationsObserver.enable();\n  }\n  /**\n   * Render passed HTML string\n   *\n   * @param {string} data - HTML string to render\n   * @returns {Promise<void>}\n   */\n  renderFromHTML(e) {\n    return this.Editor.BlockManager.clear(), this.Editor.Paste.processText(e, !0);\n  }\n  /**\n   * Stretch Block's content\n   *\n   * @param {number} index - index of Block to stretch\n   * @param {boolean} status - true to enable, false to disable\n   * @deprecated Use BlockAPI interface to stretch Blocks\n   */\n  stretchBlock(e, t = !0) {\n    ht(\n      !0,\n      \"blocks.stretchBlock()\",\n      \"BlockAPI\"\n    );\n    const o = this.Editor.BlockManager.getBlockByIndex(e);\n    o && (o.stretched = t);\n  }\n  /**\n   * Insert new Block\n   * After set caret to this Block\n   *\n   * @todo remove in 3.0.0\n   * @deprecated with insert() method\n   */\n  insertNewBlock() {\n    S(\"Method blocks.insertNewBlock() is deprecated and it will be removed in the next major release. Use blocks.insert() instead.\", \"warn\"), this.insert();\n  }\n  /**\n   * Validated block index and throws an error if it's invalid\n   *\n   * @param index - index to validate\n   */\n  validateIndex(e) {\n    if (typeof e != \"number\")\n      throw new Error(\"Index should be a number\");\n    if (e < 0)\n      throw new Error(\"Index should be greater than or equal to 0\");\n    if (e === null)\n      throw new Error(\"Index should be greater than or equal to 0\");\n  }\n}\nfunction mi(n, e) {\n  return typeof n == \"number\" ? e.BlockManager.getBlockByIndex(n) : typeof n == \"string\" ? e.BlockManager.getBlockById(n) : e.BlockManager.getBlockById(n.id);\n}\nclass bi extends E {\n  constructor() {\n    super(...arguments), this.setToFirstBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.firstBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.firstBlock, e, t), !0) : !1, this.setToLastBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.lastBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.lastBlock, e, t), !0) : !1, this.setToPreviousBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.previousBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.previousBlock, e, t), !0) : !1, this.setToNextBlock = (e = this.Editor.Caret.positions.DEFAULT, t = 0) => this.Editor.BlockManager.nextBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.nextBlock, e, t), !0) : !1, this.setToBlock = (e, t = this.Editor.Caret.positions.DEFAULT, o = 0) => {\n      const i = mi(e, this.Editor);\n      return i === void 0 ? !1 : (this.Editor.Caret.setToBlock(i, t, o), !0);\n    }, this.focus = (e = !1) => e ? this.setToLastBlock(this.Editor.Caret.positions.END) : this.setToFirstBlock(this.Editor.Caret.positions.START);\n  }\n  /**\n   * Available methods\n   *\n   * @returns {Caret}\n   */\n  get methods() {\n    return {\n      setToFirstBlock: this.setToFirstBlock,\n      setToLastBlock: this.setToLastBlock,\n      setToPreviousBlock: this.setToPreviousBlock,\n      setToNextBlock: this.setToNextBlock,\n      setToBlock: this.setToBlock,\n      focus: this.focus\n    };\n  }\n}\nclass vi extends E {\n  /**\n   * Available methods\n   *\n   * @returns {Events}\n   */\n  get methods() {\n    return {\n      emit: (e, t) => this.emit(e, t),\n      off: (e, t) => this.off(e, t),\n      on: (e, t) => this.on(e, t)\n    };\n  }\n  /**\n   * Subscribe on Events\n   *\n   * @param {string} eventName - event name to subscribe\n   * @param {Function} callback - event handler\n   */\n  on(e, t) {\n    this.eventsDispatcher.on(e, t);\n  }\n  /**\n   * Emit event with data\n   *\n   * @param {string} eventName - event to emit\n   * @param {object} data - event's data\n   */\n  emit(e, t) {\n    this.eventsDispatcher.emit(e, t);\n  }\n  /**\n   * Unsubscribe from Event\n   *\n   * @param {string} eventName - event to unsubscribe\n   * @param {Function} callback - event handler\n   */\n  off(e, t) {\n    this.eventsDispatcher.off(e, t);\n  }\n}\nclass kt extends E {\n  /**\n   * Return namespace section for tool or block tune\n   *\n   * @param toolName - tool name\n   * @param isTune - is tool a block tune\n   */\n  static getNamespace(e, t) {\n    return t ? `blockTunes.${e}` : `tools.${e}`;\n  }\n  /**\n   * Return I18n API methods with global dictionary access\n   */\n  get methods() {\n    return {\n      t: () => {\n        X(\"I18n.t() method can be accessed only from Tools\", \"warn\");\n      }\n    };\n  }\n  /**\n   * Return I18n API methods with tool namespaced dictionary\n   *\n   * @param toolName - tool name\n   * @param isTune - is tool a block tune\n   */\n  getMethodsForTool(e, t) {\n    return Object.assign(\n      this.methods,\n      {\n        t: (o) => z.t(kt.getNamespace(e, t), o)\n      }\n    );\n  }\n}\nclass ki extends E {\n  /**\n   * Editor.js Core API modules\n   */\n  get methods() {\n    return {\n      blocks: this.Editor.BlocksAPI.methods,\n      caret: this.Editor.CaretAPI.methods,\n      tools: this.Editor.ToolsAPI.methods,\n      events: this.Editor.EventsAPI.methods,\n      listeners: this.Editor.ListenersAPI.methods,\n      notifier: this.Editor.NotifierAPI.methods,\n      sanitizer: this.Editor.SanitizerAPI.methods,\n      saver: this.Editor.SaverAPI.methods,\n      selection: this.Editor.SelectionAPI.methods,\n      styles: this.Editor.StylesAPI.classes,\n      toolbar: this.Editor.ToolbarAPI.methods,\n      inlineToolbar: this.Editor.InlineToolbarAPI.methods,\n      tooltip: this.Editor.TooltipAPI.methods,\n      i18n: this.Editor.I18nAPI.methods,\n      readOnly: this.Editor.ReadOnlyAPI.methods,\n      ui: this.Editor.UiAPI.methods\n    };\n  }\n  /**\n   * Returns Editor.js Core API methods for passed tool\n   *\n   * @param toolName - tool name\n   * @param isTune - is tool a block tune\n   */\n  getMethodsForTool(e, t) {\n    return Object.assign(\n      this.methods,\n      {\n        i18n: this.Editor.I18nAPI.getMethodsForTool(e, t)\n      }\n    );\n  }\n}\nclass yi extends E {\n  /**\n   * Available methods\n   *\n   * @returns {InlineToolbar}\n   */\n  get methods() {\n    return {\n      close: () => this.close(),\n      open: () => this.open()\n    };\n  }\n  /**\n   * Open Inline Toolbar\n   */\n  open() {\n    this.Editor.InlineToolbar.tryToShow();\n  }\n  /**\n   * Close Inline Toolbar\n   */\n  close() {\n    this.Editor.InlineToolbar.close();\n  }\n}\nclass wi extends E {\n  /**\n   * Available methods\n   *\n   * @returns {Listeners}\n   */\n  get methods() {\n    return {\n      on: (e, t, o, i) => this.on(e, t, o, i),\n      off: (e, t, o, i) => this.off(e, t, o, i),\n      offById: (e) => this.offById(e)\n    };\n  }\n  /**\n   * Ads a DOM event listener. Return it's id.\n   *\n   * @param {HTMLElement} element - Element to set handler to\n   * @param {string} eventType - event type\n   * @param {() => void} handler - event handler\n   * @param {boolean} useCapture - capture event or not\n   */\n  on(e, t, o, i) {\n    return this.listeners.on(e, t, o, i);\n  }\n  /**\n   * Removes DOM listener from element\n   *\n   * @param {Element} element - Element to remove handler from\n   * @param eventType - event type\n   * @param handler - event handler\n   * @param {boolean} useCapture - capture event or not\n   */\n  off(e, t, o, i) {\n    this.listeners.off(e, t, o, i);\n  }\n  /**\n   * Removes DOM listener by the listener id\n   *\n   * @param id - id of the listener to remove\n   */\n  offById(e) {\n    this.listeners.offById(e);\n  }\n}\nvar Ko = { exports: {} };\n(function(n, e) {\n  (function(t, o) {\n    n.exports = o();\n  })(window, function() {\n    return function(t) {\n      var o = {};\n      function i(s) {\n        if (o[s])\n          return o[s].exports;\n        var r = o[s] = { i: s, l: !1, exports: {} };\n        return t[s].call(r.exports, r, r.exports, i), r.l = !0, r.exports;\n      }\n      return i.m = t, i.c = o, i.d = function(s, r, a) {\n        i.o(s, r) || Object.defineProperty(s, r, { enumerable: !0, get: a });\n      }, i.r = function(s) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(s, \"__esModule\", { value: !0 });\n      }, i.t = function(s, r) {\n        if (1 & r && (s = i(s)), 8 & r || 4 & r && typeof s == \"object\" && s && s.__esModule)\n          return s;\n        var a = /* @__PURE__ */ Object.create(null);\n        if (i.r(a), Object.defineProperty(a, \"default\", { enumerable: !0, value: s }), 2 & r && typeof s != \"string\")\n          for (var l in s)\n            i.d(a, l, (function(c) {\n              return s[c];\n            }).bind(null, l));\n        return a;\n      }, i.n = function(s) {\n        var r = s && s.__esModule ? function() {\n          return s.default;\n        } : function() {\n          return s;\n        };\n        return i.d(r, \"a\", r), r;\n      }, i.o = function(s, r) {\n        return Object.prototype.hasOwnProperty.call(s, r);\n      }, i.p = \"/\", i(i.s = 0);\n    }([function(t, o, i) {\n      i(1), /*!\n       * Codex JavaScript Notification module\n       * https://github.com/codex-team/js-notifier\n       */\n      t.exports = function() {\n        var s = i(6), r = \"cdx-notify--bounce-in\", a = null;\n        return { show: function(l) {\n          if (l.message) {\n            (function() {\n              if (a)\n                return !0;\n              a = s.getWrapper(), document.body.appendChild(a);\n            })();\n            var c = null, u = l.time || 8e3;\n            switch (l.type) {\n              case \"confirm\":\n                c = s.confirm(l);\n                break;\n              case \"prompt\":\n                c = s.prompt(l);\n                break;\n              default:\n                c = s.alert(l), window.setTimeout(function() {\n                  c.remove();\n                }, u);\n            }\n            a.appendChild(c), c.classList.add(r);\n          }\n        } };\n      }();\n    }, function(t, o, i) {\n      var s = i(2);\n      typeof s == \"string\" && (s = [[t.i, s, \"\"]]);\n      var r = { hmr: !0, transform: void 0, insertInto: void 0 };\n      i(4)(s, r), s.locals && (t.exports = s.locals);\n    }, function(t, o, i) {\n      (t.exports = i(3)(!1)).push([t.i, `.cdx-notify--error{background:#fffbfb!important}.cdx-notify--error::before{background:#fb5d5d!important}.cdx-notify__input{max-width:130px;padding:5px 10px;background:#f7f7f7;border:0;border-radius:3px;font-size:13px;color:#656b7c;outline:0}.cdx-notify__input:-ms-input-placeholder{color:#656b7c}.cdx-notify__input::placeholder{color:#656b7c}.cdx-notify__input:focus:-ms-input-placeholder{color:rgba(101,107,124,.3)}.cdx-notify__input:focus::placeholder{color:rgba(101,107,124,.3)}.cdx-notify__button{border:none;border-radius:3px;font-size:13px;padding:5px 10px;cursor:pointer}.cdx-notify__button:last-child{margin-left:10px}.cdx-notify__button--cancel{background:#f2f5f7;box-shadow:0 2px 1px 0 rgba(16,19,29,0);color:#656b7c}.cdx-notify__button--cancel:hover{background:#eee}.cdx-notify__button--confirm{background:#34c992;box-shadow:0 1px 1px 0 rgba(18,49,35,.05);color:#fff}.cdx-notify__button--confirm:hover{background:#33b082}.cdx-notify__btns-wrapper{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;margin-top:5px}.cdx-notify__cross{position:absolute;top:5px;right:5px;width:10px;height:10px;padding:5px;opacity:.54;cursor:pointer}.cdx-notify__cross::after,.cdx-notify__cross::before{content:'';position:absolute;left:9px;top:5px;height:12px;width:2px;background:#575d67}.cdx-notify__cross::before{transform:rotate(-45deg)}.cdx-notify__cross::after{transform:rotate(45deg)}.cdx-notify__cross:hover{opacity:1}.cdx-notifies{position:fixed;z-index:2;bottom:20px;left:20px;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen,Ubuntu,Cantarell,\"Fira Sans\",\"Droid Sans\",\"Helvetica Neue\",sans-serif}.cdx-notify{position:relative;width:220px;margin-top:15px;padding:13px 16px;background:#fff;box-shadow:0 11px 17px 0 rgba(23,32,61,.13);border-radius:5px;font-size:14px;line-height:1.4em;word-wrap:break-word}.cdx-notify::before{content:'';position:absolute;display:block;top:0;left:0;width:3px;height:calc(100% - 6px);margin:3px;border-radius:5px;background:0 0}@keyframes bounceIn{0%{opacity:0;transform:scale(.3)}50%{opacity:1;transform:scale(1.05)}70%{transform:scale(.9)}100%{transform:scale(1)}}.cdx-notify--bounce-in{animation-name:bounceIn;animation-duration:.6s;animation-iteration-count:1}.cdx-notify--success{background:#fafffe!important}.cdx-notify--success::before{background:#41ffb1!important}`, \"\"]);\n    }, function(t, o) {\n      t.exports = function(i) {\n        var s = [];\n        return s.toString = function() {\n          return this.map(function(r) {\n            var a = function(l, c) {\n              var u = l[1] || \"\", h = l[3];\n              if (!h)\n                return u;\n              if (c && typeof btoa == \"function\") {\n                var p = (f = h, \"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(f)))) + \" */\"), g = h.sources.map(function(v) {\n                  return \"/*# sourceURL=\" + h.sourceRoot + v + \" */\";\n                });\n                return [u].concat(g).concat([p]).join(`\n`);\n              }\n              var f;\n              return [u].join(`\n`);\n            }(r, i);\n            return r[2] ? \"@media \" + r[2] + \"{\" + a + \"}\" : a;\n          }).join(\"\");\n        }, s.i = function(r, a) {\n          typeof r == \"string\" && (r = [[null, r, \"\"]]);\n          for (var l = {}, c = 0; c < this.length; c++) {\n            var u = this[c][0];\n            typeof u == \"number\" && (l[u] = !0);\n          }\n          for (c = 0; c < r.length; c++) {\n            var h = r[c];\n            typeof h[0] == \"number\" && l[h[0]] || (a && !h[2] ? h[2] = a : a && (h[2] = \"(\" + h[2] + \") and (\" + a + \")\"), s.push(h));\n          }\n        }, s;\n      };\n    }, function(t, o, i) {\n      var s, r, a = {}, l = (s = function() {\n        return window && document && document.all && !window.atob;\n      }, function() {\n        return r === void 0 && (r = s.apply(this, arguments)), r;\n      }), c = function(k) {\n        var m = {};\n        return function(w) {\n          if (typeof w == \"function\")\n            return w();\n          if (m[w] === void 0) {\n            var x = (function(I) {\n              return document.querySelector(I);\n            }).call(this, w);\n            if (window.HTMLIFrameElement && x instanceof window.HTMLIFrameElement)\n              try {\n                x = x.contentDocument.head;\n              } catch {\n                x = null;\n              }\n            m[w] = x;\n          }\n          return m[w];\n        };\n      }(), u = null, h = 0, p = [], g = i(5);\n      function f(k, m) {\n        for (var w = 0; w < k.length; w++) {\n          var x = k[w], I = a[x.id];\n          if (I) {\n            I.refs++;\n            for (var C = 0; C < I.parts.length; C++)\n              I.parts[C](x.parts[C]);\n            for (; C < x.parts.length; C++)\n              I.parts.push(F(x.parts[C], m));\n          } else {\n            var N = [];\n            for (C = 0; C < x.parts.length; C++)\n              N.push(F(x.parts[C], m));\n            a[x.id] = { id: x.id, refs: 1, parts: N };\n          }\n        }\n      }\n      function v(k, m) {\n        for (var w = [], x = {}, I = 0; I < k.length; I++) {\n          var C = k[I], N = m.base ? C[0] + m.base : C[0], B = { css: C[1], media: C[2], sourceMap: C[3] };\n          x[N] ? x[N].parts.push(B) : w.push(x[N] = { id: N, parts: [B] });\n        }\n        return w;\n      }\n      function O(k, m) {\n        var w = c(k.insertInto);\n        if (!w)\n          throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n        var x = p[p.length - 1];\n        if (k.insertAt === \"top\")\n          x ? x.nextSibling ? w.insertBefore(m, x.nextSibling) : w.appendChild(m) : w.insertBefore(m, w.firstChild), p.push(m);\n        else if (k.insertAt === \"bottom\")\n          w.appendChild(m);\n        else {\n          if (typeof k.insertAt != \"object\" || !k.insertAt.before)\n            throw new Error(`[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n`);\n          var I = c(k.insertInto + \" \" + k.insertAt.before);\n          w.insertBefore(m, I);\n        }\n      }\n      function T(k) {\n        if (k.parentNode === null)\n          return !1;\n        k.parentNode.removeChild(k);\n        var m = p.indexOf(k);\n        m >= 0 && p.splice(m, 1);\n      }\n      function M(k) {\n        var m = document.createElement(\"style\");\n        return k.attrs.type === void 0 && (k.attrs.type = \"text/css\"), q(m, k.attrs), O(k, m), m;\n      }\n      function q(k, m) {\n        Object.keys(m).forEach(function(w) {\n          k.setAttribute(w, m[w]);\n        });\n      }\n      function F(k, m) {\n        var w, x, I, C;\n        if (m.transform && k.css) {\n          if (!(C = m.transform(k.css)))\n            return function() {\n            };\n          k.css = C;\n        }\n        if (m.singleton) {\n          var N = h++;\n          w = u || (u = M(m)), x = ie.bind(null, w, N, !1), I = ie.bind(null, w, N, !0);\n        } else\n          k.sourceMap && typeof URL == \"function\" && typeof URL.createObjectURL == \"function\" && typeof URL.revokeObjectURL == \"function\" && typeof Blob == \"function\" && typeof btoa == \"function\" ? (w = function(B) {\n            var W = document.createElement(\"link\");\n            return B.attrs.type === void 0 && (B.attrs.type = \"text/css\"), B.attrs.rel = \"stylesheet\", q(W, B.attrs), O(B, W), W;\n          }(m), x = (function(B, W, ve) {\n            var se = ve.css, tt = ve.sourceMap, Yn = W.convertToAbsoluteUrls === void 0 && tt;\n            (W.convertToAbsoluteUrls || Yn) && (se = g(se)), tt && (se += `\n/*# sourceMappingURL=data:application/json;base64,` + btoa(unescape(encodeURIComponent(JSON.stringify(tt)))) + \" */\");\n            var Kn = new Blob([se], { type: \"text/css\" }), ko = B.href;\n            B.href = URL.createObjectURL(Kn), ko && URL.revokeObjectURL(ko);\n          }).bind(null, w, m), I = function() {\n            T(w), w.href && URL.revokeObjectURL(w.href);\n          }) : (w = M(m), x = (function(B, W) {\n            var ve = W.css, se = W.media;\n            if (se && B.setAttribute(\"media\", se), B.styleSheet)\n              B.styleSheet.cssText = ve;\n            else {\n              for (; B.firstChild; )\n                B.removeChild(B.firstChild);\n              B.appendChild(document.createTextNode(ve));\n            }\n          }).bind(null, w), I = function() {\n            T(w);\n          });\n        return x(k), function(B) {\n          if (B) {\n            if (B.css === k.css && B.media === k.media && B.sourceMap === k.sourceMap)\n              return;\n            x(k = B);\n          } else\n            I();\n        };\n      }\n      t.exports = function(k, m) {\n        if (typeof DEBUG < \"u\" && DEBUG && typeof document != \"object\")\n          throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n        (m = m || {}).attrs = typeof m.attrs == \"object\" ? m.attrs : {}, m.singleton || typeof m.singleton == \"boolean\" || (m.singleton = l()), m.insertInto || (m.insertInto = \"head\"), m.insertAt || (m.insertAt = \"bottom\");\n        var w = v(k, m);\n        return f(w, m), function(x) {\n          for (var I = [], C = 0; C < w.length; C++) {\n            var N = w[C];\n            (B = a[N.id]).refs--, I.push(B);\n          }\n          for (x && f(v(x, m), m), C = 0; C < I.length; C++) {\n            var B;\n            if ((B = I[C]).refs === 0) {\n              for (var W = 0; W < B.parts.length; W++)\n                B.parts[W]();\n              delete a[B.id];\n            }\n          }\n        };\n      };\n      var H, Q = (H = [], function(k, m) {\n        return H[k] = m, H.filter(Boolean).join(`\n`);\n      });\n      function ie(k, m, w, x) {\n        var I = w ? \"\" : x.css;\n        if (k.styleSheet)\n          k.styleSheet.cssText = Q(m, I);\n        else {\n          var C = document.createTextNode(I), N = k.childNodes;\n          N[m] && k.removeChild(N[m]), N.length ? k.insertBefore(C, N[m]) : k.appendChild(C);\n        }\n      }\n    }, function(t, o) {\n      t.exports = function(i) {\n        var s = typeof window < \"u\" && window.location;\n        if (!s)\n          throw new Error(\"fixUrls requires window.location\");\n        if (!i || typeof i != \"string\")\n          return i;\n        var r = s.protocol + \"//\" + s.host, a = r + s.pathname.replace(/\\/[^\\/]*$/, \"/\");\n        return i.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(l, c) {\n          var u, h = c.trim().replace(/^\"(.*)\"$/, function(p, g) {\n            return g;\n          }).replace(/^'(.*)'$/, function(p, g) {\n            return g;\n          });\n          return /^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(h) ? l : (u = h.indexOf(\"//\") === 0 ? h : h.indexOf(\"/\") === 0 ? r + h : a + h.replace(/^\\.\\//, \"\"), \"url(\" + JSON.stringify(u) + \")\");\n        });\n      };\n    }, function(t, o, i) {\n      var s, r, a, l, c, u, h, p, g;\n      t.exports = (s = \"cdx-notifies\", r = \"cdx-notify\", a = \"cdx-notify__cross\", l = \"cdx-notify__button--confirm\", c = \"cdx-notify__button--cancel\", u = \"cdx-notify__input\", h = \"cdx-notify__button\", p = \"cdx-notify__btns-wrapper\", { alert: g = function(f) {\n        var v = document.createElement(\"DIV\"), O = document.createElement(\"DIV\"), T = f.message, M = f.style;\n        return v.classList.add(r), M && v.classList.add(r + \"--\" + M), v.innerHTML = T, O.classList.add(a), O.addEventListener(\"click\", v.remove.bind(v)), v.appendChild(O), v;\n      }, confirm: function(f) {\n        var v = g(f), O = document.createElement(\"div\"), T = document.createElement(\"button\"), M = document.createElement(\"button\"), q = v.querySelector(\".\" + a), F = f.cancelHandler, H = f.okHandler;\n        return O.classList.add(p), T.innerHTML = f.okText || \"Confirm\", M.innerHTML = f.cancelText || \"Cancel\", T.classList.add(h), M.classList.add(h), T.classList.add(l), M.classList.add(c), F && typeof F == \"function\" && (M.addEventListener(\"click\", F), q.addEventListener(\"click\", F)), H && typeof H == \"function\" && T.addEventListener(\"click\", H), T.addEventListener(\"click\", v.remove.bind(v)), M.addEventListener(\"click\", v.remove.bind(v)), O.appendChild(T), O.appendChild(M), v.appendChild(O), v;\n      }, prompt: function(f) {\n        var v = g(f), O = document.createElement(\"div\"), T = document.createElement(\"button\"), M = document.createElement(\"input\"), q = v.querySelector(\".\" + a), F = f.cancelHandler, H = f.okHandler;\n        return O.classList.add(p), T.innerHTML = f.okText || \"Ok\", T.classList.add(h), T.classList.add(l), M.classList.add(u), f.placeholder && M.setAttribute(\"placeholder\", f.placeholder), f.default && (M.value = f.default), f.inputType && (M.type = f.inputType), F && typeof F == \"function\" && q.addEventListener(\"click\", F), H && typeof H == \"function\" && T.addEventListener(\"click\", function() {\n          H(M.value);\n        }), T.addEventListener(\"click\", v.remove.bind(v)), O.appendChild(M), O.appendChild(T), v.appendChild(O), v;\n      }, getWrapper: function() {\n        var f = document.createElement(\"DIV\");\n        return f.classList.add(s), f;\n      } });\n    }]);\n  });\n})(Ko);\nvar Ei = Ko.exports;\nconst xi = /* @__PURE__ */ Ke(Ei);\nclass Bi {\n  /**\n   * Show web notification\n   *\n   * @param {NotifierOptions | ConfirmNotifierOptions | PromptNotifierOptions} options - notification options\n   */\n  show(e) {\n    xi.show(e);\n  }\n}\nclass Ci extends E {\n  /**\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.notifier = new Bi();\n  }\n  /**\n   * Available methods\n   */\n  get methods() {\n    return {\n      show: (e) => this.show(e)\n    };\n  }\n  /**\n   * Show notification\n   *\n   * @param {NotifierOptions} options - message option\n   */\n  show(e) {\n    return this.notifier.show(e);\n  }\n}\nclass Ti extends E {\n  /**\n   * Available methods\n   */\n  get methods() {\n    const e = () => this.isEnabled;\n    return {\n      toggle: (t) => this.toggle(t),\n      get isEnabled() {\n        return e();\n      }\n    };\n  }\n  /**\n   * Set or toggle read-only state\n   *\n   * @param {boolean|undefined} state - set or toggle state\n   * @returns {boolean} current value\n   */\n  toggle(e) {\n    return this.Editor.ReadOnly.toggle(e);\n  }\n  /**\n   * Returns current read-only state\n   */\n  get isEnabled() {\n    return this.Editor.ReadOnly.isEnabled;\n  }\n}\nvar Xo = { exports: {} };\n(function(n, e) {\n  (function(t, o) {\n    n.exports = o();\n  })(Ce, function() {\n    function t(h) {\n      var p = h.tags, g = Object.keys(p), f = g.map(function(v) {\n        return typeof p[v];\n      }).every(function(v) {\n        return v === \"object\" || v === \"boolean\" || v === \"function\";\n      });\n      if (!f)\n        throw new Error(\"The configuration was invalid\");\n      this.config = h;\n    }\n    var o = [\"P\", \"LI\", \"TD\", \"TH\", \"DIV\", \"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\", \"PRE\"];\n    function i(h) {\n      return o.indexOf(h.nodeName) !== -1;\n    }\n    var s = [\"A\", \"B\", \"STRONG\", \"I\", \"EM\", \"SUB\", \"SUP\", \"U\", \"STRIKE\"];\n    function r(h) {\n      return s.indexOf(h.nodeName) !== -1;\n    }\n    t.prototype.clean = function(h) {\n      const p = document.implementation.createHTMLDocument(), g = p.createElement(\"div\");\n      return g.innerHTML = h, this._sanitize(p, g), g.innerHTML;\n    }, t.prototype._sanitize = function(h, p) {\n      var g = a(h, p), f = g.firstChild();\n      if (f)\n        do {\n          if (f.nodeType === Node.TEXT_NODE)\n            if (f.data.trim() === \"\" && (f.previousElementSibling && i(f.previousElementSibling) || f.nextElementSibling && i(f.nextElementSibling))) {\n              p.removeChild(f), this._sanitize(h, p);\n              break;\n            } else\n              continue;\n          if (f.nodeType === Node.COMMENT_NODE) {\n            p.removeChild(f), this._sanitize(h, p);\n            break;\n          }\n          var v = r(f), O;\n          v && (O = Array.prototype.some.call(f.childNodes, i));\n          var T = !!p.parentNode, M = i(p) && i(f) && T, q = f.nodeName.toLowerCase(), F = l(this.config, q, f), H = v && O;\n          if (H || c(f, F) || !this.config.keepNestedBlockElements && M) {\n            if (!(f.nodeName === \"SCRIPT\" || f.nodeName === \"STYLE\"))\n              for (; f.childNodes.length > 0; )\n                p.insertBefore(f.childNodes[0], f);\n            p.removeChild(f), this._sanitize(h, p);\n            break;\n          }\n          for (var Q = 0; Q < f.attributes.length; Q += 1) {\n            var ie = f.attributes[Q];\n            u(ie, F, f) && (f.removeAttribute(ie.name), Q = Q - 1);\n          }\n          this._sanitize(h, f);\n        } while (f = g.nextSibling());\n    };\n    function a(h, p) {\n      return h.createTreeWalker(\n        p,\n        NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT,\n        null,\n        !1\n      );\n    }\n    function l(h, p, g) {\n      return typeof h.tags[p] == \"function\" ? h.tags[p](g) : h.tags[p];\n    }\n    function c(h, p) {\n      return typeof p > \"u\" ? !0 : typeof p == \"boolean\" ? !p : !1;\n    }\n    function u(h, p, g) {\n      var f = h.name.toLowerCase();\n      return p === !0 ? !1 : typeof p[f] == \"function\" ? !p[f](h.value, g) : typeof p[f] > \"u\" || p[f] === !1 ? !0 : typeof p[f] == \"string\" ? p[f] !== h.value : !1;\n    }\n    return t;\n  });\n})(Xo);\nvar Si = Xo.exports;\nconst Ii = /* @__PURE__ */ Ke(Si);\nfunction yt(n, e) {\n  return n.map((t) => {\n    const o = A(e) ? e(t.tool) : e;\n    return V(o) || (t.data = wt(t.data, o)), t;\n  });\n}\nfunction Z(n, e = {}) {\n  const t = {\n    tags: e\n  };\n  return new Ii(t).clean(n);\n}\nfunction wt(n, e) {\n  return Array.isArray(n) ? Oi(n, e) : D(n) ? _i(n, e) : te(n) ? Mi(n, e) : n;\n}\nfunction Oi(n, e) {\n  return n.map((t) => wt(t, e));\n}\nfunction _i(n, e) {\n  const t = {};\n  for (const o in n) {\n    if (!Object.prototype.hasOwnProperty.call(n, o))\n      continue;\n    const i = n[o], s = Ai(e[o]) ? e[o] : e;\n    t[o] = wt(i, s);\n  }\n  return t;\n}\nfunction Mi(n, e) {\n  return D(e) ? Z(n, e) : e === !1 ? Z(n, {}) : n;\n}\nfunction Ai(n) {\n  return D(n) || Gn(n) || A(n);\n}\nclass Li extends E {\n  /**\n   * Available methods\n   *\n   * @returns {SanitizerConfig}\n   */\n  get methods() {\n    return {\n      clean: (e, t) => this.clean(e, t)\n    };\n  }\n  /**\n   * Perform sanitizing of a string\n   *\n   * @param {string} taintString - what to sanitize\n   * @param {SanitizerConfig} config - sanitizer config\n   * @returns {string}\n   */\n  clean(e, t) {\n    return Z(e, t);\n  }\n}\nclass Pi extends E {\n  /**\n   * Available methods\n   *\n   * @returns {Saver}\n   */\n  get methods() {\n    return {\n      save: () => this.save()\n    };\n  }\n  /**\n   * Return Editor's data\n   *\n   * @returns {OutputData}\n   */\n  save() {\n    const e = \"Editor's content can not be saved in read-only mode\";\n    return this.Editor.ReadOnly.isEnabled ? (X(e, \"warn\"), Promise.reject(new Error(e))) : this.Editor.Saver.save();\n  }\n}\nclass Ni extends E {\n  constructor() {\n    super(...arguments), this.selectionUtils = new b();\n  }\n  /**\n   * Available methods\n   *\n   * @returns {SelectionAPIInterface}\n   */\n  get methods() {\n    return {\n      findParentTag: (e, t) => this.findParentTag(e, t),\n      expandToTag: (e) => this.expandToTag(e),\n      save: () => this.selectionUtils.save(),\n      restore: () => this.selectionUtils.restore(),\n      setFakeBackground: () => this.selectionUtils.setFakeBackground(),\n      removeFakeBackground: () => this.selectionUtils.removeFakeBackground()\n    };\n  }\n  /**\n   * Looks ahead from selection and find passed tag with class name\n   *\n   * @param {string} tagName - tag to find\n   * @param {string} className - tag's class name\n   * @returns {HTMLElement|null}\n   */\n  findParentTag(e, t) {\n    return this.selectionUtils.findParentTag(e, t);\n  }\n  /**\n   * Expand selection to passed tag\n   *\n   * @param {HTMLElement} node - tag that should contain selection\n   */\n  expandToTag(e) {\n    this.selectionUtils.expandToTag(e);\n  }\n}\nclass Ri extends E {\n  /**\n   * Available methods\n   */\n  get methods() {\n    return {\n      getBlockTools: () => Array.from(this.Editor.Tools.blockTools.values())\n    };\n  }\n}\nclass Di extends E {\n  /**\n   * Exported classes\n   */\n  get classes() {\n    return {\n      /**\n       * Base Block styles\n       */\n      block: \"cdx-block\",\n      /**\n       * Inline Tools styles\n       */\n      inlineToolButton: \"ce-inline-tool\",\n      inlineToolButtonActive: \"ce-inline-tool--active\",\n      /**\n       * UI elements\n       */\n      input: \"cdx-input\",\n      loader: \"cdx-loader\",\n      button: \"cdx-button\",\n      /**\n       * Settings styles\n       */\n      settingsButton: \"cdx-settings-button\",\n      settingsButtonActive: \"cdx-settings-button--active\"\n    };\n  }\n}\nclass Fi extends E {\n  /**\n   * Available methods\n   *\n   * @returns {Toolbar}\n   */\n  get methods() {\n    return {\n      close: () => this.close(),\n      open: () => this.open(),\n      toggleBlockSettings: (e) => this.toggleBlockSettings(e),\n      toggleToolbox: (e) => this.toggleToolbox(e)\n    };\n  }\n  /**\n   * Open toolbar\n   */\n  open() {\n    this.Editor.Toolbar.moveAndOpen();\n  }\n  /**\n   * Close toolbar and all included elements\n   */\n  close() {\n    this.Editor.Toolbar.close();\n  }\n  /**\n   * Toggles Block Setting of the current block\n   *\n   * @param {boolean} openingState —  opening state of Block Setting\n   */\n  toggleBlockSettings(e) {\n    if (this.Editor.BlockManager.currentBlockIndex === -1) {\n      X(\"Could't toggle the Toolbar because there is no block selected \", \"warn\");\n      return;\n    }\n    e ?? !this.Editor.BlockSettings.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.BlockSettings.open()) : this.Editor.BlockSettings.close();\n  }\n  /**\n   * Open toolbox\n   *\n   * @param {boolean} openingState - Opening state of toolbox\n   */\n  toggleToolbox(e) {\n    if (this.Editor.BlockManager.currentBlockIndex === -1) {\n      X(\"Could't toggle the Toolbox because there is no block selected \", \"warn\");\n      return;\n    }\n    e ?? !this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open()) : this.Editor.Toolbar.toolbox.close();\n  }\n}\nvar Vo = { exports: {} };\n/*!\n * CodeX.Tooltips\n * \n * @version 1.0.5\n * \n * @licence MIT\n * @author CodeX <https://codex.so>\n * \n * \n */\n(function(n, e) {\n  (function(t, o) {\n    n.exports = o();\n  })(window, function() {\n    return function(t) {\n      var o = {};\n      function i(s) {\n        if (o[s])\n          return o[s].exports;\n        var r = o[s] = { i: s, l: !1, exports: {} };\n        return t[s].call(r.exports, r, r.exports, i), r.l = !0, r.exports;\n      }\n      return i.m = t, i.c = o, i.d = function(s, r, a) {\n        i.o(s, r) || Object.defineProperty(s, r, { enumerable: !0, get: a });\n      }, i.r = function(s) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(s, \"__esModule\", { value: !0 });\n      }, i.t = function(s, r) {\n        if (1 & r && (s = i(s)), 8 & r || 4 & r && typeof s == \"object\" && s && s.__esModule)\n          return s;\n        var a = /* @__PURE__ */ Object.create(null);\n        if (i.r(a), Object.defineProperty(a, \"default\", { enumerable: !0, value: s }), 2 & r && typeof s != \"string\")\n          for (var l in s)\n            i.d(a, l, (function(c) {\n              return s[c];\n            }).bind(null, l));\n        return a;\n      }, i.n = function(s) {\n        var r = s && s.__esModule ? function() {\n          return s.default;\n        } : function() {\n          return s;\n        };\n        return i.d(r, \"a\", r), r;\n      }, i.o = function(s, r) {\n        return Object.prototype.hasOwnProperty.call(s, r);\n      }, i.p = \"\", i(i.s = 0);\n    }([function(t, o, i) {\n      t.exports = i(1);\n    }, function(t, o, i) {\n      i.r(o), i.d(o, \"default\", function() {\n        return s;\n      });\n      class s {\n        constructor() {\n          this.nodes = { wrapper: null, content: null }, this.showed = !1, this.offsetTop = 10, this.offsetLeft = 10, this.offsetRight = 10, this.hidingDelay = 0, this.handleWindowScroll = () => {\n            this.showed && this.hide(!0);\n          }, this.loadStyles(), this.prepare(), window.addEventListener(\"scroll\", this.handleWindowScroll, { passive: !0 });\n        }\n        get CSS() {\n          return { tooltip: \"ct\", tooltipContent: \"ct__content\", tooltipShown: \"ct--shown\", placement: { left: \"ct--left\", bottom: \"ct--bottom\", right: \"ct--right\", top: \"ct--top\" } };\n        }\n        show(a, l, c) {\n          this.nodes.wrapper || this.prepare(), this.hidingTimeout && clearTimeout(this.hidingTimeout);\n          const u = Object.assign({ placement: \"bottom\", marginTop: 0, marginLeft: 0, marginRight: 0, marginBottom: 0, delay: 70, hidingDelay: 0 }, c);\n          if (u.hidingDelay && (this.hidingDelay = u.hidingDelay), this.nodes.content.innerHTML = \"\", typeof l == \"string\")\n            this.nodes.content.appendChild(document.createTextNode(l));\n          else {\n            if (!(l instanceof Node))\n              throw Error(\"[CodeX Tooltip] Wrong type of «content» passed. It should be an instance of Node or String. But \" + typeof l + \" given.\");\n            this.nodes.content.appendChild(l);\n          }\n          switch (this.nodes.wrapper.classList.remove(...Object.values(this.CSS.placement)), u.placement) {\n            case \"top\":\n              this.placeTop(a, u);\n              break;\n            case \"left\":\n              this.placeLeft(a, u);\n              break;\n            case \"right\":\n              this.placeRight(a, u);\n              break;\n            case \"bottom\":\n            default:\n              this.placeBottom(a, u);\n          }\n          u && u.delay ? this.showingTimeout = setTimeout(() => {\n            this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = !0;\n          }, u.delay) : (this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = !0);\n        }\n        hide(a = !1) {\n          if (this.hidingDelay && !a)\n            return this.hidingTimeout && clearTimeout(this.hidingTimeout), void (this.hidingTimeout = setTimeout(() => {\n              this.hide(!0);\n            }, this.hidingDelay));\n          this.nodes.wrapper.classList.remove(this.CSS.tooltipShown), this.showed = !1, this.showingTimeout && clearTimeout(this.showingTimeout);\n        }\n        onHover(a, l, c) {\n          a.addEventListener(\"mouseenter\", () => {\n            this.show(a, l, c);\n          }), a.addEventListener(\"mouseleave\", () => {\n            this.hide();\n          });\n        }\n        destroy() {\n          this.nodes.wrapper.remove(), window.removeEventListener(\"scroll\", this.handleWindowScroll);\n        }\n        prepare() {\n          this.nodes.wrapper = this.make(\"div\", this.CSS.tooltip), this.nodes.content = this.make(\"div\", this.CSS.tooltipContent), this.append(this.nodes.wrapper, this.nodes.content), this.append(document.body, this.nodes.wrapper);\n        }\n        loadStyles() {\n          const a = \"codex-tooltips-style\";\n          if (document.getElementById(a))\n            return;\n          const l = i(2), c = this.make(\"style\", null, { textContent: l.toString(), id: a });\n          this.prepend(document.head, c);\n        }\n        placeBottom(a, l) {\n          const c = a.getBoundingClientRect(), u = c.left + a.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h = c.bottom + window.pageYOffset + this.offsetTop + l.marginTop;\n          this.applyPlacement(\"bottom\", u, h);\n        }\n        placeTop(a, l) {\n          const c = a.getBoundingClientRect(), u = c.left + a.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h = c.top + window.pageYOffset - this.nodes.wrapper.clientHeight - this.offsetTop;\n          this.applyPlacement(\"top\", u, h);\n        }\n        placeLeft(a, l) {\n          const c = a.getBoundingClientRect(), u = c.left - this.nodes.wrapper.offsetWidth - this.offsetLeft - l.marginLeft, h = c.top + window.pageYOffset + a.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;\n          this.applyPlacement(\"left\", u, h);\n        }\n        placeRight(a, l) {\n          const c = a.getBoundingClientRect(), u = c.right + this.offsetRight + l.marginRight, h = c.top + window.pageYOffset + a.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;\n          this.applyPlacement(\"right\", u, h);\n        }\n        applyPlacement(a, l, c) {\n          this.nodes.wrapper.classList.add(this.CSS.placement[a]), this.nodes.wrapper.style.left = l + \"px\", this.nodes.wrapper.style.top = c + \"px\";\n        }\n        make(a, l = null, c = {}) {\n          const u = document.createElement(a);\n          Array.isArray(l) ? u.classList.add(...l) : l && u.classList.add(l);\n          for (const h in c)\n            c.hasOwnProperty(h) && (u[h] = c[h]);\n          return u;\n        }\n        append(a, l) {\n          Array.isArray(l) ? l.forEach((c) => a.appendChild(c)) : a.appendChild(l);\n        }\n        prepend(a, l) {\n          Array.isArray(l) ? (l = l.reverse()).forEach((c) => a.prepend(c)) : a.prepend(l);\n        }\n      }\n    }, function(t, o) {\n      t.exports = `.ct{z-index:999;opacity:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none;-webkit-transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1),-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);will-change:opacity,top,left;-webkit-box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);border-radius:9px}.ct,.ct:before{position:absolute;top:0;left:0}.ct:before{content:\"\";bottom:0;right:0;background-color:#1d202b;z-index:-1;border-radius:4px}@supports(-webkit-mask-box-image:url(\"\")){.ct:before{border-radius:0;-webkit-mask-box-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\"><path d=\"M10.71 0h2.58c3.02 0 4.64.42 6.1 1.2a8.18 8.18 0 013.4 3.4C23.6 6.07 24 7.7 24 10.71v2.58c0 3.02-.42 4.64-1.2 6.1a8.18 8.18 0 01-3.4 3.4c-1.47.8-3.1 1.21-6.11 1.21H10.7c-3.02 0-4.64-.42-6.1-1.2a8.18 8.18 0 01-3.4-3.4C.4 17.93 0 16.3 0 13.29V10.7c0-3.02.42-4.64 1.2-6.1a8.18 8.18 0 013.4-3.4C6.07.4 7.7 0 10.71 0z\"/></svg>') 48% 41% 37.9% 53.3%}}@media (--mobile){.ct{display:none}}.ct__content{padding:6px 10px;color:#cdd1e0;font-size:12px;text-align:center;letter-spacing:.02em;line-height:1em}.ct:after{content:\"\";width:8px;height:8px;position:absolute;background-color:#1d202b;z-index:-1}.ct--bottom{-webkit-transform:translateY(5px);transform:translateY(5px)}.ct--bottom:after{top:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--top{-webkit-transform:translateY(-5px);transform:translateY(-5px)}.ct--top:after{top:auto;bottom:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--left{-webkit-transform:translateX(-5px);transform:translateX(-5px)}.ct--left:after{top:50%;left:auto;right:0;-webkit-transform:translate(41.6%,-50%) rotate(-45deg);transform:translate(41.6%,-50%) rotate(-45deg)}.ct--right{-webkit-transform:translateX(5px);transform:translateX(5px)}.ct--right:after{top:50%;left:0;-webkit-transform:translate(-41.6%,-50%) rotate(-45deg);transform:translate(-41.6%,-50%) rotate(-45deg)}.ct--shown{opacity:1;-webkit-transform:none;transform:none}`;\n    }]).default;\n  });\n})(Vo);\nvar ji = Vo.exports;\nconst Hi = /* @__PURE__ */ Ke(ji);\nlet U = null;\nfunction Et() {\n  U || (U = new Hi());\n}\nfunction $i(n, e, t) {\n  Et(), U == null || U.show(n, e, t);\n}\nfunction $e(n = !1) {\n  Et(), U == null || U.hide(n);\n}\nfunction ze(n, e, t) {\n  Et(), U == null || U.onHover(n, e, t);\n}\nfunction zi() {\n  U == null || U.destroy(), U = null;\n}\nclass Ui extends E {\n  /**\n   * @class\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    });\n  }\n  /**\n   * Available methods\n   */\n  get methods() {\n    return {\n      show: (e, t, o) => this.show(e, t, o),\n      hide: () => this.hide(),\n      onHover: (e, t, o) => this.onHover(e, t, o)\n    };\n  }\n  /**\n   * Method show tooltip on element with passed HTML content\n   *\n   * @param {HTMLElement} element - element on which tooltip should be shown\n   * @param {TooltipContent} content - tooltip content\n   * @param {TooltipOptions} options - tooltip options\n   */\n  show(e, t, o) {\n    $i(e, t, o);\n  }\n  /**\n   * Method hides tooltip on HTML page\n   */\n  hide() {\n    $e();\n  }\n  /**\n   * Decorator for showing Tooltip by mouseenter/mouseleave\n   *\n   * @param {HTMLElement} element - element on which tooltip should be shown\n   * @param {TooltipContent} content - tooltip content\n   * @param {TooltipOptions} options - tooltip options\n   */\n  onHover(e, t, o) {\n    ze(e, t, o);\n  }\n}\nclass Wi extends E {\n  /**\n   * Available methods / getters\n   */\n  get methods() {\n    return {\n      nodes: this.editorNodes\n      /**\n       * There can be added some UI methods, like toggleThinMode() etc\n       */\n    };\n  }\n  /**\n   * Exported classes\n   */\n  get editorNodes() {\n    return {\n      /**\n       * Top-level editor instance wrapper\n       */\n      wrapper: this.Editor.UI.nodes.wrapper,\n      /**\n       * Element that holds all the Blocks\n       */\n      redactor: this.Editor.UI.nodes.redactor\n    };\n  }\n}\nfunction qo(n, e) {\n  const t = {};\n  return Object.entries(n).forEach(([o, i]) => {\n    if (D(i)) {\n      const s = e ? `${e}.${o}` : o;\n      Object.values(i).every((a) => te(a)) ? t[o] = s : t[o] = qo(i, s);\n      return;\n    }\n    t[o] = i;\n  }), t;\n}\nconst K = qo(Fo);\nfunction Yi(n, e) {\n  const t = {};\n  return Object.keys(n).forEach((o) => {\n    const i = e[o];\n    i !== void 0 ? t[i] = n[o] : t[o] = n[o];\n  }), t;\n}\nconst Zo = class Ee {\n  /**\n   * @param {HTMLElement[]} nodeList — the list of iterable HTML-items\n   * @param {string} focusedCssClass - user-provided CSS-class that will be set in flipping process\n   */\n  constructor(e, t) {\n    this.cursor = -1, this.items = [], this.items = e || [], this.focusedCssClass = t;\n  }\n  /**\n   * Returns Focused button Node\n   *\n   * @returns {HTMLElement}\n   */\n  get currentItem() {\n    return this.cursor === -1 ? null : this.items[this.cursor];\n  }\n  /**\n   * Sets cursor to specified position\n   *\n   * @param cursorPosition - new cursor position\n   */\n  setCursor(e) {\n    e < this.items.length && e >= -1 && (this.dropCursor(), this.cursor = e, this.items[this.cursor].classList.add(this.focusedCssClass));\n  }\n  /**\n   * Sets items. Can be used when iterable items changed dynamically\n   *\n   * @param {HTMLElement[]} nodeList - nodes to iterate\n   */\n  setItems(e) {\n    this.items = e;\n  }\n  /**\n   * Sets cursor next to the current\n   */\n  next() {\n    this.cursor = this.leafNodesAndReturnIndex(Ee.directions.RIGHT);\n  }\n  /**\n   * Sets cursor before current\n   */\n  previous() {\n    this.cursor = this.leafNodesAndReturnIndex(Ee.directions.LEFT);\n  }\n  /**\n   * Sets cursor to the default position and removes CSS-class from previously focused item\n   */\n  dropCursor() {\n    this.cursor !== -1 && (this.items[this.cursor].classList.remove(this.focusedCssClass), this.cursor = -1);\n  }\n  /**\n   * Leafs nodes inside the target list from active element\n   *\n   * @param {string} direction - leaf direction. Can be 'left' or 'right'\n   * @returns {number} index of focused node\n   */\n  leafNodesAndReturnIndex(e) {\n    if (this.items.length === 0)\n      return this.cursor;\n    let t = this.cursor;\n    return t === -1 ? t = e === Ee.directions.RIGHT ? -1 : 0 : this.items[t].classList.remove(this.focusedCssClass), e === Ee.directions.RIGHT ? t = (t + 1) % this.items.length : t = (this.items.length + t - 1) % this.items.length, d.canSetCaret(this.items[t]) && Fe(() => b.setCursor(this.items[t]), 50)(), this.items[t].classList.add(this.focusedCssClass), t;\n  }\n};\nZo.directions = {\n  RIGHT: \"right\",\n  LEFT: \"left\"\n};\nlet ke = Zo;\nclass ce {\n  /**\n   * @param options - different constructing settings\n   */\n  constructor(e) {\n    this.iterator = null, this.activated = !1, this.flipCallbacks = [], this.onKeyDown = (t) => {\n      if (this.isEventReadyForHandling(t))\n        switch (ce.usedKeys.includes(t.keyCode) && t.preventDefault(), t.keyCode) {\n          case y.TAB:\n            this.handleTabPress(t);\n            break;\n          case y.LEFT:\n          case y.UP:\n            this.flipLeft();\n            break;\n          case y.RIGHT:\n          case y.DOWN:\n            this.flipRight();\n            break;\n          case y.ENTER:\n            this.handleEnterPress(t);\n            break;\n        }\n    }, this.iterator = new ke(e.items, e.focusedItemClass), this.activateCallback = e.activateCallback, this.allowedKeys = e.allowedKeys || ce.usedKeys;\n  }\n  /**\n   * True if flipper is currently activated\n   */\n  get isActivated() {\n    return this.activated;\n  }\n  /**\n   * Array of keys (codes) that is handled by Flipper\n   * Used to:\n   *  - preventDefault only for this keys, not all keydowns (@see constructor)\n   *  - to skip external behaviours only for these keys, when filler is activated (@see BlockEvents@arrowRightAndDown)\n   */\n  static get usedKeys() {\n    return [\n      y.TAB,\n      y.LEFT,\n      y.RIGHT,\n      y.ENTER,\n      y.UP,\n      y.DOWN\n    ];\n  }\n  /**\n   * Active tab/arrows handling by flipper\n   *\n   * @param items - Some modules (like, InlineToolbar, BlockSettings) might refresh buttons dynamically\n   * @param cursorPosition - index of the item that should be focused once flipper is activated\n   */\n  activate(e, t) {\n    this.activated = !0, e && this.iterator.setItems(e), t !== void 0 && this.iterator.setCursor(t), document.addEventListener(\"keydown\", this.onKeyDown, !0);\n  }\n  /**\n   * Disable tab/arrows handling by flipper\n   */\n  deactivate() {\n    this.activated = !1, this.dropCursor(), document.removeEventListener(\"keydown\", this.onKeyDown);\n  }\n  /**\n   * Focus first item\n   */\n  focusFirst() {\n    this.dropCursor(), this.flipRight();\n  }\n  /**\n   * Focuses previous flipper iterator item\n   */\n  flipLeft() {\n    this.iterator.previous(), this.flipCallback();\n  }\n  /**\n   * Focuses next flipper iterator item\n   */\n  flipRight() {\n    this.iterator.next(), this.flipCallback();\n  }\n  /**\n   * Return true if some button is focused\n   */\n  hasFocus() {\n    return !!this.iterator.currentItem;\n  }\n  /**\n   * Registeres function that should be executed on each navigation action\n   *\n   * @param cb - function to execute\n   */\n  onFlip(e) {\n    this.flipCallbacks.push(e);\n  }\n  /**\n   * Unregisteres function that is executed on each navigation action\n   *\n   * @param cb - function to stop executing\n   */\n  removeOnFlip(e) {\n    this.flipCallbacks = this.flipCallbacks.filter((t) => t !== e);\n  }\n  /**\n   * Drops flipper's iterator cursor\n   *\n   * @see DomIterator#dropCursor\n   */\n  dropCursor() {\n    this.iterator.dropCursor();\n  }\n  /**\n   * This function is fired before handling flipper keycodes\n   * The result of this function defines if it is need to be handled or not\n   *\n   * @param {KeyboardEvent} event - keydown keyboard event\n   * @returns {boolean}\n   */\n  isEventReadyForHandling(e) {\n    return this.activated && this.allowedKeys.includes(e.keyCode);\n  }\n  /**\n   * When flipper is activated tab press will leaf the items\n   *\n   * @param {KeyboardEvent} event - tab keydown event\n   */\n  handleTabPress(e) {\n    switch (e.shiftKey ? ke.directions.LEFT : ke.directions.RIGHT) {\n      case ke.directions.RIGHT:\n        this.flipRight();\n        break;\n      case ke.directions.LEFT:\n        this.flipLeft();\n        break;\n    }\n  }\n  /**\n   * Enter press will click current item if flipper is activated\n   *\n   * @param {KeyboardEvent} event - enter keydown event\n   */\n  handleEnterPress(e) {\n    this.activated && (this.iterator.currentItem && (e.stopPropagation(), e.preventDefault(), this.iterator.currentItem.click()), A(this.activateCallback) && this.activateCallback(this.iterator.currentItem));\n  }\n  /**\n   * Fired after flipping in any direction\n   */\n  flipCallback() {\n    this.iterator.currentItem && this.iterator.currentItem.scrollIntoViewIfNeeded(), this.flipCallbacks.forEach((e) => e());\n  }\n}\nconst Ki = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M9 12L9 7.1C9 7.04477 9.04477 7 9.1 7H10.4C11.5 7 14 7.1 14 9.5C14 9.5 14 12 11 12M9 12V16.8C9 16.9105 9.08954 17 9.2 17H12.5C14 17 15 16 15 14.5C15 11.7046 11 12 11 12M9 12H11\"/></svg>', Xi = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7 10L11.8586 14.8586C11.9367 14.9367 12.0633 14.9367 12.1414 14.8586L17 10\"/></svg>', Vi = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M14.5 17.5L9.64142 12.6414C9.56331 12.5633 9.56331 12.4367 9.64142 12.3586L14.5 7.5\"/></svg>', qi = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M9.58284 17.5L14.4414 12.6414C14.5195 12.5633 14.5195 12.4367 14.4414 12.3586L9.58284 7.5\"/></svg>', Zi = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7 15L11.8586 10.1414C11.9367 10.0633 12.0633 10.0633 12.1414 10.1414L17 15\"/></svg>', Gi = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 8L12 12M12 12L16 16M12 12L16 8M12 12L8 16\"/></svg>', Qi = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><circle cx=\"12\" cy=\"12\" r=\"4\" stroke=\"currentColor\" stroke-width=\"2\"/></svg>', Ji = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M13.34 10C12.4223 12.7337 11 17 11 17\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M14.21 7H14.2\"/></svg>', Co = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7.69998 12.6L7.67896 12.62C6.53993 13.7048 6.52012 15.5155 7.63516 16.625V16.625C8.72293 17.7073 10.4799 17.7102 11.5712 16.6314L13.0263 15.193C14.0703 14.1609 14.2141 12.525 13.3662 11.3266L13.22 11.12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16.22 11.12L16.3564 10.9805C17.2895 10.0265 17.3478 8.5207 16.4914 7.49733V7.49733C15.5691 6.39509 13.9269 6.25143 12.8271 7.17675L11.3901 8.38588C10.0935 9.47674 9.95706 11.4241 11.0888 12.6852L11.12 12.72\"/></svg>', es = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.40999 7.29999H9.4\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 7.29999H14.59\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.30999 12H9.3\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 12H14.59\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M9.40999 16.7H9.4\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2.6\" d=\"M14.6 16.7H14.59\"/></svg>', ts = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M12 7V12M12 17V12M17 12H12M12 12H7\"/></svg>', Go = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M11.5 17.5L5 11M5 11V15.5M5 11H9.5\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M12.5 6.5L19 13M19 13V8.5M19 13H14.5\"/></svg>', os = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><circle cx=\"10.5\" cy=\"10.5\" r=\"5.5\" stroke=\"currentColor\" stroke-width=\"2\"/><line x1=\"15.4142\" x2=\"19\" y1=\"15\" y2=\"18.5858\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/></svg>', ns = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M15.7795 11.5C15.7795 11.5 16.053 11.1962 16.5497 10.6722C17.4442 9.72856 17.4701 8.2475 16.5781 7.30145V7.30145C15.6482 6.31522 14.0873 6.29227 13.1288 7.25073L11.8796 8.49999\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8.24517 12.3883C8.24517 12.3883 7.97171 12.6922 7.47504 13.2161C6.58051 14.1598 6.55467 15.6408 7.44666 16.5869V16.5869C8.37653 17.5731 9.93744 17.5961 10.8959 16.6376L12.1452 15.3883\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M17.7802 15.1032L16.597 14.9422C16.0109 14.8624 15.4841 15.3059 15.4627 15.8969L15.4199 17.0818\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6.39064 9.03238L7.58432 9.06668C8.17551 9.08366 8.6522 8.58665 8.61056 7.99669L8.5271 6.81397\"/><line x1=\"12.1142\" x2=\"11.7\" y1=\"12.2\" y2=\"11.7858\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/></svg>', is = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><rect width=\"14\" height=\"14\" x=\"5\" y=\"5\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"4\"/><line x1=\"12\" x2=\"12\" y1=\"9\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M12 15.02V15.01\"/></svg>', ss = \"__\", rs = \"--\";\nfunction ne(n) {\n  return (e, t) => [[n, e].filter((i) => !!i).join(ss), t].filter((i) => !!i).join(rs);\n}\nconst ye = ne(\"ce-hint\"), we = {\n  root: ye(),\n  alignedStart: ye(null, \"align-left\"),\n  alignedCenter: ye(null, \"align-center\"),\n  title: ye(\"title\"),\n  description: ye(\"description\")\n};\nclass as {\n  /**\n   * Constructs the hint content instance\n   *\n   * @param params - hint content parameters\n   */\n  constructor(e) {\n    this.nodes = {\n      root: d.make(\"div\", [we.root, e.alignment === \"center\" ? we.alignedCenter : we.alignedStart]),\n      title: d.make(\"div\", we.title, { textContent: e.title })\n    }, this.nodes.root.appendChild(this.nodes.title), e.description !== void 0 && (this.nodes.description = d.make(\"div\", we.description, { textContent: e.description }), this.nodes.root.appendChild(this.nodes.description));\n  }\n  /**\n   * Returns the root element of the hint content\n   */\n  getElement() {\n    return this.nodes.root;\n  }\n}\nclass xt {\n  /**\n   * Constructs the instance\n   *\n   * @param params - instance parameters\n   */\n  constructor(e) {\n    this.params = e;\n  }\n  /**\n   * Item name if exists\n   */\n  get name() {\n    if (this.params !== void 0 && \"name\" in this.params)\n      return this.params.name;\n  }\n  /**\n   * Destroys the instance\n   */\n  destroy() {\n    $e();\n  }\n  /**\n   * Called when children popover is opened (if exists)\n   */\n  onChildrenOpen() {\n    var e;\n    this.params !== void 0 && \"children\" in this.params && typeof ((e = this.params.children) == null ? void 0 : e.onOpen) == \"function\" && this.params.children.onOpen();\n  }\n  /**\n   * Called when children popover is closed (if exists)\n   */\n  onChildrenClose() {\n    var e;\n    this.params !== void 0 && \"children\" in this.params && typeof ((e = this.params.children) == null ? void 0 : e.onClose) == \"function\" && this.params.children.onClose();\n  }\n  /**\n   * Called on popover item click\n   */\n  handleClick() {\n    var e, t;\n    this.params !== void 0 && \"onActivate\" in this.params && ((t = (e = this.params).onActivate) == null || t.call(e, this.params));\n  }\n  /**\n   * Adds hint to the item element if hint data is provided\n   *\n   * @param itemElement - popover item root element to add hint to\n   * @param hintData - hint data\n   */\n  addHint(e, t) {\n    const o = new as(t);\n    ze(e, o.getElement(), {\n      placement: t.position,\n      hidingDelay: 100\n    });\n  }\n  /**\n   * Returns item children that are represented as popover items\n   */\n  get children() {\n    var e;\n    return this.params !== void 0 && \"children\" in this.params && ((e = this.params.children) == null ? void 0 : e.items) !== void 0 ? this.params.children.items : [];\n  }\n  /**\n   * Returns true if item has any type of children\n   */\n  get hasChildren() {\n    return this.children.length > 0;\n  }\n  /**\n   * Returns true if item children should be open instantly after popover is opened and not on item click/hover\n   */\n  get isChildrenOpen() {\n    var e;\n    return this.params !== void 0 && \"children\" in this.params && ((e = this.params.children) == null ? void 0 : e.isOpen) === !0;\n  }\n  /**\n   * True if item children items should be navigatable via keyboard\n   */\n  get isChildrenFlippable() {\n    var e;\n    return !(this.params === void 0 || !(\"children\" in this.params) || ((e = this.params.children) == null ? void 0 : e.isFlippable) === !1);\n  }\n  /**\n   * Returns true if item has children that should be searchable\n   */\n  get isChildrenSearchable() {\n    var e;\n    return this.params !== void 0 && \"children\" in this.params && ((e = this.params.children) == null ? void 0 : e.searchable) === !0;\n  }\n  /**\n   * True if popover should close once item is activated\n   */\n  get closeOnActivate() {\n    return this.params !== void 0 && \"closeOnActivate\" in this.params && this.params.closeOnActivate;\n  }\n  /**\n   * True if item is active\n   */\n  get isActive() {\n    return this.params === void 0 || !(\"isActive\" in this.params) ? !1 : typeof this.params.isActive == \"function\" ? this.params.isActive() : this.params.isActive === !0;\n  }\n}\nconst Y = ne(\"ce-popover-item\"), L = {\n  container: Y(),\n  active: Y(null, \"active\"),\n  disabled: Y(null, \"disabled\"),\n  focused: Y(null, \"focused\"),\n  hidden: Y(null, \"hidden\"),\n  confirmationState: Y(null, \"confirmation\"),\n  noHover: Y(null, \"no-hover\"),\n  noFocus: Y(null, \"no-focus\"),\n  title: Y(\"title\"),\n  secondaryTitle: Y(\"secondary-title\"),\n  icon: Y(\"icon\"),\n  iconTool: Y(\"icon\", \"tool\"),\n  iconChevronRight: Y(\"icon\", \"chevron-right\"),\n  wobbleAnimation: ne(\"wobble\")()\n};\nclass re extends xt {\n  /**\n   * Constructs popover item instance\n   *\n   * @param params - popover item construction params\n   * @param renderParams - popover item render params.\n   * The parameters that are not set by user via popover api but rather depend on technical implementation\n   */\n  constructor(e, t) {\n    super(e), this.params = e, this.nodes = {\n      root: null,\n      icon: null\n    }, this.confirmationState = null, this.removeSpecialFocusBehavior = () => {\n      var o;\n      (o = this.nodes.root) == null || o.classList.remove(L.noFocus);\n    }, this.removeSpecialHoverBehavior = () => {\n      var o;\n      (o = this.nodes.root) == null || o.classList.remove(L.noHover);\n    }, this.onErrorAnimationEnd = () => {\n      var o, i;\n      (o = this.nodes.icon) == null || o.classList.remove(L.wobbleAnimation), (i = this.nodes.icon) == null || i.removeEventListener(\"animationend\", this.onErrorAnimationEnd);\n    }, this.nodes.root = this.make(e, t);\n  }\n  /**\n   * True if item is disabled and hence not clickable\n   */\n  get isDisabled() {\n    return this.params.isDisabled === !0;\n  }\n  /**\n   * Exposes popover item toggle parameter\n   */\n  get toggle() {\n    return this.params.toggle;\n  }\n  /**\n   * Item title\n   */\n  get title() {\n    return this.params.title;\n  }\n  /**\n   * True if confirmation state is enabled for popover item\n   */\n  get isConfirmationStateEnabled() {\n    return this.confirmationState !== null;\n  }\n  /**\n   * True if item is focused in keyboard navigation process\n   */\n  get isFocused() {\n    return this.nodes.root === null ? !1 : this.nodes.root.classList.contains(L.focused);\n  }\n  /**\n   * Returns popover item root element\n   */\n  getElement() {\n    return this.nodes.root;\n  }\n  /**\n   * Called on popover item click\n   */\n  handleClick() {\n    if (this.isConfirmationStateEnabled && this.confirmationState !== null) {\n      this.activateOrEnableConfirmationMode(this.confirmationState);\n      return;\n    }\n    this.activateOrEnableConfirmationMode(this.params);\n  }\n  /**\n   * Toggles item active state\n   *\n   * @param isActive - true if item should strictly should become active\n   */\n  toggleActive(e) {\n    var t;\n    (t = this.nodes.root) == null || t.classList.toggle(L.active, e);\n  }\n  /**\n   * Toggles item hidden state\n   *\n   * @param isHidden - true if item should be hidden\n   */\n  toggleHidden(e) {\n    var t;\n    (t = this.nodes.root) == null || t.classList.toggle(L.hidden, e);\n  }\n  /**\n   * Resets popover item to its original state\n   */\n  reset() {\n    this.isConfirmationStateEnabled && this.disableConfirmationMode();\n  }\n  /**\n   * Method called once item becomes focused during keyboard navigation\n   */\n  onFocus() {\n    this.disableSpecialHoverAndFocusBehavior();\n  }\n  /**\n   * Constructs HTML element corresponding to popover item params\n   *\n   * @param params - item construction params\n   * @param renderParams - popover item render params\n   */\n  make(e, t) {\n    var s, r;\n    const o = (t == null ? void 0 : t.wrapperTag) || \"div\", i = d.make(o, L.container, {\n      type: o === \"button\" ? \"button\" : void 0\n    });\n    return e.name && (i.dataset.itemName = e.name), this.nodes.icon = d.make(\"div\", [L.icon, L.iconTool], {\n      innerHTML: e.icon || Qi\n    }), i.appendChild(this.nodes.icon), e.title !== void 0 && i.appendChild(d.make(\"div\", L.title, {\n      innerHTML: e.title || \"\"\n    })), e.secondaryLabel && i.appendChild(d.make(\"div\", L.secondaryTitle, {\n      textContent: e.secondaryLabel\n    })), this.hasChildren && i.appendChild(d.make(\"div\", [L.icon, L.iconChevronRight], {\n      innerHTML: qi\n    })), this.isActive && i.classList.add(L.active), e.isDisabled && i.classList.add(L.disabled), e.hint !== void 0 && ((s = t == null ? void 0 : t.hint) == null ? void 0 : s.enabled) !== !1 && this.addHint(i, {\n      ...e.hint,\n      position: ((r = t == null ? void 0 : t.hint) == null ? void 0 : r.position) || \"right\"\n    }), i;\n  }\n  /**\n   * Activates confirmation mode for the item.\n   *\n   * @param newState - new popover item params that should be applied\n   */\n  enableConfirmationMode(e) {\n    if (this.nodes.root === null)\n      return;\n    const t = {\n      ...this.params,\n      ...e,\n      confirmation: \"confirmation\" in e ? e.confirmation : void 0\n    }, o = this.make(t);\n    this.nodes.root.innerHTML = o.innerHTML, this.nodes.root.classList.add(L.confirmationState), this.confirmationState = e, this.enableSpecialHoverAndFocusBehavior();\n  }\n  /**\n   * Returns item to its original state\n   */\n  disableConfirmationMode() {\n    if (this.nodes.root === null)\n      return;\n    const e = this.make(this.params);\n    this.nodes.root.innerHTML = e.innerHTML, this.nodes.root.classList.remove(L.confirmationState), this.confirmationState = null, this.disableSpecialHoverAndFocusBehavior();\n  }\n  /**\n   * Enables special focus and hover behavior for item in confirmation state.\n   * This is needed to prevent item from being highlighted as hovered/focused just after click.\n   */\n  enableSpecialHoverAndFocusBehavior() {\n    var e, t, o;\n    (e = this.nodes.root) == null || e.classList.add(L.noHover), (t = this.nodes.root) == null || t.classList.add(L.noFocus), (o = this.nodes.root) == null || o.addEventListener(\"mouseleave\", this.removeSpecialHoverBehavior, { once: !0 });\n  }\n  /**\n   * Disables special focus and hover behavior\n   */\n  disableSpecialHoverAndFocusBehavior() {\n    var e;\n    this.removeSpecialFocusBehavior(), this.removeSpecialHoverBehavior(), (e = this.nodes.root) == null || e.removeEventListener(\"mouseleave\", this.removeSpecialHoverBehavior);\n  }\n  /**\n   * Executes item's onActivate callback if the item has no confirmation configured\n   *\n   * @param item - item to activate or bring to confirmation mode\n   */\n  activateOrEnableConfirmationMode(e) {\n    var t;\n    if (!(\"confirmation\" in e) || e.confirmation === void 0)\n      try {\n        (t = e.onActivate) == null || t.call(e, e), this.disableConfirmationMode();\n      } catch {\n        this.animateError();\n      }\n    else\n      this.enableConfirmationMode(e.confirmation);\n  }\n  /**\n   * Animates item which symbolizes that error occured while executing 'onActivate()' callback\n   */\n  animateError() {\n    var e, t, o;\n    (e = this.nodes.icon) != null && e.classList.contains(L.wobbleAnimation) || ((t = this.nodes.icon) == null || t.classList.add(L.wobbleAnimation), (o = this.nodes.icon) == null || o.addEventListener(\"animationend\", this.onErrorAnimationEnd));\n  }\n}\nconst nt = ne(\"ce-popover-item-separator\"), it = {\n  container: nt(),\n  line: nt(\"line\"),\n  hidden: nt(null, \"hidden\")\n};\nclass Qo extends xt {\n  /**\n   * Constructs the instance\n   */\n  constructor() {\n    super(), this.nodes = {\n      root: d.make(\"div\", it.container),\n      line: d.make(\"div\", it.line)\n    }, this.nodes.root.appendChild(this.nodes.line);\n  }\n  /**\n   * Returns popover separator root element\n   */\n  getElement() {\n    return this.nodes.root;\n  }\n  /**\n   * Toggles item hidden state\n   *\n   * @param isHidden - true if item should be hidden\n   */\n  toggleHidden(e) {\n    var t;\n    (t = this.nodes.root) == null || t.classList.toggle(it.hidden, e);\n  }\n}\nvar G = /* @__PURE__ */ ((n) => (n.Closed = \"closed\", n.ClosedOnActivate = \"closed-on-activate\", n))(G || {});\nconst $ = ne(\"ce-popover\"), P = {\n  popover: $(),\n  popoverContainer: $(\"container\"),\n  popoverOpenTop: $(null, \"open-top\"),\n  popoverOpenLeft: $(null, \"open-left\"),\n  popoverOpened: $(null, \"opened\"),\n  search: $(\"search\"),\n  nothingFoundMessage: $(\"nothing-found-message\"),\n  nothingFoundMessageDisplayed: $(\"nothing-found-message\", \"displayed\"),\n  items: $(\"items\"),\n  overlay: $(\"overlay\"),\n  overlayHidden: $(\"overlay\", \"hidden\"),\n  popoverNested: $(null, \"nested\"),\n  getPopoverNestedClass: (n) => $(null, `nested-level-${n.toString()}`),\n  popoverInline: $(null, \"inline\"),\n  popoverHeader: $(\"header\")\n};\nvar fe = /* @__PURE__ */ ((n) => (n.NestingLevel = \"--nesting-level\", n.PopoverHeight = \"--popover-height\", n.InlinePopoverWidth = \"--inline-popover-width\", n.TriggerItemLeft = \"--trigger-item-left\", n.TriggerItemTop = \"--trigger-item-top\", n))(fe || {});\nconst To = ne(\"ce-popover-item-html\"), So = {\n  root: To(),\n  hidden: To(null, \"hidden\")\n};\nclass Se extends xt {\n  /**\n   * Constructs the instance\n   *\n   * @param params – instance parameters\n   * @param renderParams – popover item render params.\n   * The parameters that are not set by user via popover api but rather depend on technical implementation\n   */\n  constructor(e, t) {\n    var o, i;\n    super(e), this.nodes = {\n      root: d.make(\"div\", So.root)\n    }, this.nodes.root.appendChild(e.element), e.name && (this.nodes.root.dataset.itemName = e.name), e.hint !== void 0 && ((o = t == null ? void 0 : t.hint) == null ? void 0 : o.enabled) !== !1 && this.addHint(this.nodes.root, {\n      ...e.hint,\n      position: ((i = t == null ? void 0 : t.hint) == null ? void 0 : i.position) || \"right\"\n    });\n  }\n  /**\n   * Returns popover item root element\n   */\n  getElement() {\n    return this.nodes.root;\n  }\n  /**\n   * Toggles item hidden state\n   *\n   * @param isHidden - true if item should be hidden\n   */\n  toggleHidden(e) {\n    var t;\n    (t = this.nodes.root) == null || t.classList.toggle(So.hidden, e);\n  }\n  /**\n   * Returns list of buttons and inputs inside custom content\n   */\n  getControls() {\n    const e = this.nodes.root.querySelectorAll(\n      `button, ${d.allInputsSelector}`\n    );\n    return Array.from(e);\n  }\n}\nclass Jo extends Oe {\n  /**\n   * Constructs the instance\n   *\n   * @param params - popover construction params\n   * @param itemsRenderParams - popover item render params.\n   * The parameters that are not set by user via popover api but rather depend on technical implementation\n   */\n  constructor(e, t = {}) {\n    super(), this.params = e, this.itemsRenderParams = t, this.listeners = new _e(), this.messages = {\n      nothingFound: \"Nothing found\",\n      search: \"Search\"\n    }, this.items = this.buildItems(e.items), e.messages && (this.messages = {\n      ...this.messages,\n      ...e.messages\n    }), this.nodes = {}, this.nodes.popoverContainer = d.make(\"div\", [P.popoverContainer]), this.nodes.nothingFoundMessage = d.make(\"div\", [P.nothingFoundMessage], {\n      textContent: this.messages.nothingFound\n    }), this.nodes.popoverContainer.appendChild(this.nodes.nothingFoundMessage), this.nodes.items = d.make(\"div\", [P.items]), this.items.forEach((o) => {\n      const i = o.getElement();\n      i !== null && this.nodes.items.appendChild(i);\n    }), this.nodes.popoverContainer.appendChild(this.nodes.items), this.listeners.on(this.nodes.popoverContainer, \"click\", (o) => this.handleClick(o)), this.nodes.popover = d.make(\"div\", [\n      P.popover,\n      this.params.class\n    ]), this.nodes.popover.appendChild(this.nodes.popoverContainer);\n  }\n  /**\n   * List of default popover items that are searchable and may have confirmation state\n   */\n  get itemsDefault() {\n    return this.items.filter((e) => e instanceof re);\n  }\n  /**\n   * Returns HTML element corresponding to the popover\n   */\n  getElement() {\n    return this.nodes.popover;\n  }\n  /**\n   * Open popover\n   */\n  show() {\n    this.nodes.popover.classList.add(P.popoverOpened), this.search !== void 0 && this.search.focus();\n  }\n  /**\n   * Closes popover\n   */\n  hide() {\n    this.nodes.popover.classList.remove(P.popoverOpened), this.nodes.popover.classList.remove(P.popoverOpenTop), this.itemsDefault.forEach((e) => e.reset()), this.search !== void 0 && this.search.clear(), this.emit(G.Closed);\n  }\n  /**\n   * Clears memory\n   */\n  destroy() {\n    var e;\n    this.items.forEach((t) => t.destroy()), this.nodes.popover.remove(), this.listeners.removeAll(), (e = this.search) == null || e.destroy();\n  }\n  /**\n   * Looks for the item by name and imitates click on it\n   *\n   * @param name - name of the item to activate\n   */\n  activateItemByName(e) {\n    const t = this.items.find((o) => o.name === e);\n    this.handleItemClick(t);\n  }\n  /**\n   * Factory method for creating popover items\n   *\n   * @param items - list of items params\n   */\n  buildItems(e) {\n    return e.map((t) => {\n      switch (t.type) {\n        case _.Separator:\n          return new Qo();\n        case _.Html:\n          return new Se(t, this.itemsRenderParams[_.Html]);\n        default:\n          return new re(t, this.itemsRenderParams[_.Default]);\n      }\n    });\n  }\n  /**\n   * Retrieves popover item that is the target of the specified event\n   *\n   * @param event - event to retrieve popover item from\n   */\n  getTargetItem(e) {\n    return this.items.filter((t) => t instanceof re || t instanceof Se).find((t) => {\n      const o = t.getElement();\n      return o === null ? !1 : e.composedPath().includes(o);\n    });\n  }\n  /**\n   * Handles popover item click\n   *\n   * @param item - item to handle click of\n   */\n  handleItemClick(e) {\n    if (!(\"isDisabled\" in e && e.isDisabled)) {\n      if (e.hasChildren) {\n        this.showNestedItems(e), \"handleClick\" in e && typeof e.handleClick == \"function\" && e.handleClick();\n        return;\n      }\n      this.itemsDefault.filter((t) => t !== e).forEach((t) => t.reset()), \"handleClick\" in e && typeof e.handleClick == \"function\" && e.handleClick(), this.toggleItemActivenessIfNeeded(e), e.closeOnActivate && (this.hide(), this.emit(G.ClosedOnActivate));\n    }\n  }\n  /**\n   * Handles clicks inside popover\n   *\n   * @param event - item to handle click of\n   */\n  handleClick(e) {\n    const t = this.getTargetItem(e);\n    t !== void 0 && this.handleItemClick(t);\n  }\n  /**\n   * - Toggles item active state, if clicked popover item has property 'toggle' set to true.\n   *\n   * - Performs radiobutton-like behavior if the item has property 'toggle' set to string key.\n   * (All the other items with the same key get inactive, and the item gets active)\n   *\n   * @param clickedItem - popover item that was clicked\n   */\n  toggleItemActivenessIfNeeded(e) {\n    if (e instanceof re && (e.toggle === !0 && e.toggleActive(), typeof e.toggle == \"string\")) {\n      const t = this.itemsDefault.filter((o) => o.toggle === e.toggle);\n      if (t.length === 1) {\n        e.toggleActive();\n        return;\n      }\n      t.forEach((o) => {\n        o.toggleActive(o === e);\n      });\n    }\n  }\n}\nvar Ue = /* @__PURE__ */ ((n) => (n.Search = \"search\", n))(Ue || {});\nconst st = ne(\"cdx-search-field\"), rt = {\n  wrapper: st(),\n  icon: st(\"icon\"),\n  input: st(\"input\")\n};\nclass ls extends Oe {\n  /**\n   * @param options - available config\n   * @param options.items - searchable items list\n   * @param options.placeholder - input placeholder\n   */\n  constructor({ items: e, placeholder: t }) {\n    super(), this.listeners = new _e(), this.items = e, this.wrapper = d.make(\"div\", rt.wrapper);\n    const o = d.make(\"div\", rt.icon, {\n      innerHTML: os\n    });\n    this.input = d.make(\"input\", rt.input, {\n      placeholder: t,\n      /**\n       * Used to prevent focusing on the input by Tab key\n       * (Popover in the Toolbar lays below the blocks,\n       * so Tab in the last block will focus this hidden input if this property is not set)\n       */\n      tabIndex: -1\n    }), this.wrapper.appendChild(o), this.wrapper.appendChild(this.input), this.listeners.on(this.input, \"input\", () => {\n      this.searchQuery = this.input.value, this.emit(Ue.Search, {\n        query: this.searchQuery,\n        items: this.foundItems\n      });\n    });\n  }\n  /**\n   * Returns search field element\n   */\n  getElement() {\n    return this.wrapper;\n  }\n  /**\n   * Sets focus to the input\n   */\n  focus() {\n    this.input.focus();\n  }\n  /**\n   * Clears search query and results\n   */\n  clear() {\n    this.input.value = \"\", this.searchQuery = \"\", this.emit(Ue.Search, {\n      query: \"\",\n      items: this.foundItems\n    });\n  }\n  /**\n   * Clears memory\n   */\n  destroy() {\n    this.listeners.removeAll();\n  }\n  /**\n   * Returns list of found items for the current search query\n   */\n  get foundItems() {\n    return this.items.filter((e) => this.checkItem(e));\n  }\n  /**\n   * Contains logic for checking whether passed item conforms the search query\n   *\n   * @param item - item to be checked\n   */\n  checkItem(e) {\n    var i, s;\n    const t = ((i = e.title) == null ? void 0 : i.toLowerCase()) || \"\", o = (s = this.searchQuery) == null ? void 0 : s.toLowerCase();\n    return o !== void 0 ? t.includes(o) : !1;\n  }\n}\nvar cs = Object.defineProperty, ds = Object.getOwnPropertyDescriptor, us = (n, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? ds(e, t) : e, s = n.length - 1, r; s >= 0; s--)\n    (r = n[s]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && cs(e, t, i), i;\n};\nconst en = class tn extends Jo {\n  /**\n   * Construct the instance\n   *\n   * @param params - popover params\n   * @param itemsRenderParams – popover item render params.\n   * The parameters that are not set by user via popover api but rather depend on technical implementation\n   */\n  constructor(e, t) {\n    super(e, t), this.nestingLevel = 0, this.nestedPopoverTriggerItem = null, this.previouslyHoveredItem = null, this.scopeElement = document.body, this.hide = () => {\n      var o;\n      super.hide(), this.destroyNestedPopoverIfExists(), (o = this.flipper) == null || o.deactivate(), this.previouslyHoveredItem = null;\n    }, this.onFlip = () => {\n      const o = this.itemsDefault.find((i) => i.isFocused);\n      o == null || o.onFocus();\n    }, this.onSearch = (o) => {\n      var a;\n      const i = o.query === \"\", s = o.items.length === 0;\n      this.items.forEach((l) => {\n        let c = !1;\n        l instanceof re ? c = !o.items.includes(l) : (l instanceof Qo || l instanceof Se) && (c = s || !i), l.toggleHidden(c);\n      }), this.toggleNothingFoundMessage(s);\n      const r = o.query === \"\" ? this.flippableElements : o.items.map((l) => l.getElement());\n      (a = this.flipper) != null && a.isActivated && (this.flipper.deactivate(), this.flipper.activate(r));\n    }, e.nestingLevel !== void 0 && (this.nestingLevel = e.nestingLevel), this.nestingLevel > 0 && this.nodes.popover.classList.add(P.popoverNested), e.scopeElement !== void 0 && (this.scopeElement = e.scopeElement), this.nodes.popoverContainer !== null && this.listeners.on(this.nodes.popoverContainer, \"mouseover\", (o) => this.handleHover(o)), e.searchable && this.addSearch(), e.flippable !== !1 && (this.flipper = new ce({\n      items: this.flippableElements,\n      focusedItemClass: L.focused,\n      allowedKeys: [\n        y.TAB,\n        y.UP,\n        y.DOWN,\n        y.ENTER\n      ]\n    }), this.flipper.onFlip(this.onFlip));\n  }\n  /**\n   * Returns true if some item inside popover is focused\n   */\n  hasFocus() {\n    return this.flipper === void 0 ? !1 : this.flipper.hasFocus();\n  }\n  /**\n   * Scroll position inside items container of the popover\n   */\n  get scrollTop() {\n    return this.nodes.items === null ? 0 : this.nodes.items.scrollTop;\n  }\n  /**\n   * Returns visible element offset top\n   */\n  get offsetTop() {\n    return this.nodes.popoverContainer === null ? 0 : this.nodes.popoverContainer.offsetTop;\n  }\n  /**\n   * Open popover\n   */\n  show() {\n    var e;\n    this.nodes.popover.style.setProperty(fe.PopoverHeight, this.size.height + \"px\"), this.shouldOpenBottom || this.nodes.popover.classList.add(P.popoverOpenTop), this.shouldOpenRight || this.nodes.popover.classList.add(P.popoverOpenLeft), super.show(), (e = this.flipper) == null || e.activate(this.flippableElements);\n  }\n  /**\n   * Clears memory\n   */\n  destroy() {\n    this.hide(), super.destroy();\n  }\n  /**\n   * Handles displaying nested items for the item.\n   *\n   * @param item – item to show nested popover for\n   */\n  showNestedItems(e) {\n    this.nestedPopover !== null && this.nestedPopover !== void 0 || (this.nestedPopoverTriggerItem = e, this.showNestedPopoverForItem(e));\n  }\n  /**\n   * Handles hover events inside popover items container\n   *\n   * @param event - hover event data\n   */\n  handleHover(e) {\n    const t = this.getTargetItem(e);\n    t !== void 0 && this.previouslyHoveredItem !== t && (this.destroyNestedPopoverIfExists(), this.previouslyHoveredItem = t, t.hasChildren && this.showNestedPopoverForItem(t));\n  }\n  /**\n   * Sets CSS variable with position of item near which nested popover should be displayed.\n   * Is used for correct positioning of the nested popover\n   *\n   * @param nestedPopoverEl - nested popover element\n   * @param item – item near which nested popover should be displayed\n   */\n  setTriggerItemPosition(e, t) {\n    const o = t.getElement(), i = (o ? o.offsetTop : 0) - this.scrollTop, s = this.offsetTop + i;\n    e.style.setProperty(fe.TriggerItemTop, s + \"px\");\n  }\n  /**\n   * Destroys existing nested popover\n   */\n  destroyNestedPopoverIfExists() {\n    var e, t;\n    this.nestedPopover === void 0 || this.nestedPopover === null || (this.nestedPopover.off(G.ClosedOnActivate, this.hide), this.nestedPopover.hide(), this.nestedPopover.destroy(), this.nestedPopover.getElement().remove(), this.nestedPopover = null, (e = this.flipper) == null || e.activate(this.flippableElements), (t = this.nestedPopoverTriggerItem) == null || t.onChildrenClose());\n  }\n  /**\n   * Creates and displays nested popover for specified item.\n   * Is used only on desktop\n   *\n   * @param item - item to display nested popover by\n   */\n  showNestedPopoverForItem(e) {\n    var o;\n    this.nestedPopover = new tn({\n      searchable: e.isChildrenSearchable,\n      items: e.children,\n      nestingLevel: this.nestingLevel + 1,\n      flippable: e.isChildrenFlippable,\n      messages: this.messages\n    }), e.onChildrenOpen(), this.nestedPopover.on(G.ClosedOnActivate, this.hide);\n    const t = this.nestedPopover.getElement();\n    return this.nodes.popover.appendChild(t), this.setTriggerItemPosition(t, e), t.style.setProperty(fe.NestingLevel, this.nestedPopover.nestingLevel.toString()), this.nestedPopover.show(), (o = this.flipper) == null || o.deactivate(), this.nestedPopover;\n  }\n  /**\n   * Checks if popover should be opened bottom.\n   * It should happen when there is enough space below or not enough space above\n   */\n  get shouldOpenBottom() {\n    if (this.nodes.popover === void 0 || this.nodes.popover === null)\n      return !1;\n    const e = this.nodes.popoverContainer.getBoundingClientRect(), t = this.scopeElement.getBoundingClientRect(), o = this.size.height, i = e.top + o, s = e.top - o, r = Math.min(window.innerHeight, t.bottom);\n    return s < t.top || i <= r;\n  }\n  /**\n   * Checks if popover should be opened left.\n   * It should happen when there is enough space in the right or not enough space in the left\n   */\n  get shouldOpenRight() {\n    if (this.nodes.popover === void 0 || this.nodes.popover === null)\n      return !1;\n    const e = this.nodes.popover.getBoundingClientRect(), t = this.scopeElement.getBoundingClientRect(), o = this.size.width, i = e.right + o, s = e.left - o, r = Math.min(window.innerWidth, t.right);\n    return s < t.left || i <= r;\n  }\n  get size() {\n    var i;\n    const e = {\n      height: 0,\n      width: 0\n    };\n    if (this.nodes.popover === null)\n      return e;\n    const t = this.nodes.popover.cloneNode(!0);\n    t.style.visibility = \"hidden\", t.style.position = \"absolute\", t.style.top = \"-1000px\", t.classList.add(P.popoverOpened), (i = t.querySelector(\".\" + P.popoverNested)) == null || i.remove(), document.body.appendChild(t);\n    const o = t.querySelector(\".\" + P.popoverContainer);\n    return e.height = o.offsetHeight, e.width = o.offsetWidth, t.remove(), e;\n  }\n  /**\n   * Returns list of elements available for keyboard navigation.\n   */\n  get flippableElements() {\n    return this.items.map((t) => {\n      if (t instanceof re)\n        return t.getElement();\n      if (t instanceof Se)\n        return t.getControls();\n    }).flat().filter((t) => t != null);\n  }\n  /**\n   * Adds search to the popover\n   */\n  addSearch() {\n    this.search = new ls({\n      items: this.itemsDefault,\n      placeholder: this.messages.search\n    }), this.search.on(Ue.Search, this.onSearch);\n    const e = this.search.getElement();\n    e.classList.add(P.search), this.nodes.popoverContainer.insertBefore(e, this.nodes.popoverContainer.firstChild);\n  }\n  /**\n   * Toggles nothing found message visibility\n   *\n   * @param isDisplayed - true if the message should be displayed\n   */\n  toggleNothingFoundMessage(e) {\n    this.nodes.nothingFoundMessage.classList.toggle(P.nothingFoundMessageDisplayed, e);\n  }\n};\nus([\n  me\n], en.prototype, \"size\", 1);\nlet Bt = en;\nclass hs extends Bt {\n  /**\n   * Constructs the instance\n   *\n   * @param params - instance parameters\n   */\n  constructor(e) {\n    const t = !be();\n    super(\n      {\n        ...e,\n        class: P.popoverInline\n      },\n      {\n        [_.Default]: {\n          /**\n           * We use button instead of div here to fix bug associated with focus loss (which leads to selection change) on click in safari\n           *\n           * @todo figure out better way to solve the issue\n           */\n          wrapperTag: \"button\",\n          hint: {\n            position: \"top\",\n            alignment: \"center\",\n            enabled: t\n          }\n        },\n        [_.Html]: {\n          hint: {\n            position: \"top\",\n            alignment: \"center\",\n            enabled: t\n          }\n        }\n      }\n    ), this.items.forEach((o) => {\n      !(o instanceof re) && !(o instanceof Se) || o.hasChildren && o.isChildrenOpen && this.showNestedItems(o);\n    });\n  }\n  /**\n   * Returns visible element offset top\n   */\n  get offsetLeft() {\n    return this.nodes.popoverContainer === null ? 0 : this.nodes.popoverContainer.offsetLeft;\n  }\n  /**\n   * Open popover\n   */\n  show() {\n    this.nestingLevel === 0 && this.nodes.popover.style.setProperty(\n      fe.InlinePopoverWidth,\n      this.size.width + \"px\"\n    ), super.show();\n  }\n  /**\n   * Disable hover event handling.\n   * Overrides parent's class behavior\n   */\n  handleHover() {\n  }\n  /**\n   * Sets CSS variable with position of item near which nested popover should be displayed.\n   * Is used to position nested popover right below clicked item\n   *\n   * @param nestedPopoverEl - nested popover element\n   * @param item – item near which nested popover should be displayed\n   */\n  setTriggerItemPosition(e, t) {\n    const o = t.getElement(), i = o ? o.offsetLeft : 0, s = this.offsetLeft + i;\n    e.style.setProperty(\n      fe.TriggerItemLeft,\n      s + \"px\"\n    );\n  }\n  /**\n   * Handles displaying nested items for the item.\n   * Overriding in order to add toggling behaviour\n   *\n   * @param item – item to toggle nested popover for\n   */\n  showNestedItems(e) {\n    if (this.nestedPopoverTriggerItem === e) {\n      this.destroyNestedPopoverIfExists(), this.nestedPopoverTriggerItem = null;\n      return;\n    }\n    super.showNestedItems(e);\n  }\n  /**\n   * Creates and displays nested popover for specified item.\n   * Is used only on desktop\n   *\n   * @param item - item to display nested popover by\n   */\n  showNestedPopoverForItem(e) {\n    const t = super.showNestedPopoverForItem(e);\n    return t.getElement().classList.add(P.getPopoverNestedClass(t.nestingLevel)), t;\n  }\n  /**\n   * Overrides default item click handling.\n   * Helps to close nested popover once other item is clicked.\n   *\n   * @param item - clicked item\n   */\n  handleItemClick(e) {\n    var t;\n    e !== this.nestedPopoverTriggerItem && ((t = this.nestedPopoverTriggerItem) == null || t.handleClick(), super.destroyNestedPopoverIfExists()), super.handleItemClick(e);\n  }\n}\nconst on = class xe {\n  constructor() {\n    this.scrollPosition = null;\n  }\n  /**\n   * Locks body element scroll\n   */\n  lock() {\n    pt ? this.lockHard() : document.body.classList.add(xe.CSS.scrollLocked);\n  }\n  /**\n   * Unlocks body element scroll\n   */\n  unlock() {\n    pt ? this.unlockHard() : document.body.classList.remove(xe.CSS.scrollLocked);\n  }\n  /**\n   * Locks scroll in a hard way (via setting fixed position to body element)\n   */\n  lockHard() {\n    this.scrollPosition = window.pageYOffset, document.documentElement.style.setProperty(\n      \"--window-scroll-offset\",\n      `${this.scrollPosition}px`\n    ), document.body.classList.add(xe.CSS.scrollLockedHard);\n  }\n  /**\n   * Unlocks hard scroll lock\n   */\n  unlockHard() {\n    document.body.classList.remove(xe.CSS.scrollLockedHard), this.scrollPosition !== null && window.scrollTo(0, this.scrollPosition), this.scrollPosition = null;\n  }\n};\non.CSS = {\n  scrollLocked: \"ce-scroll-locked\",\n  scrollLockedHard: \"ce-scroll-locked--hard\"\n};\nlet ps = on;\nconst at = ne(\"ce-popover-header\"), lt = {\n  root: at(),\n  text: at(\"text\"),\n  backButton: at(\"back-button\")\n};\nclass fs {\n  /**\n   * Constructs the instance\n   *\n   * @param params - popover header params\n   */\n  constructor({ text: e, onBackButtonClick: t }) {\n    this.listeners = new _e(), this.text = e, this.onBackButtonClick = t, this.nodes = {\n      root: d.make(\"div\", [lt.root]),\n      backButton: d.make(\"button\", [lt.backButton]),\n      text: d.make(\"div\", [lt.text])\n    }, this.nodes.backButton.innerHTML = Vi, this.nodes.root.appendChild(this.nodes.backButton), this.listeners.on(this.nodes.backButton, \"click\", this.onBackButtonClick), this.nodes.text.innerText = this.text, this.nodes.root.appendChild(this.nodes.text);\n  }\n  /**\n   * Returns popover header root html element\n   */\n  getElement() {\n    return this.nodes.root;\n  }\n  /**\n   * Destroys the instance\n   */\n  destroy() {\n    this.nodes.root.remove(), this.listeners.destroy();\n  }\n}\nclass gs {\n  constructor() {\n    this.history = [];\n  }\n  /**\n   * Push new popover state\n   *\n   * @param state - new state\n   */\n  push(e) {\n    this.history.push(e);\n  }\n  /**\n   * Pop last popover state\n   */\n  pop() {\n    return this.history.pop();\n  }\n  /**\n   * Title retrieved from the current state\n   */\n  get currentTitle() {\n    return this.history.length === 0 ? \"\" : this.history[this.history.length - 1].title;\n  }\n  /**\n   * Items list retrieved from the current state\n   */\n  get currentItems() {\n    return this.history.length === 0 ? [] : this.history[this.history.length - 1].items;\n  }\n  /**\n   * Returns history to initial popover state\n   */\n  reset() {\n    for (; this.history.length > 1; )\n      this.pop();\n  }\n}\nclass nn extends Jo {\n  /**\n   * Construct the instance\n   *\n   * @param params - popover params\n   */\n  constructor(e) {\n    super(e, {\n      [_.Default]: {\n        hint: {\n          enabled: !1\n        }\n      },\n      [_.Html]: {\n        hint: {\n          enabled: !1\n        }\n      }\n    }), this.scrollLocker = new ps(), this.history = new gs(), this.isHidden = !0, this.nodes.overlay = d.make(\"div\", [P.overlay, P.overlayHidden]), this.nodes.popover.insertBefore(this.nodes.overlay, this.nodes.popover.firstChild), this.listeners.on(this.nodes.overlay, \"click\", () => {\n      this.hide();\n    }), this.history.push({ items: e.items });\n  }\n  /**\n   * Open popover\n   */\n  show() {\n    this.nodes.overlay.classList.remove(P.overlayHidden), super.show(), this.scrollLocker.lock(), this.isHidden = !1;\n  }\n  /**\n   * Closes popover\n   */\n  hide() {\n    this.isHidden || (super.hide(), this.nodes.overlay.classList.add(P.overlayHidden), this.scrollLocker.unlock(), this.history.reset(), this.isHidden = !0);\n  }\n  /**\n   * Clears memory\n   */\n  destroy() {\n    super.destroy(), this.scrollLocker.unlock();\n  }\n  /**\n   * Handles displaying nested items for the item\n   *\n   * @param item – item to show nested popover for\n   */\n  showNestedItems(e) {\n    this.updateItemsAndHeader(e.children, e.title), this.history.push({\n      title: e.title,\n      items: e.children\n    });\n  }\n  /**\n   * Removes rendered popover items and header and displays new ones\n   *\n   * @param items - new popover items\n   * @param title - new popover header text\n   */\n  updateItemsAndHeader(e, t) {\n    if (this.header !== null && this.header !== void 0 && (this.header.destroy(), this.header = null), t !== void 0) {\n      this.header = new fs({\n        text: t,\n        onBackButtonClick: () => {\n          this.history.pop(), this.updateItemsAndHeader(this.history.currentItems, this.history.currentTitle);\n        }\n      });\n      const o = this.header.getElement();\n      o !== null && this.nodes.popoverContainer.insertBefore(o, this.nodes.popoverContainer.firstChild);\n    }\n    this.items.forEach((o) => {\n      var i;\n      return (i = o.getElement()) == null ? void 0 : i.remove();\n    }), this.items = this.buildItems(e), this.items.forEach((o) => {\n      var s;\n      const i = o.getElement();\n      i !== null && ((s = this.nodes.items) == null || s.appendChild(i));\n    });\n  }\n}\nclass ms extends E {\n  constructor() {\n    super(...arguments), this.opened = !1, this.selection = new b(), this.popover = null, this.close = () => {\n      this.opened && (this.opened = !1, b.isAtEditor || this.selection.restore(), this.selection.clearSaved(), !this.Editor.CrossBlockSelection.isCrossBlockSelectionStarted && this.Editor.BlockManager.currentBlock && this.Editor.BlockSelection.unselectBlock(this.Editor.BlockManager.currentBlock), this.eventsDispatcher.emit(this.events.closed), this.popover && (this.popover.off(G.Closed, this.onPopoverClose), this.popover.destroy(), this.popover.getElement().remove(), this.popover = null));\n    }, this.onPopoverClose = () => {\n      this.close();\n    };\n  }\n  /**\n   * Module Events\n   */\n  get events() {\n    return {\n      opened: \"block-settings-opened\",\n      closed: \"block-settings-closed\"\n    };\n  }\n  /**\n   * Block Settings CSS\n   */\n  get CSS() {\n    return {\n      settings: \"ce-settings\"\n    };\n  }\n  /**\n   * Getter for inner popover's flipper instance\n   *\n   * @todo remove once BlockSettings becomes standalone non-module class\n   */\n  get flipper() {\n    var e;\n    if (this.popover !== null)\n      return \"flipper\" in this.popover ? (e = this.popover) == null ? void 0 : e.flipper : void 0;\n  }\n  /**\n   * Panel with block settings with 2 sections:\n   *  - Tool's Settings\n   *  - Default Settings [Move, Remove, etc]\n   */\n  make() {\n    this.nodes.wrapper = d.make(\"div\", [this.CSS.settings]), this.nodes.wrapper.setAttribute(\"data-cy\", \"block-tunes\"), this.eventsDispatcher.on(Te, this.close);\n  }\n  /**\n   * Destroys module\n   */\n  destroy() {\n    this.removeAllNodes(), this.listeners.destroy(), this.eventsDispatcher.off(Te, this.close);\n  }\n  /**\n   * Open Block Settings pane\n   *\n   * @param targetBlock - near which Block we should open BlockSettings\n   */\n  async open(e = this.Editor.BlockManager.currentBlock) {\n    var s;\n    this.opened = !0, this.selection.save(), this.Editor.BlockSelection.selectBlock(e), this.Editor.BlockSelection.clearCache();\n    const { toolTunes: t, commonTunes: o } = e.getTunes();\n    this.eventsDispatcher.emit(this.events.opened);\n    const i = be() ? nn : Bt;\n    this.popover = new i({\n      searchable: !0,\n      items: await this.getTunesItems(e, o, t),\n      scopeElement: this.Editor.API.methods.ui.nodes.redactor,\n      messages: {\n        nothingFound: z.ui(K.ui.popover, \"Nothing found\"),\n        search: z.ui(K.ui.popover, \"Filter\")\n      }\n    }), this.popover.on(G.Closed, this.onPopoverClose), (s = this.nodes.wrapper) == null || s.append(this.popover.getElement()), this.popover.show();\n  }\n  /**\n   * Returns root block settings element\n   */\n  getElement() {\n    return this.nodes.wrapper;\n  }\n  /**\n   * Returns list of items to be displayed in block tunes menu.\n   * Merges tool specific tunes, conversion menu and common tunes in one list in predefined order\n   *\n   * @param currentBlock –  block we are about to open block tunes for\n   * @param commonTunes – common tunes\n   * @param toolTunes - tool specific tunes\n   */\n  async getTunesItems(e, t, o) {\n    const i = [];\n    o !== void 0 && o.length > 0 && (i.push(...o), i.push({\n      type: _.Separator\n    }));\n    const s = Array.from(this.Editor.Tools.blockTools.values()), a = (await Yo(e, s)).reduce((l, c) => (c.toolbox.forEach((u) => {\n      l.push({\n        icon: u.icon,\n        title: z.t(K.toolNames, u.title),\n        name: c.name,\n        closeOnActivate: !0,\n        onActivate: async () => {\n          const { BlockManager: h, Caret: p, Toolbar: g } = this.Editor, f = await h.convert(e, c.name, u.data);\n          g.close(), p.setToBlock(f, p.positions.END);\n        }\n      });\n    }), l), []);\n    return a.length > 0 && (i.push({\n      icon: Go,\n      name: \"convert-to\",\n      title: z.ui(K.ui.popover, \"Convert to\"),\n      children: {\n        searchable: !0,\n        items: a\n      }\n    }), i.push({\n      type: _.Separator\n    })), i.push(...t), i.map((l) => this.resolveTuneAliases(l));\n  }\n  /**\n   * Resolves aliases in tunes menu items\n   *\n   * @param item - item with resolved aliases\n   */\n  resolveTuneAliases(e) {\n    if (e.type === _.Separator || e.type === _.Html)\n      return e;\n    const t = Yi(e, { label: \"title\" });\n    return e.confirmation && (t.confirmation = this.resolveTuneAliases(e.confirmation)), t;\n  }\n}\nvar sn = { exports: {} };\n/*!\n * Library for handling keyboard shortcuts\n * @copyright CodeX (https://codex.so)\n * @license MIT\n * @author CodeX (https://codex.so)\n * @version 1.2.0\n */\n(function(n, e) {\n  (function(t, o) {\n    n.exports = o();\n  })(window, function() {\n    return function(t) {\n      var o = {};\n      function i(s) {\n        if (o[s])\n          return o[s].exports;\n        var r = o[s] = { i: s, l: !1, exports: {} };\n        return t[s].call(r.exports, r, r.exports, i), r.l = !0, r.exports;\n      }\n      return i.m = t, i.c = o, i.d = function(s, r, a) {\n        i.o(s, r) || Object.defineProperty(s, r, { enumerable: !0, get: a });\n      }, i.r = function(s) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(s, \"__esModule\", { value: !0 });\n      }, i.t = function(s, r) {\n        if (1 & r && (s = i(s)), 8 & r || 4 & r && typeof s == \"object\" && s && s.__esModule)\n          return s;\n        var a = /* @__PURE__ */ Object.create(null);\n        if (i.r(a), Object.defineProperty(a, \"default\", { enumerable: !0, value: s }), 2 & r && typeof s != \"string\")\n          for (var l in s)\n            i.d(a, l, (function(c) {\n              return s[c];\n            }).bind(null, l));\n        return a;\n      }, i.n = function(s) {\n        var r = s && s.__esModule ? function() {\n          return s.default;\n        } : function() {\n          return s;\n        };\n        return i.d(r, \"a\", r), r;\n      }, i.o = function(s, r) {\n        return Object.prototype.hasOwnProperty.call(s, r);\n      }, i.p = \"\", i(i.s = 0);\n    }([function(t, o, i) {\n      function s(l, c) {\n        for (var u = 0; u < c.length; u++) {\n          var h = c[u];\n          h.enumerable = h.enumerable || !1, h.configurable = !0, \"value\" in h && (h.writable = !0), Object.defineProperty(l, h.key, h);\n        }\n      }\n      function r(l, c, u) {\n        return c && s(l.prototype, c), u && s(l, u), l;\n      }\n      i.r(o);\n      var a = function() {\n        function l(c) {\n          var u = this;\n          (function(h, p) {\n            if (!(h instanceof p))\n              throw new TypeError(\"Cannot call a class as a function\");\n          })(this, l), this.commands = {}, this.keys = {}, this.name = c.name, this.parseShortcutName(c.name), this.element = c.on, this.callback = c.callback, this.executeShortcut = function(h) {\n            u.execute(h);\n          }, this.element.addEventListener(\"keydown\", this.executeShortcut, !1);\n        }\n        return r(l, null, [{ key: \"supportedCommands\", get: function() {\n          return { SHIFT: [\"SHIFT\"], CMD: [\"CMD\", \"CONTROL\", \"COMMAND\", \"WINDOWS\", \"CTRL\"], ALT: [\"ALT\", \"OPTION\"] };\n        } }, { key: \"keyCodes\", get: function() {\n          return { 0: 48, 1: 49, 2: 50, 3: 51, 4: 52, 5: 53, 6: 54, 7: 55, 8: 56, 9: 57, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, BACKSPACE: 8, ENTER: 13, ESCAPE: 27, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, INSERT: 45, DELETE: 46, \".\": 190 };\n        } }]), r(l, [{ key: \"parseShortcutName\", value: function(c) {\n          c = c.split(\"+\");\n          for (var u = 0; u < c.length; u++) {\n            c[u] = c[u].toUpperCase();\n            var h = !1;\n            for (var p in l.supportedCommands)\n              if (l.supportedCommands[p].includes(c[u])) {\n                h = this.commands[p] = !0;\n                break;\n              }\n            h || (this.keys[c[u]] = !0);\n          }\n          for (var g in l.supportedCommands)\n            this.commands[g] || (this.commands[g] = !1);\n        } }, { key: \"execute\", value: function(c) {\n          var u, h = { CMD: c.ctrlKey || c.metaKey, SHIFT: c.shiftKey, ALT: c.altKey }, p = !0;\n          for (u in this.commands)\n            this.commands[u] !== h[u] && (p = !1);\n          var g, f = !0;\n          for (g in this.keys)\n            f = f && c.keyCode === l.keyCodes[g];\n          p && f && this.callback(c);\n        } }, { key: \"remove\", value: function() {\n          this.element.removeEventListener(\"keydown\", this.executeShortcut);\n        } }]), l;\n      }();\n      o.default = a;\n    }]).default;\n  });\n})(sn);\nvar bs = sn.exports;\nconst vs = /* @__PURE__ */ Ke(bs);\nclass ks {\n  constructor() {\n    this.registeredShortcuts = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Register shortcut\n   *\n   * @param shortcut - shortcut options\n   */\n  add(e) {\n    if (this.findShortcut(e.on, e.name))\n      throw Error(\n        `Shortcut ${e.name} is already registered for ${e.on}. Please remove it before add a new handler.`\n      );\n    const o = new vs({\n      name: e.name,\n      on: e.on,\n      callback: e.handler\n    }), i = this.registeredShortcuts.get(e.on) || [];\n    this.registeredShortcuts.set(e.on, [...i, o]);\n  }\n  /**\n   * Remove shortcut\n   *\n   * @param element - Element shortcut is set for\n   * @param name - shortcut name\n   */\n  remove(e, t) {\n    const o = this.findShortcut(e, t);\n    if (!o)\n      return;\n    o.remove();\n    const i = this.registeredShortcuts.get(e);\n    this.registeredShortcuts.set(e, i.filter((s) => s !== o));\n  }\n  /**\n   * Get Shortcut instance if exist\n   *\n   * @param element - Element shorcut is set for\n   * @param shortcut - shortcut name\n   * @returns {number} index - shortcut index if exist\n   */\n  findShortcut(e, t) {\n    return (this.registeredShortcuts.get(e) || []).find(({ name: i }) => i === t);\n  }\n}\nconst ge = new ks();\nvar ys = Object.defineProperty, ws = Object.getOwnPropertyDescriptor, rn = (n, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? ws(e, t) : e, s = n.length - 1, r; s >= 0; s--)\n    (r = n[s]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && ys(e, t, i), i;\n}, Le = /* @__PURE__ */ ((n) => (n.Opened = \"toolbox-opened\", n.Closed = \"toolbox-closed\", n.BlockAdded = \"toolbox-block-added\", n))(Le || {});\nconst Ct = class an extends Oe {\n  /**\n   * Toolbox constructor\n   *\n   * @param options - available parameters\n   * @param options.api - Editor API methods\n   * @param options.tools - Tools available to check whether some of them should be displayed at the Toolbox or not\n   */\n  constructor({ api: e, tools: t, i18nLabels: o }) {\n    super(), this.opened = !1, this.listeners = new _e(), this.popover = null, this.handleMobileLayoutToggle = () => {\n      this.destroyPopover(), this.initPopover();\n    }, this.onPopoverClose = () => {\n      this.opened = !1, this.emit(\n        \"toolbox-closed\"\n        /* Closed */\n      );\n    }, this.api = e, this.tools = t, this.i18nLabels = o, this.enableShortcuts(), this.nodes = {\n      toolbox: d.make(\"div\", an.CSS.toolbox)\n    }, this.initPopover(), this.nodes.toolbox.setAttribute(\"data-cy\", \"toolbox\"), this.api.events.on(Te, this.handleMobileLayoutToggle);\n  }\n  /**\n   * Returns True if Toolbox is Empty and nothing to show\n   *\n   * @returns {boolean}\n   */\n  get isEmpty() {\n    return this.toolsToBeDisplayed.length === 0;\n  }\n  /**\n   * CSS styles\n   */\n  static get CSS() {\n    return {\n      toolbox: \"ce-toolbox\"\n    };\n  }\n  /**\n   * Returns root block settings element\n   */\n  getElement() {\n    return this.nodes.toolbox;\n  }\n  /**\n   * Returns true if the Toolbox has the Flipper activated and the Flipper has selected button\n   */\n  hasFocus() {\n    if (this.popover !== null)\n      return \"hasFocus\" in this.popover ? this.popover.hasFocus() : void 0;\n  }\n  /**\n   * Destroy Module\n   */\n  destroy() {\n    var e;\n    super.destroy(), this.nodes && this.nodes.toolbox && this.nodes.toolbox.remove(), this.removeAllShortcuts(), (e = this.popover) == null || e.off(G.Closed, this.onPopoverClose), this.listeners.destroy(), this.api.events.off(Te, this.handleMobileLayoutToggle);\n  }\n  /**\n   * Toolbox Tool's button click handler\n   *\n   * @param toolName - tool type to be activated\n   * @param blockDataOverrides - Block data predefined by the activated Toolbox item\n   */\n  toolButtonActivated(e, t) {\n    this.insertNewBlock(e, t);\n  }\n  /**\n   * Open Toolbox with Tools\n   */\n  open() {\n    var e;\n    this.isEmpty || ((e = this.popover) == null || e.show(), this.opened = !0, this.emit(\n      \"toolbox-opened\"\n      /* Opened */\n    ));\n  }\n  /**\n   * Close Toolbox\n   */\n  close() {\n    var e;\n    (e = this.popover) == null || e.hide(), this.opened = !1, this.emit(\n      \"toolbox-closed\"\n      /* Closed */\n    );\n  }\n  /**\n   * Close Toolbox\n   */\n  toggle() {\n    this.opened ? this.close() : this.open();\n  }\n  /**\n   * Creates toolbox popover and appends it inside wrapper element\n   */\n  initPopover() {\n    var t;\n    const e = be() ? nn : Bt;\n    this.popover = new e({\n      scopeElement: this.api.ui.nodes.redactor,\n      searchable: !0,\n      messages: {\n        nothingFound: this.i18nLabels.nothingFound,\n        search: this.i18nLabels.filter\n      },\n      items: this.toolboxItemsToBeDisplayed\n    }), this.popover.on(G.Closed, this.onPopoverClose), (t = this.nodes.toolbox) == null || t.append(this.popover.getElement());\n  }\n  /**\n   * Destroys popover instance and removes it from DOM\n   */\n  destroyPopover() {\n    this.popover !== null && (this.popover.hide(), this.popover.off(G.Closed, this.onPopoverClose), this.popover.destroy(), this.popover = null), this.nodes.toolbox !== null && (this.nodes.toolbox.innerHTML = \"\");\n  }\n  get toolsToBeDisplayed() {\n    const e = [];\n    return this.tools.forEach((t) => {\n      t.toolbox && e.push(t);\n    }), e;\n  }\n  get toolboxItemsToBeDisplayed() {\n    const e = (t, o, i = !0) => ({\n      icon: t.icon,\n      title: z.t(K.toolNames, t.title || je(o.name)),\n      name: o.name,\n      onActivate: () => {\n        this.toolButtonActivated(o.name, t.data);\n      },\n      secondaryLabel: o.shortcut && i ? vt(o.shortcut) : \"\"\n    });\n    return this.toolsToBeDisplayed.reduce((t, o) => (Array.isArray(o.toolbox) ? o.toolbox.forEach((i, s) => {\n      t.push(e(i, o, s === 0));\n    }) : o.toolbox !== void 0 && t.push(e(o.toolbox, o)), t), []);\n  }\n  /**\n   * Iterate all tools and enable theirs shortcuts if specified\n   */\n  enableShortcuts() {\n    this.toolsToBeDisplayed.forEach((e) => {\n      const t = e.shortcut;\n      t && this.enableShortcutForTool(e.name, t);\n    });\n  }\n  /**\n   * Enable shortcut Block Tool implemented shortcut\n   *\n   * @param {string} toolName - Tool name\n   * @param {string} shortcut - shortcut according to the ShortcutData Module format\n   */\n  enableShortcutForTool(e, t) {\n    ge.add({\n      name: t,\n      on: this.api.ui.nodes.redactor,\n      handler: async (o) => {\n        o.preventDefault();\n        const i = this.api.blocks.getCurrentBlockIndex(), s = this.api.blocks.getBlockByIndex(i);\n        if (s)\n          try {\n            const r = await this.api.blocks.convert(s.id, e);\n            this.api.caret.setToBlock(r, \"end\");\n            return;\n          } catch {\n          }\n        this.insertNewBlock(e);\n      }\n    });\n  }\n  /**\n   * Removes all added shortcuts\n   * Fired when the Read-Only mode is activated\n   */\n  removeAllShortcuts() {\n    this.toolsToBeDisplayed.forEach((e) => {\n      const t = e.shortcut;\n      t && ge.remove(this.api.ui.nodes.redactor, t);\n    });\n  }\n  /**\n   * Inserts new block\n   * Can be called when button clicked on Toolbox or by ShortcutData\n   *\n   * @param {string} toolName - Tool name\n   * @param blockDataOverrides - predefined Block data\n   */\n  async insertNewBlock(e, t) {\n    const o = this.api.blocks.getCurrentBlockIndex(), i = this.api.blocks.getBlockByIndex(o);\n    if (!i)\n      return;\n    const s = i.isEmpty ? o : o + 1;\n    let r;\n    if (t) {\n      const l = await this.api.blocks.composeBlockData(e);\n      r = Object.assign(l, t);\n    }\n    const a = this.api.blocks.insert(\n      e,\n      r,\n      void 0,\n      s,\n      void 0,\n      i.isEmpty\n    );\n    a.call(ee.APPEND_CALLBACK), this.api.caret.setToBlock(s), this.emit(\"toolbox-block-added\", {\n      block: a\n    }), this.api.toolbar.close();\n  }\n};\nrn([\n  me\n], Ct.prototype, \"toolsToBeDisplayed\", 1);\nrn([\n  me\n], Ct.prototype, \"toolboxItemsToBeDisplayed\", 1);\nlet Es = Ct;\nconst ln = \"block hovered\";\nasync function xs(n, e) {\n  const t = navigator.keyboard;\n  if (!t)\n    return e;\n  try {\n    return (await t.getLayoutMap()).get(n) || e;\n  } catch (o) {\n    return console.error(o), e;\n  }\n}\nclass Bs extends E {\n  /**\n   * @class\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.toolboxInstance = null;\n  }\n  /**\n   * CSS styles\n   *\n   * @returns {object}\n   */\n  get CSS() {\n    return {\n      toolbar: \"ce-toolbar\",\n      content: \"ce-toolbar__content\",\n      actions: \"ce-toolbar__actions\",\n      actionsOpened: \"ce-toolbar__actions--opened\",\n      toolbarOpened: \"ce-toolbar--opened\",\n      openedToolboxHolderModifier: \"codex-editor--toolbox-opened\",\n      plusButton: \"ce-toolbar__plus\",\n      plusButtonShortcut: \"ce-toolbar__plus-shortcut\",\n      settingsToggler: \"ce-toolbar__settings-btn\",\n      settingsTogglerHidden: \"ce-toolbar__settings-btn--hidden\"\n    };\n  }\n  /**\n   * Returns the Toolbar opening state\n   *\n   * @returns {boolean}\n   */\n  get opened() {\n    return this.nodes.wrapper.classList.contains(this.CSS.toolbarOpened);\n  }\n  /**\n   * Public interface for accessing the Toolbox\n   */\n  get toolbox() {\n    var e;\n    return {\n      opened: (e = this.toolboxInstance) == null ? void 0 : e.opened,\n      close: () => {\n        var t;\n        (t = this.toolboxInstance) == null || t.close();\n      },\n      open: () => {\n        if (this.toolboxInstance === null) {\n          S(\"toolbox.open() called before initialization is finished\", \"warn\");\n          return;\n        }\n        this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.toolboxInstance.open();\n      },\n      toggle: () => {\n        if (this.toolboxInstance === null) {\n          S(\"toolbox.toggle() called before initialization is finished\", \"warn\");\n          return;\n        }\n        this.toolboxInstance.toggle();\n      },\n      hasFocus: () => {\n        var t;\n        return (t = this.toolboxInstance) == null ? void 0 : t.hasFocus();\n      }\n    };\n  }\n  /**\n   * Block actions appearance manipulations\n   */\n  get blockActions() {\n    return {\n      hide: () => {\n        this.nodes.actions.classList.remove(this.CSS.actionsOpened);\n      },\n      show: () => {\n        this.nodes.actions.classList.add(this.CSS.actionsOpened);\n      }\n    };\n  }\n  /**\n   * Methods for working with Block Tunes toggler\n   */\n  get blockTunesToggler() {\n    return {\n      hide: () => this.nodes.settingsToggler.classList.add(this.CSS.settingsTogglerHidden),\n      show: () => this.nodes.settingsToggler.classList.remove(this.CSS.settingsTogglerHidden)\n    };\n  }\n  /**\n   * Toggles read-only mode\n   *\n   * @param {boolean} readOnlyEnabled - read-only mode\n   */\n  toggleReadOnly(e) {\n    e ? (this.destroy(), this.Editor.BlockSettings.destroy(), this.disableModuleBindings()) : window.requestIdleCallback(() => {\n      this.drawUI(), this.enableModuleBindings();\n    }, { timeout: 2e3 });\n  }\n  /**\n   * Move Toolbar to the passed (or current) Block\n   *\n   * @param block - block to move Toolbar near it\n   */\n  moveAndOpen(e = this.Editor.BlockManager.currentBlock) {\n    if (this.toolboxInstance === null) {\n      S(\"Can't open Toolbar since Editor initialization is not finished yet\", \"warn\");\n      return;\n    }\n    if (this.toolboxInstance.opened && this.toolboxInstance.close(), this.Editor.BlockSettings.opened && this.Editor.BlockSettings.close(), !e)\n      return;\n    this.hoveredBlock = e;\n    const t = e.holder, { isMobile: o } = this.Editor.UI;\n    let i;\n    const s = 20, r = e.firstInput, a = t.getBoundingClientRect(), l = r !== void 0 ? r.getBoundingClientRect() : null, c = l !== null ? l.top - a.top : null, u = c !== null ? c > s : void 0;\n    if (o)\n      i = t.offsetTop + t.offsetHeight;\n    else if (r === void 0 || u) {\n      const h = parseInt(window.getComputedStyle(e.pluginsContent).paddingTop);\n      i = t.offsetTop + h;\n    } else {\n      const h = li(r), p = parseInt(window.getComputedStyle(this.nodes.plusButton).height, 10), g = 8;\n      i = t.offsetTop + h - p + g + c;\n    }\n    this.nodes.wrapper.style.top = `${Math.floor(i)}px`, this.Editor.BlockManager.blocks.length === 1 && e.isEmpty ? this.blockTunesToggler.hide() : this.blockTunesToggler.show(), this.open();\n  }\n  /**\n   * Close the Toolbar\n   */\n  close() {\n    var e, t;\n    this.Editor.ReadOnly.isEnabled || ((e = this.nodes.wrapper) == null || e.classList.remove(this.CSS.toolbarOpened), this.blockActions.hide(), (t = this.toolboxInstance) == null || t.close(), this.Editor.BlockSettings.close(), this.reset());\n  }\n  /**\n   * Reset the Toolbar position to prevent DOM height growth, for example after blocks deletion\n   */\n  reset() {\n    this.nodes.wrapper.style.top = \"unset\";\n  }\n  /**\n   * Open Toolbar with Plus Button and Actions\n   *\n   * @param {boolean} withBlockActions - by default, Toolbar opens with Block Actions.\n   *                                     This flag allows to open Toolbar without Actions.\n   */\n  open(e = !0) {\n    this.nodes.wrapper.classList.add(this.CSS.toolbarOpened), e ? this.blockActions.show() : this.blockActions.hide();\n  }\n  /**\n   * Draws Toolbar elements\n   */\n  async make() {\n    this.nodes.wrapper = d.make(\"div\", this.CSS.toolbar), [\"content\", \"actions\"].forEach((s) => {\n      this.nodes[s] = d.make(\"div\", this.CSS[s]);\n    }), d.append(this.nodes.wrapper, this.nodes.content), d.append(this.nodes.content, this.nodes.actions), this.nodes.plusButton = d.make(\"div\", this.CSS.plusButton, {\n      innerHTML: ts\n    }), d.append(this.nodes.actions, this.nodes.plusButton), this.readOnlyMutableListeners.on(this.nodes.plusButton, \"click\", () => {\n      $e(!0), this.plusButtonClicked();\n    }, !1);\n    const e = d.make(\"div\");\n    e.appendChild(document.createTextNode(z.ui(K.ui.toolbar.toolbox, \"Add\"))), e.appendChild(d.make(\"div\", this.CSS.plusButtonShortcut, {\n      textContent: \"/\"\n    })), ze(this.nodes.plusButton, e, {\n      hidingDelay: 400\n    }), this.nodes.settingsToggler = d.make(\"span\", this.CSS.settingsToggler, {\n      innerHTML: es\n    }), d.append(this.nodes.actions, this.nodes.settingsToggler);\n    const t = d.make(\"div\"), o = d.text(z.ui(K.ui.blockTunes.toggler, \"Click to tune\")), i = await xs(\"Slash\", \"/\");\n    t.appendChild(o), t.appendChild(d.make(\"div\", this.CSS.plusButtonShortcut, {\n      textContent: vt(`CMD + ${i}`)\n    })), ze(this.nodes.settingsToggler, t, {\n      hidingDelay: 400\n    }), d.append(this.nodes.actions, this.makeToolbox()), d.append(this.nodes.actions, this.Editor.BlockSettings.getElement()), d.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper);\n  }\n  /**\n   * Creates the Toolbox instance and return it's rendered element\n   */\n  makeToolbox() {\n    return this.toolboxInstance = new Es({\n      api: this.Editor.API.methods,\n      tools: this.Editor.Tools.blockTools,\n      i18nLabels: {\n        filter: z.ui(K.ui.popover, \"Filter\"),\n        nothingFound: z.ui(K.ui.popover, \"Nothing found\")\n      }\n    }), this.toolboxInstance.on(Le.Opened, () => {\n      this.Editor.UI.nodes.wrapper.classList.add(this.CSS.openedToolboxHolderModifier);\n    }), this.toolboxInstance.on(Le.Closed, () => {\n      this.Editor.UI.nodes.wrapper.classList.remove(this.CSS.openedToolboxHolderModifier);\n    }), this.toolboxInstance.on(Le.BlockAdded, ({ block: e }) => {\n      const { BlockManager: t, Caret: o } = this.Editor, i = t.getBlockById(e.id);\n      i.inputs.length === 0 && (i === t.lastBlock ? (t.insertAtEnd(), o.setToBlock(t.lastBlock)) : o.setToBlock(t.nextBlock));\n    }), this.toolboxInstance.getElement();\n  }\n  /**\n   * Handler for Plus Button\n   */\n  plusButtonClicked() {\n    var e;\n    this.Editor.BlockManager.currentBlock = this.hoveredBlock, (e = this.toolboxInstance) == null || e.toggle();\n  }\n  /**\n   * Enable bindings\n   */\n  enableModuleBindings() {\n    this.readOnlyMutableListeners.on(this.nodes.settingsToggler, \"mousedown\", (e) => {\n      var t;\n      e.stopPropagation(), this.settingsTogglerClicked(), (t = this.toolboxInstance) != null && t.opened && this.toolboxInstance.close(), $e(!0);\n    }, !0), be() || this.eventsDispatcher.on(ln, (e) => {\n      var t;\n      this.Editor.BlockSettings.opened || (t = this.toolboxInstance) != null && t.opened || this.moveAndOpen(e.block);\n    });\n  }\n  /**\n   * Disable bindings\n   */\n  disableModuleBindings() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Clicks on the Block Settings toggler\n   */\n  settingsTogglerClicked() {\n    this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.BlockSettings.open(this.hoveredBlock);\n  }\n  /**\n   * Draws Toolbar UI\n   *\n   * Toolbar contains BlockSettings and Toolbox.\n   * That's why at first we draw its components and then Toolbar itself\n   *\n   * Steps:\n   *  - Make Toolbar dependent components like BlockSettings, Toolbox and so on\n   *  - Make itself and append dependent nodes to itself\n   *\n   */\n  drawUI() {\n    this.Editor.BlockSettings.make(), this.make();\n  }\n  /**\n   * Removes all created and saved HTMLElements\n   * It is used in Read-Only mode\n   */\n  destroy() {\n    this.removeAllNodes(), this.toolboxInstance && this.toolboxInstance.destroy();\n  }\n}\nvar ae = /* @__PURE__ */ ((n) => (n[n.Block = 0] = \"Block\", n[n.Inline = 1] = \"Inline\", n[n.Tune = 2] = \"Tune\", n))(ae || {}), Pe = /* @__PURE__ */ ((n) => (n.Shortcut = \"shortcut\", n.Toolbox = \"toolbox\", n.EnabledInlineTools = \"inlineToolbar\", n.EnabledBlockTunes = \"tunes\", n.Config = \"config\", n))(Pe || {}), cn = /* @__PURE__ */ ((n) => (n.Shortcut = \"shortcut\", n.SanitizeConfig = \"sanitize\", n))(cn || {}), pe = /* @__PURE__ */ ((n) => (n.IsEnabledLineBreaks = \"enableLineBreaks\", n.Toolbox = \"toolbox\", n.ConversionConfig = \"conversionConfig\", n.IsReadOnlySupported = \"isReadOnlySupported\", n.PasteConfig = \"pasteConfig\", n))(pe || {}), We = /* @__PURE__ */ ((n) => (n.IsInline = \"isInline\", n.Title = \"title\", n.IsReadOnlySupported = \"isReadOnlySupported\", n))(We || {}), mt = /* @__PURE__ */ ((n) => (n.IsTune = \"isTune\", n))(mt || {});\nclass Tt {\n  /**\n   * @class\n   * @param {ConstructorOptions} options - Constructor options\n   */\n  constructor({\n    name: e,\n    constructable: t,\n    config: o,\n    api: i,\n    isDefault: s,\n    isInternal: r = !1,\n    defaultPlaceholder: a\n  }) {\n    this.api = i, this.name = e, this.constructable = t, this.config = o, this.isDefault = s, this.isInternal = r, this.defaultPlaceholder = a;\n  }\n  /**\n   * Returns Tool user configuration\n   */\n  get settings() {\n    const e = this.config.config || {};\n    return this.isDefault && !(\"placeholder\" in e) && this.defaultPlaceholder && (e.placeholder = this.defaultPlaceholder), e;\n  }\n  /**\n   * Calls Tool's reset method\n   */\n  reset() {\n    if (A(this.constructable.reset))\n      return this.constructable.reset();\n  }\n  /**\n   * Calls Tool's prepare method\n   */\n  prepare() {\n    if (A(this.constructable.prepare))\n      return this.constructable.prepare({\n        toolName: this.name,\n        config: this.settings\n      });\n  }\n  /**\n   * Returns shortcut for Tool (internal or specified by user)\n   */\n  get shortcut() {\n    const e = this.constructable.shortcut;\n    return this.config.shortcut || e;\n  }\n  /**\n   * Returns Tool's sanitizer configuration\n   */\n  get sanitizeConfig() {\n    return this.constructable.sanitize || {};\n  }\n  /**\n   * Returns true if Tools is inline\n   */\n  isInline() {\n    return this.type === ae.Inline;\n  }\n  /**\n   * Returns true if Tools is block\n   */\n  isBlock() {\n    return this.type === ae.Block;\n  }\n  /**\n   * Returns true if Tools is tune\n   */\n  isTune() {\n    return this.type === ae.Tune;\n  }\n}\nclass Cs extends E {\n  /**\n   * @param moduleConfiguration - Module Configuration\n   * @param moduleConfiguration.config - Editor's config\n   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.CSS = {\n      inlineToolbar: \"ce-inline-toolbar\"\n    }, this.opened = !1, this.popover = null, this.toolbarVerticalMargin = be() ? 20 : 6, this.tools = /* @__PURE__ */ new Map(), window.requestIdleCallback(() => {\n      this.make();\n    }, { timeout: 2e3 });\n  }\n  /**\n   *  Moving / appearance\n   *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   */\n  /**\n   * Shows Inline Toolbar if something is selected\n   *\n   * @param [needToClose] - pass true to close toolbar if it is not allowed.\n   *                                  Avoid to use it just for closing IT, better call .close() clearly.\n   */\n  async tryToShow(e = !1) {\n    e && this.close(), this.allowedToShow() && (await this.open(), this.Editor.Toolbar.close());\n  }\n  /**\n   * Hides Inline Toolbar\n   */\n  close() {\n    var e, t;\n    if (this.opened) {\n      for (const [o, i] of this.tools) {\n        const s = this.getToolShortcut(o.name);\n        s !== void 0 && ge.remove(this.Editor.UI.nodes.redactor, s), A(i.clear) && i.clear();\n      }\n      this.tools = /* @__PURE__ */ new Map(), this.reset(), this.opened = !1, (e = this.popover) == null || e.hide(), (t = this.popover) == null || t.destroy(), this.popover = null;\n    }\n  }\n  /**\n   * Check if node is contained by Inline Toolbar\n   *\n   * @param {Node} node — node to check\n   */\n  containsNode(e) {\n    return this.nodes.wrapper === void 0 ? !1 : this.nodes.wrapper.contains(e);\n  }\n  /**\n   * Removes UI and its components\n   */\n  destroy() {\n    var e;\n    this.removeAllNodes(), (e = this.popover) == null || e.destroy(), this.popover = null;\n  }\n  /**\n   * Making DOM\n   */\n  make() {\n    this.nodes.wrapper = d.make(\"div\", [\n      this.CSS.inlineToolbar,\n      ...this.isRtl ? [this.Editor.UI.CSS.editorRtlFix] : []\n    ]), this.nodes.wrapper.setAttribute(\"data-cy\", \"inline-toolbar\"), d.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper);\n  }\n  /**\n   * Shows Inline Toolbar\n   */\n  async open() {\n    var t;\n    if (this.opened)\n      return;\n    this.opened = !0, this.popover !== null && this.popover.destroy(), this.createToolsInstances();\n    const e = await this.getPopoverItems();\n    this.popover = new hs({\n      items: e,\n      scopeElement: this.Editor.API.methods.ui.nodes.redactor,\n      messages: {\n        nothingFound: z.ui(K.ui.popover, \"Nothing found\"),\n        search: z.ui(K.ui.popover, \"Filter\")\n      }\n    }), this.move(this.popover.size.width), (t = this.nodes.wrapper) == null || t.append(this.popover.getElement()), this.popover.show();\n  }\n  /**\n   * Move Toolbar to the selected text\n   *\n   * @param popoverWidth - width of the toolbar popover\n   */\n  move(e) {\n    const t = b.rect, o = this.Editor.UI.nodes.wrapper.getBoundingClientRect(), i = {\n      x: t.x - o.x,\n      y: t.y + t.height - // + window.scrollY\n      o.top + this.toolbarVerticalMargin\n    };\n    i.x + e + o.x > this.Editor.UI.contentRect.right && (i.x = this.Editor.UI.contentRect.right - e - o.x), this.nodes.wrapper.style.left = Math.floor(i.x) + \"px\", this.nodes.wrapper.style.top = Math.floor(i.y) + \"px\";\n  }\n  /**\n   * Clear orientation classes and reset position\n   */\n  reset() {\n    this.nodes.wrapper.style.left = \"0\", this.nodes.wrapper.style.top = \"0\";\n  }\n  /**\n   * Need to show Inline Toolbar or not\n   */\n  allowedToShow() {\n    const e = [\"IMG\", \"INPUT\"], t = b.get(), o = b.text;\n    if (!t || !t.anchorNode || t.isCollapsed || o.length < 1)\n      return !1;\n    const i = d.isElement(t.anchorNode) ? t.anchorNode : t.anchorNode.parentElement;\n    if (i === null || t !== null && e.includes(i.tagName))\n      return !1;\n    const s = this.Editor.BlockManager.getBlock(t.anchorNode);\n    return !s || this.getTools().some((c) => s.tool.inlineTools.has(c.name)) === !1 ? !1 : i.closest(\"[contenteditable]\") !== null;\n  }\n  /**\n   *  Working with Tools\n   *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   */\n  /**\n   * Returns tools that are available for current block\n   *\n   * Used to check if Inline Toolbar could be shown\n   * and to render tools in the Inline Toolbar\n   */\n  getTools() {\n    const e = this.Editor.BlockManager.currentBlock;\n    return e ? Array.from(e.tool.inlineTools.values()).filter((o) => !(this.Editor.ReadOnly.isEnabled && o.isReadOnlySupported !== !0)) : [];\n  }\n  /**\n   * Constructs tools instances and saves them to this.tools\n   */\n  createToolsInstances() {\n    this.tools = /* @__PURE__ */ new Map(), this.getTools().forEach((t) => {\n      const o = t.create();\n      this.tools.set(t, o);\n    });\n  }\n  /**\n   * Returns Popover Items for tools segregated by their appearance type: regular items and custom html elements.\n   */\n  async getPopoverItems() {\n    const e = [];\n    let t = 0;\n    for (const [o, i] of this.tools) {\n      const s = await i.render(), r = this.getToolShortcut(o.name);\n      if (r !== void 0)\n        try {\n          this.enableShortcuts(o.name, r);\n        } catch {\n        }\n      const a = r !== void 0 ? vt(r) : void 0, l = z.t(\n        K.toolNames,\n        o.title || je(o.name)\n      );\n      [s].flat().forEach((c) => {\n        var h, p;\n        const u = {\n          name: o.name,\n          onActivate: () => {\n            this.toolClicked(i);\n          },\n          hint: {\n            title: l,\n            description: a\n          }\n        };\n        if (d.isElement(c)) {\n          const g = {\n            ...u,\n            element: c,\n            type: _.Html\n          };\n          if (A(i.renderActions)) {\n            const f = i.renderActions();\n            g.children = {\n              isOpen: (h = i.checkState) == null ? void 0 : h.call(i, b.get()),\n              /** Disable keyboard navigation in actions, as it might conflict with enter press handling */\n              isFlippable: !1,\n              items: [\n                {\n                  type: _.Html,\n                  element: f\n                }\n              ]\n            };\n          } else\n            (p = i.checkState) == null || p.call(i, b.get());\n          e.push(g);\n        } else if (c.type === _.Html)\n          e.push({\n            ...u,\n            ...c,\n            type: _.Html\n          });\n        else if (c.type === _.Separator)\n          e.push({\n            type: _.Separator\n          });\n        else {\n          const g = {\n            ...u,\n            ...c,\n            type: _.Default\n          };\n          \"children\" in g && t !== 0 && e.push({\n            type: _.Separator\n          }), e.push(g), \"children\" in g && t < this.tools.size - 1 && e.push({\n            type: _.Separator\n          });\n        }\n      }), t++;\n    }\n    return e;\n  }\n  /**\n   * Get shortcut name for tool\n   *\n   * @param toolName — Tool name\n   */\n  getToolShortcut(e) {\n    const { Tools: t } = this.Editor, o = t.inlineTools.get(e), i = t.internal.inlineTools;\n    return Array.from(i.keys()).includes(e) ? this.inlineTools[e][cn.Shortcut] : o == null ? void 0 : o.shortcut;\n  }\n  /**\n   * Enable Tool shortcut with Editor Shortcuts Module\n   *\n   * @param toolName - tool name\n   * @param shortcut - shortcut according to the ShortcutData Module format\n   */\n  enableShortcuts(e, t) {\n    ge.add({\n      name: t,\n      handler: (o) => {\n        var s;\n        const { currentBlock: i } = this.Editor.BlockManager;\n        i && i.tool.enabledInlineTools && (o.preventDefault(), (s = this.popover) == null || s.activateItemByName(e));\n      },\n      /**\n       * We need to bind shortcut to the document to make it work in read-only mode\n       */\n      on: document\n    });\n  }\n  /**\n   * Inline Tool button clicks\n   *\n   * @param tool - Tool's instance\n   */\n  toolClicked(e) {\n    var o;\n    const t = b.range;\n    (o = e.surround) == null || o.call(e, t), this.checkToolsState();\n  }\n  /**\n   * Check Tools` state by selection\n   */\n  checkToolsState() {\n    var e;\n    (e = this.tools) == null || e.forEach((t) => {\n      var o;\n      (o = t.checkState) == null || o.call(t, b.get());\n    });\n  }\n  /**\n   * Get inline tools tools\n   * Tools that has isInline is true\n   */\n  get inlineTools() {\n    const e = {};\n    return Array.from(this.Editor.Tools.inlineTools.entries()).forEach(([t, o]) => {\n      e[t] = o.create();\n    }), e;\n  }\n}\nfunction dn() {\n  const n = window.getSelection();\n  if (n === null)\n    return [null, 0];\n  let e = n.focusNode, t = n.focusOffset;\n  return e === null ? [null, 0] : (e.nodeType !== Node.TEXT_NODE && e.childNodes.length > 0 && (e.childNodes[t] ? (e = e.childNodes[t], t = 0) : (e = e.childNodes[t - 1], t = e.textContent.length)), [e, t]);\n}\nfunction un(n, e, t, o) {\n  const i = document.createRange();\n  o === \"left\" ? (i.setStart(n, 0), i.setEnd(e, t)) : (i.setStart(e, t), i.setEnd(n, n.childNodes.length));\n  const s = i.cloneContents(), r = document.createElement(\"div\");\n  r.appendChild(s);\n  const a = r.textContent || \"\";\n  return ai(a);\n}\nfunction Ne(n) {\n  const e = d.getDeepestNode(n);\n  if (e === null || d.isEmpty(n))\n    return !0;\n  if (d.isNativeInput(e))\n    return e.selectionEnd === 0;\n  if (d.isEmpty(n))\n    return !0;\n  const [t, o] = dn();\n  return t === null ? !1 : un(n, t, o, \"left\");\n}\nfunction Re(n) {\n  const e = d.getDeepestNode(n, !0);\n  if (e === null)\n    return !0;\n  if (d.isNativeInput(e))\n    return e.selectionEnd === e.value.length;\n  const [t, o] = dn();\n  return t === null ? !1 : un(n, t, o, \"right\");\n}\nvar hn = {}, St = {}, Xe = {}, de = {}, It = {}, Ot = {};\nObject.defineProperty(Ot, \"__esModule\", { value: !0 });\nOt.allInputsSelector = Ts;\nfunction Ts() {\n  var n = [\"text\", \"password\", \"email\", \"number\", \"search\", \"tel\", \"url\"];\n  return \"[contenteditable=true], textarea, input:not([type]), \" + n.map(function(e) {\n    return 'input[type=\"'.concat(e, '\"]');\n  }).join(\", \");\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.allInputsSelector = void 0;\n  var e = Ot;\n  Object.defineProperty(n, \"allInputsSelector\", { enumerable: !0, get: function() {\n    return e.allInputsSelector;\n  } });\n})(It);\nvar ue = {}, _t = {};\nObject.defineProperty(_t, \"__esModule\", { value: !0 });\n_t.isNativeInput = Ss;\nfunction Ss(n) {\n  var e = [\n    \"INPUT\",\n    \"TEXTAREA\"\n  ];\n  return n && n.tagName ? e.includes(n.tagName) : !1;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isNativeInput = void 0;\n  var e = _t;\n  Object.defineProperty(n, \"isNativeInput\", { enumerable: !0, get: function() {\n    return e.isNativeInput;\n  } });\n})(ue);\nvar pn = {}, Mt = {};\nObject.defineProperty(Mt, \"__esModule\", { value: !0 });\nMt.append = Is;\nfunction Is(n, e) {\n  Array.isArray(e) ? e.forEach(function(t) {\n    n.appendChild(t);\n  }) : n.appendChild(e);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.append = void 0;\n  var e = Mt;\n  Object.defineProperty(n, \"append\", { enumerable: !0, get: function() {\n    return e.append;\n  } });\n})(pn);\nvar At = {}, Lt = {};\nObject.defineProperty(Lt, \"__esModule\", { value: !0 });\nLt.blockElements = Os;\nfunction Os() {\n  return [\n    \"address\",\n    \"article\",\n    \"aside\",\n    \"blockquote\",\n    \"canvas\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"li\",\n    \"main\",\n    \"nav\",\n    \"noscript\",\n    \"ol\",\n    \"output\",\n    \"p\",\n    \"pre\",\n    \"ruby\",\n    \"section\",\n    \"table\",\n    \"tbody\",\n    \"thead\",\n    \"tr\",\n    \"tfoot\",\n    \"ul\",\n    \"video\"\n  ];\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.blockElements = void 0;\n  var e = Lt;\n  Object.defineProperty(n, \"blockElements\", { enumerable: !0, get: function() {\n    return e.blockElements;\n  } });\n})(At);\nvar fn = {}, Pt = {};\nObject.defineProperty(Pt, \"__esModule\", { value: !0 });\nPt.calculateBaseline = _s;\nfunction _s(n) {\n  var e = window.getComputedStyle(n), t = parseFloat(e.fontSize), o = parseFloat(e.lineHeight) || t * 1.2, i = parseFloat(e.paddingTop), s = parseFloat(e.borderTopWidth), r = parseFloat(e.marginTop), a = t * 0.8, l = (o - t) / 2, c = r + s + i + l + a;\n  return c;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.calculateBaseline = void 0;\n  var e = Pt;\n  Object.defineProperty(n, \"calculateBaseline\", { enumerable: !0, get: function() {\n    return e.calculateBaseline;\n  } });\n})(fn);\nvar gn = {}, Nt = {}, Rt = {}, Dt = {};\nObject.defineProperty(Dt, \"__esModule\", { value: !0 });\nDt.isContentEditable = Ms;\nfunction Ms(n) {\n  return n.contentEditable === \"true\";\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isContentEditable = void 0;\n  var e = Dt;\n  Object.defineProperty(n, \"isContentEditable\", { enumerable: !0, get: function() {\n    return e.isContentEditable;\n  } });\n})(Rt);\nObject.defineProperty(Nt, \"__esModule\", { value: !0 });\nNt.canSetCaret = Ps;\nvar As = ue, Ls = Rt;\nfunction Ps(n) {\n  var e = !0;\n  if ((0, As.isNativeInput)(n))\n    switch (n.type) {\n      case \"file\":\n      case \"checkbox\":\n      case \"radio\":\n      case \"hidden\":\n      case \"submit\":\n      case \"button\":\n      case \"image\":\n      case \"reset\":\n        e = !1;\n        break;\n    }\n  else\n    e = (0, Ls.isContentEditable)(n);\n  return e;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.canSetCaret = void 0;\n  var e = Nt;\n  Object.defineProperty(n, \"canSetCaret\", { enumerable: !0, get: function() {\n    return e.canSetCaret;\n  } });\n})(gn);\nvar Ve = {}, Ft = {};\nfunction Ns(n, e, t) {\n  const o = t.value !== void 0 ? \"value\" : \"get\", i = t[o], s = `#${e}Cache`;\n  if (t[o] = function(...r) {\n    return this[s] === void 0 && (this[s] = i.apply(this, r)), this[s];\n  }, o === \"get\" && t.set) {\n    const r = t.set;\n    t.set = function(a) {\n      delete n[s], r.apply(this, a);\n    };\n  }\n  return t;\n}\nfunction mn() {\n  const n = {\n    win: !1,\n    mac: !1,\n    x11: !1,\n    linux: !1\n  }, e = Object.keys(n).find((t) => window.navigator.appVersion.toLowerCase().indexOf(t) !== -1);\n  return e !== void 0 && (n[e] = !0), n;\n}\nfunction jt(n) {\n  return n != null && n !== \"\" && (typeof n != \"object\" || Object.keys(n).length > 0);\n}\nfunction Rs(n) {\n  return !jt(n);\n}\nconst Ds = () => typeof window < \"u\" && window.navigator !== null && jt(window.navigator.platform) && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === \"MacIntel\" && window.navigator.maxTouchPoints > 1);\nfunction Fs(n) {\n  const e = mn();\n  return n = n.replace(/shift/gi, \"⇧\").replace(/backspace/gi, \"⌫\").replace(/enter/gi, \"⏎\").replace(/up/gi, \"↑\").replace(/left/gi, \"→\").replace(/down/gi, \"↓\").replace(/right/gi, \"←\").replace(/escape/gi, \"⎋\").replace(/insert/gi, \"Ins\").replace(/delete/gi, \"␡\").replace(/\\+/gi, \"+\"), e.mac ? n = n.replace(/ctrl|cmd/gi, \"⌘\").replace(/alt/gi, \"⌥\") : n = n.replace(/cmd/gi, \"Ctrl\").replace(/windows/gi, \"WIN\"), n;\n}\nfunction js(n) {\n  return n[0].toUpperCase() + n.slice(1);\n}\nfunction Hs(n) {\n  const e = document.createElement(\"div\");\n  e.style.position = \"absolute\", e.style.left = \"-999px\", e.style.bottom = \"-999px\", e.innerHTML = n, document.body.appendChild(e);\n  const t = window.getSelection(), o = document.createRange();\n  if (o.selectNode(e), t === null)\n    throw new Error(\"Cannot copy text to clipboard\");\n  t.removeAllRanges(), t.addRange(o), document.execCommand(\"copy\"), document.body.removeChild(e);\n}\nfunction $s(n, e, t) {\n  let o;\n  return (...i) => {\n    const s = this, r = () => {\n      o = void 0, t !== !0 && n.apply(s, i);\n    }, a = t === !0 && o !== void 0;\n    window.clearTimeout(o), o = window.setTimeout(r, e), a && n.apply(s, i);\n  };\n}\nfunction oe(n) {\n  return Object.prototype.toString.call(n).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n}\nfunction zs(n) {\n  return oe(n) === \"boolean\";\n}\nfunction bn(n) {\n  return oe(n) === \"function\" || oe(n) === \"asyncfunction\";\n}\nfunction Us(n) {\n  return bn(n) && /^\\s*class\\s+/.test(n.toString());\n}\nfunction Ws(n) {\n  return oe(n) === \"number\";\n}\nfunction De(n) {\n  return oe(n) === \"object\";\n}\nfunction Ys(n) {\n  return Promise.resolve(n) === n;\n}\nfunction Ks(n) {\n  return oe(n) === \"string\";\n}\nfunction Xs(n) {\n  return oe(n) === \"undefined\";\n}\nfunction bt(n, ...e) {\n  if (!e.length)\n    return n;\n  const t = e.shift();\n  if (De(n) && De(t))\n    for (const o in t)\n      De(t[o]) ? (n[o] === void 0 && Object.assign(n, { [o]: {} }), bt(n[o], t[o])) : Object.assign(n, { [o]: t[o] });\n  return bt(n, ...e);\n}\nfunction Vs(n, e, t) {\n  const o = `«${e}» is deprecated and will be removed in the next major release. Please use the «${t}» instead.`;\n  n && console.warn(o);\n}\nfunction qs(n) {\n  try {\n    return new URL(n).href;\n  } catch {\n  }\n  return n.substring(0, 2) === \"//\" ? window.location.protocol + n : window.location.origin + n;\n}\nfunction Zs(n) {\n  return n > 47 && n < 58 || n === 32 || n === 13 || n === 229 || n > 64 && n < 91 || n > 95 && n < 112 || n > 185 && n < 193 || n > 218 && n < 223;\n}\nconst Gs = {\n  BACKSPACE: 8,\n  TAB: 9,\n  ENTER: 13,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  ESC: 27,\n  SPACE: 32,\n  LEFT: 37,\n  UP: 38,\n  DOWN: 40,\n  RIGHT: 39,\n  DELETE: 46,\n  META: 91,\n  SLASH: 191\n}, Qs = {\n  LEFT: 0,\n  WHEEL: 1,\n  RIGHT: 2,\n  BACKWARD: 3,\n  FORWARD: 4\n};\nlet Js = class {\n  constructor() {\n    this.completed = Promise.resolve();\n  }\n  /**\n   * Add new promise to queue\n   * @param operation - promise should be added to queue\n   */\n  add(e) {\n    return new Promise((t, o) => {\n      this.completed = this.completed.then(e).then(t).catch(o);\n    });\n  }\n};\nfunction er(n, e, t = void 0) {\n  let o, i, s, r = null, a = 0;\n  t || (t = {});\n  const l = function() {\n    a = t.leading === !1 ? 0 : Date.now(), r = null, s = n.apply(o, i), r === null && (o = i = null);\n  };\n  return function() {\n    const c = Date.now();\n    !a && t.leading === !1 && (a = c);\n    const u = e - (c - a);\n    return o = this, i = arguments, u <= 0 || u > e ? (r && (clearTimeout(r), r = null), a = c, s = n.apply(o, i), r === null && (o = i = null)) : !r && t.trailing !== !1 && (r = setTimeout(l, u)), s;\n  };\n}\nconst tr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  PromiseQueue: Js,\n  beautifyShortcut: Fs,\n  cacheable: Ns,\n  capitalize: js,\n  copyTextToClipboard: Hs,\n  debounce: $s,\n  deepMerge: bt,\n  deprecationAssert: Vs,\n  getUserOS: mn,\n  getValidUrl: qs,\n  isBoolean: zs,\n  isClass: Us,\n  isEmpty: Rs,\n  isFunction: bn,\n  isIosDevice: Ds,\n  isNumber: Ws,\n  isObject: De,\n  isPrintableKey: Zs,\n  isPromise: Ys,\n  isString: Ks,\n  isUndefined: Xs,\n  keyCodes: Gs,\n  mouseButtons: Qs,\n  notEmpty: jt,\n  throttle: er,\n  typeOf: oe\n}, Symbol.toStringTag, { value: \"Module\" })), Ht = /* @__PURE__ */ Xn(tr);\nObject.defineProperty(Ft, \"__esModule\", { value: !0 });\nFt.containsOnlyInlineElements = ir;\nvar or = Ht, nr = At;\nfunction ir(n) {\n  var e;\n  (0, or.isString)(n) ? (e = document.createElement(\"div\"), e.innerHTML = n) : e = n;\n  var t = function(o) {\n    return !(0, nr.blockElements)().includes(o.tagName.toLowerCase()) && Array.from(o.children).every(t);\n  };\n  return Array.from(e.children).every(t);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.containsOnlyInlineElements = void 0;\n  var e = Ft;\n  Object.defineProperty(n, \"containsOnlyInlineElements\", { enumerable: !0, get: function() {\n    return e.containsOnlyInlineElements;\n  } });\n})(Ve);\nvar vn = {}, $t = {}, qe = {}, zt = {};\nObject.defineProperty(zt, \"__esModule\", { value: !0 });\nzt.make = sr;\nfunction sr(n, e, t) {\n  var o;\n  e === void 0 && (e = null), t === void 0 && (t = {});\n  var i = document.createElement(n);\n  if (Array.isArray(e)) {\n    var s = e.filter(function(a) {\n      return a !== void 0;\n    });\n    (o = i.classList).add.apply(o, s);\n  } else\n    e !== null && i.classList.add(e);\n  for (var r in t)\n    Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]);\n  return i;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.make = void 0;\n  var e = zt;\n  Object.defineProperty(n, \"make\", { enumerable: !0, get: function() {\n    return e.make;\n  } });\n})(qe);\nObject.defineProperty($t, \"__esModule\", { value: !0 });\n$t.fragmentToString = ar;\nvar rr = qe;\nfunction ar(n) {\n  var e = (0, rr.make)(\"div\");\n  return e.appendChild(n), e.innerHTML;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.fragmentToString = void 0;\n  var e = $t;\n  Object.defineProperty(n, \"fragmentToString\", { enumerable: !0, get: function() {\n    return e.fragmentToString;\n  } });\n})(vn);\nvar kn = {}, Ut = {};\nObject.defineProperty(Ut, \"__esModule\", { value: !0 });\nUt.getContentLength = cr;\nvar lr = ue;\nfunction cr(n) {\n  var e, t;\n  return (0, lr.isNativeInput)(n) ? n.value.length : n.nodeType === Node.TEXT_NODE ? n.length : (t = (e = n.textContent) === null || e === void 0 ? void 0 : e.length) !== null && t !== void 0 ? t : 0;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.getContentLength = void 0;\n  var e = Ut;\n  Object.defineProperty(n, \"getContentLength\", { enumerable: !0, get: function() {\n    return e.getContentLength;\n  } });\n})(kn);\nvar Wt = {}, Yt = {}, Io = Ce && Ce.__spreadArray || function(n, e, t) {\n  if (t || arguments.length === 2)\n    for (var o = 0, i = e.length, s; o < i; o++)\n      (s || !(o in e)) && (s || (s = Array.prototype.slice.call(e, 0, o)), s[o] = e[o]);\n  return n.concat(s || Array.prototype.slice.call(e));\n};\nObject.defineProperty(Yt, \"__esModule\", { value: !0 });\nYt.getDeepestBlockElements = yn;\nvar dr = Ve;\nfunction yn(n) {\n  return (0, dr.containsOnlyInlineElements)(n) ? [n] : Array.from(n.children).reduce(function(e, t) {\n    return Io(Io([], e, !0), yn(t), !0);\n  }, []);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.getDeepestBlockElements = void 0;\n  var e = Yt;\n  Object.defineProperty(n, \"getDeepestBlockElements\", { enumerable: !0, get: function() {\n    return e.getDeepestBlockElements;\n  } });\n})(Wt);\nvar wn = {}, Kt = {}, Ze = {}, Xt = {};\nObject.defineProperty(Xt, \"__esModule\", { value: !0 });\nXt.isLineBreakTag = ur;\nfunction ur(n) {\n  return [\n    \"BR\",\n    \"WBR\"\n  ].includes(n.tagName);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isLineBreakTag = void 0;\n  var e = Xt;\n  Object.defineProperty(n, \"isLineBreakTag\", { enumerable: !0, get: function() {\n    return e.isLineBreakTag;\n  } });\n})(Ze);\nvar Ge = {}, Vt = {};\nObject.defineProperty(Vt, \"__esModule\", { value: !0 });\nVt.isSingleTag = hr;\nfunction hr(n) {\n  return [\n    \"AREA\",\n    \"BASE\",\n    \"BR\",\n    \"COL\",\n    \"COMMAND\",\n    \"EMBED\",\n    \"HR\",\n    \"IMG\",\n    \"INPUT\",\n    \"KEYGEN\",\n    \"LINK\",\n    \"META\",\n    \"PARAM\",\n    \"SOURCE\",\n    \"TRACK\",\n    \"WBR\"\n  ].includes(n.tagName);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isSingleTag = void 0;\n  var e = Vt;\n  Object.defineProperty(n, \"isSingleTag\", { enumerable: !0, get: function() {\n    return e.isSingleTag;\n  } });\n})(Ge);\nObject.defineProperty(Kt, \"__esModule\", { value: !0 });\nKt.getDeepestNode = En;\nvar pr = ue, fr = Ze, gr = Ge;\nfunction En(n, e) {\n  e === void 0 && (e = !1);\n  var t = e ? \"lastChild\" : \"firstChild\", o = e ? \"previousSibling\" : \"nextSibling\";\n  if (n.nodeType === Node.ELEMENT_NODE && n[t]) {\n    var i = n[t];\n    if ((0, gr.isSingleTag)(i) && !(0, pr.isNativeInput)(i) && !(0, fr.isLineBreakTag)(i))\n      if (i[o])\n        i = i[o];\n      else if (i.parentNode !== null && i.parentNode[o])\n        i = i.parentNode[o];\n      else\n        return i.parentNode;\n    return En(i, e);\n  }\n  return n;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.getDeepestNode = void 0;\n  var e = Kt;\n  Object.defineProperty(n, \"getDeepestNode\", { enumerable: !0, get: function() {\n    return e.getDeepestNode;\n  } });\n})(wn);\nvar xn = {}, qt = {}, Me = Ce && Ce.__spreadArray || function(n, e, t) {\n  if (t || arguments.length === 2)\n    for (var o = 0, i = e.length, s; o < i; o++)\n      (s || !(o in e)) && (s || (s = Array.prototype.slice.call(e, 0, o)), s[o] = e[o]);\n  return n.concat(s || Array.prototype.slice.call(e));\n};\nObject.defineProperty(qt, \"__esModule\", { value: !0 });\nqt.findAllInputs = yr;\nvar mr = Ve, br = Wt, vr = It, kr = ue;\nfunction yr(n) {\n  return Array.from(n.querySelectorAll((0, vr.allInputsSelector)())).reduce(function(e, t) {\n    return (0, kr.isNativeInput)(t) || (0, mr.containsOnlyInlineElements)(t) ? Me(Me([], e, !0), [t], !1) : Me(Me([], e, !0), (0, br.getDeepestBlockElements)(t), !0);\n  }, []);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.findAllInputs = void 0;\n  var e = qt;\n  Object.defineProperty(n, \"findAllInputs\", { enumerable: !0, get: function() {\n    return e.findAllInputs;\n  } });\n})(xn);\nvar Bn = {}, Zt = {};\nObject.defineProperty(Zt, \"__esModule\", { value: !0 });\nZt.isCollapsedWhitespaces = wr;\nfunction wr(n) {\n  return !/[^\\t\\n\\r ]/.test(n);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isCollapsedWhitespaces = void 0;\n  var e = Zt;\n  Object.defineProperty(n, \"isCollapsedWhitespaces\", { enumerable: !0, get: function() {\n    return e.isCollapsedWhitespaces;\n  } });\n})(Bn);\nvar Gt = {}, Qt = {};\nObject.defineProperty(Qt, \"__esModule\", { value: !0 });\nQt.isElement = xr;\nvar Er = Ht;\nfunction xr(n) {\n  return (0, Er.isNumber)(n) ? !1 : !!n && !!n.nodeType && n.nodeType === Node.ELEMENT_NODE;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isElement = void 0;\n  var e = Qt;\n  Object.defineProperty(n, \"isElement\", { enumerable: !0, get: function() {\n    return e.isElement;\n  } });\n})(Gt);\nvar Cn = {}, Jt = {}, eo = {}, to = {};\nObject.defineProperty(to, \"__esModule\", { value: !0 });\nto.isLeaf = Br;\nfunction Br(n) {\n  return n === null ? !1 : n.childNodes.length === 0;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isLeaf = void 0;\n  var e = to;\n  Object.defineProperty(n, \"isLeaf\", { enumerable: !0, get: function() {\n    return e.isLeaf;\n  } });\n})(eo);\nvar oo = {}, no = {};\nObject.defineProperty(no, \"__esModule\", { value: !0 });\nno.isNodeEmpty = Or;\nvar Cr = Ze, Tr = Gt, Sr = ue, Ir = Ge;\nfunction Or(n, e) {\n  var t = \"\";\n  return (0, Ir.isSingleTag)(n) && !(0, Cr.isLineBreakTag)(n) ? !1 : ((0, Tr.isElement)(n) && (0, Sr.isNativeInput)(n) ? t = n.value : n.textContent !== null && (t = n.textContent.replace(\"​\", \"\")), e !== void 0 && (t = t.replace(new RegExp(e, \"g\"), \"\")), t.trim().length === 0);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isNodeEmpty = void 0;\n  var e = no;\n  Object.defineProperty(n, \"isNodeEmpty\", { enumerable: !0, get: function() {\n    return e.isNodeEmpty;\n  } });\n})(oo);\nObject.defineProperty(Jt, \"__esModule\", { value: !0 });\nJt.isEmpty = Ar;\nvar _r = eo, Mr = oo;\nfunction Ar(n, e) {\n  n.normalize();\n  for (var t = [n]; t.length > 0; ) {\n    var o = t.shift();\n    if (o) {\n      if (n = o, (0, _r.isLeaf)(n) && !(0, Mr.isNodeEmpty)(n, e))\n        return !1;\n      t.push.apply(t, Array.from(n.childNodes));\n    }\n  }\n  return !0;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isEmpty = void 0;\n  var e = Jt;\n  Object.defineProperty(n, \"isEmpty\", { enumerable: !0, get: function() {\n    return e.isEmpty;\n  } });\n})(Cn);\nvar Tn = {}, io = {};\nObject.defineProperty(io, \"__esModule\", { value: !0 });\nio.isFragment = Pr;\nvar Lr = Ht;\nfunction Pr(n) {\n  return (0, Lr.isNumber)(n) ? !1 : !!n && !!n.nodeType && n.nodeType === Node.DOCUMENT_FRAGMENT_NODE;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isFragment = void 0;\n  var e = io;\n  Object.defineProperty(n, \"isFragment\", { enumerable: !0, get: function() {\n    return e.isFragment;\n  } });\n})(Tn);\nvar Sn = {}, so = {};\nObject.defineProperty(so, \"__esModule\", { value: !0 });\nso.isHTMLString = Rr;\nvar Nr = qe;\nfunction Rr(n) {\n  var e = (0, Nr.make)(\"div\");\n  return e.innerHTML = n, e.childElementCount > 0;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isHTMLString = void 0;\n  var e = so;\n  Object.defineProperty(n, \"isHTMLString\", { enumerable: !0, get: function() {\n    return e.isHTMLString;\n  } });\n})(Sn);\nvar In = {}, ro = {};\nObject.defineProperty(ro, \"__esModule\", { value: !0 });\nro.offset = Dr;\nfunction Dr(n) {\n  var e = n.getBoundingClientRect(), t = window.pageXOffset || document.documentElement.scrollLeft, o = window.pageYOffset || document.documentElement.scrollTop, i = e.top + o, s = e.left + t;\n  return {\n    top: i,\n    left: s,\n    bottom: i + e.height,\n    right: s + e.width\n  };\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.offset = void 0;\n  var e = ro;\n  Object.defineProperty(n, \"offset\", { enumerable: !0, get: function() {\n    return e.offset;\n  } });\n})(In);\nvar On = {}, ao = {};\nObject.defineProperty(ao, \"__esModule\", { value: !0 });\nao.prepend = Fr;\nfunction Fr(n, e) {\n  Array.isArray(e) ? (e = e.reverse(), e.forEach(function(t) {\n    return n.prepend(t);\n  })) : n.prepend(e);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.prepend = void 0;\n  var e = ao;\n  Object.defineProperty(n, \"prepend\", { enumerable: !0, get: function() {\n    return e.prepend;\n  } });\n})(On);\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.prepend = n.offset = n.make = n.isLineBreakTag = n.isSingleTag = n.isNodeEmpty = n.isLeaf = n.isHTMLString = n.isFragment = n.isEmpty = n.isElement = n.isContentEditable = n.isCollapsedWhitespaces = n.findAllInputs = n.isNativeInput = n.allInputsSelector = n.getDeepestNode = n.getDeepestBlockElements = n.getContentLength = n.fragmentToString = n.containsOnlyInlineElements = n.canSetCaret = n.calculateBaseline = n.blockElements = n.append = void 0;\n  var e = It;\n  Object.defineProperty(n, \"allInputsSelector\", { enumerable: !0, get: function() {\n    return e.allInputsSelector;\n  } });\n  var t = ue;\n  Object.defineProperty(n, \"isNativeInput\", { enumerable: !0, get: function() {\n    return t.isNativeInput;\n  } });\n  var o = pn;\n  Object.defineProperty(n, \"append\", { enumerable: !0, get: function() {\n    return o.append;\n  } });\n  var i = At;\n  Object.defineProperty(n, \"blockElements\", { enumerable: !0, get: function() {\n    return i.blockElements;\n  } });\n  var s = fn;\n  Object.defineProperty(n, \"calculateBaseline\", { enumerable: !0, get: function() {\n    return s.calculateBaseline;\n  } });\n  var r = gn;\n  Object.defineProperty(n, \"canSetCaret\", { enumerable: !0, get: function() {\n    return r.canSetCaret;\n  } });\n  var a = Ve;\n  Object.defineProperty(n, \"containsOnlyInlineElements\", { enumerable: !0, get: function() {\n    return a.containsOnlyInlineElements;\n  } });\n  var l = vn;\n  Object.defineProperty(n, \"fragmentToString\", { enumerable: !0, get: function() {\n    return l.fragmentToString;\n  } });\n  var c = kn;\n  Object.defineProperty(n, \"getContentLength\", { enumerable: !0, get: function() {\n    return c.getContentLength;\n  } });\n  var u = Wt;\n  Object.defineProperty(n, \"getDeepestBlockElements\", { enumerable: !0, get: function() {\n    return u.getDeepestBlockElements;\n  } });\n  var h = wn;\n  Object.defineProperty(n, \"getDeepestNode\", { enumerable: !0, get: function() {\n    return h.getDeepestNode;\n  } });\n  var p = xn;\n  Object.defineProperty(n, \"findAllInputs\", { enumerable: !0, get: function() {\n    return p.findAllInputs;\n  } });\n  var g = Bn;\n  Object.defineProperty(n, \"isCollapsedWhitespaces\", { enumerable: !0, get: function() {\n    return g.isCollapsedWhitespaces;\n  } });\n  var f = Rt;\n  Object.defineProperty(n, \"isContentEditable\", { enumerable: !0, get: function() {\n    return f.isContentEditable;\n  } });\n  var v = Gt;\n  Object.defineProperty(n, \"isElement\", { enumerable: !0, get: function() {\n    return v.isElement;\n  } });\n  var O = Cn;\n  Object.defineProperty(n, \"isEmpty\", { enumerable: !0, get: function() {\n    return O.isEmpty;\n  } });\n  var T = Tn;\n  Object.defineProperty(n, \"isFragment\", { enumerable: !0, get: function() {\n    return T.isFragment;\n  } });\n  var M = Sn;\n  Object.defineProperty(n, \"isHTMLString\", { enumerable: !0, get: function() {\n    return M.isHTMLString;\n  } });\n  var q = eo;\n  Object.defineProperty(n, \"isLeaf\", { enumerable: !0, get: function() {\n    return q.isLeaf;\n  } });\n  var F = oo;\n  Object.defineProperty(n, \"isNodeEmpty\", { enumerable: !0, get: function() {\n    return F.isNodeEmpty;\n  } });\n  var H = Ze;\n  Object.defineProperty(n, \"isLineBreakTag\", { enumerable: !0, get: function() {\n    return H.isLineBreakTag;\n  } });\n  var Q = Ge;\n  Object.defineProperty(n, \"isSingleTag\", { enumerable: !0, get: function() {\n    return Q.isSingleTag;\n  } });\n  var ie = qe;\n  Object.defineProperty(n, \"make\", { enumerable: !0, get: function() {\n    return ie.make;\n  } });\n  var k = In;\n  Object.defineProperty(n, \"offset\", { enumerable: !0, get: function() {\n    return k.offset;\n  } });\n  var m = On;\n  Object.defineProperty(n, \"prepend\", { enumerable: !0, get: function() {\n    return m.prepend;\n  } });\n})(de);\nvar Qe = {};\nObject.defineProperty(Qe, \"__esModule\", { value: !0 });\nQe.getContenteditableSlice = Hr;\nvar jr = de;\nfunction Hr(n, e, t, o, i) {\n  var s;\n  i === void 0 && (i = !1);\n  var r = document.createRange();\n  if (o === \"left\" ? (r.setStart(n, 0), r.setEnd(e, t)) : (r.setStart(e, t), r.setEnd(n, n.childNodes.length)), i === !0) {\n    var a = r.extractContents();\n    return (0, jr.fragmentToString)(a);\n  }\n  var l = r.cloneContents(), c = document.createElement(\"div\");\n  c.appendChild(l);\n  var u = (s = c.textContent) !== null && s !== void 0 ? s : \"\";\n  return u;\n}\nObject.defineProperty(Xe, \"__esModule\", { value: !0 });\nXe.checkContenteditableSliceForEmptiness = Ur;\nvar $r = de, zr = Qe;\nfunction Ur(n, e, t, o) {\n  var i = (0, zr.getContenteditableSlice)(n, e, t, o);\n  return (0, $r.isCollapsedWhitespaces)(i);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.checkContenteditableSliceForEmptiness = void 0;\n  var e = Xe;\n  Object.defineProperty(n, \"checkContenteditableSliceForEmptiness\", { enumerable: !0, get: function() {\n    return e.checkContenteditableSliceForEmptiness;\n  } });\n})(St);\nvar _n = {};\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.getContenteditableSlice = void 0;\n  var e = Qe;\n  Object.defineProperty(n, \"getContenteditableSlice\", { enumerable: !0, get: function() {\n    return e.getContenteditableSlice;\n  } });\n})(_n);\nvar Mn = {}, lo = {};\nObject.defineProperty(lo, \"__esModule\", { value: !0 });\nlo.focus = Yr;\nvar Wr = de;\nfunction Yr(n, e) {\n  var t, o;\n  if (e === void 0 && (e = !0), (0, Wr.isNativeInput)(n)) {\n    n.focus();\n    var i = e ? 0 : n.value.length;\n    n.setSelectionRange(i, i);\n  } else {\n    var s = document.createRange(), r = window.getSelection();\n    if (!r)\n      return;\n    var a = function(p) {\n      var g = document.createTextNode(\"\");\n      p.appendChild(g), s.setStart(g, 0), s.setEnd(g, 0);\n    }, l = function(p) {\n      return p != null;\n    }, c = n.childNodes, u = e ? c[0] : c[c.length - 1];\n    if (l(u)) {\n      for (; l(u) && u.nodeType !== Node.TEXT_NODE; )\n        u = e ? u.firstChild : u.lastChild;\n      if (l(u) && u.nodeType === Node.TEXT_NODE) {\n        var h = (o = (t = u.textContent) === null || t === void 0 ? void 0 : t.length) !== null && o !== void 0 ? o : 0, i = e ? 0 : h;\n        s.setStart(u, i), s.setEnd(u, i);\n      } else\n        a(n);\n    } else\n      a(n);\n    r.removeAllRanges(), r.addRange(s);\n  }\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.focus = void 0;\n  var e = lo;\n  Object.defineProperty(n, \"focus\", { enumerable: !0, get: function() {\n    return e.focus;\n  } });\n})(Mn);\nvar co = {}, Je = {};\nObject.defineProperty(Je, \"__esModule\", { value: !0 });\nJe.getCaretNodeAndOffset = Kr;\nfunction Kr() {\n  var n = window.getSelection();\n  if (n === null)\n    return [null, 0];\n  var e = n.focusNode, t = n.focusOffset;\n  return e === null ? [null, 0] : (e.nodeType !== Node.TEXT_NODE && e.childNodes.length > 0 && (e.childNodes[t] !== void 0 ? (e = e.childNodes[t], t = 0) : (e = e.childNodes[t - 1], e.textContent !== null && (t = e.textContent.length))), [e, t]);\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.getCaretNodeAndOffset = void 0;\n  var e = Je;\n  Object.defineProperty(n, \"getCaretNodeAndOffset\", { enumerable: !0, get: function() {\n    return e.getCaretNodeAndOffset;\n  } });\n})(co);\nvar An = {}, et = {};\nObject.defineProperty(et, \"__esModule\", { value: !0 });\net.getRange = Xr;\nfunction Xr() {\n  var n = window.getSelection();\n  return n && n.rangeCount ? n.getRangeAt(0) : null;\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.getRange = void 0;\n  var e = et;\n  Object.defineProperty(n, \"getRange\", { enumerable: !0, get: function() {\n    return e.getRange;\n  } });\n})(An);\nvar Ln = {}, uo = {};\nObject.defineProperty(uo, \"__esModule\", { value: !0 });\nuo.isCaretAtEndOfInput = Zr;\nvar Oo = de, Vr = co, qr = St;\nfunction Zr(n) {\n  var e = (0, Oo.getDeepestNode)(n, !0);\n  if (e === null)\n    return !0;\n  if ((0, Oo.isNativeInput)(e))\n    return e.selectionEnd === e.value.length;\n  var t = (0, Vr.getCaretNodeAndOffset)(), o = t[0], i = t[1];\n  return o === null ? !1 : (0, qr.checkContenteditableSliceForEmptiness)(n, o, i, \"right\");\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isCaretAtEndOfInput = void 0;\n  var e = uo;\n  Object.defineProperty(n, \"isCaretAtEndOfInput\", { enumerable: !0, get: function() {\n    return e.isCaretAtEndOfInput;\n  } });\n})(Ln);\nvar Pn = {}, ho = {};\nObject.defineProperty(ho, \"__esModule\", { value: !0 });\nho.isCaretAtStartOfInput = Jr;\nvar Ae = de, Gr = Je, Qr = Xe;\nfunction Jr(n) {\n  var e = (0, Ae.getDeepestNode)(n);\n  if (e === null || (0, Ae.isEmpty)(n))\n    return !0;\n  if ((0, Ae.isNativeInput)(e))\n    return e.selectionEnd === 0;\n  if ((0, Ae.isEmpty)(n))\n    return !0;\n  var t = (0, Gr.getCaretNodeAndOffset)(), o = t[0], i = t[1];\n  return o === null ? !1 : (0, Qr.checkContenteditableSliceForEmptiness)(n, o, i, \"left\");\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.isCaretAtStartOfInput = void 0;\n  var e = ho;\n  Object.defineProperty(n, \"isCaretAtStartOfInput\", { enumerable: !0, get: function() {\n    return e.isCaretAtStartOfInput;\n  } });\n})(Pn);\nvar Nn = {}, po = {};\nObject.defineProperty(po, \"__esModule\", { value: !0 });\npo.save = oa;\nvar ea = de, ta = et;\nfunction oa() {\n  var n = (0, ta.getRange)(), e = (0, ea.make)(\"span\");\n  if (e.id = \"cursor\", e.hidden = !0, !!n)\n    return n.insertNode(e), function() {\n      var o = window.getSelection();\n      o && (n.setStartAfter(e), n.setEndAfter(e), o.removeAllRanges(), o.addRange(n), setTimeout(function() {\n        e.remove();\n      }, 150));\n    };\n}\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.save = void 0;\n  var e = po;\n  Object.defineProperty(n, \"save\", { enumerable: !0, get: function() {\n    return e.save;\n  } });\n})(Nn);\n(function(n) {\n  Object.defineProperty(n, \"__esModule\", { value: !0 }), n.save = n.isCaretAtStartOfInput = n.isCaretAtEndOfInput = n.getRange = n.getCaretNodeAndOffset = n.focus = n.getContenteditableSlice = n.checkContenteditableSliceForEmptiness = void 0;\n  var e = St;\n  Object.defineProperty(n, \"checkContenteditableSliceForEmptiness\", { enumerable: !0, get: function() {\n    return e.checkContenteditableSliceForEmptiness;\n  } });\n  var t = _n;\n  Object.defineProperty(n, \"getContenteditableSlice\", { enumerable: !0, get: function() {\n    return t.getContenteditableSlice;\n  } });\n  var o = Mn;\n  Object.defineProperty(n, \"focus\", { enumerable: !0, get: function() {\n    return o.focus;\n  } });\n  var i = co;\n  Object.defineProperty(n, \"getCaretNodeAndOffset\", { enumerable: !0, get: function() {\n    return i.getCaretNodeAndOffset;\n  } });\n  var s = An;\n  Object.defineProperty(n, \"getRange\", { enumerable: !0, get: function() {\n    return s.getRange;\n  } });\n  var r = Ln;\n  Object.defineProperty(n, \"isCaretAtEndOfInput\", { enumerable: !0, get: function() {\n    return r.isCaretAtEndOfInput;\n  } });\n  var a = Pn;\n  Object.defineProperty(n, \"isCaretAtStartOfInput\", { enumerable: !0, get: function() {\n    return a.isCaretAtStartOfInput;\n  } });\n  var l = Nn;\n  Object.defineProperty(n, \"save\", { enumerable: !0, get: function() {\n    return l.save;\n  } });\n})(hn);\nclass na extends E {\n  /**\n   * All keydowns on Block\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  keydown(e) {\n    switch (this.beforeKeydownProcessing(e), e.keyCode) {\n      case y.BACKSPACE:\n        this.backspace(e);\n        break;\n      case y.DELETE:\n        this.delete(e);\n        break;\n      case y.ENTER:\n        this.enter(e);\n        break;\n      case y.DOWN:\n      case y.RIGHT:\n        this.arrowRightAndDown(e);\n        break;\n      case y.UP:\n      case y.LEFT:\n        this.arrowLeftAndUp(e);\n        break;\n      case y.TAB:\n        this.tabPressed(e);\n        break;\n    }\n    e.key === \"/\" && !e.ctrlKey && !e.metaKey && this.slashPressed(e), e.code === \"Slash\" && (e.ctrlKey || e.metaKey) && (e.preventDefault(), this.commandSlashPressed());\n  }\n  /**\n   * Fires on keydown before event processing\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  beforeKeydownProcessing(e) {\n    this.needToolbarClosing(e) && Po(e.keyCode) && (this.Editor.Toolbar.close(), e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || this.Editor.BlockSelection.clearSelection(e));\n  }\n  /**\n   * Key up on Block:\n   * - shows Inline Toolbar if something selected\n   * - shows conversion toolbar with 85% of block selection\n   *\n   * @param {KeyboardEvent} event - keyup event\n   */\n  keyup(e) {\n    e.shiftKey || this.Editor.UI.checkEmptiness();\n  }\n  /**\n   * Add drop target styles\n   *\n   * @param {DragEvent} event - drag over event\n   */\n  dragOver(e) {\n    const t = this.Editor.BlockManager.getBlockByChildNode(e.target);\n    t.dropTarget = !0;\n  }\n  /**\n   * Remove drop target style\n   *\n   * @param {DragEvent} event - drag leave event\n   */\n  dragLeave(e) {\n    const t = this.Editor.BlockManager.getBlockByChildNode(e.target);\n    t.dropTarget = !1;\n  }\n  /**\n   * Copying selected blocks\n   * Before putting to the clipboard we sanitize all blocks and then copy to the clipboard\n   *\n   * @param {ClipboardEvent} event - clipboard event\n   */\n  handleCommandC(e) {\n    const { BlockSelection: t } = this.Editor;\n    t.anyBlockSelected && t.copySelectedBlocks(e);\n  }\n  /**\n   * Copy and Delete selected Blocks\n   *\n   * @param {ClipboardEvent} event - clipboard event\n   */\n  handleCommandX(e) {\n    const { BlockSelection: t, BlockManager: o, Caret: i } = this.Editor;\n    t.anyBlockSelected && t.copySelectedBlocks(e).then(() => {\n      const s = o.removeSelectedBlocks(), r = o.insertDefaultBlockAtIndex(s, !0);\n      i.setToBlock(r, i.positions.START), t.clearSelection(e);\n    });\n  }\n  /**\n   * Tab pressed inside a Block.\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  tabPressed(e) {\n    const { InlineToolbar: t, Caret: o } = this.Editor;\n    if (t.opened)\n      return;\n    (e.shiftKey ? o.navigatePrevious(!0) : o.navigateNext(!0)) && e.preventDefault();\n  }\n  /**\n   * '/' + 'command' keydown inside a Block\n   */\n  commandSlashPressed() {\n    this.Editor.BlockSelection.selectedBlocks.length > 1 || this.activateBlockSettings();\n  }\n  /**\n   * '/' keydown inside a Block\n   *\n   * @param event - keydown\n   */\n  slashPressed(e) {\n    this.Editor.BlockManager.currentBlock.isEmpty && (e.preventDefault(), this.Editor.Caret.insertContentAtCaretPosition(\"/\"), this.activateToolbox());\n  }\n  /**\n   * ENTER pressed on block\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  enter(e) {\n    const { BlockManager: t, UI: o } = this.Editor, i = t.currentBlock;\n    if (i === void 0 || i.tool.isLineBreaksEnabled || o.someToolbarOpened && o.someFlipperButtonFocused || e.shiftKey && !pt)\n      return;\n    let s = i;\n    i.currentInput !== void 0 && Ne(i.currentInput) && !i.hasMedia ? this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex) : i.currentInput && Re(i.currentInput) ? s = this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex + 1) : s = this.Editor.BlockManager.split(), this.Editor.Caret.setToBlock(s), this.Editor.Toolbar.moveAndOpen(s), e.preventDefault();\n  }\n  /**\n   * Handle backspace keydown on Block\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  backspace(e) {\n    const { BlockManager: t, Caret: o } = this.Editor, { currentBlock: i, previousBlock: s } = t;\n    if (i === void 0 || !b.isCollapsed || !i.currentInput || !Ne(i.currentInput))\n      return;\n    if (e.preventDefault(), this.Editor.Toolbar.close(), !(i.currentInput === i.firstInput)) {\n      o.navigatePrevious();\n      return;\n    }\n    if (s === null)\n      return;\n    if (s.isEmpty) {\n      t.removeBlock(s);\n      return;\n    }\n    if (i.isEmpty) {\n      t.removeBlock(i);\n      const l = t.currentBlock;\n      o.setToBlock(l, o.positions.END);\n      return;\n    }\n    xo(s, i) ? this.mergeBlocks(s, i) : o.setToBlock(s, o.positions.END);\n  }\n  /**\n   * Handles delete keydown on Block\n   * Removes char after the caret.\n   * If caret is at the end of the block, merge next block with current\n   *\n   * @param {KeyboardEvent} event - keydown\n   */\n  delete(e) {\n    const { BlockManager: t, Caret: o } = this.Editor, { currentBlock: i, nextBlock: s } = t;\n    if (!b.isCollapsed || !Re(i.currentInput))\n      return;\n    if (e.preventDefault(), this.Editor.Toolbar.close(), !(i.currentInput === i.lastInput)) {\n      o.navigateNext();\n      return;\n    }\n    if (s === null)\n      return;\n    if (s.isEmpty) {\n      t.removeBlock(s);\n      return;\n    }\n    if (i.isEmpty) {\n      t.removeBlock(i), o.setToBlock(s, o.positions.START);\n      return;\n    }\n    xo(i, s) ? this.mergeBlocks(i, s) : o.setToBlock(s, o.positions.START);\n  }\n  /**\n   * Merge passed Blocks\n   *\n   * @param targetBlock - to which Block we want to merge\n   * @param blockToMerge - what Block we want to merge\n   */\n  mergeBlocks(e, t) {\n    const { BlockManager: o, Toolbar: i } = this.Editor;\n    e.lastInput !== void 0 && (hn.focus(e.lastInput, !1), o.mergeBlocks(e, t).then(() => {\n      i.close();\n    }));\n  }\n  /**\n   * Handle right and down keyboard keys\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  arrowRightAndDown(e) {\n    const t = ce.usedKeys.includes(e.keyCode) && (!e.shiftKey || e.keyCode === y.TAB);\n    if (this.Editor.UI.someToolbarOpened && t)\n      return;\n    this.Editor.Toolbar.close();\n    const { currentBlock: o } = this.Editor.BlockManager, s = ((o == null ? void 0 : o.currentInput) !== void 0 ? Re(o.currentInput) : void 0) || this.Editor.BlockSelection.anyBlockSelected;\n    if (e.shiftKey && e.keyCode === y.DOWN && s) {\n      this.Editor.CrossBlockSelection.toggleBlockSelectedState();\n      return;\n    }\n    if (e.keyCode === y.DOWN || e.keyCode === y.RIGHT && !this.isRtl ? this.Editor.Caret.navigateNext() : this.Editor.Caret.navigatePrevious()) {\n      e.preventDefault();\n      return;\n    }\n    Fe(() => {\n      this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();\n    }, 20)(), this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * Handle left and up keyboard keys\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  arrowLeftAndUp(e) {\n    if (this.Editor.UI.someToolbarOpened) {\n      if (ce.usedKeys.includes(e.keyCode) && (!e.shiftKey || e.keyCode === y.TAB))\n        return;\n      this.Editor.UI.closeAllToolbars();\n    }\n    this.Editor.Toolbar.close();\n    const { currentBlock: t } = this.Editor.BlockManager, i = ((t == null ? void 0 : t.currentInput) !== void 0 ? Ne(t.currentInput) : void 0) || this.Editor.BlockSelection.anyBlockSelected;\n    if (e.shiftKey && e.keyCode === y.UP && i) {\n      this.Editor.CrossBlockSelection.toggleBlockSelectedState(!1);\n      return;\n    }\n    if (e.keyCode === y.UP || e.keyCode === y.LEFT && !this.isRtl ? this.Editor.Caret.navigatePrevious() : this.Editor.Caret.navigateNext()) {\n      e.preventDefault();\n      return;\n    }\n    Fe(() => {\n      this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();\n    }, 20)(), this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * Cases when we need to close Toolbar\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  needToolbarClosing(e) {\n    const t = e.keyCode === y.ENTER && this.Editor.Toolbar.toolbox.opened, o = e.keyCode === y.ENTER && this.Editor.BlockSettings.opened, i = e.keyCode === y.ENTER && this.Editor.InlineToolbar.opened, s = e.keyCode === y.TAB;\n    return !(e.shiftKey || s || t || o || i);\n  }\n  /**\n   * If Toolbox is not open, then just open it and show plus button\n   */\n  activateToolbox() {\n    this.Editor.Toolbar.opened || this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open();\n  }\n  /**\n   * Open Toolbar and show BlockSettings before flipping Tools\n   */\n  activateBlockSettings() {\n    this.Editor.Toolbar.opened || this.Editor.Toolbar.moveAndOpen(), this.Editor.BlockSettings.opened || this.Editor.BlockSettings.open();\n  }\n}\nclass ct {\n  /**\n   * @class\n   * @param {HTMLElement} workingArea — editor`s working node\n   */\n  constructor(e) {\n    this.blocks = [], this.workingArea = e;\n  }\n  /**\n   * Get length of Block instances array\n   *\n   * @returns {number}\n   */\n  get length() {\n    return this.blocks.length;\n  }\n  /**\n   * Get Block instances array\n   *\n   * @returns {Block[]}\n   */\n  get array() {\n    return this.blocks;\n  }\n  /**\n   * Get blocks html elements array\n   *\n   * @returns {HTMLElement[]}\n   */\n  get nodes() {\n    return No(this.workingArea.children);\n  }\n  /**\n   * Proxy trap to implement array-like setter\n   *\n   * @example\n   * blocks[0] = new Block(...)\n   * @param {Blocks} instance — Blocks instance\n   * @param {PropertyKey} property — block index or any Blocks class property key to set\n   * @param {Block} value — value to set\n   * @returns {boolean}\n   */\n  static set(e, t, o) {\n    return isNaN(Number(t)) ? (Reflect.set(e, t, o), !0) : (e.insert(+t, o), !0);\n  }\n  /**\n   * Proxy trap to implement array-like getter\n   *\n   * @param {Blocks} instance — Blocks instance\n   * @param {PropertyKey} property — Blocks class property key\n   * @returns {Block|*}\n   */\n  static get(e, t) {\n    return isNaN(Number(t)) ? Reflect.get(e, t) : e.get(+t);\n  }\n  /**\n   * Push new Block to the blocks array and append it to working area\n   *\n   * @param {Block} block - Block to add\n   */\n  push(e) {\n    this.blocks.push(e), this.insertToDOM(e);\n  }\n  /**\n   * Swaps blocks with indexes first and second\n   *\n   * @param {number} first - first block index\n   * @param {number} second - second block index\n   * @deprecated — use 'move' instead\n   */\n  swap(e, t) {\n    const o = this.blocks[t];\n    d.swap(this.blocks[e].holder, o.holder), this.blocks[t] = this.blocks[e], this.blocks[e] = o;\n  }\n  /**\n   * Move a block from one to another index\n   *\n   * @param {number} toIndex - new index of the block\n   * @param {number} fromIndex - block to move\n   */\n  move(e, t) {\n    const o = this.blocks.splice(t, 1)[0], i = e - 1, s = Math.max(0, i), r = this.blocks[s];\n    e > 0 ? this.insertToDOM(o, \"afterend\", r) : this.insertToDOM(o, \"beforebegin\", r), this.blocks.splice(e, 0, o);\n    const a = this.composeBlockEvent(\"move\", {\n      fromIndex: t,\n      toIndex: e\n    });\n    o.call(ee.MOVED, a);\n  }\n  /**\n   * Insert new Block at passed index\n   *\n   * @param {number} index — index to insert Block\n   * @param {Block} block — Block to insert\n   * @param {boolean} replace — it true, replace block on given index\n   */\n  insert(e, t, o = !1) {\n    if (!this.length) {\n      this.push(t);\n      return;\n    }\n    e > this.length && (e = this.length), o && (this.blocks[e].holder.remove(), this.blocks[e].call(ee.REMOVED));\n    const i = o ? 1 : 0;\n    if (this.blocks.splice(e, i, t), e > 0) {\n      const s = this.blocks[e - 1];\n      this.insertToDOM(t, \"afterend\", s);\n    } else {\n      const s = this.blocks[e + 1];\n      s ? this.insertToDOM(t, \"beforebegin\", s) : this.insertToDOM(t);\n    }\n  }\n  /**\n   * Replaces block under passed index with passed block\n   *\n   * @param index - index of existed block\n   * @param block - new block\n   */\n  replace(e, t) {\n    if (this.blocks[e] === void 0)\n      throw Error(\"Incorrect index\");\n    this.blocks[e].holder.replaceWith(t.holder), this.blocks[e] = t;\n  }\n  /**\n   * Inserts several blocks at once\n   *\n   * @param blocks - blocks to insert\n   * @param index - index to insert blocks at\n   */\n  insertMany(e, t) {\n    const o = new DocumentFragment();\n    for (const i of e)\n      o.appendChild(i.holder);\n    if (this.length > 0) {\n      if (t > 0) {\n        const i = Math.min(t - 1, this.length - 1);\n        this.blocks[i].holder.after(o);\n      } else\n        t === 0 && this.workingArea.prepend(o);\n      this.blocks.splice(t, 0, ...e);\n    } else\n      this.blocks.push(...e), this.workingArea.appendChild(o);\n    e.forEach((i) => i.call(ee.RENDERED));\n  }\n  /**\n   * Remove block\n   *\n   * @param {number} index - index of Block to remove\n   */\n  remove(e) {\n    isNaN(e) && (e = this.length - 1), this.blocks[e].holder.remove(), this.blocks[e].call(ee.REMOVED), this.blocks.splice(e, 1);\n  }\n  /**\n   * Remove all blocks\n   */\n  removeAll() {\n    this.workingArea.innerHTML = \"\", this.blocks.forEach((e) => e.call(ee.REMOVED)), this.blocks.length = 0;\n  }\n  /**\n   * Insert Block after passed target\n   *\n   * @todo decide if this method is necessary\n   * @param {Block} targetBlock — target after which Block should be inserted\n   * @param {Block} newBlock — Block to insert\n   */\n  insertAfter(e, t) {\n    const o = this.blocks.indexOf(e);\n    this.insert(o + 1, t);\n  }\n  /**\n   * Get Block by index\n   *\n   * @param {number} index — Block index\n   * @returns {Block}\n   */\n  get(e) {\n    return this.blocks[e];\n  }\n  /**\n   * Return index of passed Block\n   *\n   * @param {Block} block - Block to find\n   * @returns {number}\n   */\n  indexOf(e) {\n    return this.blocks.indexOf(e);\n  }\n  /**\n   * Insert new Block into DOM\n   *\n   * @param {Block} block - Block to insert\n   * @param {InsertPosition} position — insert position (if set, will use insertAdjacentElement)\n   * @param {Block} target — Block related to position\n   */\n  insertToDOM(e, t, o) {\n    t ? o.holder.insertAdjacentElement(t, e.holder) : this.workingArea.appendChild(e.holder), e.call(ee.RENDERED);\n  }\n  /**\n   * Composes Block event with passed type and details\n   *\n   * @param {string} type - event type\n   * @param {object} detail - event detail\n   */\n  composeBlockEvent(e, t) {\n    return new CustomEvent(e, {\n      detail: t\n    });\n  }\n}\nconst _o = \"block-removed\", Mo = \"block-added\", ia = \"block-moved\", Ao = \"block-changed\";\nclass sa {\n  constructor() {\n    this.completed = Promise.resolve();\n  }\n  /**\n   * Add new promise to queue\n   *\n   * @param operation - promise should be added to queue\n   */\n  add(e) {\n    return new Promise((t, o) => {\n      this.completed = this.completed.then(e).then(t).catch(o);\n    });\n  }\n}\nclass ra extends E {\n  constructor() {\n    super(...arguments), this._currentBlockIndex = -1, this._blocks = null;\n  }\n  /**\n   * Returns current Block index\n   *\n   * @returns {number}\n   */\n  get currentBlockIndex() {\n    return this._currentBlockIndex;\n  }\n  /**\n   * Set current Block index and fire Block lifecycle callbacks\n   *\n   * @param {number} newIndex - index of Block to set as current\n   */\n  set currentBlockIndex(e) {\n    this._currentBlockIndex = e;\n  }\n  /**\n   * returns first Block\n   *\n   * @returns {Block}\n   */\n  get firstBlock() {\n    return this._blocks[0];\n  }\n  /**\n   * returns last Block\n   *\n   * @returns {Block}\n   */\n  get lastBlock() {\n    return this._blocks[this._blocks.length - 1];\n  }\n  /**\n   * Get current Block instance\n   *\n   * @returns {Block}\n   */\n  get currentBlock() {\n    return this._blocks[this.currentBlockIndex];\n  }\n  /**\n   * Set passed Block as a current\n   *\n   * @param block - block to set as a current\n   */\n  set currentBlock(e) {\n    this.currentBlockIndex = this.getBlockIndex(e);\n  }\n  /**\n   * Returns next Block instance\n   *\n   * @returns {Block|null}\n   */\n  get nextBlock() {\n    return this.currentBlockIndex === this._blocks.length - 1 ? null : this._blocks[this.currentBlockIndex + 1];\n  }\n  /**\n   * Return first Block with inputs after current Block\n   *\n   * @returns {Block | undefined}\n   */\n  get nextContentfulBlock() {\n    return this.blocks.slice(this.currentBlockIndex + 1).find((t) => !!t.inputs.length);\n  }\n  /**\n   * Return first Block with inputs before current Block\n   *\n   * @returns {Block | undefined}\n   */\n  get previousContentfulBlock() {\n    return this.blocks.slice(0, this.currentBlockIndex).reverse().find((t) => !!t.inputs.length);\n  }\n  /**\n   * Returns previous Block instance\n   *\n   * @returns {Block|null}\n   */\n  get previousBlock() {\n    return this.currentBlockIndex === 0 ? null : this._blocks[this.currentBlockIndex - 1];\n  }\n  /**\n   * Get array of Block instances\n   *\n   * @returns {Block[]} {@link Blocks#array}\n   */\n  get blocks() {\n    return this._blocks.array;\n  }\n  /**\n   * Check if each Block is empty\n   *\n   * @returns {boolean}\n   */\n  get isEditorEmpty() {\n    return this.blocks.every((e) => e.isEmpty);\n  }\n  /**\n   * Should be called after Editor.UI preparation\n   * Define this._blocks property\n   */\n  prepare() {\n    const e = new ct(this.Editor.UI.nodes.redactor);\n    this._blocks = new Proxy(e, {\n      set: ct.set,\n      get: ct.get\n    }), this.listeners.on(\n      document,\n      \"copy\",\n      (t) => this.Editor.BlockEvents.handleCommandC(t)\n    );\n  }\n  /**\n   * Toggle read-only state\n   *\n   * If readOnly is true:\n   *  - Unbind event handlers from created Blocks\n   *\n   * if readOnly is false:\n   *  - Bind event handlers to all existing Blocks\n   *\n   * @param {boolean} readOnlyEnabled - \"read only\" state\n   */\n  toggleReadOnly(e) {\n    e ? this.disableModuleBindings() : this.enableModuleBindings();\n  }\n  /**\n   * Creates Block instance by tool name\n   *\n   * @param {object} options - block creation options\n   * @param {string} options.tool - tools passed in editor config {@link EditorConfig#tools}\n   * @param {string} [options.id] - unique id for this block\n   * @param {BlockToolData} [options.data] - constructor params\n   * @returns {Block}\n   */\n  composeBlock({\n    tool: e,\n    data: t = {},\n    id: o = void 0,\n    tunes: i = {}\n  }) {\n    const s = this.Editor.ReadOnly.isEnabled, r = this.Editor.Tools.blockTools.get(e), a = new R({\n      id: o,\n      data: t,\n      tool: r,\n      api: this.Editor.API,\n      readOnly: s,\n      tunesData: i\n    }, this.eventsDispatcher);\n    return s || window.requestIdleCallback(() => {\n      this.bindBlockEvents(a);\n    }, { timeout: 2e3 }), a;\n  }\n  /**\n   * Insert new block into _blocks\n   *\n   * @param {object} options - insert options\n   * @param {string} [options.id] - block's unique id\n   * @param {string} [options.tool] - plugin name, by default method inserts the default block type\n   * @param {object} [options.data] - plugin data\n   * @param {number} [options.index] - index where to insert new Block\n   * @param {boolean} [options.needToFocus] - flag shows if needed to update current Block index\n   * @param {boolean} [options.replace] - flag shows if block by passed index should be replaced with inserted one\n   * @returns {Block}\n   */\n  insert({\n    id: e = void 0,\n    tool: t = this.config.defaultBlock,\n    data: o = {},\n    index: i,\n    needToFocus: s = !0,\n    replace: r = !1,\n    tunes: a = {}\n  } = {}) {\n    let l = i;\n    l === void 0 && (l = this.currentBlockIndex + (r ? 0 : 1));\n    const c = this.composeBlock({\n      id: e,\n      tool: t,\n      data: o,\n      tunes: a\n    });\n    return r && this.blockDidMutated(_o, this.getBlockByIndex(l), {\n      index: l\n    }), this._blocks.insert(l, c, r), this.blockDidMutated(Mo, c, {\n      index: l\n    }), s ? this.currentBlockIndex = l : l <= this.currentBlockIndex && this.currentBlockIndex++, c;\n  }\n  /**\n   * Inserts several blocks at once\n   *\n   * @param blocks - blocks to insert\n   * @param index - index where to insert\n   */\n  insertMany(e, t = 0) {\n    this._blocks.insertMany(e, t);\n  }\n  /**\n   * Update Block data.\n   *\n   * Currently we don't have an 'update' method in the Tools API, so we just create a new block with the same id and type\n   * Should not trigger 'block-removed' or 'block-added' events.\n   *\n   * If neither data nor tunes is provided, return the provided block instead.\n   *\n   * @param block - block to update\n   * @param data - (optional) new data\n   * @param tunes - (optional) tune data\n   */\n  async update(e, t, o) {\n    if (!t && !o)\n      return e;\n    const i = await e.data, s = this.composeBlock({\n      id: e.id,\n      tool: e.name,\n      data: Object.assign({}, i, t ?? {}),\n      tunes: o ?? e.tunes\n    }), r = this.getBlockIndex(e);\n    return this._blocks.replace(r, s), this.blockDidMutated(Ao, s, {\n      index: r\n    }), s;\n  }\n  /**\n   * Replace passed Block with the new one with specified Tool and data\n   *\n   * @param block - block to replace\n   * @param newTool - new Tool name\n   * @param data - new Tool data\n   */\n  replace(e, t, o) {\n    const i = this.getBlockIndex(e);\n    return this.insert({\n      tool: t,\n      data: o,\n      index: i,\n      replace: !0\n    });\n  }\n  /**\n   * Insert pasted content. Call onPaste callback after insert.\n   *\n   * @param {string} toolName - name of Tool to insert\n   * @param {PasteEvent} pasteEvent - pasted data\n   * @param {boolean} replace - should replace current block\n   */\n  paste(e, t, o = !1) {\n    const i = this.insert({\n      tool: e,\n      replace: o\n    });\n    try {\n      window.requestIdleCallback(() => {\n        i.call(ee.ON_PASTE, t);\n      });\n    } catch (s) {\n      S(`${e}: onPaste callback call is failed`, \"error\", s);\n    }\n    return i;\n  }\n  /**\n   * Insert new default block at passed index\n   *\n   * @param {number} index - index where Block should be inserted\n   * @param {boolean} needToFocus - if true, updates current Block index\n   *\n   * TODO: Remove method and use insert() with index instead (?)\n   * @returns {Block} inserted Block\n   */\n  insertDefaultBlockAtIndex(e, t = !1) {\n    const o = this.composeBlock({ tool: this.config.defaultBlock });\n    return this._blocks[e] = o, this.blockDidMutated(Mo, o, {\n      index: e\n    }), t ? this.currentBlockIndex = e : e <= this.currentBlockIndex && this.currentBlockIndex++, o;\n  }\n  /**\n   * Always inserts at the end\n   *\n   * @returns {Block}\n   */\n  insertAtEnd() {\n    return this.currentBlockIndex = this.blocks.length - 1, this.insert();\n  }\n  /**\n   * Merge two blocks\n   *\n   * @param {Block} targetBlock - previous block will be append to this block\n   * @param {Block} blockToMerge - block that will be merged with target block\n   * @returns {Promise} - the sequence that can be continued\n   */\n  async mergeBlocks(e, t) {\n    let o;\n    if (e.name === t.name && e.mergeable) {\n      const i = await t.data;\n      if (V(i)) {\n        console.error(\"Could not merge Block. Failed to extract original Block data.\");\n        return;\n      }\n      const [s] = yt([i], e.tool.sanitizeConfig);\n      o = s;\n    } else if (e.mergeable && He(t, \"export\") && He(e, \"import\")) {\n      const i = await t.exportDataAsString(), s = Z(i, e.tool.sanitizeConfig);\n      o = Bo(s, e.tool.conversionConfig);\n    }\n    o !== void 0 && (await e.mergeWith(o), this.removeBlock(t), this.currentBlockIndex = this._blocks.indexOf(e));\n  }\n  /**\n   * Remove passed Block\n   *\n   * @param block - Block to remove\n   * @param addLastBlock - if true, adds new default block at the end. @todo remove this logic and use event-bus instead\n   */\n  removeBlock(e, t = !0) {\n    return new Promise((o) => {\n      const i = this._blocks.indexOf(e);\n      if (!this.validateIndex(i))\n        throw new Error(\"Can't find a Block to remove\");\n      e.destroy(), this._blocks.remove(i), this.blockDidMutated(_o, e, {\n        index: i\n      }), this.currentBlockIndex >= i && this.currentBlockIndex--, this.blocks.length ? i === 0 && (this.currentBlockIndex = 0) : (this.unsetCurrentBlock(), t && this.insert()), o();\n    });\n  }\n  /**\n   * Remove only selected Blocks\n   * and returns first Block index where started removing...\n   *\n   * @returns {number|undefined}\n   */\n  removeSelectedBlocks() {\n    let e;\n    for (let t = this.blocks.length - 1; t >= 0; t--)\n      this.blocks[t].selected && (this.removeBlock(this.blocks[t]), e = t);\n    return e;\n  }\n  /**\n   * Attention!\n   * After removing insert the new default typed Block and focus on it\n   * Removes all blocks\n   */\n  removeAllBlocks() {\n    for (let e = this.blocks.length - 1; e >= 0; e--)\n      this._blocks.remove(e);\n    this.unsetCurrentBlock(), this.insert(), this.currentBlock.firstInput.focus();\n  }\n  /**\n   * Split current Block\n   * 1. Extract content from Caret position to the Block`s end\n   * 2. Insert a new Block below current one with extracted content\n   *\n   * @returns {Block}\n   */\n  split() {\n    const e = this.Editor.Caret.extractFragmentFromCaretPosition(), t = d.make(\"div\");\n    t.appendChild(e);\n    const o = {\n      text: d.isEmpty(t) ? \"\" : t.innerHTML\n    };\n    return this.insert({ data: o });\n  }\n  /**\n   * Returns Block by passed index\n   *\n   * @param {number} index - index to get. -1 to get last\n   * @returns {Block}\n   */\n  getBlockByIndex(e) {\n    return e === -1 && (e = this._blocks.length - 1), this._blocks[e];\n  }\n  /**\n   * Returns an index for passed Block\n   *\n   * @param block - block to find index\n   */\n  getBlockIndex(e) {\n    return this._blocks.indexOf(e);\n  }\n  /**\n   * Returns the Block by passed id\n   *\n   * @param id - id of block to get\n   * @returns {Block}\n   */\n  getBlockById(e) {\n    return this._blocks.array.find((t) => t.id === e);\n  }\n  /**\n   * Get Block instance by html element\n   *\n   * @param {Node} element - html element to get Block by\n   */\n  getBlock(e) {\n    d.isElement(e) || (e = e.parentNode);\n    const t = this._blocks.nodes, o = e.closest(`.${R.CSS.wrapper}`), i = t.indexOf(o);\n    if (i >= 0)\n      return this._blocks[i];\n  }\n  /**\n   * 1) Find first-level Block from passed child Node\n   * 2) Mark it as current\n   *\n   * @param {Node} childNode - look ahead from this node.\n   * @returns {Block | undefined} can return undefined in case when the passed child note is not a part of the current editor instance\n   */\n  setCurrentBlockByChildNode(e) {\n    d.isElement(e) || (e = e.parentNode);\n    const t = e.closest(`.${R.CSS.wrapper}`);\n    if (!t)\n      return;\n    const o = t.closest(`.${this.Editor.UI.CSS.editorWrapper}`);\n    if (o != null && o.isEqualNode(this.Editor.UI.nodes.wrapper))\n      return this.currentBlockIndex = this._blocks.nodes.indexOf(t), this.currentBlock.updateCurrentInput(), this.currentBlock;\n  }\n  /**\n   * Return block which contents passed node\n   *\n   * @param {Node} childNode - node to get Block by\n   * @returns {Block}\n   */\n  getBlockByChildNode(e) {\n    if (!e || !(e instanceof Node))\n      return;\n    d.isElement(e) || (e = e.parentNode);\n    const t = e.closest(`.${R.CSS.wrapper}`);\n    return this.blocks.find((o) => o.holder === t);\n  }\n  /**\n   * Swap Blocks Position\n   *\n   * @param {number} fromIndex - index of first block\n   * @param {number} toIndex - index of second block\n   * @deprecated — use 'move' instead\n   */\n  swap(e, t) {\n    this._blocks.swap(e, t), this.currentBlockIndex = t;\n  }\n  /**\n   * Move a block to a new index\n   *\n   * @param {number} toIndex - index where to move Block\n   * @param {number} fromIndex - index of Block to move\n   */\n  move(e, t = this.currentBlockIndex) {\n    if (isNaN(e) || isNaN(t)) {\n      S(\"Warning during 'move' call: incorrect indices provided.\", \"warn\");\n      return;\n    }\n    if (!this.validateIndex(e) || !this.validateIndex(t)) {\n      S(\"Warning during 'move' call: indices cannot be lower than 0 or greater than the amount of blocks.\", \"warn\");\n      return;\n    }\n    this._blocks.move(e, t), this.currentBlockIndex = e, this.blockDidMutated(ia, this.currentBlock, {\n      fromIndex: t,\n      toIndex: e\n    });\n  }\n  /**\n   * Converts passed Block to the new Tool\n   * Uses Conversion Config\n   *\n   * @param blockToConvert - Block that should be converted\n   * @param targetToolName - name of the Tool to convert to\n   * @param blockDataOverrides - optional new Block data overrides\n   */\n  async convert(e, t, o) {\n    if (!await e.save())\n      throw new Error(\"Could not convert Block. Failed to extract original Block data.\");\n    const s = this.Editor.Tools.blockTools.get(t);\n    if (!s)\n      throw new Error(`Could not convert Block. Tool «${t}» not found.`);\n    const r = await e.exportDataAsString(), a = Z(\n      r,\n      s.sanitizeConfig\n    );\n    let l = Bo(a, s.conversionConfig, s.settings);\n    return o && (l = Object.assign(l, o)), this.replace(e, s.name, l);\n  }\n  /**\n   * Sets current Block Index -1 which means unknown\n   * and clear highlights\n   */\n  unsetCurrentBlock() {\n    this.currentBlockIndex = -1;\n  }\n  /**\n   * Clears Editor\n   *\n   * @param {boolean} needToAddDefaultBlock - 1) in internal calls (for example, in api.blocks.render)\n   *                                             we don't need to add an empty default block\n   *                                        2) in api.blocks.clear we should add empty block\n   */\n  async clear(e = !1) {\n    const t = new sa();\n    this.blocks.forEach((o) => {\n      t.add(async () => {\n        await this.removeBlock(o, !1);\n      });\n    }), await t.completed, this.unsetCurrentBlock(), e && this.insert(), this.Editor.UI.checkEmptiness();\n  }\n  /**\n   * Cleans up all the block tools' resources\n   * This is called when editor is destroyed\n   */\n  async destroy() {\n    await Promise.all(this.blocks.map((e) => e.destroy()));\n  }\n  /**\n   * Bind Block events\n   *\n   * @param {Block} block - Block to which event should be bound\n   */\n  bindBlockEvents(e) {\n    const { BlockEvents: t } = this.Editor;\n    this.readOnlyMutableListeners.on(e.holder, \"keydown\", (o) => {\n      t.keydown(o);\n    }), this.readOnlyMutableListeners.on(e.holder, \"keyup\", (o) => {\n      t.keyup(o);\n    }), this.readOnlyMutableListeners.on(e.holder, \"dragover\", (o) => {\n      t.dragOver(o);\n    }), this.readOnlyMutableListeners.on(e.holder, \"dragleave\", (o) => {\n      t.dragLeave(o);\n    }), e.on(\"didMutated\", (o) => this.blockDidMutated(Ao, o, {\n      index: this.getBlockIndex(o)\n    }));\n  }\n  /**\n   * Disable mutable handlers and bindings\n   */\n  disableModuleBindings() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Enables all module handlers and bindings for all Blocks\n   */\n  enableModuleBindings() {\n    this.readOnlyMutableListeners.on(\n      document,\n      \"cut\",\n      (e) => this.Editor.BlockEvents.handleCommandX(e)\n    ), this.blocks.forEach((e) => {\n      this.bindBlockEvents(e);\n    });\n  }\n  /**\n   * Validates that the given index is not lower than 0 or higher than the amount of blocks\n   *\n   * @param {number} index - index of blocks array to validate\n   * @returns {boolean}\n   */\n  validateIndex(e) {\n    return !(e < 0 || e >= this._blocks.length);\n  }\n  /**\n   * Block mutation callback\n   *\n   * @param mutationType - what happened with block\n   * @param block - mutated block\n   * @param detailData - additional data to pass with change event\n   */\n  blockDidMutated(e, t, o) {\n    const i = new CustomEvent(e, {\n      detail: {\n        target: new J(t),\n        ...o\n      }\n    });\n    return this.eventsDispatcher.emit($o, {\n      event: i\n    }), t;\n  }\n}\nclass aa extends E {\n  constructor() {\n    super(...arguments), this.anyBlockSelectedCache = null, this.needToSelectAll = !1, this.nativeInputSelected = !1, this.readyToBlockSelection = !1;\n  }\n  /**\n   * Sanitizer Config\n   *\n   * @returns {SanitizerConfig}\n   */\n  get sanitizerConfig() {\n    return {\n      p: {},\n      h1: {},\n      h2: {},\n      h3: {},\n      h4: {},\n      h5: {},\n      h6: {},\n      ol: {},\n      ul: {},\n      li: {},\n      br: !0,\n      img: {\n        src: !0,\n        width: !0,\n        height: !0\n      },\n      a: {\n        href: !0\n      },\n      b: {},\n      i: {},\n      u: {}\n    };\n  }\n  /**\n   * Flag that identifies all Blocks selection\n   *\n   * @returns {boolean}\n   */\n  get allBlocksSelected() {\n    const { BlockManager: e } = this.Editor;\n    return e.blocks.every((t) => t.selected === !0);\n  }\n  /**\n   * Set selected all blocks\n   *\n   * @param {boolean} state - state to set\n   */\n  set allBlocksSelected(e) {\n    const { BlockManager: t } = this.Editor;\n    t.blocks.forEach((o) => {\n      o.selected = e;\n    }), this.clearCache();\n  }\n  /**\n   * Flag that identifies any Block selection\n   *\n   * @returns {boolean}\n   */\n  get anyBlockSelected() {\n    const { BlockManager: e } = this.Editor;\n    return this.anyBlockSelectedCache === null && (this.anyBlockSelectedCache = e.blocks.some((t) => t.selected === !0)), this.anyBlockSelectedCache;\n  }\n  /**\n   * Return selected Blocks array\n   *\n   * @returns {Block[]}\n   */\n  get selectedBlocks() {\n    return this.Editor.BlockManager.blocks.filter((e) => e.selected);\n  }\n  /**\n   * Module Preparation\n   * Registers Shortcuts CMD+A and CMD+C\n   * to select all and copy them\n   */\n  prepare() {\n    this.selection = new b(), ge.add({\n      name: \"CMD+A\",\n      handler: (e) => {\n        const { BlockManager: t, ReadOnly: o } = this.Editor;\n        if (o.isEnabled) {\n          e.preventDefault(), this.selectAllBlocks();\n          return;\n        }\n        t.currentBlock && this.handleCommandA(e);\n      },\n      on: this.Editor.UI.nodes.redactor\n    });\n  }\n  /**\n   * Toggle read-only state\n   *\n   *  - Remove all ranges\n   *  - Unselect all Blocks\n   */\n  toggleReadOnly() {\n    b.get().removeAllRanges(), this.allBlocksSelected = !1;\n  }\n  /**\n   * Remove selection of Block\n   *\n   * @param {number?} index - Block index according to the BlockManager's indexes\n   */\n  unSelectBlockByIndex(e) {\n    const { BlockManager: t } = this.Editor;\n    let o;\n    isNaN(e) ? o = t.currentBlock : o = t.getBlockByIndex(e), o.selected = !1, this.clearCache();\n  }\n  /**\n   * Clear selection from Blocks\n   *\n   * @param {Event} reason - event caused clear of selection\n   * @param {boolean} restoreSelection - if true, restore saved selection\n   */\n  clearSelection(e, t = !1) {\n    const { BlockManager: o, Caret: i, RectangleSelection: s } = this.Editor;\n    this.needToSelectAll = !1, this.nativeInputSelected = !1, this.readyToBlockSelection = !1;\n    const r = e && e instanceof KeyboardEvent, a = r && Po(e.keyCode);\n    if (this.anyBlockSelected && r && a && !b.isSelectionExists) {\n      const l = o.removeSelectedBlocks();\n      o.insertDefaultBlockAtIndex(l, !0), i.setToBlock(o.currentBlock), Fe(() => {\n        const c = e.key;\n        i.insertContentAtCaretPosition(c.length > 1 ? \"\" : c);\n      }, 20)();\n    }\n    if (this.Editor.CrossBlockSelection.clear(e), !this.anyBlockSelected || s.isRectActivated()) {\n      this.Editor.RectangleSelection.clearSelection();\n      return;\n    }\n    t && this.selection.restore(), this.allBlocksSelected = !1;\n  }\n  /**\n   * Reduce each Block and copy its content\n   *\n   * @param {ClipboardEvent} e - copy/cut event\n   * @returns {Promise<void>}\n   */\n  copySelectedBlocks(e) {\n    e.preventDefault();\n    const t = d.make(\"div\");\n    this.selectedBlocks.forEach((s) => {\n      const r = Z(s.holder.innerHTML, this.sanitizerConfig), a = d.make(\"p\");\n      a.innerHTML = r, t.appendChild(a);\n    });\n    const o = Array.from(t.childNodes).map((s) => s.textContent).join(`\n\n`), i = t.innerHTML;\n    return e.clipboardData.setData(\"text/plain\", o), e.clipboardData.setData(\"text/html\", i), Promise.all(this.selectedBlocks.map((s) => s.save())).then((s) => {\n      try {\n        e.clipboardData.setData(this.Editor.Paste.MIME_TYPE, JSON.stringify(s));\n      } catch {\n      }\n    });\n  }\n  /**\n   * Select Block by its index\n   *\n   * @param {number?} index - Block index according to the BlockManager's indexes\n   */\n  selectBlockByIndex(e) {\n    const { BlockManager: t } = this.Editor, o = t.getBlockByIndex(e);\n    o !== void 0 && this.selectBlock(o);\n  }\n  /**\n   * Select passed Block\n   *\n   * @param {Block} block - Block to select\n   */\n  selectBlock(e) {\n    this.selection.save(), b.get().removeAllRanges(), e.selected = !0, this.clearCache(), this.Editor.InlineToolbar.close();\n  }\n  /**\n   * Remove selection from passed Block\n   *\n   * @param {Block} block - Block to unselect\n   */\n  unselectBlock(e) {\n    e.selected = !1, this.clearCache();\n  }\n  /**\n   * Clear anyBlockSelected cache\n   */\n  clearCache() {\n    this.anyBlockSelectedCache = null;\n  }\n  /**\n   * Module destruction\n   * De-registers Shortcut CMD+A\n   */\n  destroy() {\n    ge.remove(this.Editor.UI.nodes.redactor, \"CMD+A\");\n  }\n  /**\n   * First CMD+A selects all input content by native behaviour,\n   * next CMD+A keypress selects all blocks\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  handleCommandA(e) {\n    if (this.Editor.RectangleSelection.clearSelection(), d.isNativeInput(e.target) && !this.readyToBlockSelection) {\n      this.readyToBlockSelection = !0;\n      return;\n    }\n    const t = this.Editor.BlockManager.getBlock(e.target), o = t.inputs;\n    if (o.length > 1 && !this.readyToBlockSelection) {\n      this.readyToBlockSelection = !0;\n      return;\n    }\n    if (o.length === 1 && !this.needToSelectAll) {\n      this.needToSelectAll = !0;\n      return;\n    }\n    this.needToSelectAll ? (e.preventDefault(), this.selectAllBlocks(), this.needToSelectAll = !1, this.readyToBlockSelection = !1) : this.readyToBlockSelection && (e.preventDefault(), this.selectBlock(t), this.needToSelectAll = !0);\n  }\n  /**\n   * Select All Blocks\n   * Each Block has selected setter that makes Block copyable\n   */\n  selectAllBlocks() {\n    this.selection.save(), b.get().removeAllRanges(), this.allBlocksSelected = !0, this.Editor.InlineToolbar.close();\n  }\n}\nclass Ye extends E {\n  /**\n   * Allowed caret positions in input\n   *\n   * @static\n   * @returns {{START: string, END: string, DEFAULT: string}}\n   */\n  get positions() {\n    return {\n      START: \"start\",\n      END: \"end\",\n      DEFAULT: \"default\"\n    };\n  }\n  /**\n   * Elements styles that can be useful for Caret Module\n   */\n  static get CSS() {\n    return {\n      shadowCaret: \"cdx-shadow-caret\"\n    };\n  }\n  /**\n   * Method gets Block instance and puts caret to the text node with offset\n   * There two ways that method applies caret position:\n   *   - first found text node: sets at the beginning, but you can pass an offset\n   *   - last found text node: sets at the end of the node. Also, you can customize the behaviour\n   *\n   * @param {Block} block - Block class\n   * @param {string} position - position where to set caret.\n   *                            If default - leave default behaviour and apply offset if it's passed\n   * @param {number} offset - caret offset regarding to the text node\n   */\n  setToBlock(e, t = this.positions.DEFAULT, o = 0) {\n    var c;\n    const { BlockManager: i, BlockSelection: s } = this.Editor;\n    if (s.clearSelection(), !e.focusable) {\n      (c = window.getSelection()) == null || c.removeAllRanges(), s.selectBlock(e), i.currentBlock = e;\n      return;\n    }\n    let r;\n    switch (t) {\n      case this.positions.START:\n        r = e.firstInput;\n        break;\n      case this.positions.END:\n        r = e.lastInput;\n        break;\n      default:\n        r = e.currentInput;\n    }\n    if (!r)\n      return;\n    const a = d.getDeepestNode(r, t === this.positions.END), l = d.getContentLength(a);\n    switch (!0) {\n      case t === this.positions.START:\n        o = 0;\n        break;\n      case t === this.positions.END:\n      case o > l:\n        o = l;\n        break;\n    }\n    this.set(a, o), i.setCurrentBlockByChildNode(e.holder), i.currentBlock.currentInput = r;\n  }\n  /**\n   * Set caret to the current input of current Block.\n   *\n   * @param {HTMLElement} input - input where caret should be set\n   * @param {string} position - position of the caret.\n   *                            If default - leave default behaviour and apply offset if it's passed\n   * @param {number} offset - caret offset regarding to the text node\n   */\n  setToInput(e, t = this.positions.DEFAULT, o = 0) {\n    const { currentBlock: i } = this.Editor.BlockManager, s = d.getDeepestNode(e);\n    switch (t) {\n      case this.positions.START:\n        this.set(s, 0);\n        break;\n      case this.positions.END:\n        this.set(s, d.getContentLength(s));\n        break;\n      default:\n        o && this.set(s, o);\n    }\n    i.currentInput = e;\n  }\n  /**\n   * Creates Document Range and sets caret to the element with offset\n   *\n   * @param {HTMLElement} element - target node.\n   * @param {number} offset - offset\n   */\n  set(e, t = 0) {\n    const { top: i, bottom: s } = b.setCursor(e, t), { innerHeight: r } = window;\n    i < 0 ? window.scrollBy(0, i - 30) : s > r && window.scrollBy(0, s - r + 30);\n  }\n  /**\n   * Set Caret to the last Block\n   * If last block is not empty, append another empty block\n   */\n  setToTheLastBlock() {\n    const e = this.Editor.BlockManager.lastBlock;\n    if (e)\n      if (e.tool.isDefault && e.isEmpty)\n        this.setToBlock(e);\n      else {\n        const t = this.Editor.BlockManager.insertAtEnd();\n        this.setToBlock(t);\n      }\n  }\n  /**\n   * Extract content fragment of current Block from Caret position to the end of the Block\n   */\n  extractFragmentFromCaretPosition() {\n    const e = b.get();\n    if (e.rangeCount) {\n      const t = e.getRangeAt(0), o = this.Editor.BlockManager.currentBlock.currentInput;\n      if (t.deleteContents(), o)\n        if (d.isNativeInput(o)) {\n          const i = o, s = document.createDocumentFragment(), r = i.value.substring(0, i.selectionStart), a = i.value.substring(i.selectionStart);\n          return s.textContent = a, i.value = r, s;\n        } else {\n          const i = t.cloneRange();\n          return i.selectNodeContents(o), i.setStart(t.endContainer, t.endOffset), i.extractContents();\n        }\n    }\n  }\n  /**\n   * Set's caret to the next Block or Tool`s input\n   * Before moving caret, we should check if caret position is at the end of Plugins node\n   * Using {@link Dom#getDeepestNode} to get a last node and match with current selection\n   *\n   * @param {boolean} force - pass true to skip check for caret position\n   */\n  navigateNext(e = !1) {\n    const { BlockManager: t } = this.Editor, { currentBlock: o, nextBlock: i } = t;\n    if (o === void 0)\n      return !1;\n    const { nextInput: s, currentInput: r } = o, a = r !== void 0 ? Re(r) : void 0;\n    let l = i;\n    const c = e || a || !o.focusable;\n    if (s && c)\n      return this.setToInput(s, this.positions.START), !0;\n    if (l === null) {\n      if (o.tool.isDefault || !c)\n        return !1;\n      l = t.insertAtEnd();\n    }\n    return c ? (this.setToBlock(l, this.positions.START), !0) : !1;\n  }\n  /**\n   * Set's caret to the previous Tool`s input or Block\n   * Before moving caret, we should check if caret position is start of the Plugins node\n   * Using {@link Dom#getDeepestNode} to get a last node and match with current selection\n   *\n   * @param {boolean} force - pass true to skip check for caret position\n   */\n  navigatePrevious(e = !1) {\n    const { currentBlock: t, previousBlock: o } = this.Editor.BlockManager;\n    if (!t)\n      return !1;\n    const { previousInput: i, currentInput: s } = t, r = s !== void 0 ? Ne(s) : void 0, a = e || r || !t.focusable;\n    return i && a ? (this.setToInput(i, this.positions.END), !0) : o !== null && a ? (this.setToBlock(o, this.positions.END), !0) : !1;\n  }\n  /**\n   * Inserts shadow element after passed element where caret can be placed\n   *\n   * @param {Element} element - element after which shadow caret should be inserted\n   */\n  createShadow(e) {\n    const t = document.createElement(\"span\");\n    t.classList.add(Ye.CSS.shadowCaret), e.insertAdjacentElement(\"beforeend\", t);\n  }\n  /**\n   * Restores caret position\n   *\n   * @param {HTMLElement} element - element where caret should be restored\n   */\n  restoreCaret(e) {\n    const t = e.querySelector(`.${Ye.CSS.shadowCaret}`);\n    if (!t)\n      return;\n    new b().expandToTag(t);\n    const i = document.createRange();\n    i.selectNode(t), i.extractContents();\n  }\n  /**\n   * Inserts passed content at caret position\n   *\n   * @param {string} content - content to insert\n   */\n  insertContentAtCaretPosition(e) {\n    const t = document.createDocumentFragment(), o = document.createElement(\"div\"), i = b.get(), s = b.range;\n    o.innerHTML = e, Array.from(o.childNodes).forEach((c) => t.appendChild(c)), t.childNodes.length === 0 && t.appendChild(new Text());\n    const r = t.lastChild;\n    s.deleteContents(), s.insertNode(t);\n    const a = document.createRange(), l = r.nodeType === Node.TEXT_NODE ? r : r.firstChild;\n    l !== null && l.textContent !== null && a.setStart(l, l.textContent.length), i.removeAllRanges(), i.addRange(a);\n  }\n}\nclass la extends E {\n  constructor() {\n    super(...arguments), this.onMouseUp = () => {\n      this.listeners.off(document, \"mouseover\", this.onMouseOver), this.listeners.off(document, \"mouseup\", this.onMouseUp);\n    }, this.onMouseOver = (e) => {\n      const { BlockManager: t, BlockSelection: o } = this.Editor;\n      if (e.relatedTarget === null && e.target === null)\n        return;\n      const i = t.getBlockByChildNode(e.relatedTarget) || this.lastSelectedBlock, s = t.getBlockByChildNode(e.target);\n      if (!(!i || !s) && s !== i) {\n        if (i === this.firstSelectedBlock) {\n          b.get().removeAllRanges(), i.selected = !0, s.selected = !0, o.clearCache();\n          return;\n        }\n        if (s === this.firstSelectedBlock) {\n          i.selected = !1, s.selected = !1, o.clearCache();\n          return;\n        }\n        this.Editor.InlineToolbar.close(), this.toggleBlocksSelectedState(i, s), this.lastSelectedBlock = s;\n      }\n    };\n  }\n  /**\n   * Module preparation\n   *\n   * @returns {Promise}\n   */\n  async prepare() {\n    this.listeners.on(document, \"mousedown\", (e) => {\n      this.enableCrossBlockSelection(e);\n    });\n  }\n  /**\n   * Sets up listeners\n   *\n   * @param {MouseEvent} event - mouse down event\n   */\n  watchSelection(e) {\n    if (e.button !== qn.LEFT)\n      return;\n    const { BlockManager: t } = this.Editor;\n    this.firstSelectedBlock = t.getBlock(e.target), this.lastSelectedBlock = this.firstSelectedBlock, this.listeners.on(document, \"mouseover\", this.onMouseOver), this.listeners.on(document, \"mouseup\", this.onMouseUp);\n  }\n  /**\n   * Return boolean is cross block selection started:\n   * there should be at least 2 selected blocks\n   */\n  get isCrossBlockSelectionStarted() {\n    return !!this.firstSelectedBlock && !!this.lastSelectedBlock && this.firstSelectedBlock !== this.lastSelectedBlock;\n  }\n  /**\n   * Change selection state of the next Block\n   * Used for CBS via Shift + arrow keys\n   *\n   * @param {boolean} next - if true, toggle next block. Previous otherwise\n   */\n  toggleBlockSelectedState(e = !0) {\n    const { BlockManager: t, BlockSelection: o } = this.Editor;\n    this.lastSelectedBlock || (this.lastSelectedBlock = this.firstSelectedBlock = t.currentBlock), this.firstSelectedBlock === this.lastSelectedBlock && (this.firstSelectedBlock.selected = !0, o.clearCache(), b.get().removeAllRanges());\n    const i = t.blocks.indexOf(this.lastSelectedBlock) + (e ? 1 : -1), s = t.blocks[i];\n    s && (this.lastSelectedBlock.selected !== s.selected ? (s.selected = !0, o.clearCache()) : (this.lastSelectedBlock.selected = !1, o.clearCache()), this.lastSelectedBlock = s, this.Editor.InlineToolbar.close(), s.holder.scrollIntoView({\n      block: \"nearest\"\n    }));\n  }\n  /**\n   * Clear saved state\n   *\n   * @param {Event} reason - event caused clear of selection\n   */\n  clear(e) {\n    const { BlockManager: t, BlockSelection: o, Caret: i } = this.Editor, s = t.blocks.indexOf(this.firstSelectedBlock), r = t.blocks.indexOf(this.lastSelectedBlock);\n    if (o.anyBlockSelected && s > -1 && r > -1 && e && e instanceof KeyboardEvent)\n      switch (e.keyCode) {\n        case y.DOWN:\n        case y.RIGHT:\n          i.setToBlock(t.blocks[Math.max(s, r)], i.positions.END);\n          break;\n        case y.UP:\n        case y.LEFT:\n          i.setToBlock(t.blocks[Math.min(s, r)], i.positions.START);\n          break;\n        default:\n          i.setToBlock(t.blocks[Math.max(s, r)], i.positions.END);\n      }\n    this.firstSelectedBlock = this.lastSelectedBlock = null;\n  }\n  /**\n   * Enables Cross Block Selection\n   *\n   * @param {MouseEvent} event - mouse down event\n   */\n  enableCrossBlockSelection(e) {\n    const { UI: t } = this.Editor;\n    b.isCollapsed || this.Editor.BlockSelection.clearSelection(e), t.nodes.redactor.contains(e.target) ? this.watchSelection(e) : this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * Change blocks selection state between passed two blocks.\n   *\n   * @param {Block} firstBlock - first block in range\n   * @param {Block} lastBlock - last block in range\n   */\n  toggleBlocksSelectedState(e, t) {\n    const { BlockManager: o, BlockSelection: i } = this.Editor, s = o.blocks.indexOf(e), r = o.blocks.indexOf(t), a = e.selected !== t.selected;\n    for (let l = Math.min(s, r); l <= Math.max(s, r); l++) {\n      const c = o.blocks[l];\n      c !== this.firstSelectedBlock && c !== (a ? e : t) && (o.blocks[l].selected = !o.blocks[l].selected, i.clearCache());\n    }\n  }\n}\nclass ca extends E {\n  constructor() {\n    super(...arguments), this.isStartedAtEditor = !1;\n  }\n  /**\n   * Toggle read-only state\n   *\n   * if state is true:\n   *  - disable all drag-n-drop event handlers\n   *\n   * if state is false:\n   *  - restore drag-n-drop event handlers\n   *\n   * @param {boolean} readOnlyEnabled - \"read only\" state\n   */\n  toggleReadOnly(e) {\n    e ? this.disableModuleBindings() : this.enableModuleBindings();\n  }\n  /**\n   * Add drag events listeners to editor zone\n   */\n  enableModuleBindings() {\n    const { UI: e } = this.Editor;\n    this.readOnlyMutableListeners.on(e.nodes.holder, \"drop\", async (t) => {\n      await this.processDrop(t);\n    }, !0), this.readOnlyMutableListeners.on(e.nodes.holder, \"dragstart\", () => {\n      this.processDragStart();\n    }), this.readOnlyMutableListeners.on(e.nodes.holder, \"dragover\", (t) => {\n      this.processDragOver(t);\n    }, !0);\n  }\n  /**\n   * Unbind drag-n-drop event handlers\n   */\n  disableModuleBindings() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Handle drop event\n   *\n   * @param {DragEvent} dropEvent - drop event\n   */\n  async processDrop(e) {\n    const {\n      BlockManager: t,\n      Paste: o,\n      Caret: i\n    } = this.Editor;\n    e.preventDefault(), t.blocks.forEach((r) => {\n      r.dropTarget = !1;\n    }), b.isAtEditor && !b.isCollapsed && this.isStartedAtEditor && document.execCommand(\"delete\"), this.isStartedAtEditor = !1;\n    const s = t.setCurrentBlockByChildNode(e.target);\n    if (s)\n      this.Editor.Caret.setToBlock(s, i.positions.END);\n    else {\n      const r = t.setCurrentBlockByChildNode(t.lastBlock.holder);\n      this.Editor.Caret.setToBlock(r, i.positions.END);\n    }\n    await o.processDataTransfer(e.dataTransfer, !0);\n  }\n  /**\n   * Handle drag start event\n   */\n  processDragStart() {\n    b.isAtEditor && !b.isCollapsed && (this.isStartedAtEditor = !0), this.Editor.InlineToolbar.close();\n  }\n  /**\n   * @param {DragEvent} dragEvent - drag event\n   */\n  processDragOver(e) {\n    e.preventDefault();\n  }\n}\nconst da = 180, ua = 400;\nclass ha extends E {\n  /**\n   * Prepare the module\n   *\n   * @param options - options used by the modification observer module\n   * @param options.config - Editor configuration object\n   * @param options.eventsDispatcher - common Editor event bus\n   */\n  constructor({ config: e, eventsDispatcher: t }) {\n    super({\n      config: e,\n      eventsDispatcher: t\n    }), this.disabled = !1, this.batchingTimeout = null, this.batchingOnChangeQueue = /* @__PURE__ */ new Map(), this.batchTime = ua, this.mutationObserver = new MutationObserver((o) => {\n      this.redactorChanged(o);\n    }), this.eventsDispatcher.on($o, (o) => {\n      this.particularBlockChanged(o.event);\n    }), this.eventsDispatcher.on(zo, () => {\n      this.disable();\n    }), this.eventsDispatcher.on(Uo, () => {\n      this.enable();\n    });\n  }\n  /**\n   * Enables onChange event\n   */\n  enable() {\n    this.mutationObserver.observe(\n      this.Editor.UI.nodes.redactor,\n      {\n        childList: !0,\n        subtree: !0,\n        characterData: !0,\n        attributes: !0\n      }\n    ), this.disabled = !1;\n  }\n  /**\n   * Disables onChange event\n   */\n  disable() {\n    this.mutationObserver.disconnect(), this.disabled = !0;\n  }\n  /**\n   * Call onChange event passed to Editor.js configuration\n   *\n   * @param event - some of our custom change events\n   */\n  particularBlockChanged(e) {\n    this.disabled || !A(this.config.onChange) || (this.batchingOnChangeQueue.set(`block:${e.detail.target.id}:event:${e.type}`, e), this.batchingTimeout && clearTimeout(this.batchingTimeout), this.batchingTimeout = setTimeout(() => {\n      let t;\n      this.batchingOnChangeQueue.size === 1 ? t = this.batchingOnChangeQueue.values().next().value : t = Array.from(this.batchingOnChangeQueue.values()), this.config.onChange && this.config.onChange(this.Editor.API.methods, t), this.batchingOnChangeQueue.clear();\n    }, this.batchTime));\n  }\n  /**\n   * Fired on every blocks wrapper dom change\n   *\n   * @param mutations - mutations happened\n   */\n  redactorChanged(e) {\n    this.eventsDispatcher.emit(ft, {\n      mutations: e\n    });\n  }\n}\nconst Rn = class Dn extends E {\n  constructor() {\n    super(...arguments), this.MIME_TYPE = \"application/x-editor-js\", this.toolsTags = {}, this.tagsByTool = {}, this.toolsPatterns = [], this.toolsFiles = {}, this.exceptionList = [], this.processTool = (e) => {\n      try {\n        const t = e.create({}, {}, !1);\n        if (e.pasteConfig === !1) {\n          this.exceptionList.push(e.name);\n          return;\n        }\n        if (!A(t.onPaste))\n          return;\n        this.getTagsConfig(e), this.getFilesConfig(e), this.getPatternsConfig(e);\n      } catch (t) {\n        S(\n          `Paste handling for «${e.name}» Tool hasn't been set up because of the error`,\n          \"warn\",\n          t\n        );\n      }\n    }, this.handlePasteEvent = async (e) => {\n      const { BlockManager: t, Toolbar: o } = this.Editor, i = t.setCurrentBlockByChildNode(e.target);\n      !i || this.isNativeBehaviour(e.target) && !e.clipboardData.types.includes(\"Files\") || i && this.exceptionList.includes(i.name) || (e.preventDefault(), this.processDataTransfer(e.clipboardData), o.close());\n    };\n  }\n  /**\n   * Set onPaste callback and collect tools` paste configurations\n   */\n  async prepare() {\n    this.processTools();\n  }\n  /**\n   * Set read-only state\n   *\n   * @param {boolean} readOnlyEnabled - read only flag value\n   */\n  toggleReadOnly(e) {\n    e ? this.unsetCallback() : this.setCallback();\n  }\n  /**\n   * Handle pasted or dropped data transfer object\n   *\n   * @param {DataTransfer} dataTransfer - pasted or dropped data transfer object\n   * @param {boolean} isDragNDrop - true if data transfer comes from drag'n'drop events\n   */\n  async processDataTransfer(e, t = !1) {\n    const { Tools: o } = this.Editor, i = e.types;\n    if ((i.includes ? i.includes(\"Files\") : i.contains(\"Files\")) && !V(this.toolsFiles)) {\n      await this.processFiles(e.files);\n      return;\n    }\n    const r = e.getData(this.MIME_TYPE), a = e.getData(\"text/plain\");\n    let l = e.getData(\"text/html\");\n    if (r)\n      try {\n        this.insertEditorJSData(JSON.parse(r));\n        return;\n      } catch {\n      }\n    t && a.trim() && l.trim() && (l = \"<p>\" + (l.trim() ? l : a) + \"</p>\");\n    const c = Object.keys(this.toolsTags).reduce((p, g) => (p[g.toLowerCase()] = this.toolsTags[g].sanitizationConfig ?? {}, p), {}), u = Object.assign({}, c, o.getAllInlineToolsSanitizeConfig(), { br: {} }), h = Z(l, u);\n    !h.trim() || h.trim() === a || !d.isHTMLString(h) ? await this.processText(a) : await this.processText(h, !0);\n  }\n  /**\n   * Process pasted text and divide them into Blocks\n   *\n   * @param {string} data - text to process. Can be HTML or plain.\n   * @param {boolean} isHTML - if passed string is HTML, this parameter should be true\n   */\n  async processText(e, t = !1) {\n    const { Caret: o, BlockManager: i } = this.Editor, s = t ? this.processHTML(e) : this.processPlain(e);\n    if (!s.length)\n      return;\n    if (s.length === 1) {\n      s[0].isBlock ? this.processSingleBlock(s.pop()) : this.processInlinePaste(s.pop());\n      return;\n    }\n    const a = i.currentBlock && i.currentBlock.tool.isDefault && i.currentBlock.isEmpty;\n    s.map(\n      async (l, c) => this.insertBlock(l, c === 0 && a)\n    ), i.currentBlock && o.setToBlock(i.currentBlock, o.positions.END);\n  }\n  /**\n   * Set onPaste callback handler\n   */\n  setCallback() {\n    this.listeners.on(this.Editor.UI.nodes.holder, \"paste\", this.handlePasteEvent);\n  }\n  /**\n   * Unset onPaste callback handler\n   */\n  unsetCallback() {\n    this.listeners.off(this.Editor.UI.nodes.holder, \"paste\", this.handlePasteEvent);\n  }\n  /**\n   * Get and process tool`s paste configs\n   */\n  processTools() {\n    const e = this.Editor.Tools.blockTools;\n    Array.from(e.values()).forEach(this.processTool);\n  }\n  /**\n   * Get tags name list from either tag name or sanitization config.\n   *\n   * @param {string | object} tagOrSanitizeConfig - tag name or sanitize config object.\n   * @returns {string[]} array of tags.\n   */\n  collectTagNames(e) {\n    return te(e) ? [e] : D(e) ? Object.keys(e) : [];\n  }\n  /**\n   * Get tags to substitute by Tool\n   *\n   * @param tool - BlockTool object\n   */\n  getTagsConfig(e) {\n    if (e.pasteConfig === !1)\n      return;\n    const t = e.pasteConfig.tags || [], o = [];\n    t.forEach((i) => {\n      const s = this.collectTagNames(i);\n      o.push(...s), s.forEach((r) => {\n        if (Object.prototype.hasOwnProperty.call(this.toolsTags, r)) {\n          S(\n            `Paste handler for «${e.name}» Tool on «${r}» tag is skipped because it is already used by «${this.toolsTags[r].tool.name}» Tool.`,\n            \"warn\"\n          );\n          return;\n        }\n        const a = D(i) ? i[r] : null;\n        this.toolsTags[r.toUpperCase()] = {\n          tool: e,\n          sanitizationConfig: a\n        };\n      });\n    }), this.tagsByTool[e.name] = o.map((i) => i.toUpperCase());\n  }\n  /**\n   * Get files` types and extensions to substitute by Tool\n   *\n   * @param tool - BlockTool object\n   */\n  getFilesConfig(e) {\n    if (e.pasteConfig === !1)\n      return;\n    const { files: t = {} } = e.pasteConfig;\n    let { extensions: o, mimeTypes: i } = t;\n    !o && !i || (o && !Array.isArray(o) && (S(`«extensions» property of the onDrop config for «${e.name}» Tool should be an array`), o = []), i && !Array.isArray(i) && (S(`«mimeTypes» property of the onDrop config for «${e.name}» Tool should be an array`), i = []), i && (i = i.filter((s) => ei(s) ? !0 : (S(`MIME type value «${s}» for the «${e.name}» Tool is not a valid MIME type`, \"warn\"), !1))), this.toolsFiles[e.name] = {\n      extensions: o || [],\n      mimeTypes: i || []\n    });\n  }\n  /**\n   * Get RegExp patterns to substitute by Tool\n   *\n   * @param tool - BlockTool object\n   */\n  getPatternsConfig(e) {\n    e.pasteConfig === !1 || !e.pasteConfig.patterns || V(e.pasteConfig.patterns) || Object.entries(e.pasteConfig.patterns).forEach(([t, o]) => {\n      o instanceof RegExp || S(\n        `Pattern ${o} for «${e.name}» Tool is skipped because it should be a Regexp instance.`,\n        \"warn\"\n      ), this.toolsPatterns.push({\n        key: t,\n        pattern: o,\n        tool: e\n      });\n    });\n  }\n  /**\n   * Check if browser behavior suits better\n   *\n   * @param {EventTarget} element - element where content has been pasted\n   * @returns {boolean}\n   */\n  isNativeBehaviour(e) {\n    return d.isNativeInput(e);\n  }\n  /**\n   * Get files from data transfer object and insert related Tools\n   *\n   * @param {FileList} items - pasted or dropped items\n   */\n  async processFiles(e) {\n    const { BlockManager: t } = this.Editor;\n    let o;\n    o = await Promise.all(\n      Array.from(e).map((r) => this.processFile(r))\n    ), o = o.filter((r) => !!r);\n    const s = t.currentBlock.tool.isDefault && t.currentBlock.isEmpty;\n    o.forEach(\n      (r, a) => {\n        t.paste(r.type, r.event, a === 0 && s);\n      }\n    );\n  }\n  /**\n   * Get information about file and find Tool to handle it\n   *\n   * @param {File} file - file to process\n   */\n  async processFile(e) {\n    const t = Jn(e), o = Object.entries(this.toolsFiles).find(([r, { mimeTypes: a, extensions: l }]) => {\n      const [c, u] = e.type.split(\"/\"), h = l.find((g) => g.toLowerCase() === t.toLowerCase()), p = a.find((g) => {\n        const [f, v] = g.split(\"/\");\n        return f === c && (v === u || v === \"*\");\n      });\n      return !!h || !!p;\n    });\n    if (!o)\n      return;\n    const [i] = o;\n    return {\n      event: this.composePasteEvent(\"file\", {\n        file: e\n      }),\n      type: i\n    };\n  }\n  /**\n   * Split HTML string to blocks and return it as array of Block data\n   *\n   * @param {string} innerHTML - html string to process\n   * @returns {PasteData[]}\n   */\n  processHTML(e) {\n    const { Tools: t } = this.Editor, o = d.make(\"DIV\");\n    return o.innerHTML = e, this.getNodes(o).map((s) => {\n      let r, a = t.defaultTool, l = !1;\n      switch (s.nodeType) {\n        case Node.DOCUMENT_FRAGMENT_NODE:\n          r = d.make(\"div\"), r.appendChild(s);\n          break;\n        case Node.ELEMENT_NODE:\n          r = s, l = !0, this.toolsTags[r.tagName] && (a = this.toolsTags[r.tagName].tool);\n          break;\n      }\n      const { tags: c } = a.pasteConfig || { tags: [] }, u = c.reduce((g, f) => (this.collectTagNames(f).forEach((O) => {\n        const T = D(f) ? f[O] : null;\n        g[O.toLowerCase()] = T || {};\n      }), g), {}), h = Object.assign({}, u, a.baseSanitizeConfig);\n      if (r.tagName.toLowerCase() === \"table\") {\n        const g = Z(r.outerHTML, h);\n        r = d.make(\"div\", void 0, {\n          innerHTML: g\n        }).firstChild;\n      } else\n        r.innerHTML = Z(r.innerHTML, h);\n      const p = this.composePasteEvent(\"tag\", {\n        data: r\n      });\n      return {\n        content: r,\n        isBlock: l,\n        tool: a.name,\n        event: p\n      };\n    }).filter((s) => {\n      const r = d.isEmpty(s.content), a = d.isSingleTag(s.content);\n      return !r || a;\n    });\n  }\n  /**\n   * Split plain text by new line symbols and return it as array of Block data\n   *\n   * @param {string} plain - string to process\n   * @returns {PasteData[]}\n   */\n  processPlain(e) {\n    const { defaultBlock: t } = this.config;\n    if (!e)\n      return [];\n    const o = t;\n    return e.split(/\\r?\\n/).filter((i) => i.trim()).map((i) => {\n      const s = d.make(\"div\");\n      s.textContent = i;\n      const r = this.composePasteEvent(\"tag\", {\n        data: s\n      });\n      return {\n        content: s,\n        tool: o,\n        isBlock: !1,\n        event: r\n      };\n    });\n  }\n  /**\n   * Process paste of single Block tool content\n   *\n   * @param {PasteData} dataToInsert - data of Block to insert\n   */\n  async processSingleBlock(e) {\n    const { Caret: t, BlockManager: o } = this.Editor, { currentBlock: i } = o;\n    if (!i || e.tool !== i.name || !d.containsOnlyInlineElements(e.content.innerHTML)) {\n      this.insertBlock(e, (i == null ? void 0 : i.tool.isDefault) && i.isEmpty);\n      return;\n    }\n    t.insertContentAtCaretPosition(e.content.innerHTML);\n  }\n  /**\n   * Process paste to single Block:\n   * 1. Find patterns` matches\n   * 2. Insert new block if it is not the same type as current one\n   * 3. Just insert text if there is no substitutions\n   *\n   * @param {PasteData} dataToInsert - data of Block to insert\n   */\n  async processInlinePaste(e) {\n    const { BlockManager: t, Caret: o } = this.Editor, { content: i } = e;\n    if (t.currentBlock && t.currentBlock.tool.isDefault && i.textContent.length < Dn.PATTERN_PROCESSING_MAX_LENGTH) {\n      const r = await this.processPattern(i.textContent);\n      if (r) {\n        const a = t.currentBlock && t.currentBlock.tool.isDefault && t.currentBlock.isEmpty, l = t.paste(r.tool, r.event, a);\n        o.setToBlock(l, o.positions.END);\n        return;\n      }\n    }\n    if (t.currentBlock && t.currentBlock.currentInput) {\n      const r = t.currentBlock.tool.baseSanitizeConfig;\n      document.execCommand(\n        \"insertHTML\",\n        !1,\n        Z(i.innerHTML, r)\n      );\n    } else\n      this.insertBlock(e);\n  }\n  /**\n   * Get patterns` matches\n   *\n   * @param {string} text - text to process\n   * @returns {Promise<{event: PasteEvent, tool: string}>}\n   */\n  async processPattern(e) {\n    const t = this.toolsPatterns.find((i) => {\n      const s = i.pattern.exec(e);\n      return s ? e === s.shift() : !1;\n    });\n    return t ? {\n      event: this.composePasteEvent(\"pattern\", {\n        key: t.key,\n        data: e\n      }),\n      tool: t.tool.name\n    } : void 0;\n  }\n  /**\n   * Insert pasted Block content to Editor\n   *\n   * @param {PasteData} data - data to insert\n   * @param {boolean} canReplaceCurrentBlock - if true and is current Block is empty, will replace current Block\n   * @returns {void}\n   */\n  insertBlock(e, t = !1) {\n    const { BlockManager: o, Caret: i } = this.Editor, { currentBlock: s } = o;\n    let r;\n    if (t && s && s.isEmpty) {\n      r = o.paste(e.tool, e.event, !0), i.setToBlock(r, i.positions.END);\n      return;\n    }\n    r = o.paste(e.tool, e.event), i.setToBlock(r, i.positions.END);\n  }\n  /**\n   * Insert data passed as application/x-editor-js JSON\n   *\n   * @param {Array} blocks — Blocks' data to insert\n   * @returns {void}\n   */\n  insertEditorJSData(e) {\n    const { BlockManager: t, Caret: o, Tools: i } = this.Editor;\n    yt(\n      e,\n      (r) => i.blockTools.get(r).sanitizeConfig\n    ).forEach(({ tool: r, data: a }, l) => {\n      let c = !1;\n      l === 0 && (c = t.currentBlock && t.currentBlock.tool.isDefault && t.currentBlock.isEmpty);\n      const u = t.insert({\n        tool: r,\n        data: a,\n        replace: c\n      });\n      o.setToBlock(u, o.positions.END);\n    });\n  }\n  /**\n   * Fetch nodes from Element node\n   *\n   * @param {Node} node - current node\n   * @param {Node[]} nodes - processed nodes\n   * @param {Node} destNode - destination node\n   */\n  processElementNode(e, t, o) {\n    const i = Object.keys(this.toolsTags), s = e, { tool: r } = this.toolsTags[s.tagName] || {}, a = this.tagsByTool[r == null ? void 0 : r.name] || [], l = i.includes(s.tagName), c = d.blockElements.includes(s.tagName.toLowerCase()), u = Array.from(s.children).some(\n      ({ tagName: p }) => i.includes(p) && !a.includes(p)\n    ), h = Array.from(s.children).some(\n      ({ tagName: p }) => d.blockElements.includes(p.toLowerCase())\n    );\n    if (!c && !l && !u)\n      return o.appendChild(s), [...t, o];\n    if (l && !u || c && !h && !u)\n      return [...t, o, s];\n  }\n  /**\n   * Recursively divide HTML string to two types of nodes:\n   * 1. Block element\n   * 2. Document Fragments contained text and markup tags like a, b, i etc.\n   *\n   * @param {Node} wrapper - wrapper of paster HTML content\n   * @returns {Node[]}\n   */\n  getNodes(e) {\n    const t = Array.from(e.childNodes);\n    let o;\n    const i = (s, r) => {\n      if (d.isEmpty(r) && !d.isSingleTag(r))\n        return s;\n      const a = s[s.length - 1];\n      let l = new DocumentFragment();\n      switch (a && d.isFragment(a) && (l = s.pop()), r.nodeType) {\n        case Node.ELEMENT_NODE:\n          if (o = this.processElementNode(r, s, l), o)\n            return o;\n          break;\n        case Node.TEXT_NODE:\n          return l.appendChild(r), [...s, l];\n        default:\n          return [...s, l];\n      }\n      return [...s, ...Array.from(r.childNodes).reduce(i, [])];\n    };\n    return t.reduce(i, []);\n  }\n  /**\n   * Compose paste event with passed type and detail\n   *\n   * @param {string} type - event type\n   * @param {PasteEventDetail} detail - event detail\n   */\n  composePasteEvent(e, t) {\n    return new CustomEvent(e, {\n      detail: t\n    });\n  }\n};\nRn.PATTERN_PROCESSING_MAX_LENGTH = 450;\nlet pa = Rn;\nclass fa extends E {\n  constructor() {\n    super(...arguments), this.toolsDontSupportReadOnly = [], this.readOnlyEnabled = !1;\n  }\n  /**\n   * Returns state of read only mode\n   */\n  get isEnabled() {\n    return this.readOnlyEnabled;\n  }\n  /**\n   * Set initial state\n   */\n  async prepare() {\n    const { Tools: e } = this.Editor, { blockTools: t } = e, o = [];\n    Array.from(t.entries()).forEach(([i, s]) => {\n      s.isReadOnlySupported || o.push(i);\n    }), this.toolsDontSupportReadOnly = o, this.config.readOnly && o.length > 0 && this.throwCriticalError(), this.toggle(this.config.readOnly, !0);\n  }\n  /**\n   * Set read-only mode or toggle current state\n   * Call all Modules `toggleReadOnly` method and re-render Editor\n   *\n   * @param state - (optional) read-only state or toggle\n   * @param isInitial - (optional) true when editor is initializing\n   */\n  async toggle(e = !this.readOnlyEnabled, t = !1) {\n    e && this.toolsDontSupportReadOnly.length > 0 && this.throwCriticalError();\n    const o = this.readOnlyEnabled;\n    this.readOnlyEnabled = e;\n    for (const s in this.Editor)\n      this.Editor[s].toggleReadOnly && this.Editor[s].toggleReadOnly(e);\n    if (o === e)\n      return this.readOnlyEnabled;\n    if (t)\n      return this.readOnlyEnabled;\n    this.Editor.ModificationsObserver.disable();\n    const i = await this.Editor.Saver.save();\n    return await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(i.blocks), this.Editor.ModificationsObserver.enable(), this.readOnlyEnabled;\n  }\n  /**\n   * Throws an error about tools which don't support read-only mode\n   */\n  throwCriticalError() {\n    throw new Ho(\n      `To enable read-only mode all connected tools should support it. Tools ${this.toolsDontSupportReadOnly.join(\", \")} don't support read-only mode.`\n    );\n  }\n}\nclass Be extends E {\n  constructor() {\n    super(...arguments), this.isRectSelectionActivated = !1, this.SCROLL_SPEED = 3, this.HEIGHT_OF_SCROLL_ZONE = 40, this.BOTTOM_SCROLL_ZONE = 1, this.TOP_SCROLL_ZONE = 2, this.MAIN_MOUSE_BUTTON = 0, this.mousedown = !1, this.isScrolling = !1, this.inScrollZone = null, this.startX = 0, this.startY = 0, this.mouseX = 0, this.mouseY = 0, this.stackOfSelected = [], this.listenerIds = [];\n  }\n  /**\n   * CSS classes for the Block\n   *\n   * @returns {{wrapper: string, content: string}}\n   */\n  static get CSS() {\n    return {\n      overlay: \"codex-editor-overlay\",\n      overlayContainer: \"codex-editor-overlay__container\",\n      rect: \"codex-editor-overlay__rectangle\",\n      topScrollZone: \"codex-editor-overlay__scroll-zone--top\",\n      bottomScrollZone: \"codex-editor-overlay__scroll-zone--bottom\"\n    };\n  }\n  /**\n   * Module Preparation\n   * Creating rect and hang handlers\n   */\n  prepare() {\n    this.enableModuleBindings();\n  }\n  /**\n   * Init rect params\n   *\n   * @param {number} pageX - X coord of mouse\n   * @param {number} pageY - Y coord of mouse\n   */\n  startSelection(e, t) {\n    const o = document.elementFromPoint(e - window.pageXOffset, t - window.pageYOffset);\n    o.closest(`.${this.Editor.Toolbar.CSS.toolbar}`) || (this.Editor.BlockSelection.allBlocksSelected = !1, this.clearSelection(), this.stackOfSelected = []);\n    const s = [\n      `.${R.CSS.content}`,\n      `.${this.Editor.Toolbar.CSS.toolbar}`,\n      `.${this.Editor.InlineToolbar.CSS.inlineToolbar}`\n    ], r = o.closest(\".\" + this.Editor.UI.CSS.editorWrapper), a = s.some((l) => !!o.closest(l));\n    !r || a || (this.mousedown = !0, this.startX = e, this.startY = t);\n  }\n  /**\n   * Clear all params to end selection\n   */\n  endSelection() {\n    this.mousedown = !1, this.startX = 0, this.startY = 0, this.overlayRectangle.style.display = \"none\";\n  }\n  /**\n   * is RectSelection Activated\n   */\n  isRectActivated() {\n    return this.isRectSelectionActivated;\n  }\n  /**\n   * Mark that selection is end\n   */\n  clearSelection() {\n    this.isRectSelectionActivated = !1;\n  }\n  /**\n   * Sets Module necessary event handlers\n   */\n  enableModuleBindings() {\n    const { container: e } = this.genHTML();\n    this.listeners.on(e, \"mousedown\", (t) => {\n      this.processMouseDown(t);\n    }, !1), this.listeners.on(document.body, \"mousemove\", dt((t) => {\n      this.processMouseMove(t);\n    }, 10), {\n      passive: !0\n    }), this.listeners.on(document.body, \"mouseleave\", () => {\n      this.processMouseLeave();\n    }), this.listeners.on(window, \"scroll\", dt((t) => {\n      this.processScroll(t);\n    }, 10), {\n      passive: !0\n    }), this.listeners.on(document.body, \"mouseup\", () => {\n      this.processMouseUp();\n    }, !1);\n  }\n  /**\n   * Handle mouse down events\n   *\n   * @param {MouseEvent} mouseEvent - mouse event payload\n   */\n  processMouseDown(e) {\n    if (e.button !== this.MAIN_MOUSE_BUTTON)\n      return;\n    e.target.closest(d.allInputsSelector) !== null || this.startSelection(e.pageX, e.pageY);\n  }\n  /**\n   * Handle mouse move events\n   *\n   * @param {MouseEvent} mouseEvent - mouse event payload\n   */\n  processMouseMove(e) {\n    this.changingRectangle(e), this.scrollByZones(e.clientY);\n  }\n  /**\n   * Handle mouse leave\n   */\n  processMouseLeave() {\n    this.clearSelection(), this.endSelection();\n  }\n  /**\n   * @param {MouseEvent} mouseEvent - mouse event payload\n   */\n  processScroll(e) {\n    this.changingRectangle(e);\n  }\n  /**\n   * Handle mouse up\n   */\n  processMouseUp() {\n    this.clearSelection(), this.endSelection();\n  }\n  /**\n   * Scroll If mouse in scroll zone\n   *\n   * @param {number} clientY - Y coord of mouse\n   */\n  scrollByZones(e) {\n    if (this.inScrollZone = null, e <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.TOP_SCROLL_ZONE), document.documentElement.clientHeight - e <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.BOTTOM_SCROLL_ZONE), !this.inScrollZone) {\n      this.isScrolling = !1;\n      return;\n    }\n    this.isScrolling || (this.scrollVertical(this.inScrollZone === this.TOP_SCROLL_ZONE ? -this.SCROLL_SPEED : this.SCROLL_SPEED), this.isScrolling = !0);\n  }\n  /**\n   * Generates required HTML elements\n   *\n   * @returns {Object<string, Element>}\n   */\n  genHTML() {\n    const { UI: e } = this.Editor, t = e.nodes.holder.querySelector(\".\" + e.CSS.editorWrapper), o = d.make(\"div\", Be.CSS.overlay, {}), i = d.make(\"div\", Be.CSS.overlayContainer, {}), s = d.make(\"div\", Be.CSS.rect, {});\n    return i.appendChild(s), o.appendChild(i), t.appendChild(o), this.overlayRectangle = s, {\n      container: t,\n      overlay: o\n    };\n  }\n  /**\n   * Activates scrolling if blockSelection is active and mouse is in scroll zone\n   *\n   * @param {number} speed - speed of scrolling\n   */\n  scrollVertical(e) {\n    if (!(this.inScrollZone && this.mousedown))\n      return;\n    const t = window.pageYOffset;\n    window.scrollBy(0, e), this.mouseY += window.pageYOffset - t, setTimeout(() => {\n      this.scrollVertical(e);\n    }, 0);\n  }\n  /**\n   * Handles the change in the rectangle and its effect\n   *\n   * @param {MouseEvent} event - mouse event\n   */\n  changingRectangle(e) {\n    if (!this.mousedown)\n      return;\n    e.pageY !== void 0 && (this.mouseX = e.pageX, this.mouseY = e.pageY);\n    const { rightPos: t, leftPos: o, index: i } = this.genInfoForMouseSelection(), s = this.startX > t && this.mouseX > t, r = this.startX < o && this.mouseX < o;\n    this.rectCrossesBlocks = !(s || r), this.isRectSelectionActivated || (this.rectCrossesBlocks = !1, this.isRectSelectionActivated = !0, this.shrinkRectangleToPoint(), this.overlayRectangle.style.display = \"block\"), this.updateRectangleSize(), this.Editor.Toolbar.close(), i !== void 0 && (this.trySelectNextBlock(i), this.inverseSelection(), b.get().removeAllRanges());\n  }\n  /**\n   * Shrink rect to singular point\n   */\n  shrinkRectangleToPoint() {\n    this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`;\n  }\n  /**\n   * Select or unselect all of blocks in array if rect is out or in selectable area\n   */\n  inverseSelection() {\n    const t = this.Editor.BlockManager.getBlockByIndex(this.stackOfSelected[0]).selected;\n    if (this.rectCrossesBlocks && !t)\n      for (const o of this.stackOfSelected)\n        this.Editor.BlockSelection.selectBlockByIndex(o);\n    if (!this.rectCrossesBlocks && t)\n      for (const o of this.stackOfSelected)\n        this.Editor.BlockSelection.unSelectBlockByIndex(o);\n  }\n  /**\n   * Updates size of rectangle\n   */\n  updateRectangleSize() {\n    this.mouseY >= this.startY ? (this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.mouseY - window.pageYOffset}px`) : (this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.top = `${this.mouseY - window.pageYOffset}px`), this.mouseX >= this.startX ? (this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.mouseX - window.pageXOffset}px`) : (this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.left = `${this.mouseX - window.pageXOffset}px`);\n  }\n  /**\n   * Collects information needed to determine the behavior of the rectangle\n   *\n   * @returns {object} index - index next Block, leftPos - start of left border of Block, rightPos - right border\n   */\n  genInfoForMouseSelection() {\n    const t = document.body.offsetWidth / 2, o = this.mouseY - window.pageYOffset, i = document.elementFromPoint(t, o), s = this.Editor.BlockManager.getBlockByChildNode(i);\n    let r;\n    s !== void 0 && (r = this.Editor.BlockManager.blocks.findIndex((h) => h.holder === s.holder));\n    const a = this.Editor.BlockManager.lastBlock.holder.querySelector(\".\" + R.CSS.content), l = Number.parseInt(window.getComputedStyle(a).width, 10) / 2, c = t - l, u = t + l;\n    return {\n      index: r,\n      leftPos: c,\n      rightPos: u\n    };\n  }\n  /**\n   * Select block with index index\n   *\n   * @param index - index of block in redactor\n   */\n  addBlockInSelection(e) {\n    this.rectCrossesBlocks && this.Editor.BlockSelection.selectBlockByIndex(e), this.stackOfSelected.push(e);\n  }\n  /**\n   * Adds a block to the selection and determines which blocks should be selected\n   *\n   * @param {object} index - index of new block in the reactor\n   */\n  trySelectNextBlock(e) {\n    const t = this.stackOfSelected[this.stackOfSelected.length - 1] === e, o = this.stackOfSelected.length, i = 1, s = -1, r = 0;\n    if (t)\n      return;\n    const a = this.stackOfSelected[o - 1] - this.stackOfSelected[o - 2] > 0;\n    let l = r;\n    o > 1 && (l = a ? i : s);\n    const c = e > this.stackOfSelected[o - 1] && l === i, u = e < this.stackOfSelected[o - 1] && l === s, p = !(c || u || l === r);\n    if (!p && (e > this.stackOfSelected[o - 1] || this.stackOfSelected[o - 1] === void 0)) {\n      let v = this.stackOfSelected[o - 1] + 1 || e;\n      for (v; v <= e; v++)\n        this.addBlockInSelection(v);\n      return;\n    }\n    if (!p && e < this.stackOfSelected[o - 1]) {\n      for (let v = this.stackOfSelected[o - 1] - 1; v >= e; v--)\n        this.addBlockInSelection(v);\n      return;\n    }\n    if (!p)\n      return;\n    let g = o - 1, f;\n    for (e > this.stackOfSelected[o - 1] ? f = () => e > this.stackOfSelected[g] : f = () => e < this.stackOfSelected[g]; f(); )\n      this.rectCrossesBlocks && this.Editor.BlockSelection.unSelectBlockByIndex(this.stackOfSelected[g]), this.stackOfSelected.pop(), g--;\n  }\n}\nclass ga extends E {\n  /**\n   * Renders passed blocks as one batch\n   *\n   * @param blocksData - blocks to render\n   */\n  async render(e) {\n    return new Promise((t) => {\n      const { Tools: o, BlockManager: i } = this.Editor;\n      if (e.length === 0)\n        i.insert();\n      else {\n        const s = e.map(({ type: r, data: a, tunes: l, id: c }) => {\n          o.available.has(r) === !1 && (X(`Tool «${r}» is not found. Check 'tools' property at the Editor.js config.`, \"warn\"), a = this.composeStubDataForTool(r, a, c), r = o.stubTool);\n          let u;\n          try {\n            u = i.composeBlock({\n              id: c,\n              tool: r,\n              data: a,\n              tunes: l\n            });\n          } catch (h) {\n            S(`Block «${r}» skipped because of plugins error`, \"error\", {\n              data: a,\n              error: h\n            }), a = this.composeStubDataForTool(r, a, c), r = o.stubTool, u = i.composeBlock({\n              id: c,\n              tool: r,\n              data: a,\n              tunes: l\n            });\n          }\n          return u;\n        });\n        i.insertMany(s);\n      }\n      window.requestIdleCallback(() => {\n        t();\n      }, { timeout: 2e3 });\n    });\n  }\n  /**\n   * Create data for the Stub Tool that will be used instead of unavailable tool\n   *\n   * @param tool - unavailable tool name to stub\n   * @param data - data of unavailable block\n   * @param [id] - id of unavailable block\n   */\n  composeStubDataForTool(e, t, o) {\n    const { Tools: i } = this.Editor;\n    let s = e;\n    if (i.unavailable.has(e)) {\n      const r = i.unavailable.get(e).toolbox;\n      r !== void 0 && r[0].title !== void 0 && (s = r[0].title);\n    }\n    return {\n      savedData: {\n        id: o,\n        type: e,\n        data: t\n      },\n      title: s\n    };\n  }\n}\nclass ma extends E {\n  /**\n   * Composes new chain of Promises to fire them alternatelly\n   *\n   * @returns {OutputData}\n   */\n  async save() {\n    const { BlockManager: e, Tools: t } = this.Editor, o = e.blocks, i = [];\n    try {\n      o.forEach((a) => {\n        i.push(this.getSavedData(a));\n      });\n      const s = await Promise.all(i), r = await yt(s, (a) => t.blockTools.get(a).sanitizeConfig);\n      return this.makeOutput(r);\n    } catch (s) {\n      X(\"Saving failed due to the Error %o\", \"error\", s);\n    }\n  }\n  /**\n   * Saves and validates\n   *\n   * @param {Block} block - Editor's Tool\n   * @returns {ValidatedData} - Tool's validated data\n   */\n  async getSavedData(e) {\n    const t = await e.save(), o = t && await e.validate(t.data);\n    return {\n      ...t,\n      isValid: o\n    };\n  }\n  /**\n   * Creates output object with saved data, time and version of editor\n   *\n   * @param {ValidatedData} allExtractedData - data extracted from Blocks\n   * @returns {OutputData}\n   */\n  makeOutput(e) {\n    const t = [];\n    return e.forEach(({ id: o, tool: i, data: s, tunes: r, isValid: a }) => {\n      if (!a) {\n        S(`Block «${i}» skipped because saved data is invalid`);\n        return;\n      }\n      if (i === this.Editor.Tools.stubTool) {\n        t.push(s);\n        return;\n      }\n      const l = {\n        id: o,\n        type: i,\n        data: s,\n        ...!V(r) && {\n          tunes: r\n        }\n      };\n      t.push(l);\n    }), {\n      time: +/* @__PURE__ */ new Date(),\n      blocks: t,\n      version: \"2.31.0-rc.7\"\n    };\n  }\n}\n(function() {\n  try {\n    if (typeof document < \"u\") {\n      var n = document.createElement(\"style\");\n      n.appendChild(document.createTextNode(\".ce-paragraph{line-height:1.6em;outline:none}.ce-block:only-of-type .ce-paragraph[data-placeholder-active]:empty:before,.ce-block:only-of-type .ce-paragraph[data-placeholder-active][data-empty=true]:before{content:attr(data-placeholder-active)}.ce-paragraph p:first-of-type{margin-top:0}.ce-paragraph p:last-of-type{margin-bottom:0}\")), document.head.appendChild(n);\n    }\n  } catch (e) {\n    console.error(\"vite-plugin-css-injected-by-js\", e);\n  }\n})();\nconst ba = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 9V7.2C8 7.08954 8.08954 7 8.2 7L12 7M16 9V7.2C16 7.08954 15.9105 7 15.8 7L12 7M12 7L12 17M12 17H10M12 17H14\"/></svg>';\nfunction va(n) {\n  const e = document.createElement(\"div\");\n  e.innerHTML = n.trim();\n  const t = document.createDocumentFragment();\n  return t.append(...Array.from(e.childNodes)), t;\n}\n/**\n * Base Paragraph Block for the Editor.js.\n * Represents a regular text block\n *\n * @author CodeX (team@codex.so)\n * @copyright CodeX 2018\n * @license The MIT License (MIT)\n */\nclass fo {\n  /**\n   * Default placeholder for Paragraph Tool\n   *\n   * @returns {string}\n   * @class\n   */\n  static get DEFAULT_PLACEHOLDER() {\n    return \"\";\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {object} params - constructor params\n   * @param {ParagraphData} params.data - previously saved data\n   * @param {ParagraphConfig} params.config - user config for Tool\n   * @param {object} params.api - editor.js api\n   * @param {boolean} readOnly - read only mode flag\n   */\n  constructor({ data: e, config: t, api: o, readOnly: i }) {\n    this.api = o, this.readOnly = i, this._CSS = {\n      block: this.api.styles.block,\n      wrapper: \"ce-paragraph\"\n    }, this.readOnly || (this.onKeyUp = this.onKeyUp.bind(this)), this._placeholder = t.placeholder ? t.placeholder : fo.DEFAULT_PLACEHOLDER, this._data = e ?? {}, this._element = null, this._preserveBlank = t.preserveBlank ?? !1;\n  }\n  /**\n   * Check if text content is empty and set empty string to inner html.\n   * We need this because some browsers (e.g. Safari) insert <br> into empty contenteditanle elements\n   *\n   * @param {KeyboardEvent} e - key up event\n   */\n  onKeyUp(e) {\n    if (e.code !== \"Backspace\" && e.code !== \"Delete\" || !this._element)\n      return;\n    const { textContent: t } = this._element;\n    t === \"\" && (this._element.innerHTML = \"\");\n  }\n  /**\n   * Create Tool's view\n   *\n   * @returns {HTMLDivElement}\n   * @private\n   */\n  drawView() {\n    const e = document.createElement(\"DIV\");\n    return e.classList.add(this._CSS.wrapper, this._CSS.block), e.contentEditable = \"false\", e.dataset.placeholderActive = this.api.i18n.t(this._placeholder), this._data.text && (e.innerHTML = this._data.text), this.readOnly || (e.contentEditable = \"true\", e.addEventListener(\"keyup\", this.onKeyUp)), e;\n  }\n  /**\n   * Return Tool's view\n   *\n   * @returns {HTMLDivElement}\n   */\n  render() {\n    return this._element = this.drawView(), this._element;\n  }\n  /**\n   * Method that specified how to merge two Text blocks.\n   * Called by Editor.js by backspace at the beginning of the Block\n   *\n   * @param {ParagraphData} data\n   * @public\n   */\n  merge(e) {\n    if (!this._element)\n      return;\n    this._data.text += e.text;\n    const t = va(e.text);\n    this._element.appendChild(t), this._element.normalize();\n  }\n  /**\n   * Validate Paragraph block data:\n   * - check for emptiness\n   *\n   * @param {ParagraphData} savedData — data received after saving\n   * @returns {boolean} false if saved data is not correct, otherwise true\n   * @public\n   */\n  validate(e) {\n    return !(e.text.trim() === \"\" && !this._preserveBlank);\n  }\n  /**\n   * Extract Tool's data from the view\n   *\n   * @param {HTMLDivElement} toolsContent - Paragraph tools rendered view\n   * @returns {ParagraphData} - saved data\n   * @public\n   */\n  save(e) {\n    return {\n      text: e.innerHTML\n    };\n  }\n  /**\n   * On paste callback fired from Editor.\n   *\n   * @param {HTMLPasteEvent} event - event with pasted data\n   */\n  onPaste(e) {\n    const t = {\n      text: e.detail.data.innerHTML\n    };\n    this._data = t, window.requestAnimationFrame(() => {\n      this._element && (this._element.innerHTML = this._data.text || \"\");\n    });\n  }\n  /**\n   * Enable Conversion Toolbar. Paragraph can be converted to/from other tools\n   * @returns {ConversionConfig}\n   */\n  static get conversionConfig() {\n    return {\n      export: \"text\",\n      // to convert Paragraph to other block, use 'text' property of saved data\n      import: \"text\"\n      // to covert other block's exported string to Paragraph, fill 'text' property of tool data\n    };\n  }\n  /**\n   * Sanitizer rules\n   * @returns {SanitizerConfig} - Edtior.js sanitizer config\n   */\n  static get sanitize() {\n    return {\n      text: {\n        br: !0\n      }\n    };\n  }\n  /**\n   * Returns true to notify the core that read-only mode is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Used by Editor paste handling API.\n   * Provides configuration to handle P tags.\n   *\n   * @returns {PasteConfig} - Paragraph Paste Setting\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"P\"]\n    };\n  }\n  /**\n   * Icon and title for displaying at the Toolbox\n   *\n   * @returns {ToolboxConfig} - Paragraph Toolbox Setting\n   */\n  static get toolbox() {\n    return {\n      icon: ba,\n      title: \"Text\"\n    };\n  }\n}\nclass go {\n  constructor() {\n    this.commandName = \"bold\";\n  }\n  /**\n   * Sanitizer Rule\n   * Leave <b> tags\n   *\n   * @returns {object}\n   */\n  static get sanitize() {\n    return {\n      b: {}\n    };\n  }\n  /**\n   * Create button for Inline Toolbar\n   */\n  render() {\n    return {\n      icon: Ki,\n      name: \"bold\",\n      onActivate: () => {\n        document.execCommand(this.commandName);\n      },\n      isActive: () => document.queryCommandState(this.commandName)\n    };\n  }\n  /**\n   * Set a shortcut\n   *\n   * @returns {boolean}\n   */\n  get shortcut() {\n    return \"CMD+B\";\n  }\n}\ngo.isInline = !0;\ngo.title = \"Bold\";\nclass mo {\n  constructor() {\n    this.commandName = \"italic\", this.CSS = {\n      button: \"ce-inline-tool\",\n      buttonActive: \"ce-inline-tool--active\",\n      buttonModifier: \"ce-inline-tool--italic\"\n    }, this.nodes = {\n      button: null\n    };\n  }\n  /**\n   * Sanitizer Rule\n   * Leave <i> tags\n   *\n   * @returns {object}\n   */\n  static get sanitize() {\n    return {\n      i: {}\n    };\n  }\n  /**\n   * Create button for Inline Toolbar\n   */\n  render() {\n    return this.nodes.button = document.createElement(\"button\"), this.nodes.button.type = \"button\", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = Ji, this.nodes.button;\n  }\n  /**\n   * Wrap range with <i> tag\n   */\n  surround() {\n    document.execCommand(this.commandName);\n  }\n  /**\n   * Check selection and set activated state to button if there are <i> tag\n   */\n  checkState() {\n    const e = document.queryCommandState(this.commandName);\n    return this.nodes.button.classList.toggle(this.CSS.buttonActive, e), e;\n  }\n  /**\n   * Set a shortcut\n   */\n  get shortcut() {\n    return \"CMD+I\";\n  }\n}\nmo.isInline = !0;\nmo.title = \"Italic\";\nclass bo {\n  /**\n   * @param api - Editor.js API\n   */\n  constructor({ api: e }) {\n    this.commandLink = \"createLink\", this.commandUnlink = \"unlink\", this.ENTER_KEY = 13, this.CSS = {\n      button: \"ce-inline-tool\",\n      buttonActive: \"ce-inline-tool--active\",\n      buttonModifier: \"ce-inline-tool--link\",\n      buttonUnlink: \"ce-inline-tool--unlink\",\n      input: \"ce-inline-tool-input\",\n      inputShowed: \"ce-inline-tool-input--showed\"\n    }, this.nodes = {\n      button: null,\n      input: null\n    }, this.inputOpened = !1, this.toolbar = e.toolbar, this.inlineToolbar = e.inlineToolbar, this.notifier = e.notifier, this.i18n = e.i18n, this.selection = new b();\n  }\n  /**\n   * Sanitizer Rule\n   * Leave <a> tags\n   *\n   * @returns {object}\n   */\n  static get sanitize() {\n    return {\n      a: {\n        href: !0,\n        target: \"_blank\",\n        rel: \"nofollow\"\n      }\n    };\n  }\n  /**\n   * Create button for Inline Toolbar\n   */\n  render() {\n    return this.nodes.button = document.createElement(\"button\"), this.nodes.button.type = \"button\", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = Co, this.nodes.button;\n  }\n  /**\n   * Input for the link\n   */\n  renderActions() {\n    return this.nodes.input = document.createElement(\"input\"), this.nodes.input.placeholder = this.i18n.t(\"Add a link\"), this.nodes.input.enterKeyHint = \"done\", this.nodes.input.classList.add(this.CSS.input), this.nodes.input.addEventListener(\"keydown\", (e) => {\n      e.keyCode === this.ENTER_KEY && this.enterPressed(e);\n    }), this.nodes.input;\n  }\n  /**\n   * Handle clicks on the Inline Toolbar icon\n   *\n   * @param {Range} range - range to wrap with link\n   */\n  surround(e) {\n    if (e) {\n      this.inputOpened ? (this.selection.restore(), this.selection.removeFakeBackground()) : (this.selection.setFakeBackground(), this.selection.save());\n      const t = this.selection.findParentTag(\"A\");\n      if (t) {\n        this.selection.expandToTag(t), this.unlink(), this.closeActions(), this.checkState(), this.toolbar.close();\n        return;\n      }\n    }\n    this.toggleActions();\n  }\n  /**\n   * Check selection and set activated state to button if there are <a> tag\n   */\n  checkState() {\n    const e = this.selection.findParentTag(\"A\");\n    if (e) {\n      this.nodes.button.innerHTML = ns, this.nodes.button.classList.add(this.CSS.buttonUnlink), this.nodes.button.classList.add(this.CSS.buttonActive), this.openActions();\n      const t = e.getAttribute(\"href\");\n      this.nodes.input.value = t !== \"null\" ? t : \"\", this.selection.save();\n    } else\n      this.nodes.button.innerHTML = Co, this.nodes.button.classList.remove(this.CSS.buttonUnlink), this.nodes.button.classList.remove(this.CSS.buttonActive);\n    return !!e;\n  }\n  /**\n   * Function called with Inline Toolbar closing\n   */\n  clear() {\n    this.closeActions();\n  }\n  /**\n   * Set a shortcut\n   */\n  get shortcut() {\n    return \"CMD+K\";\n  }\n  /**\n   * Show/close link input\n   */\n  toggleActions() {\n    this.inputOpened ? this.closeActions(!1) : this.openActions(!0);\n  }\n  /**\n   * @param {boolean} needFocus - on link creation we need to focus input. On editing - nope.\n   */\n  openActions(e = !1) {\n    this.nodes.input.classList.add(this.CSS.inputShowed), e && this.nodes.input.focus(), this.inputOpened = !0;\n  }\n  /**\n   * Close input\n   *\n   * @param {boolean} clearSavedSelection — we don't need to clear saved selection\n   *                                        on toggle-clicks on the icon of opened Toolbar\n   */\n  closeActions(e = !0) {\n    if (this.selection.isFakeBackgroundEnabled) {\n      const t = new b();\n      t.save(), this.selection.restore(), this.selection.removeFakeBackground(), t.restore();\n    }\n    this.nodes.input.classList.remove(this.CSS.inputShowed), this.nodes.input.value = \"\", e && this.selection.clearSaved(), this.inputOpened = !1;\n  }\n  /**\n   * Enter pressed on input\n   *\n   * @param {KeyboardEvent} event - enter keydown event\n   */\n  enterPressed(e) {\n    let t = this.nodes.input.value || \"\";\n    if (!t.trim()) {\n      this.selection.restore(), this.unlink(), e.preventDefault(), this.closeActions();\n      return;\n    }\n    if (!this.validateURL(t)) {\n      this.notifier.show({\n        message: \"Pasted link is not valid.\",\n        style: \"error\"\n      }), S(\"Incorrect Link pasted\", \"warn\", t);\n      return;\n    }\n    t = this.prepareLink(t), this.selection.restore(), this.selection.removeFakeBackground(), this.insertLink(t), e.preventDefault(), e.stopPropagation(), e.stopImmediatePropagation(), this.selection.collapseToEnd(), this.inlineToolbar.close();\n  }\n  /**\n   * Detects if passed string is URL\n   *\n   * @param {string} str - string to validate\n   * @returns {boolean}\n   */\n  validateURL(e) {\n    return !/\\s/.test(e);\n  }\n  /**\n   * Process link before injection\n   * - sanitize\n   * - add protocol for links like 'google.com'\n   *\n   * @param {string} link - raw user input\n   */\n  prepareLink(e) {\n    return e = e.trim(), e = this.addProtocol(e), e;\n  }\n  /**\n   * Add 'http' protocol to the links like 'vc.ru', 'google.com'\n   *\n   * @param {string} link - string to process\n   */\n  addProtocol(e) {\n    if (/^(\\w+):(\\/\\/)?/.test(e))\n      return e;\n    const t = /^\\/[^/\\s]/.test(e), o = e.substring(0, 1) === \"#\", i = /^\\/\\/[^/\\s]/.test(e);\n    return !t && !o && !i && (e = \"http://\" + e), e;\n  }\n  /**\n   * Inserts <a> tag with \"href\"\n   *\n   * @param {string} link - \"href\" value\n   */\n  insertLink(e) {\n    const t = this.selection.findParentTag(\"A\");\n    t && this.selection.expandToTag(t), document.execCommand(this.commandLink, !1, e);\n  }\n  /**\n   * Removes <a> tag\n   */\n  unlink() {\n    document.execCommand(this.commandUnlink);\n  }\n}\nbo.isInline = !0;\nbo.title = \"Link\";\nclass Fn {\n  /**\n   * @param api - Editor.js API\n   */\n  constructor({ api: e }) {\n    this.i18nAPI = e.i18n, this.blocksAPI = e.blocks, this.selectionAPI = e.selection, this.toolsAPI = e.tools, this.caretAPI = e.caret;\n  }\n  /**\n   * Returns tool's UI config\n   */\n  async render() {\n    const e = b.get(), t = this.blocksAPI.getBlockByElement(e.anchorNode);\n    if (t === void 0)\n      return [];\n    const o = this.toolsAPI.getBlockTools(), i = await Yo(t, o);\n    if (i.length === 0)\n      return [];\n    const s = i.reduce((c, u) => {\n      var h;\n      return (h = u.toolbox) == null || h.forEach((p) => {\n        c.push({\n          icon: p.icon,\n          title: z.t(K.toolNames, p.title),\n          name: u.name,\n          closeOnActivate: !0,\n          onActivate: async () => {\n            const g = await this.blocksAPI.convert(t.id, u.name, p.data);\n            this.caretAPI.setToBlock(g, \"end\");\n          }\n        });\n      }), c;\n    }, []), r = await t.getActiveToolboxEntry(), a = r !== void 0 ? r.icon : Go, l = !be();\n    return {\n      icon: a,\n      name: \"convert-to\",\n      hint: {\n        title: this.i18nAPI.t(\"Convert to\")\n      },\n      children: {\n        searchable: l,\n        items: s,\n        onOpen: () => {\n          l && (this.selectionAPI.setFakeBackground(), this.selectionAPI.save());\n        },\n        onClose: () => {\n          l && (this.selectionAPI.restore(), this.selectionAPI.removeFakeBackground());\n        }\n      }\n    };\n  }\n}\nFn.isInline = !0;\nclass jn {\n  /**\n   * @param options - constructor options\n   * @param options.data - stub tool data\n   * @param options.api - Editor.js API\n   */\n  constructor({ data: e, api: t }) {\n    this.CSS = {\n      wrapper: \"ce-stub\",\n      info: \"ce-stub__info\",\n      title: \"ce-stub__title\",\n      subtitle: \"ce-stub__subtitle\"\n    }, this.api = t, this.title = e.title || this.api.i18n.t(\"Error\"), this.subtitle = this.api.i18n.t(\"The block can not be displayed correctly.\"), this.savedData = e.savedData, this.wrapper = this.make();\n  }\n  /**\n   * Returns stub holder\n   *\n   * @returns {HTMLElement}\n   */\n  render() {\n    return this.wrapper;\n  }\n  /**\n   * Return original Tool data\n   *\n   * @returns {BlockToolData}\n   */\n  save() {\n    return this.savedData;\n  }\n  /**\n   * Create Tool html markup\n   *\n   * @returns {HTMLElement}\n   */\n  make() {\n    const e = d.make(\"div\", this.CSS.wrapper), t = is, o = d.make(\"div\", this.CSS.info), i = d.make(\"div\", this.CSS.title, {\n      textContent: this.title\n    }), s = d.make(\"div\", this.CSS.subtitle, {\n      textContent: this.subtitle\n    });\n    return e.innerHTML = t, o.appendChild(i), o.appendChild(s), e.appendChild(o), e;\n  }\n}\njn.isReadOnlySupported = !0;\nclass ka extends Tt {\n  constructor() {\n    super(...arguments), this.type = ae.Inline;\n  }\n  /**\n   * Returns title for Inline Tool if specified by user\n   */\n  get title() {\n    return this.constructable[We.Title];\n  }\n  /**\n   * Constructs new InlineTool instance from constructable\n   */\n  create() {\n    return new this.constructable({\n      api: this.api,\n      config: this.settings\n    });\n  }\n  /**\n   * Allows inline tool to be available in read-only mode\n   * Can be used, for example, by comments tool\n   */\n  get isReadOnlySupported() {\n    return this.constructable[We.IsReadOnlySupported] ?? !1;\n  }\n}\nclass ya extends Tt {\n  constructor() {\n    super(...arguments), this.type = ae.Tune;\n  }\n  /**\n   * Constructs new BlockTune instance from constructable\n   *\n   * @param data - Tune data\n   * @param block - Block API object\n   */\n  create(e, t) {\n    return new this.constructable({\n      api: this.api,\n      config: this.settings,\n      block: t,\n      data: e\n    });\n  }\n}\nclass j extends Map {\n  /**\n   * Returns Block Tools collection\n   */\n  get blockTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isBlock());\n    return new j(e);\n  }\n  /**\n   * Returns Inline Tools collection\n   */\n  get inlineTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isInline());\n    return new j(e);\n  }\n  /**\n   * Returns Block Tunes collection\n   */\n  get blockTunes() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isTune());\n    return new j(e);\n  }\n  /**\n   * Returns internal Tools collection\n   */\n  get internalTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => t.isInternal);\n    return new j(e);\n  }\n  /**\n   * Returns Tools collection provided by user\n   */\n  get externalTools() {\n    const e = Array.from(this.entries()).filter(([, t]) => !t.isInternal);\n    return new j(e);\n  }\n}\nvar wa = Object.defineProperty, Ea = Object.getOwnPropertyDescriptor, Hn = (n, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? Ea(e, t) : e, s = n.length - 1, r; s >= 0; s--)\n    (r = n[s]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && wa(e, t, i), i;\n};\nclass vo extends Tt {\n  constructor() {\n    super(...arguments), this.type = ae.Block, this.inlineTools = new j(), this.tunes = new j();\n  }\n  /**\n   * Creates new Tool instance\n   *\n   * @param data - Tool data\n   * @param block - BlockAPI for current Block\n   * @param readOnly - True if Editor is in read-only mode\n   */\n  create(e, t, o) {\n    return new this.constructable({\n      data: e,\n      block: t,\n      readOnly: o,\n      api: this.api,\n      config: this.settings\n    });\n  }\n  /**\n   * Returns true if read-only mode is supported by Tool\n   */\n  get isReadOnlySupported() {\n    return this.constructable[pe.IsReadOnlySupported] === !0;\n  }\n  /**\n   * Returns true if Tool supports linebreaks\n   */\n  get isLineBreaksEnabled() {\n    return this.constructable[pe.IsEnabledLineBreaks];\n  }\n  /**\n   * Returns Tool toolbox configuration (internal or user-specified).\n   *\n   * Merges internal and user-defined toolbox configs based on the following rules:\n   *\n   * - If both internal and user-defined toolbox configs are arrays their items are merged.\n   * Length of the second one is kept.\n   *\n   * - If both are objects their properties are merged.\n   *\n   * - If one is an object and another is an array than internal config is replaced with user-defined\n   * config. This is made to allow user to override default tool's toolbox representation (single/multiple entries)\n   */\n  get toolbox() {\n    const e = this.constructable[pe.Toolbox], t = this.config[Pe.Toolbox];\n    if (!V(e) && t !== !1)\n      return t ? Array.isArray(e) ? Array.isArray(t) ? t.map((o, i) => {\n        const s = e[i];\n        return s ? {\n          ...s,\n          ...o\n        } : o;\n      }) : [t] : Array.isArray(t) ? t : [\n        {\n          ...e,\n          ...t\n        }\n      ] : Array.isArray(e) ? e : [e];\n  }\n  /**\n   * Returns Tool conversion configuration\n   */\n  get conversionConfig() {\n    return this.constructable[pe.ConversionConfig];\n  }\n  /**\n   * Returns enabled inline tools for Tool\n   */\n  get enabledInlineTools() {\n    return this.config[Pe.EnabledInlineTools] || !1;\n  }\n  /**\n   * Returns enabled tunes for Tool\n   */\n  get enabledBlockTunes() {\n    return this.config[Pe.EnabledBlockTunes];\n  }\n  /**\n   * Returns Tool paste configuration\n   */\n  get pasteConfig() {\n    return this.constructable[pe.PasteConfig] ?? {};\n  }\n  get sanitizeConfig() {\n    const e = super.sanitizeConfig, t = this.baseSanitizeConfig;\n    if (V(e))\n      return t;\n    const o = {};\n    for (const i in e)\n      if (Object.prototype.hasOwnProperty.call(e, i)) {\n        const s = e[i];\n        D(s) ? o[i] = Object.assign({}, t, s) : o[i] = s;\n      }\n    return o;\n  }\n  get baseSanitizeConfig() {\n    const e = {};\n    return Array.from(this.inlineTools.values()).forEach((t) => Object.assign(e, t.sanitizeConfig)), Array.from(this.tunes.values()).forEach((t) => Object.assign(e, t.sanitizeConfig)), e;\n  }\n}\nHn([\n  me\n], vo.prototype, \"sanitizeConfig\", 1);\nHn([\n  me\n], vo.prototype, \"baseSanitizeConfig\", 1);\nclass xa {\n  /**\n   * @class\n   * @param config - tools config\n   * @param editorConfig - EditorJS config\n   * @param api - EditorJS API module\n   */\n  constructor(e, t, o) {\n    this.api = o, this.config = e, this.editorConfig = t;\n  }\n  /**\n   * Returns Tool object based on it's type\n   *\n   * @param name - tool name\n   */\n  get(e) {\n    const { class: t, isInternal: o = !1, ...i } = this.config[e], s = this.getConstructor(t), r = t[mt.IsTune];\n    return new s({\n      name: e,\n      constructable: t,\n      config: i,\n      api: this.api.getMethodsForTool(e, r),\n      isDefault: e === this.editorConfig.defaultBlock,\n      defaultPlaceholder: this.editorConfig.placeholder,\n      isInternal: o\n    });\n  }\n  /**\n   * Find appropriate Tool object constructor for Tool constructable\n   *\n   * @param constructable - Tools constructable\n   */\n  getConstructor(e) {\n    switch (!0) {\n      case e[We.IsInline]:\n        return ka;\n      case e[mt.IsTune]:\n        return ya;\n      default:\n        return vo;\n    }\n  }\n}\nclass $n {\n  /**\n   * MoveDownTune constructor\n   *\n   * @param {API} api — Editor's API\n   */\n  constructor({ api: e }) {\n    this.CSS = {\n      animation: \"wobble\"\n    }, this.api = e;\n  }\n  /**\n   * Tune's appearance in block settings menu\n   */\n  render() {\n    return {\n      icon: Xi,\n      title: this.api.i18n.t(\"Move down\"),\n      onActivate: () => this.handleClick(),\n      name: \"move-down\"\n    };\n  }\n  /**\n   * Handle clicks on 'move down' button\n   */\n  handleClick() {\n    const e = this.api.blocks.getCurrentBlockIndex(), t = this.api.blocks.getBlockByIndex(e + 1);\n    if (!t)\n      throw new Error(\"Unable to move Block down since it is already the last\");\n    const o = t.holder, i = o.getBoundingClientRect();\n    let s = Math.abs(window.innerHeight - o.offsetHeight);\n    i.top < window.innerHeight && (s = window.scrollY + o.offsetHeight), window.scrollTo(0, s), this.api.blocks.move(e + 1), this.api.toolbar.toggleBlockSettings(!0);\n  }\n}\n$n.isTune = !0;\nclass zn {\n  /**\n   * DeleteTune constructor\n   *\n   * @param {API} api - Editor's API\n   */\n  constructor({ api: e }) {\n    this.api = e;\n  }\n  /**\n   * Tune's appearance in block settings menu\n   */\n  render() {\n    return {\n      icon: Gi,\n      title: this.api.i18n.t(\"Delete\"),\n      name: \"delete\",\n      confirmation: {\n        title: this.api.i18n.t(\"Click to delete\"),\n        onActivate: () => this.handleClick()\n      }\n    };\n  }\n  /**\n   * Delete block conditions passed\n   */\n  handleClick() {\n    this.api.blocks.delete();\n  }\n}\nzn.isTune = !0;\nclass Un {\n  /**\n   * MoveUpTune constructor\n   *\n   * @param {API} api - Editor's API\n   */\n  constructor({ api: e }) {\n    this.CSS = {\n      animation: \"wobble\"\n    }, this.api = e;\n  }\n  /**\n   * Tune's appearance in block settings menu\n   */\n  render() {\n    return {\n      icon: Zi,\n      title: this.api.i18n.t(\"Move up\"),\n      onActivate: () => this.handleClick(),\n      name: \"move-up\"\n    };\n  }\n  /**\n   * Move current block up\n   */\n  handleClick() {\n    const e = this.api.blocks.getCurrentBlockIndex(), t = this.api.blocks.getBlockByIndex(e), o = this.api.blocks.getBlockByIndex(e - 1);\n    if (e === 0 || !t || !o)\n      throw new Error(\"Unable to move Block up since it is already the first\");\n    const i = t.holder, s = o.holder, r = i.getBoundingClientRect(), a = s.getBoundingClientRect();\n    let l;\n    a.top > 0 ? l = Math.abs(r.top) - Math.abs(a.top) : l = Math.abs(r.top) + a.height, window.scrollBy(0, -1 * l), this.api.blocks.move(e - 1), this.api.toolbar.toggleBlockSettings(!0);\n  }\n}\nUn.isTune = !0;\nvar Ba = Object.defineProperty, Ca = Object.getOwnPropertyDescriptor, Ta = (n, e, t, o) => {\n  for (var i = o > 1 ? void 0 : o ? Ca(e, t) : e, s = n.length - 1, r; s >= 0; s--)\n    (r = n[s]) && (i = (o ? r(e, t, i) : r(i)) || i);\n  return o && i && Ba(e, t, i), i;\n};\nclass Wn extends E {\n  constructor() {\n    super(...arguments), this.stubTool = \"stub\", this.toolsAvailable = new j(), this.toolsUnavailable = new j();\n  }\n  /**\n   * Returns available Tools\n   */\n  get available() {\n    return this.toolsAvailable;\n  }\n  /**\n   * Returns unavailable Tools\n   */\n  get unavailable() {\n    return this.toolsUnavailable;\n  }\n  /**\n   * Return Tools for the Inline Toolbar\n   */\n  get inlineTools() {\n    return this.available.inlineTools;\n  }\n  /**\n   * Return editor block tools\n   */\n  get blockTools() {\n    return this.available.blockTools;\n  }\n  /**\n   * Return available Block Tunes\n   *\n   * @returns {object} - object of Inline Tool's classes\n   */\n  get blockTunes() {\n    return this.available.blockTunes;\n  }\n  /**\n   * Returns default Tool object\n   */\n  get defaultTool() {\n    return this.blockTools.get(this.config.defaultBlock);\n  }\n  /**\n   * Returns internal tools\n   */\n  get internal() {\n    return this.available.internalTools;\n  }\n  /**\n   * Creates instances via passed or default configuration\n   *\n   * @returns {Promise<void>}\n   */\n  async prepare() {\n    if (this.validateTools(), this.config.tools = ut({}, this.internalTools, this.config.tools), !Object.prototype.hasOwnProperty.call(this.config, \"tools\") || Object.keys(this.config.tools).length === 0)\n      throw Error(\"Can't start without tools\");\n    const e = this.prepareConfig();\n    this.factory = new xa(e, this.config, this.Editor.API);\n    const t = this.getListOfPrepareFunctions(e);\n    if (t.length === 0)\n      return Promise.resolve();\n    await Qn(t, (o) => {\n      this.toolPrepareMethodSuccess(o);\n    }, (o) => {\n      this.toolPrepareMethodFallback(o);\n    }), this.prepareBlockTools();\n  }\n  getAllInlineToolsSanitizeConfig() {\n    const e = {};\n    return Array.from(this.inlineTools.values()).forEach((t) => {\n      Object.assign(e, t.sanitizeConfig);\n    }), e;\n  }\n  /**\n   * Calls each Tool reset method to clean up anything set by Tool\n   */\n  destroy() {\n    Object.values(this.available).forEach(async (e) => {\n      A(e.reset) && await e.reset();\n    });\n  }\n  /**\n   * Returns internal tools\n   * Includes Bold, Italic, Link and Paragraph\n   */\n  get internalTools() {\n    return {\n      convertTo: {\n        class: Fn,\n        isInternal: !0\n      },\n      link: {\n        class: bo,\n        isInternal: !0\n      },\n      bold: {\n        class: go,\n        isInternal: !0\n      },\n      italic: {\n        class: mo,\n        isInternal: !0\n      },\n      paragraph: {\n        class: fo,\n        inlineToolbar: !0,\n        isInternal: !0\n      },\n      stub: {\n        class: jn,\n        isInternal: !0\n      },\n      moveUp: {\n        class: Un,\n        isInternal: !0\n      },\n      delete: {\n        class: zn,\n        isInternal: !0\n      },\n      moveDown: {\n        class: $n,\n        isInternal: !0\n      }\n    };\n  }\n  /**\n   * Tool prepare method success callback\n   *\n   * @param {object} data - append tool to available list\n   */\n  toolPrepareMethodSuccess(e) {\n    const t = this.factory.get(e.toolName);\n    if (t.isInline()) {\n      const i = [\"render\"].filter((s) => !t.create()[s]);\n      if (i.length) {\n        S(\n          `Incorrect Inline Tool: ${t.name}. Some of required methods is not implemented %o`,\n          \"warn\",\n          i\n        ), this.toolsUnavailable.set(t.name, t);\n        return;\n      }\n    }\n    this.toolsAvailable.set(t.name, t);\n  }\n  /**\n   * Tool prepare method fail callback\n   *\n   * @param {object} data - append tool to unavailable list\n   */\n  toolPrepareMethodFallback(e) {\n    this.toolsUnavailable.set(e.toolName, this.factory.get(e.toolName));\n  }\n  /**\n   * Binds prepare function of plugins with user or default config\n   *\n   * @returns {Array} list of functions that needs to be fired sequentially\n   * @param config - tools config\n   */\n  getListOfPrepareFunctions(e) {\n    const t = [];\n    return Object.entries(e).forEach(([o, i]) => {\n      t.push({\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        function: A(i.class.prepare) ? i.class.prepare : () => {\n        },\n        data: {\n          toolName: o,\n          config: i.config\n        }\n      });\n    }), t;\n  }\n  /**\n   * Assign enabled Inline Tools and Block Tunes for Block Tool\n   */\n  prepareBlockTools() {\n    Array.from(this.blockTools.values()).forEach((e) => {\n      this.assignInlineToolsToBlockTool(e), this.assignBlockTunesToBlockTool(e);\n    });\n  }\n  /**\n   * Assign enabled Inline Tools for Block Tool\n   *\n   * @param tool - Block Tool\n   */\n  assignInlineToolsToBlockTool(e) {\n    if (this.config.inlineToolbar !== !1) {\n      if (e.enabledInlineTools === !0) {\n        e.inlineTools = new j(\n          Array.isArray(this.config.inlineToolbar) ? this.config.inlineToolbar.map((t) => [t, this.inlineTools.get(t)]) : Array.from(this.inlineTools.entries())\n        );\n        return;\n      }\n      Array.isArray(e.enabledInlineTools) && (e.inlineTools = new j(\n        /** Prepend ConvertTo Inline Tool */\n        [\"convertTo\", ...e.enabledInlineTools].map((t) => [t, this.inlineTools.get(t)])\n      ));\n    }\n  }\n  /**\n   * Assign enabled Block Tunes for Block Tool\n   *\n   * @param tool — Block Tool\n   */\n  assignBlockTunesToBlockTool(e) {\n    if (e.enabledBlockTunes !== !1) {\n      if (Array.isArray(e.enabledBlockTunes)) {\n        const t = new j(\n          e.enabledBlockTunes.map((o) => [o, this.blockTunes.get(o)])\n        );\n        e.tunes = new j([...t, ...this.blockTunes.internalTools]);\n        return;\n      }\n      if (Array.isArray(this.config.tunes)) {\n        const t = new j(\n          this.config.tunes.map((o) => [o, this.blockTunes.get(o)])\n        );\n        e.tunes = new j([...t, ...this.blockTunes.internalTools]);\n        return;\n      }\n      e.tunes = this.blockTunes.internalTools;\n    }\n  }\n  /**\n   * Validate Tools configuration objects and throw Error for user if it is invalid\n   */\n  validateTools() {\n    for (const e in this.config.tools)\n      if (Object.prototype.hasOwnProperty.call(this.config.tools, e)) {\n        if (e in this.internalTools)\n          return;\n        const t = this.config.tools[e];\n        if (!A(t) && !A(t.class))\n          throw Error(\n            `Tool «${e}» must be a constructor function or an object with function in the «class» property`\n          );\n      }\n  }\n  /**\n   * Unify tools config\n   */\n  prepareConfig() {\n    const e = {};\n    for (const t in this.config.tools)\n      D(this.config.tools[t]) ? e[t] = this.config.tools[t] : e[t] = { class: this.config.tools[t] };\n    return e;\n  }\n}\nTa([\n  me\n], Wn.prototype, \"getAllInlineToolsSanitizeConfig\", 1);\nconst Sa = `:root{--selectionColor: #e1f2ff;--inlineSelectionColor: #d4ecff;--bg-light: #eff2f5;--grayText: #707684;--color-dark: #1D202B;--color-active-icon: #388AE5;--color-gray-border: rgba(201, 201, 204, .48);--content-width: 650px;--narrow-mode-right-padding: 50px;--toolbox-buttons-size: 26px;--toolbox-buttons-size--mobile: 36px;--icon-size: 20px;--icon-size--mobile: 28px;--block-padding-vertical: .4em;--color-line-gray: #EFF0F1 }.codex-editor{position:relative;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:1}.codex-editor .hide{display:none}.codex-editor__redactor [contenteditable]:empty:after{content:\"\\\\feff\"}@media (min-width: 651px){.codex-editor--narrow .codex-editor__redactor{margin-right:50px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .codex-editor__redactor{margin-left:50px;margin-right:0}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__actions{right:-5px}}.codex-editor-copyable{position:absolute;height:1px;width:1px;top:-400%;opacity:.001}.codex-editor-overlay{position:fixed;top:0;left:0;right:0;bottom:0;z-index:999;pointer-events:none;overflow:hidden}.codex-editor-overlay__container{position:relative;pointer-events:auto;z-index:0}.codex-editor-overlay__rectangle{position:absolute;pointer-events:none;background-color:#2eaadc33;border:1px solid transparent}.codex-editor svg{max-height:100%}.codex-editor path{stroke:currentColor}.codex-editor ::-moz-selection{background-color:#d4ecff}.codex-editor ::selection{background-color:#d4ecff}.codex-editor--toolbox-opened [contentEditable=true][data-placeholder]:focus:before{opacity:0!important}.ce-scroll-locked{overflow:hidden}.ce-scroll-locked--hard{overflow:hidden;top:calc(-1 * var(--window-scroll-offset));position:fixed;width:100%}.ce-toolbar{position:absolute;left:0;right:0;top:0;-webkit-transition:opacity .1s ease;transition:opacity .1s ease;will-change:opacity,top;display:none}.ce-toolbar--opened{display:block}.ce-toolbar__content{max-width:650px;margin:0 auto;position:relative}.ce-toolbar__plus{color:#1d202b;cursor:pointer;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-flex-negative:0;flex-shrink:0}@media (max-width: 650px){.ce-toolbar__plus{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__plus:hover{background-color:#eff2f5}}.ce-toolbar__plus--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.ce-toolbar__plus-shortcut{opacity:.6;word-spacing:-2px;margin-top:5px}@media (max-width: 650px){.ce-toolbar__plus{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__plus--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__plus--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__actions{position:absolute;right:100%;opacity:0;display:-webkit-box;display:-ms-flexbox;display:flex;padding-right:5px}.ce-toolbar__actions--opened{opacity:1}@media (max-width: 650px){.ce-toolbar__actions{right:auto}}.ce-toolbar__settings-btn{color:#1d202b;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;margin-left:3px;cursor:pointer;user-select:none}@media (max-width: 650px){.ce-toolbar__settings-btn{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__settings-btn:hover{background-color:#eff2f5}}.ce-toolbar__settings-btn--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}@media (min-width: 651px){.ce-toolbar__settings-btn{width:24px}}.ce-toolbar__settings-btn--hidden{display:none}@media (max-width: 650px){.ce-toolbar__settings-btn{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__settings-btn--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__settings-btn--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__plus svg,.ce-toolbar__settings-btn svg{width:24px;height:24px}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__plus{left:5px}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbox .ce-popover{right:0;left:auto;left:initial}}.ce-inline-toolbar{--y-offset: 8px;--color-background-icon-active: rgba(56, 138, 229, .1);--color-text-icon-active: #388AE5;--color-text-primary: black;position:absolute;visibility:hidden;-webkit-transition:opacity .25s ease;transition:opacity .25s ease;will-change:opacity,left,top;top:0;left:0;z-index:3;opacity:1;visibility:visible}.ce-inline-toolbar [hidden]{display:none!important}.ce-inline-toolbar__toggler-and-button-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;padding:0 6px}.ce-inline-toolbar__buttons{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown{display:-webkit-box;display:-ms-flexbox;display:flex;padding:6px;margin:0 6px 0 -6px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;border-right:1px solid rgba(201,201,204,.48);-webkit-box-sizing:border-box;box-sizing:border-box}@media (hover: hover){.ce-inline-toolbar__dropdown:hover{background:#eff2f5}}.ce-inline-toolbar__dropdown--hidden{display:none}.ce-inline-toolbar__dropdown-content,.ce-inline-toolbar__dropdown-arrow{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown-content svg,.ce-inline-toolbar__dropdown-arrow svg{width:20px;height:20px}.ce-inline-toolbar__shortcut{opacity:.6;word-spacing:-3px;margin-top:3px}.ce-inline-tool{color:var(--color-text-primary);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border:0;border-radius:4px;line-height:normal;height:100%;padding:0;width:28px;background-color:transparent;cursor:pointer}@media (max-width: 650px){.ce-inline-tool{width:36px;height:36px}}@media (hover: hover){.ce-inline-tool:hover{background-color:#f8f8f8}}.ce-inline-tool svg{display:block;width:20px;height:20px}@media (max-width: 650px){.ce-inline-tool svg{width:28px;height:28px}}.ce-inline-tool--link .icon--unlink,.ce-inline-tool--unlink .icon--link{display:none}.ce-inline-tool--unlink .icon--unlink{display:inline-block;margin-bottom:-1px}.ce-inline-tool-input{background:#F8F8F8;border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:4px 8px;font-size:14px;line-height:22px;outline:none;margin:0;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box;display:none;font-weight:500;-webkit-appearance:none;font-family:inherit}@media (max-width: 650px){.ce-inline-tool-input{font-size:15px;font-weight:500}}.ce-inline-tool-input::-webkit-input-placeholder{color:#707684}.ce-inline-tool-input::-moz-placeholder{color:#707684}.ce-inline-tool-input:-ms-input-placeholder{color:#707684}.ce-inline-tool-input::-ms-input-placeholder{color:#707684}.ce-inline-tool-input::placeholder{color:#707684}.ce-inline-tool-input--showed{display:block}.ce-inline-tool--active{background:var(--color-background-icon-active);color:var(--color-text-icon-active)}@-webkit-keyframes fade-in{0%{opacity:0}to{opacity:1}}@keyframes fade-in{0%{opacity:0}to{opacity:1}}.ce-block{-webkit-animation:fade-in .3s ease;animation:fade-in .3s ease;-webkit-animation-fill-mode:none;animation-fill-mode:none;-webkit-animation-fill-mode:initial;animation-fill-mode:initial}.ce-block:first-of-type{margin-top:0}.ce-block--selected .ce-block__content{background:#e1f2ff}.ce-block--selected .ce-block__content [contenteditable]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ce-block--selected .ce-block__content img,.ce-block--selected .ce-block__content .ce-stub{opacity:.55}.ce-block--stretched .ce-block__content{max-width:none}.ce-block__content{position:relative;max-width:650px;margin:0 auto;-webkit-transition:background-color .15s ease;transition:background-color .15s ease}.ce-block--drop-target .ce-block__content:before{content:\"\";position:absolute;top:100%;left:-20px;margin-top:-1px;height:8px;width:8px;border:solid #388AE5;border-width:1px 1px 0 0;-webkit-transform-origin:right;transform-origin:right;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.ce-block--drop-target .ce-block__content:after{content:\"\";position:absolute;top:100%;height:1px;width:100%;color:#388ae5;background:repeating-linear-gradient(90deg,#388AE5,#388AE5 1px,#fff 1px,#fff 6px)}.ce-block a{cursor:pointer;-webkit-text-decoration:underline;text-decoration:underline}.ce-block b{font-weight:700}.ce-block i{font-style:italic}@-webkit-keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}.cdx-block{padding:.4em 0}.cdx-block::-webkit-input-placeholder{line-height:normal!important}.cdx-input{border:1px solid rgba(201,201,204,.48);-webkit-box-shadow:inset 0 1px 2px 0 rgba(35,44,72,.06);box-shadow:inset 0 1px 2px #232c480f;border-radius:3px;padding:10px 12px;outline:none;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box}.cdx-input[data-placeholder]:before{position:static!important}.cdx-input[data-placeholder]:before{display:inline-block;width:0;white-space:nowrap;pointer-events:none}.cdx-settings-button{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;border-radius:3px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;min-width:26px;min-height:26px}.cdx-settings-button--focused{background:rgba(34,186,255,.08)!important}.cdx-settings-button--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.cdx-settings-button--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.cdx-settings-button--active{color:#388ae5}.cdx-settings-button svg{width:auto;height:auto}@media (max-width: 650px){.cdx-settings-button svg{width:28px;height:28px}}@media (max-width: 650px){.cdx-settings-button{width:36px;height:36px;border-radius:8px}}@media (hover: hover){.cdx-settings-button:hover{background-color:#eff2f5}}.cdx-loader{position:relative;border:1px solid rgba(201,201,204,.48)}.cdx-loader:before{content:\"\";position:absolute;left:50%;top:50%;width:18px;height:18px;margin:-11px 0 0 -11px;border:2px solid rgba(201,201,204,.48);border-left-color:#388ae5;border-radius:50%;-webkit-animation:cdxRotation 1.2s infinite linear;animation:cdxRotation 1.2s infinite linear}@-webkit-keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.cdx-button{padding:13px;border-radius:3px;border:1px solid rgba(201,201,204,.48);font-size:14.9px;background:#fff;-webkit-box-shadow:0 2px 2px 0 rgba(18,30,57,.04);box-shadow:0 2px 2px #121e390a;color:#707684;text-align:center;cursor:pointer}@media (hover: hover){.cdx-button:hover{background:#FBFCFE;-webkit-box-shadow:0 1px 3px 0 rgba(18,30,57,.08);box-shadow:0 1px 3px #121e3914}}.cdx-button svg{height:20px;margin-right:.2em;margin-top:-2px}.ce-stub{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:12px 18px;margin:10px 0;border-radius:10px;background:#eff2f5;border:1px solid #EFF0F1;color:#707684;font-size:14px}.ce-stub svg{width:20px;height:20px}.ce-stub__info{margin-left:14px}.ce-stub__title{font-weight:500;text-transform:capitalize}.codex-editor.codex-editor--rtl{direction:rtl}.codex-editor.codex-editor--rtl .cdx-list{padding-left:0;padding-right:40px}.codex-editor.codex-editor--rtl .ce-toolbar__plus{right:-26px;left:auto}.codex-editor.codex-editor--rtl .ce-toolbar__actions{right:auto;left:-26px}@media (max-width: 650px){.codex-editor.codex-editor--rtl .ce-toolbar__actions{margin-left:0;margin-right:auto;padding-right:0;padding-left:10px}}.codex-editor.codex-editor--rtl .ce-settings{left:5px;right:auto}.codex-editor.codex-editor--rtl .ce-settings:before{right:auto;left:25px}.codex-editor.codex-editor--rtl .ce-settings__button:not(:nth-child(3n+3)){margin-left:3px;margin-right:0}.codex-editor.codex-editor--rtl .ce-conversion-tool__icon{margin-right:0;margin-left:10px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown{border-right:0px solid transparent;border-left:1px solid rgba(201,201,204,.48);margin:0 -6px 0 6px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown .icon--toggler-down{margin-left:0;margin-right:4px}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__plus{left:0;right:5px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__actions{left:-5px}}.cdx-search-field{--icon-margin-right: 10px;background:#F8F8F8;border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:2px;display:grid;grid-template-columns:auto auto 1fr;grid-template-rows:auto}.cdx-search-field__icon{width:26px;height:26px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:var(--icon-margin-right)}.cdx-search-field__icon svg{width:20px;height:20px;color:#707684}.cdx-search-field__input{font-size:14px;outline:none;font-weight:500;font-family:inherit;border:0;background:transparent;margin:0;padding:0;line-height:22px;min-width:calc(100% - 26px - var(--icon-margin-right))}.cdx-search-field__input::-webkit-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-moz-placeholder{color:#707684;font-weight:500}.cdx-search-field__input:-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::placeholder{color:#707684;font-weight:500}.ce-popover{--border-radius: 6px;--width: 200px;--max-height: 270px;--padding: 6px;--offset-from-target: 8px;--color-border: #EFF0F1;--color-shadow: rgba(13, 20, 33, .1);--color-background: white;--color-text-primary: black;--color-text-secondary: #707684;--color-border-icon: rgba(201, 201, 204, .48);--color-border-icon-disabled: #EFF0F1;--color-text-icon-active: #388AE5;--color-background-icon-active: rgba(56, 138, 229, .1);--color-background-item-focus: rgba(34, 186, 255, .08);--color-shadow-item-focus: rgba(7, 161, 227, .08);--color-background-item-hover: #F8F8F8;--color-background-item-confirm: #E24A4A;--color-background-item-confirm-hover: #CE4343;--popover-top: calc(100% + var(--offset-from-target));--popover-left: 0;--nested-popover-overlap: 4px;--icon-size: 20px;--item-padding: 3px;--item-height: calc(var(--icon-size) + 2 * var(--item-padding))}.ce-popover__container{min-width:var(--width);width:var(--width);max-height:var(--max-height);border-radius:var(--border-radius);overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-box-shadow:0px 3px 15px -3px var(--color-shadow);box-shadow:0 3px 15px -3px var(--color-shadow);position:absolute;left:var(--popover-left);top:var(--popover-top);background:var(--color-background);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;z-index:4;opacity:0;max-height:0;pointer-events:none;padding:0;border:none}.ce-popover--opened>.ce-popover__container{opacity:1;padding:var(--padding);max-height:var(--max-height);pointer-events:auto;-webkit-animation:panelShowing .1s ease;animation:panelShowing .1s ease;border:1px solid var(--color-border)}@media (max-width: 650px){.ce-popover--opened>.ce-popover__container{-webkit-animation:panelShowingMobile .25s ease;animation:panelShowingMobile .25s ease}}.ce-popover--open-top .ce-popover__container{--popover-top: calc(-1 * (var(--offset-from-target) + var(--popover-height)))}.ce-popover--open-left .ce-popover__container{--popover-left: calc(-1 * var(--width) + 100%)}.ce-popover__items{overflow-y:auto;-ms-scroll-chaining:none;overscroll-behavior:contain}@media (max-width: 650px){.ce-popover__overlay{position:fixed;top:0;bottom:0;left:0;right:0;background:#1D202B;z-index:3;opacity:.5;-webkit-transition:opacity .12s ease-in;transition:opacity .12s ease-in;will-change:opacity;visibility:visible}}.ce-popover__overlay--hidden{display:none}@media (max-width: 650px){.ce-popover .ce-popover__container{--offset: 5px;position:fixed;max-width:none;min-width:calc(100% - var(--offset) * 2);left:var(--offset);right:var(--offset);bottom:calc(var(--offset) + env(safe-area-inset-bottom));top:auto;border-radius:10px}}.ce-popover__search{margin-bottom:5px}.ce-popover__nothing-found-message{color:#707684;display:none;cursor:default;padding:3px;font-size:14px;line-height:20px;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ce-popover__nothing-found-message--displayed{display:block}.ce-popover--nested .ce-popover__container{--popover-left: calc(var(--nesting-level) * (var(--width) - var(--nested-popover-overlap)));top:calc(var(--trigger-item-top) - var(--nested-popover-overlap));position:absolute}.ce-popover--open-top.ce-popover--nested .ce-popover__container{top:calc(var(--trigger-item-top) - var(--popover-height) + var(--item-height) + var(--offset-from-target) + var(--nested-popover-overlap))}.ce-popover--open-left .ce-popover--nested .ce-popover__container{--popover-left: calc(-1 * (var(--nesting-level) + 1) * var(--width) + 100%)}.ce-popover-item-separator{padding:4px 3px}.ce-popover-item-separator--hidden{display:none}.ce-popover-item-separator__line{height:1px;background:var(--color-border);width:100%}.ce-popover-item-html--hidden{display:none}.ce-popover-item{--border-radius: 6px;border-radius:var(--border-radius);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:var(--item-padding);color:var(--color-text-primary);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border:none;background:transparent}@media (max-width: 650px){.ce-popover-item{padding:4px}}.ce-popover-item:not(:last-of-type){margin-bottom:1px}.ce-popover-item__icon{width:26px;height:26px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center}.ce-popover-item__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-popover-item__icon{width:36px;height:36px;border-radius:8px}.ce-popover-item__icon svg{width:28px;height:28px}}.ce-popover-item__icon--tool{margin-right:4px}.ce-popover-item__title{font-size:14px;line-height:20px;font-weight:500;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin-right:auto}@media (max-width: 650px){.ce-popover-item__title{font-size:16px}}.ce-popover-item__secondary-title{color:var(--color-text-secondary);font-size:12px;white-space:nowrap;letter-spacing:-.1em;padding-right:5px;opacity:.6}@media (max-width: 650px){.ce-popover-item__secondary-title{display:none}}.ce-popover-item--active{background:var(--color-background-icon-active);color:var(--color-text-icon-active)}.ce-popover-item--disabled{color:var(--color-text-secondary);cursor:default;pointer-events:none}.ce-popover-item--focused:not(.ce-popover-item--no-focus){background:var(--color-background-item-focus)!important}.ce-popover-item--hidden{display:none}@media (hover: hover){.ce-popover-item:hover{cursor:pointer}.ce-popover-item:hover:not(.ce-popover-item--no-hover){background-color:var(--color-background-item-hover)}}.ce-popover-item--confirmation{background:var(--color-background-item-confirm)}.ce-popover-item--confirmation .ce-popover-item__title,.ce-popover-item--confirmation .ce-popover-item__icon{color:#fff}@media (hover: hover){.ce-popover-item--confirmation:not(.ce-popover-item--no-hover):hover{background:var(--color-background-item-confirm-hover)}}.ce-popover-item--confirmation:not(.ce-popover-item--no-focus).ce-popover-item--focused{background:var(--color-background-item-confirm-hover)!important}@-webkit-keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}.wobble{-webkit-animation-name:wobble;animation-name:wobble;-webkit-animation-duration:.4s;animation-duration:.4s}@-webkit-keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}@keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}.ce-popover-header{margin-bottom:8px;margin-top:4px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ce-popover-header__text{font-size:18px;font-weight:600}.ce-popover-header__back-button{border:0;background:transparent;width:36px;height:36px;color:var(--color-text-primary)}.ce-popover-header__back-button svg{display:block;width:28px;height:28px}.ce-popover--inline{--height: 38px;--height-mobile: 46px;--container-padding: 4px;position:relative}.ce-popover--inline .ce-popover__custom-content{margin-bottom:0}.ce-popover--inline .ce-popover__items{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-popover--inline .ce-popover__container{-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;padding:var(--container-padding);height:var(--height);top:0;min-width:-webkit-max-content;min-width:-moz-max-content;min-width:max-content;width:-webkit-max-content;width:-moz-max-content;width:max-content;-webkit-animation:none;animation:none}@media (max-width: 650px){.ce-popover--inline .ce-popover__container{height:var(--height-mobile);position:absolute}}.ce-popover--inline .ce-popover-item-separator{padding:0 4px}.ce-popover--inline .ce-popover-item-separator__line{height:100%;width:1px}.ce-popover--inline .ce-popover-item{border-radius:4px;padding:4px}.ce-popover--inline .ce-popover-item__icon--tool{-webkit-box-shadow:none;box-shadow:none;background:transparent;margin-right:0}.ce-popover--inline .ce-popover-item__icon{width:auto;width:initial;height:auto;height:initial}.ce-popover--inline .ce-popover-item__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-popover--inline .ce-popover-item__icon svg{width:28px;height:28px}}.ce-popover--inline .ce-popover-item:not(:last-of-type){margin-bottom:0;margin-bottom:initial}.ce-popover--inline .ce-popover-item-html{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ce-popover--inline .ce-popover-item__icon--chevron-right{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.ce-popover--inline .ce-popover--nested-level-1 .ce-popover__container{--offset: 3px;left:0;top:calc(var(--height) + var(--offset))}@media (max-width: 650px){.ce-popover--inline .ce-popover--nested-level-1 .ce-popover__container{top:calc(var(--height-mobile) + var(--offset))}}.ce-popover--inline .ce-popover--nested .ce-popover__container{min-width:var(--width);width:var(--width);height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;padding:6px;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.ce-popover--inline .ce-popover--nested .ce-popover__items{display:block;width:100%}.ce-popover--inline .ce-popover--nested .ce-popover-item{border-radius:6px;padding:3px}@media (max-width: 650px){.ce-popover--inline .ce-popover--nested .ce-popover-item{padding:4px}}.ce-popover--inline .ce-popover--nested .ce-popover-item__icon--tool{margin-right:4px}.ce-popover--inline .ce-popover--nested .ce-popover-item__icon{width:26px;height:26px}.ce-popover--inline .ce-popover--nested .ce-popover-item-separator{padding:4px 3px}.ce-popover--inline .ce-popover--nested .ce-popover-item-separator__line{width:100%;height:1px}.codex-editor [data-placeholder]:empty:before,.codex-editor [data-placeholder][data-empty=true]:before{pointer-events:none;color:#707684;cursor:text;content:attr(data-placeholder)}.codex-editor [data-placeholder-active]:empty:before,.codex-editor [data-placeholder-active][data-empty=true]:before{pointer-events:none;color:#707684;cursor:text}.codex-editor [data-placeholder-active]:empty:focus:before,.codex-editor [data-placeholder-active][data-empty=true]:focus:before{content:attr(data-placeholder-active)}\n`;\nclass Ia extends E {\n  constructor() {\n    super(...arguments), this.isMobile = !1, this.contentRectCache = null, this.resizeDebouncer = Eo(() => {\n      this.windowResize();\n    }, 200), this.selectionChangeDebounced = Eo(() => {\n      this.selectionChanged();\n    }, da), this.documentTouchedListener = (e) => {\n      this.documentTouched(e);\n    };\n  }\n  /**\n   * Editor.js UI CSS class names\n   *\n   * @returns {{editorWrapper: string, editorZone: string}}\n   */\n  get CSS() {\n    return {\n      editorWrapper: \"codex-editor\",\n      editorWrapperNarrow: \"codex-editor--narrow\",\n      editorZone: \"codex-editor__redactor\",\n      editorZoneHidden: \"codex-editor__redactor--hidden\",\n      editorEmpty: \"codex-editor--empty\",\n      editorRtlFix: \"codex-editor--rtl\"\n    };\n  }\n  /**\n   * Return Width of center column of Editor\n   *\n   * @returns {DOMRect}\n   */\n  get contentRect() {\n    if (this.contentRectCache !== null)\n      return this.contentRectCache;\n    const e = this.nodes.wrapper.querySelector(`.${R.CSS.content}`);\n    return e ? (this.contentRectCache = e.getBoundingClientRect(), this.contentRectCache) : {\n      width: 650,\n      left: 0,\n      right: 0\n    };\n  }\n  /**\n   * Making main interface\n   */\n  async prepare() {\n    this.setIsMobile(), this.make(), this.loadStyles();\n  }\n  /**\n   * Toggle read-only state\n   *\n   * If readOnly is true:\n   *  - removes all listeners from main UI module elements\n   *\n   * if readOnly is false:\n   *  - enables all listeners to UI module elements\n   *\n   * @param {boolean} readOnlyEnabled - \"read only\" state\n   */\n  toggleReadOnly(e) {\n    e ? this.unbindReadOnlySensitiveListeners() : window.requestIdleCallback(() => {\n      this.bindReadOnlySensitiveListeners();\n    }, {\n      timeout: 2e3\n    });\n  }\n  /**\n   * Check if Editor is empty and set CSS class to wrapper\n   */\n  checkEmptiness() {\n    const { BlockManager: e } = this.Editor;\n    this.nodes.wrapper.classList.toggle(this.CSS.editorEmpty, e.isEditorEmpty);\n  }\n  /**\n   * Check if one of Toolbar is opened\n   * Used to prevent global keydowns (for example, Enter) conflicts with Enter-on-toolbar\n   *\n   * @returns {boolean}\n   */\n  get someToolbarOpened() {\n    const { Toolbar: e, BlockSettings: t, InlineToolbar: o } = this.Editor;\n    return !!(t.opened || o.opened || e.toolbox.opened);\n  }\n  /**\n   * Check for some Flipper-buttons is under focus\n   */\n  get someFlipperButtonFocused() {\n    return this.Editor.Toolbar.toolbox.hasFocus() ? !0 : Object.entries(this.Editor).filter(([e, t]) => t.flipper instanceof ce).some(([e, t]) => t.flipper.hasFocus());\n  }\n  /**\n   * Clean editor`s UI\n   */\n  destroy() {\n    this.nodes.holder.innerHTML = \"\", this.unbindReadOnlyInsensitiveListeners();\n  }\n  /**\n   * Close all Editor's toolbars\n   */\n  closeAllToolbars() {\n    const { Toolbar: e, BlockSettings: t, InlineToolbar: o } = this.Editor;\n    t.close(), o.close(), e.toolbox.close();\n  }\n  /**\n   * Check for mobile mode and save the result\n   */\n  setIsMobile() {\n    const e = window.innerWidth < Ro;\n    e !== this.isMobile && this.eventsDispatcher.emit(Te, {\n      isEnabled: this.isMobile\n    }), this.isMobile = e;\n  }\n  /**\n   * Makes Editor.js interface\n   */\n  make() {\n    this.nodes.holder = d.getHolder(this.config.holder), this.nodes.wrapper = d.make(\"div\", [\n      this.CSS.editorWrapper,\n      ...this.isRtl ? [this.CSS.editorRtlFix] : []\n    ]), this.nodes.redactor = d.make(\"div\", this.CSS.editorZone), this.nodes.holder.offsetWidth < this.contentRect.width && this.nodes.wrapper.classList.add(this.CSS.editorWrapperNarrow), this.nodes.redactor.style.paddingBottom = this.config.minHeight + \"px\", this.nodes.wrapper.appendChild(this.nodes.redactor), this.nodes.holder.appendChild(this.nodes.wrapper), this.bindReadOnlyInsensitiveListeners();\n  }\n  /**\n   * Appends CSS\n   */\n  loadStyles() {\n    const e = \"editor-js-styles\";\n    if (d.get(e))\n      return;\n    const t = d.make(\"style\", null, {\n      id: e,\n      textContent: Sa.toString()\n    });\n    this.config.style && !V(this.config.style) && this.config.style.nonce && t.setAttribute(\"nonce\", this.config.style.nonce), d.prepend(document.head, t);\n  }\n  /**\n   * Adds listeners that should work both in read-only and read-write modes\n   */\n  bindReadOnlyInsensitiveListeners() {\n    this.listeners.on(document, \"selectionchange\", this.selectionChangeDebounced), this.listeners.on(window, \"resize\", this.resizeDebouncer, {\n      passive: !0\n    }), this.listeners.on(this.nodes.redactor, \"mousedown\", this.documentTouchedListener, {\n      capture: !0,\n      passive: !0\n    }), this.listeners.on(this.nodes.redactor, \"touchstart\", this.documentTouchedListener, {\n      capture: !0,\n      passive: !0\n    });\n  }\n  /**\n   * Removes listeners that should work both in read-only and read-write modes\n   */\n  unbindReadOnlyInsensitiveListeners() {\n    this.listeners.off(document, \"selectionchange\", this.selectionChangeDebounced), this.listeners.off(window, \"resize\", this.resizeDebouncer), this.listeners.off(this.nodes.redactor, \"mousedown\", this.documentTouchedListener), this.listeners.off(this.nodes.redactor, \"touchstart\", this.documentTouchedListener);\n  }\n  /**\n   * Adds listeners that should work only in read-only mode\n   */\n  bindReadOnlySensitiveListeners() {\n    this.readOnlyMutableListeners.on(this.nodes.redactor, \"click\", (e) => {\n      this.redactorClicked(e);\n    }, !1), this.readOnlyMutableListeners.on(document, \"keydown\", (e) => {\n      this.documentKeydown(e);\n    }, !0), this.readOnlyMutableListeners.on(document, \"mousedown\", (e) => {\n      this.documentClicked(e);\n    }, !0), this.watchBlockHoveredEvents(), this.enableInputsEmptyMark();\n  }\n  /**\n   * Listen redactor mousemove to emit 'block-hovered' event\n   */\n  watchBlockHoveredEvents() {\n    let e;\n    this.readOnlyMutableListeners.on(this.nodes.redactor, \"mousemove\", dt((t) => {\n      const o = t.target.closest(\".ce-block\");\n      this.Editor.BlockSelection.anyBlockSelected || o && e !== o && (e = o, this.eventsDispatcher.emit(ln, {\n        block: this.Editor.BlockManager.getBlockByChildNode(o)\n      }));\n    }, 20), {\n      passive: !0\n    });\n  }\n  /**\n   * Unbind events that should work only in read-only mode\n   */\n  unbindReadOnlySensitiveListeners() {\n    this.readOnlyMutableListeners.clearAll();\n  }\n  /**\n   * Resize window handler\n   */\n  windowResize() {\n    this.contentRectCache = null, this.setIsMobile();\n  }\n  /**\n   * All keydowns on document\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  documentKeydown(e) {\n    switch (e.keyCode) {\n      case y.ENTER:\n        this.enterPressed(e);\n        break;\n      case y.BACKSPACE:\n      case y.DELETE:\n        this.backspacePressed(e);\n        break;\n      case y.ESC:\n        this.escapePressed(e);\n        break;\n      default:\n        this.defaultBehaviour(e);\n        break;\n    }\n  }\n  /**\n   * Ignore all other document's keydown events\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  defaultBehaviour(e) {\n    const { currentBlock: t } = this.Editor.BlockManager, o = e.target.closest(`.${this.CSS.editorWrapper}`), i = e.altKey || e.ctrlKey || e.metaKey || e.shiftKey;\n    if (t !== void 0 && o === null) {\n      this.Editor.BlockEvents.keydown(e);\n      return;\n    }\n    o || t && i || (this.Editor.BlockManager.unsetCurrentBlock(), this.Editor.Toolbar.close());\n  }\n  /**\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  backspacePressed(e) {\n    const { BlockManager: t, BlockSelection: o, Caret: i } = this.Editor;\n    if (o.anyBlockSelected && !b.isSelectionExists) {\n      const s = t.removeSelectedBlocks(), r = t.insertDefaultBlockAtIndex(s, !0);\n      i.setToBlock(r, i.positions.START), o.clearSelection(e), e.preventDefault(), e.stopPropagation(), e.stopImmediatePropagation();\n    }\n  }\n  /**\n   * Escape pressed\n   * If some of Toolbar components are opened, then close it otherwise close Toolbar\n   *\n   * @param {Event} event - escape keydown event\n   */\n  escapePressed(e) {\n    this.Editor.BlockSelection.clearSelection(e), this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.toolbox.close(), this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock, this.Editor.Caret.positions.END)) : this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.InlineToolbar.opened ? this.Editor.InlineToolbar.close() : this.Editor.Toolbar.close();\n  }\n  /**\n   * Enter pressed on document\n   *\n   * @param {KeyboardEvent} event - keyboard event\n   */\n  enterPressed(e) {\n    const { BlockManager: t, BlockSelection: o } = this.Editor;\n    if (this.someToolbarOpened)\n      return;\n    const i = t.currentBlockIndex >= 0;\n    if (o.anyBlockSelected && !b.isSelectionExists) {\n      o.clearSelection(e), e.preventDefault(), e.stopImmediatePropagation(), e.stopPropagation();\n      return;\n    }\n    if (!this.someToolbarOpened && i && e.target.tagName === \"BODY\") {\n      const s = this.Editor.BlockManager.insert();\n      e.preventDefault(), this.Editor.Caret.setToBlock(s), this.Editor.Toolbar.moveAndOpen(s);\n    }\n    this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * All clicks on document\n   *\n   * @param {MouseEvent} event - Click event\n   */\n  documentClicked(e) {\n    var a, l;\n    if (!e.isTrusted)\n      return;\n    const t = e.target;\n    this.nodes.holder.contains(t) || b.isAtEditor || (this.Editor.BlockManager.unsetCurrentBlock(), this.Editor.Toolbar.close());\n    const i = (a = this.Editor.BlockSettings.nodes.wrapper) == null ? void 0 : a.contains(t), s = (l = this.Editor.Toolbar.nodes.settingsToggler) == null ? void 0 : l.contains(t), r = i || s;\n    if (this.Editor.BlockSettings.opened && !r) {\n      this.Editor.BlockSettings.close();\n      const c = this.Editor.BlockManager.getBlockByChildNode(t);\n      this.Editor.Toolbar.moveAndOpen(c);\n    }\n    this.Editor.BlockSelection.clearSelection(e);\n  }\n  /**\n   * First touch on editor\n   * Fired before click\n   *\n   * Used to change current block — we need to do it before 'selectionChange' event.\n   * Also:\n   * - Move and show the Toolbar\n   * - Set a Caret\n   *\n   * @param event - touch or mouse event\n   */\n  documentTouched(e) {\n    let t = e.target;\n    if (t === this.nodes.redactor) {\n      const o = e instanceof MouseEvent ? e.clientX : e.touches[0].clientX, i = e instanceof MouseEvent ? e.clientY : e.touches[0].clientY;\n      t = document.elementFromPoint(o, i);\n    }\n    try {\n      this.Editor.BlockManager.setCurrentBlockByChildNode(t);\n    } catch {\n      this.Editor.RectangleSelection.isRectActivated() || this.Editor.Caret.setToTheLastBlock();\n    }\n    this.Editor.ReadOnly.isEnabled || this.Editor.Toolbar.moveAndOpen();\n  }\n  /**\n   * All clicks on the redactor zone\n   *\n   * @param {MouseEvent} event - click event\n   * @description\n   * - By clicks on the Editor's bottom zone:\n   *      - if last Block is empty, set a Caret to this\n   *      - otherwise, add a new empty Block and set a Caret to that\n   */\n  redactorClicked(e) {\n    if (!b.isCollapsed)\n      return;\n    const t = e.target, o = e.metaKey || e.ctrlKey;\n    if (d.isAnchor(t) && o) {\n      e.stopImmediatePropagation(), e.stopPropagation();\n      const i = t.getAttribute(\"href\"), s = oi(i);\n      ii(s);\n      return;\n    }\n    this.processBottomZoneClick(e);\n  }\n  /**\n   * Check if user clicks on the Editor's bottom zone:\n   *  - set caret to the last block\n   *  - or add new empty block\n   *\n   * @param event - click event\n   */\n  processBottomZoneClick(e) {\n    const t = this.Editor.BlockManager.getBlockByIndex(-1), o = d.offset(t.holder).bottom, i = e.pageY, { BlockSelection: s } = this.Editor;\n    if (e.target instanceof Element && e.target.isEqualNode(this.nodes.redactor) && /**\n    * If there is cross block selection started, target will be equal to redactor so we need additional check\n    */\n    !s.anyBlockSelected && /**\n    * Prevent caret jumping (to last block) when clicking between blocks\n    */\n    o < i) {\n      e.stopImmediatePropagation(), e.stopPropagation();\n      const { BlockManager: a, Caret: l, Toolbar: c } = this.Editor;\n      (!a.lastBlock.tool.isDefault || !a.lastBlock.isEmpty) && a.insertAtEnd(), l.setToTheLastBlock(), c.moveAndOpen(a.lastBlock);\n    }\n  }\n  /**\n   * Handle selection changes on mobile devices\n   * Uses for showing the Inline Toolbar\n   */\n  selectionChanged() {\n    const { CrossBlockSelection: e, BlockSelection: t } = this.Editor, o = b.anchorElement;\n    if (e.isCrossBlockSelectionStarted && t.anyBlockSelected && b.get().removeAllRanges(), !o) {\n      b.range || this.Editor.InlineToolbar.close();\n      return;\n    }\n    const i = o.closest(`.${R.CSS.content}`);\n    (i === null || i.closest(`.${b.CSS.editorWrapper}`) !== this.nodes.wrapper) && (this.Editor.InlineToolbar.containsNode(o) || this.Editor.InlineToolbar.close(), !(o.dataset.inlineToolbar === \"true\")) || (this.Editor.BlockManager.currentBlock || this.Editor.BlockManager.setCurrentBlockByChildNode(o), this.Editor.InlineToolbar.tryToShow(!0));\n  }\n  /**\n   * Editor.js provides and ability to show placeholders for empty contenteditable elements\n   *\n   * This method watches for input and focus events and toggles 'data-empty' attribute\n   * to workaroud the case, when inputs contains only <br>s and has no visible content\n   * Then, CSS could rely on this attribute to show placeholders\n   */\n  enableInputsEmptyMark() {\n    function e(t) {\n      const o = t.target;\n      Do(o);\n    }\n    this.readOnlyMutableListeners.on(this.nodes.wrapper, \"input\", e), this.readOnlyMutableListeners.on(this.nodes.wrapper, \"focusin\", e), this.readOnlyMutableListeners.on(this.nodes.wrapper, \"focusout\", e);\n  }\n}\nconst Oa = {\n  // API Modules\n  BlocksAPI: gi,\n  CaretAPI: bi,\n  EventsAPI: vi,\n  I18nAPI: kt,\n  API: ki,\n  InlineToolbarAPI: yi,\n  ListenersAPI: wi,\n  NotifierAPI: Ci,\n  ReadOnlyAPI: Ti,\n  SanitizerAPI: Li,\n  SaverAPI: Pi,\n  SelectionAPI: Ni,\n  ToolsAPI: Ri,\n  StylesAPI: Di,\n  ToolbarAPI: Fi,\n  TooltipAPI: Ui,\n  UiAPI: Wi,\n  // Toolbar Modules\n  BlockSettings: ms,\n  Toolbar: Bs,\n  InlineToolbar: Cs,\n  // Modules\n  BlockEvents: na,\n  BlockManager: ra,\n  BlockSelection: aa,\n  Caret: Ye,\n  CrossBlockSelection: la,\n  DragNDrop: ca,\n  ModificationsObserver: ha,\n  Paste: pa,\n  ReadOnly: fa,\n  RectangleSelection: Be,\n  Renderer: ga,\n  Saver: ma,\n  Tools: Wn,\n  UI: Ia\n};\nclass _a {\n  /**\n   * @param {EditorConfig} config - user configuration\n   */\n  constructor(e) {\n    this.moduleInstances = {}, this.eventsDispatcher = new Oe();\n    let t, o;\n    this.isReady = new Promise((i, s) => {\n      t = i, o = s;\n    }), Promise.resolve().then(async () => {\n      this.configuration = e, this.validate(), this.init(), await this.start(), await this.render();\n      const { BlockManager: i, Caret: s, UI: r, ModificationsObserver: a } = this.moduleInstances;\n      r.checkEmptiness(), a.enable(), this.configuration.autofocus === !0 && this.configuration.readOnly !== !0 && s.setToBlock(i.blocks[0], s.positions.START), t();\n    }).catch((i) => {\n      S(`Editor.js is not ready because of ${i}`, \"error\"), o(i);\n    });\n  }\n  /**\n   * Setting for configuration\n   *\n   * @param {EditorConfig|string} config - Editor's config to set\n   */\n  set configuration(e) {\n    var o, i;\n    D(e) ? this.config = {\n      ...e\n    } : this.config = {\n      holder: e\n    }, ht(!!this.config.holderId, \"config.holderId\", \"config.holder\"), this.config.holderId && !this.config.holder && (this.config.holder = this.config.holderId, this.config.holderId = null), this.config.holder == null && (this.config.holder = \"editorjs\"), this.config.logLevel || (this.config.logLevel = Lo.VERBOSE), Zn(this.config.logLevel), ht(!!this.config.initialBlock, \"config.initialBlock\", \"config.defaultBlock\"), this.config.defaultBlock = this.config.defaultBlock || this.config.initialBlock || \"paragraph\", this.config.minHeight = this.config.minHeight !== void 0 ? this.config.minHeight : 300;\n    const t = {\n      type: this.config.defaultBlock,\n      data: {}\n    };\n    this.config.placeholder = this.config.placeholder || !1, this.config.sanitizer = this.config.sanitizer || {\n      p: !0,\n      b: !0,\n      a: !0\n    }, this.config.hideToolbar = this.config.hideToolbar ? this.config.hideToolbar : !1, this.config.tools = this.config.tools || {}, this.config.i18n = this.config.i18n || {}, this.config.data = this.config.data || { blocks: [] }, this.config.onReady = this.config.onReady || (() => {\n    }), this.config.onChange = this.config.onChange || (() => {\n    }), this.config.inlineToolbar = this.config.inlineToolbar !== void 0 ? this.config.inlineToolbar : !0, (V(this.config.data) || !this.config.data.blocks || this.config.data.blocks.length === 0) && (this.config.data = { blocks: [t] }), this.config.readOnly = this.config.readOnly || !1, (o = this.config.i18n) != null && o.messages && z.setDictionary(this.config.i18n.messages), this.config.i18n.direction = ((i = this.config.i18n) == null ? void 0 : i.direction) || \"ltr\";\n  }\n  /**\n   * Returns private property\n   *\n   * @returns {EditorConfig}\n   */\n  get configuration() {\n    return this.config;\n  }\n  /**\n   * Checks for required fields in Editor's config\n   */\n  validate() {\n    const { holderId: e, holder: t } = this.config;\n    if (e && t)\n      throw Error(\"«holderId» and «holder» param can't assign at the same time.\");\n    if (te(t) && !d.get(t))\n      throw Error(`element with ID «${t}» is missing. Pass correct holder's ID.`);\n    if (t && D(t) && !d.isElement(t))\n      throw Error(\"«holder» value must be an Element node\");\n  }\n  /**\n   * Initializes modules:\n   *  - make and save instances\n   *  - configure\n   */\n  init() {\n    this.constructModules(), this.configureModules();\n  }\n  /**\n   * Start Editor!\n   *\n   * Get list of modules that needs to be prepared and return a sequence (Promise)\n   *\n   * @returns {Promise<void>}\n   */\n  async start() {\n    await [\n      \"Tools\",\n      \"UI\",\n      \"BlockManager\",\n      \"Paste\",\n      \"BlockSelection\",\n      \"RectangleSelection\",\n      \"CrossBlockSelection\",\n      \"ReadOnly\"\n    ].reduce(\n      (t, o) => t.then(async () => {\n        try {\n          await this.moduleInstances[o].prepare();\n        } catch (i) {\n          if (i instanceof Ho)\n            throw new Error(i.message);\n          S(`Module ${o} was skipped because of %o`, \"warn\", i);\n        }\n      }),\n      Promise.resolve()\n    );\n  }\n  /**\n   * Render initial data\n   */\n  render() {\n    return this.moduleInstances.Renderer.render(this.config.data.blocks);\n  }\n  /**\n   * Make modules instances and save it to the @property this.moduleInstances\n   */\n  constructModules() {\n    Object.entries(Oa).forEach(([e, t]) => {\n      try {\n        this.moduleInstances[e] = new t({\n          config: this.configuration,\n          eventsDispatcher: this.eventsDispatcher\n        });\n      } catch (o) {\n        S(\"[constructModules]\", `Module ${e} skipped because`, \"error\", o);\n      }\n    });\n  }\n  /**\n   * Modules instances configuration:\n   *  - pass other modules to the 'state' property\n   *  - ...\n   */\n  configureModules() {\n    for (const e in this.moduleInstances)\n      Object.prototype.hasOwnProperty.call(this.moduleInstances, e) && (this.moduleInstances[e].state = this.getModulesDiff(e));\n  }\n  /**\n   * Return modules without passed name\n   *\n   * @param {string} name - module for witch modules difference should be calculated\n   */\n  getModulesDiff(e) {\n    const t = {};\n    for (const o in this.moduleInstances)\n      o !== e && (t[o] = this.moduleInstances[o]);\n    return t;\n  }\n}\n/**\n * Editor.js\n *\n * @license Apache-2.0\n * @see Editor.js <https://editorjs.io>\n * @author CodeX Team <https://codex.so>\n */\nclass Aa {\n  /** Editor version */\n  static get version() {\n    return \"2.31.0-rc.7\";\n  }\n  /**\n   * @param {EditorConfig|string|undefined} [configuration] - user configuration\n   */\n  constructor(e) {\n    let t = () => {\n    };\n    D(e) && A(e.onReady) && (t = e.onReady);\n    const o = new _a(e);\n    this.isReady = o.isReady.then(() => {\n      this.exportAPI(o), t();\n    });\n  }\n  /**\n   * Export external API methods\n   *\n   * @param {Core} editor — Editor's instance\n   */\n  exportAPI(e) {\n    const t = [\"configuration\"], o = () => {\n      Object.values(e.moduleInstances).forEach((s) => {\n        A(s.destroy) && s.destroy(), s.listeners.removeAll();\n      }), zi(), e = null;\n      for (const s in this)\n        Object.prototype.hasOwnProperty.call(this, s) && delete this[s];\n      Object.setPrototypeOf(this, null);\n    };\n    t.forEach((s) => {\n      this[s] = e[s];\n    }), this.destroy = o, Object.setPrototypeOf(this, e.moduleInstances.API.methods), delete this.exportAPI, Object.entries({\n      blocks: {\n        clear: \"clear\",\n        render: \"render\"\n      },\n      caret: {\n        focus: \"focus\"\n      },\n      events: {\n        on: \"on\",\n        off: \"off\",\n        emit: \"emit\"\n      },\n      saver: {\n        save: \"save\"\n      }\n    }).forEach(([s, r]) => {\n      Object.entries(r).forEach(([a, l]) => {\n        this[l] = e.moduleInstances.API.methods[s][a];\n      });\n    });\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2VkaXRvcmpzL2Rpc3QvZWRpdG9yanMubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxZQUFZLGFBQWEsSUFBSSx3QkFBd0Isc0NBQXNDLDZEQUE2RCxnQkFBZ0IsdUJBQXVCLGtCQUFrQixzQkFBc0IsV0FBVyxlQUFlLGtDQUFrQyxTQUFTLG1EQUFtRDtBQUMvVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQ0FBZ0M7QUFDekM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFL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Q0EsMkRBQTJELGlCQUFpQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaUJBQWlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUhBQXVIO0FBQ3BJO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscURBQXFEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaU1BQWlNO0FBQ3JNO0FBQ0EsK0dBQStHLHFNQUFxTTtBQUNwVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw2TUFBNk07QUFDN007QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQTRDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvR0FBb0c7QUFDekc7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsVUFBVSw4R0FBOEcsVUFBVTtBQUNyTTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNB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O0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsRUFBRSxhQUFhLEVBQUU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGlCQUFpQjtBQUM5QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFD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O0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEVBQUUsR0FBRyxFQUFFO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RCxLQUFLLHVJQUF1SSw0QkFBNEI7QUFDeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtT0FBbU8sVUFBVTtBQUM3TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGFBQWE7QUFDckU7QUFDQTtBQUNBO0FBQ0EsNlBBQTZQO0FBQzdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLGtCQUFrQjtBQUN2QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFFBQVE7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9CQUFvQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLLHVCQUF1QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSyxJQUFJLGNBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVMsU0FBUyxTQUFTLFNBQVM7QUFDL0MsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVc7QUFDWCwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLDhDQUE4QztBQUM5QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCxXQUFXO0FBQ1gsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVcsU0FBUyxTQUFTO0FBQzdCLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLDRDQUE0QztBQUM1QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYO0FBQ0Esb0VBQW9FLEVBQUU7QUFDdEU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxTQUFTLHdDQUF3QyxXQUFXO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixFQUFFLGlGQUFpRixFQUFFO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsaUJBQWlCO0FBQzFDLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVyxTQUFTLFNBQVM7QUFDN0IsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCxXQUFXO0FBQ1gsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVcsU0FBUyxTQUFTO0FBQzdCLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLCtDQUErQztBQUMvQztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVcsU0FBUztBQUNwQjtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCxXQUFXO0FBQ1gsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCxXQUFXO0FBQ1gsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVcsU0FBUyxTQUFTO0FBQzdCLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHdDQUF3QztBQUN4QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCxXQUFXO0FBQ1gsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLDZDQUE2QztBQUM3QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHdDQUF3QztBQUN4QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE4QztBQUM5QztBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE4QztBQUM5QztBQUNBLEtBQUs7QUFDTDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLEtBQUs7QUFDTDtBQUNBLDRDQUE0QztBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLEtBQUs7QUFDTDtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLEtBQUs7QUFDTDtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLEtBQUs7QUFDTDtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQztBQUMvQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE4QztBQUM5QztBQUNBLEtBQUs7QUFDTDtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLEtBQUs7QUFDTDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLEtBQUs7QUFDTDtBQUNBLDBDQUEwQztBQUMxQztBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBLEtBQUs7QUFDTDtBQUNBLDJDQUEyQztBQUMzQztBQUNBLEtBQUs7QUFDTDtBQUNBLDZDQUE2QztBQUM3QztBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBLDRDQUE0QztBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQztBQUMvQztBQUNBLEtBQUs7QUFDTDtBQUNBLDRDQUE0QztBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBLHFDQUFxQztBQUNyQztBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBLHdDQUF3QztBQUN4QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVc7QUFDWCwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWEsdUNBQXVDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHNDQUFzQztBQUN0QztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCxXQUFXO0FBQ1gsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVc7QUFDWCwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHFDQUFxQztBQUNyQztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLEtBQUs7QUFDTDtBQUNBLHNDQUFzQztBQUN0QztBQUNBLEtBQUs7QUFDTDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLEtBQUs7QUFDTDtBQUNBLHlDQUF5QztBQUN6QztBQUNBLEtBQUs7QUFDTDtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLEtBQUs7QUFDTDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLEtBQUs7QUFDTDtBQUNBLHFDQUFxQztBQUNyQztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQSxZQUFZLCtDQUErQztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEIsaUJBQWlCLG9DQUFvQztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEIsaUJBQWlCLGdDQUFnQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOEJBQThCO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxhQUFhO0FBQzFCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFN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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFFBQVE7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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STtBQUNyODRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsWUFBWSxpREFBaUQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpREFBaUQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvZWRpdG9yanMvZGlzdC9lZGl0b3Jqcy5tanM/YzM1NyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt0cnl7aWYodHlwZW9mIGRvY3VtZW50PFwidVwiKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7ZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIi5jZS1oaW50LS1hbGlnbi1zdGFydHt0ZXh0LWFsaWduOmxlZnR9LmNlLWhpbnQtLWFsaWduLWNlbnRlcnt0ZXh0LWFsaWduOmNlbnRlcn0uY2UtaGludF9fZGVzY3JpcHRpb257b3BhY2l0eTouNjttYXJnaW4tdG9wOjNweH1cIikpLGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZSl9fWNhdGNoKHQpe2NvbnNvbGUuZXJyb3IoXCJ2aXRlLXBsdWdpbi1jc3MtaW5qZWN0ZWQtYnktanNcIix0KX19KSgpO1xudmFyIENlID0gdHlwZW9mIGdsb2JhbFRoaXMgPCBcInVcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsIDwgXCJ1XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA8IFwidVwiID8gc2VsZiA6IHt9O1xuZnVuY3Rpb24gS2Uobikge1xuICByZXR1cm4gbiAmJiBuLl9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIFwiZGVmYXVsdFwiKSA/IG4uZGVmYXVsdCA6IG47XG59XG5mdW5jdGlvbiBYbihuKSB7XG4gIGlmIChuLl9fZXNNb2R1bGUpXG4gICAgcmV0dXJuIG47XG4gIHZhciBlID0gbi5kZWZhdWx0O1xuICBpZiAodHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIHQgPSBmdW5jdGlvbiBvKCkge1xuICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBvID8gUmVmbGVjdC5jb25zdHJ1Y3QoZSwgYXJndW1lbnRzLCB0aGlzLmNvbnN0cnVjdG9yKSA6IGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHQucHJvdG90eXBlID0gZS5wcm90b3R5cGU7XG4gIH0gZWxzZVxuICAgIHQgPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIE9iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgIHZhciBpID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLCBvKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgbywgaS5nZXQgPyBpIDoge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbltvXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiBvdCgpIHtcbn1cbk9iamVjdC5hc3NpZ24ob3QsIHtcbiAgZGVmYXVsdDogb3QsXG4gIHJlZ2lzdGVyOiBvdCxcbiAgcmV2ZXJ0OiBmdW5jdGlvbigpIHtcbiAgfSxcbiAgX19lc01vZHVsZTogITBcbn0pO1xuRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCAoRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUub01hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZnVuY3Rpb24obikge1xuICBjb25zdCBlID0gKHRoaXMuZG9jdW1lbnQgfHwgdGhpcy5vd25lckRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKG4pO1xuICBsZXQgdCA9IGUubGVuZ3RoO1xuICBmb3IgKDsgLS10ID49IDAgJiYgZS5pdGVtKHQpICE9PSB0aGlzOyApXG4gICAgO1xuICByZXR1cm4gdCA+IC0xO1xufSk7XG5FbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0IHx8IChFbGVtZW50LnByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24obikge1xuICBsZXQgZSA9IHRoaXM7XG4gIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGUpKVxuICAgIHJldHVybiBudWxsO1xuICBkbyB7XG4gICAgaWYgKGUubWF0Y2hlcyhuKSlcbiAgICAgIHJldHVybiBlO1xuICAgIGUgPSBlLnBhcmVudEVsZW1lbnQgfHwgZS5wYXJlbnROb2RlO1xuICB9IHdoaWxlIChlICE9PSBudWxsKTtcbiAgcmV0dXJuIG51bGw7XG59KTtcbkVsZW1lbnQucHJvdG90eXBlLnByZXBlbmQgfHwgKEVsZW1lbnQucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbihlKSB7XG4gIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIEFycmF5LmlzQXJyYXkoZSkgfHwgKGUgPSBbZV0pLCBlLmZvckVhY2goKG8pID0+IHtcbiAgICBjb25zdCBpID0gbyBpbnN0YW5jZW9mIE5vZGU7XG4gICAgdC5hcHBlbmRDaGlsZChpID8gbyA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG8pKTtcbiAgfSksIHRoaXMuaW5zZXJ0QmVmb3JlKHQsIHRoaXMuZmlyc3RDaGlsZCk7XG59KTtcbkVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3SWZOZWVkZWQgfHwgKEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3SWZOZWVkZWQgPSBmdW5jdGlvbihuKSB7XG4gIG4gPSBhcmd1bWVudHMubGVuZ3RoID09PSAwID8gITAgOiAhIW47XG4gIGNvbnN0IGUgPSB0aGlzLnBhcmVudE5vZGUsIHQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlLCBudWxsKSwgbyA9IHBhcnNlSW50KHQuZ2V0UHJvcGVydHlWYWx1ZShcImJvcmRlci10b3Atd2lkdGhcIikpLCBpID0gcGFyc2VJbnQodC5nZXRQcm9wZXJ0eVZhbHVlKFwiYm9yZGVyLWxlZnQtd2lkdGhcIikpLCBzID0gdGhpcy5vZmZzZXRUb3AgLSBlLm9mZnNldFRvcCA8IGUuc2Nyb2xsVG9wLCByID0gdGhpcy5vZmZzZXRUb3AgLSBlLm9mZnNldFRvcCArIHRoaXMuY2xpZW50SGVpZ2h0IC0gbyA+IGUuc2Nyb2xsVG9wICsgZS5jbGllbnRIZWlnaHQsIGEgPSB0aGlzLm9mZnNldExlZnQgLSBlLm9mZnNldExlZnQgPCBlLnNjcm9sbExlZnQsIGwgPSB0aGlzLm9mZnNldExlZnQgLSBlLm9mZnNldExlZnQgKyB0aGlzLmNsaWVudFdpZHRoIC0gaSA+IGUuc2Nyb2xsTGVmdCArIGUuY2xpZW50V2lkdGgsIGMgPSBzICYmICFyO1xuICAocyB8fCByKSAmJiBuICYmIChlLnNjcm9sbFRvcCA9IHRoaXMub2Zmc2V0VG9wIC0gZS5vZmZzZXRUb3AgLSBlLmNsaWVudEhlaWdodCAvIDIgLSBvICsgdGhpcy5jbGllbnRIZWlnaHQgLyAyKSwgKGEgfHwgbCkgJiYgbiAmJiAoZS5zY3JvbGxMZWZ0ID0gdGhpcy5vZmZzZXRMZWZ0IC0gZS5vZmZzZXRMZWZ0IC0gZS5jbGllbnRXaWR0aCAvIDIgLSBpICsgdGhpcy5jbGllbnRXaWR0aCAvIDIpLCAocyB8fCByIHx8IGEgfHwgbCkgJiYgIW4gJiYgdGhpcy5zY3JvbGxJbnRvVmlldyhjKTtcbn0pO1xud2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2sgPSB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayB8fCBmdW5jdGlvbihuKSB7XG4gIGNvbnN0IGUgPSBEYXRlLm5vdygpO1xuICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBuKHtcbiAgICAgIGRpZFRpbWVvdXQ6ICExLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCA1MCAtIChEYXRlLm5vdygpIC0gZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCAxKTtcbn07XG53aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrID0gd2luZG93LmNhbmNlbElkbGVDYWxsYmFjayB8fCBmdW5jdGlvbihuKSB7XG4gIGNsZWFyVGltZW91dChuKTtcbn07XG5sZXQgVm4gPSAobiA9IDIxKSA9PiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KG4pKS5yZWR1Y2UoKGUsIHQpID0+ICh0ICY9IDYzLCB0IDwgMzYgPyBlICs9IHQudG9TdHJpbmcoMzYpIDogdCA8IDYyID8gZSArPSAodCAtIDI2KS50b1N0cmluZygzNikudG9VcHBlckNhc2UoKSA6IHQgPiA2MiA/IGUgKz0gXCItXCIgOiBlICs9IFwiX1wiLCBlKSwgXCJcIik7XG52YXIgTG8gPSAvKiBAX19QVVJFX18gKi8gKChuKSA9PiAobi5WRVJCT1NFID0gXCJWRVJCT1NFXCIsIG4uSU5GTyA9IFwiSU5GT1wiLCBuLldBUk4gPSBcIldBUk5cIiwgbi5FUlJPUiA9IFwiRVJST1JcIiwgbikpKExvIHx8IHt9KTtcbmNvbnN0IHkgPSB7XG4gIEJBQ0tTUEFDRTogOCxcbiAgVEFCOiA5LFxuICBFTlRFUjogMTMsXG4gIFNISUZUOiAxNixcbiAgQ1RSTDogMTcsXG4gIEFMVDogMTgsXG4gIEVTQzogMjcsXG4gIFNQQUNFOiAzMixcbiAgTEVGVDogMzcsXG4gIFVQOiAzOCxcbiAgRE9XTjogNDAsXG4gIFJJR0hUOiAzOSxcbiAgREVMRVRFOiA0NixcbiAgTUVUQTogOTEsXG4gIFNMQVNIOiAxOTFcbn0sIHFuID0ge1xuICBMRUZUOiAwLFxuICBXSEVFTDogMSxcbiAgUklHSFQ6IDIsXG4gIEJBQ0tXQVJEOiAzLFxuICBGT1JXQVJEOiA0XG59O1xuZnVuY3Rpb24gSWUobiwgZSwgdCA9IFwibG9nXCIsIG8sIGkgPSBcImNvbG9yOiBpbmhlcml0XCIpIHtcbiAgaWYgKCEoXCJjb25zb2xlXCIgaW4gd2luZG93KSB8fCAhd2luZG93LmNvbnNvbGVbdF0pXG4gICAgcmV0dXJuO1xuICBjb25zdCBzID0gW1wiaW5mb1wiLCBcImxvZ1wiLCBcIndhcm5cIiwgXCJlcnJvclwiXS5pbmNsdWRlcyh0KSwgciA9IFtdO1xuICBzd2l0Y2ggKEllLmxvZ0xldmVsKSB7XG4gICAgY2FzZSBcIkVSUk9SXCI6XG4gICAgICBpZiAodCAhPT0gXCJlcnJvclwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiV0FSTlwiOlxuICAgICAgaWYgKCFbXCJlcnJvclwiLCBcIndhcm5cIl0uaW5jbHVkZXModCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJJTkZPXCI6XG4gICAgICBpZiAoIXMgfHwgbilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgbyAmJiByLnB1c2gobyk7XG4gIGNvbnN0IGEgPSBcIkVkaXRvci5qcyAyLjMxLjAtcmMuN1wiLCBsID0gYGxpbmUtaGVpZ2h0OiAxZW07XG4gICAgICAgICAgICBjb2xvcjogIzAwNkZFQTtcbiAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTFweDtcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxZW07XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xuICAgICAgICAgICAgcGFkZGluZzogNHB4IDlweDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDMwcHg7XG4gICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDU2LCAxMzgsIDIyOSwgMC4xNik7XG4gICAgICAgICAgICBtYXJnaW46IDRweCA1cHggNHB4IDA7YDtcbiAgbiAmJiAocyA/IChyLnVuc2hpZnQobCwgaSksIGUgPSBgJWMke2F9JWMgJHtlfWApIDogZSA9IGAoICR7YX0gKSR7ZX1gKTtcbiAgdHJ5IHtcbiAgICBzID8gbyA/IGNvbnNvbGVbdF0oYCR7ZX0gJW9gLCAuLi5yKSA6IGNvbnNvbGVbdF0oZSwgLi4ucikgOiBjb25zb2xlW3RdKGUpO1xuICB9IGNhdGNoIHtcbiAgfVxufVxuSWUubG9nTGV2ZWwgPSBcIlZFUkJPU0VcIjtcbmZ1bmN0aW9uIFpuKG4pIHtcbiAgSWUubG9nTGV2ZWwgPSBuO1xufVxuY29uc3QgUyA9IEllLmJpbmQod2luZG93LCAhMSksIFggPSBJZS5iaW5kKHdpbmRvdywgITApO1xuZnVuY3Rpb24gbGUobikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG4pLm1hdGNoKC9cXHMoW2EtekEtWl0rKS8pWzFdLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBBKG4pIHtcbiAgcmV0dXJuIGxlKG4pID09PSBcImZ1bmN0aW9uXCIgfHwgbGUobikgPT09IFwiYXN5bmNmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gRChuKSB7XG4gIHJldHVybiBsZShuKSA9PT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIHRlKG4pIHtcbiAgcmV0dXJuIGxlKG4pID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gR24obikge1xuICByZXR1cm4gbGUobikgPT09IFwiYm9vbGVhblwiO1xufVxuZnVuY3Rpb24geW8obikge1xuICByZXR1cm4gbGUobikgPT09IFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiB3byhuKSB7XG4gIHJldHVybiBsZShuKSA9PT0gXCJ1bmRlZmluZWRcIjtcbn1cbmZ1bmN0aW9uIFYobikge1xuICByZXR1cm4gbiA/IE9iamVjdC5rZXlzKG4pLmxlbmd0aCA9PT0gMCAmJiBuLmNvbnN0cnVjdG9yID09PSBPYmplY3QgOiAhMDtcbn1cbmZ1bmN0aW9uIFBvKG4pIHtcbiAgcmV0dXJuIG4gPiA0NyAmJiBuIDwgNTggfHwgLy8gbnVtYmVyIGtleXNcbiAgbiA9PT0gMzIgfHwgbiA9PT0gMTMgfHwgLy8gU3BhY2UgYmFyICYgcmV0dXJuIGtleShzKVxuICBuID09PSAyMjkgfHwgLy8gcHJvY2Vzc2luZyBrZXkgaW5wdXQgZm9yIGNlcnRhaW4gbGFuZ3VhZ2VzIOKAlCBDaGluZXNlLCBKYXBhbmVzZSwgZXRjLlxuICBuID4gNjQgJiYgbiA8IDkxIHx8IC8vIGxldHRlciBrZXlzXG4gIG4gPiA5NSAmJiBuIDwgMTEyIHx8IC8vIE51bXBhZCBrZXlzXG4gIG4gPiAxODUgJiYgbiA8IDE5MyB8fCAvLyA7PSwtLi9gIChpbiBvcmRlcilcbiAgbiA+IDIxOCAmJiBuIDwgMjIzO1xufVxuYXN5bmMgZnVuY3Rpb24gUW4obiwgZSA9ICgpID0+IHtcbn0sIHQgPSAoKSA9PiB7XG59KSB7XG4gIGFzeW5jIGZ1bmN0aW9uIG8oaSwgcywgcikge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBpLmZ1bmN0aW9uKGkuZGF0YSksIGF3YWl0IHMod28oaS5kYXRhKSA/IHt9IDogaS5kYXRhKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHIod28oaS5kYXRhKSA/IHt9IDogaS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG4ucmVkdWNlKGFzeW5jIChpLCBzKSA9PiAoYXdhaXQgaSwgbyhzLCBlLCB0KSksIFByb21pc2UucmVzb2x2ZSgpKTtcbn1cbmZ1bmN0aW9uIE5vKG4pIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG4pO1xufVxuZnVuY3Rpb24gRmUobiwgZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMsIG8gPSBhcmd1bWVudHM7XG4gICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4gbi5hcHBseSh0LCBvKSwgZSk7XG4gIH07XG59XG5mdW5jdGlvbiBKbihuKSB7XG4gIHJldHVybiBuLm5hbWUuc3BsaXQoXCIuXCIpLnBvcCgpO1xufVxuZnVuY3Rpb24gZWkobikge1xuICByZXR1cm4gL15bLVxcd10rXFwvKFstK1xcd10rfFxcKikkLy50ZXN0KG4pO1xufVxuZnVuY3Rpb24gRW8obiwgZSwgdCkge1xuICBsZXQgbztcbiAgcmV0dXJuICguLi5pKSA9PiB7XG4gICAgY29uc3QgcyA9IHRoaXMsIHIgPSAoKSA9PiB7XG4gICAgICBvID0gbnVsbCwgdCB8fCBuLmFwcGx5KHMsIGkpO1xuICAgIH0sIGEgPSB0ICYmICFvO1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQobyksIG8gPSB3aW5kb3cuc2V0VGltZW91dChyLCBlKSwgYSAmJiBuLmFwcGx5KHMsIGkpO1xuICB9O1xufVxuZnVuY3Rpb24gZHQobiwgZSwgdCA9IHZvaWQgMCkge1xuICBsZXQgbywgaSwgcywgciA9IG51bGwsIGEgPSAwO1xuICB0IHx8ICh0ID0ge30pO1xuICBjb25zdCBsID0gZnVuY3Rpb24oKSB7XG4gICAgYSA9IHQubGVhZGluZyA9PT0gITEgPyAwIDogRGF0ZS5ub3coKSwgciA9IG51bGwsIHMgPSBuLmFwcGx5KG8sIGkpLCByIHx8IChvID0gaSA9IG51bGwpO1xuICB9O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgYyA9IERhdGUubm93KCk7XG4gICAgIWEgJiYgdC5sZWFkaW5nID09PSAhMSAmJiAoYSA9IGMpO1xuICAgIGNvbnN0IHUgPSBlIC0gKGMgLSBhKTtcbiAgICByZXR1cm4gbyA9IHRoaXMsIGkgPSBhcmd1bWVudHMsIHUgPD0gMCB8fCB1ID4gZSA/IChyICYmIChjbGVhclRpbWVvdXQociksIHIgPSBudWxsKSwgYSA9IGMsIHMgPSBuLmFwcGx5KG8sIGkpLCByIHx8IChvID0gaSA9IG51bGwpKSA6ICFyICYmIHQudHJhaWxpbmcgIT09ICExICYmIChyID0gc2V0VGltZW91dChsLCB1KSksIHM7XG4gIH07XG59XG5mdW5jdGlvbiB0aSgpIHtcbiAgY29uc3QgbiA9IHtcbiAgICB3aW46ICExLFxuICAgIG1hYzogITEsXG4gICAgeDExOiAhMSxcbiAgICBsaW51eDogITFcbiAgfSwgZSA9IE9iamVjdC5rZXlzKG4pLmZpbmQoKHQpID0+IHdpbmRvdy5uYXZpZ2F0b3IuYXBwVmVyc2lvbi50b0xvd2VyQ2FzZSgpLmluZGV4T2YodCkgIT09IC0xKTtcbiAgcmV0dXJuIGUgJiYgKG5bZV0gPSAhMCksIG47XG59XG5mdW5jdGlvbiBqZShuKSB7XG4gIHJldHVybiBuWzBdLnRvVXBwZXJDYXNlKCkgKyBuLnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gdXQobiwgLi4uZSkge1xuICBpZiAoIWUubGVuZ3RoKVxuICAgIHJldHVybiBuO1xuICBjb25zdCB0ID0gZS5zaGlmdCgpO1xuICBpZiAoRChuKSAmJiBEKHQpKVxuICAgIGZvciAoY29uc3QgbyBpbiB0KVxuICAgICAgRCh0W29dKSA/IChuW29dIHx8IE9iamVjdC5hc3NpZ24obiwgeyBbb106IHt9IH0pLCB1dChuW29dLCB0W29dKSkgOiBPYmplY3QuYXNzaWduKG4sIHsgW29dOiB0W29dIH0pO1xuICByZXR1cm4gdXQobiwgLi4uZSk7XG59XG5mdW5jdGlvbiB2dChuKSB7XG4gIGNvbnN0IGUgPSB0aSgpO1xuICByZXR1cm4gbiA9IG4ucmVwbGFjZSgvc2hpZnQvZ2ksIFwi4oenXCIpLnJlcGxhY2UoL2JhY2tzcGFjZS9naSwgXCLijKtcIikucmVwbGFjZSgvZW50ZXIvZ2ksIFwi4o+OXCIpLnJlcGxhY2UoL3VwL2dpLCBcIuKGkVwiKS5yZXBsYWNlKC9sZWZ0L2dpLCBcIuKGklwiKS5yZXBsYWNlKC9kb3duL2dpLCBcIuKGk1wiKS5yZXBsYWNlKC9yaWdodC9naSwgXCLihpBcIikucmVwbGFjZSgvZXNjYXBlL2dpLCBcIuKOi1wiKS5yZXBsYWNlKC9pbnNlcnQvZ2ksIFwiSW5zXCIpLnJlcGxhY2UoL2RlbGV0ZS9naSwgXCLikKFcIikucmVwbGFjZSgvXFwrL2dpLCBcIiArIFwiKSwgZS5tYWMgPyBuID0gbi5yZXBsYWNlKC9jdHJsfGNtZC9naSwgXCLijJhcIikucmVwbGFjZSgvYWx0L2dpLCBcIuKMpVwiKSA6IG4gPSBuLnJlcGxhY2UoL2NtZC9naSwgXCJDdHJsXCIpLnJlcGxhY2UoL3dpbmRvd3MvZ2ksIFwiV0lOXCIpLCBuO1xufVxuZnVuY3Rpb24gb2kobikge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgVVJMKG4pLmhyZWY7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBuLnN1YnN0cmluZygwLCAyKSA9PT0gXCIvL1wiID8gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgbiA6IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyBuO1xufVxuZnVuY3Rpb24gbmkoKSB7XG4gIHJldHVybiBWbigxMCk7XG59XG5mdW5jdGlvbiBpaShuKSB7XG4gIHdpbmRvdy5vcGVuKG4sIFwiX2JsYW5rXCIpO1xufVxuZnVuY3Rpb24gc2kobiA9IFwiXCIpIHtcbiAgcmV0dXJuIGAke259JHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTgpLnRvU3RyaW5nKDE2KX1gO1xufVxuZnVuY3Rpb24gaHQobiwgZSwgdCkge1xuICBjb25zdCBvID0gYMKrJHtlfcK7IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBQbGVhc2UgdXNlIHRoZSDCqyR7dH3CuyBpbnN0ZWFkLmA7XG4gIG4gJiYgWChvLCBcIndhcm5cIik7XG59XG5mdW5jdGlvbiBtZShuLCBlLCB0KSB7XG4gIGNvbnN0IG8gPSB0LnZhbHVlID8gXCJ2YWx1ZVwiIDogXCJnZXRcIiwgaSA9IHRbb10sIHMgPSBgIyR7ZX1DYWNoZWA7XG4gIGlmICh0W29dID0gZnVuY3Rpb24oLi4ucikge1xuICAgIHJldHVybiB0aGlzW3NdID09PSB2b2lkIDAgJiYgKHRoaXNbc10gPSBpLmFwcGx5KHRoaXMsIC4uLnIpKSwgdGhpc1tzXTtcbiAgfSwgbyA9PT0gXCJnZXRcIiAmJiB0LnNldCkge1xuICAgIGNvbnN0IHIgPSB0LnNldDtcbiAgICB0LnNldCA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIGRlbGV0ZSBuW3NdLCByLmFwcGx5KHRoaXMsIGEpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5jb25zdCBSbyA9IDY1MDtcbmZ1bmN0aW9uIGJlKCkge1xuICByZXR1cm4gd2luZG93Lm1hdGNoTWVkaWEoYChtYXgtd2lkdGg6ICR7Um99cHgpYCkubWF0Y2hlcztcbn1cbmNvbnN0IHB0ID0gdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSAmJiAoL2lQKGFkfGhvbmV8b2QpLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0pIHx8IHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0gPT09IFwiTWFjSW50ZWxcIiAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMSk7XG5mdW5jdGlvbiByaShuLCBlKSB7XG4gIGNvbnN0IHQgPSBBcnJheS5pc0FycmF5KG4pIHx8IEQobiksIG8gPSBBcnJheS5pc0FycmF5KGUpIHx8IEQoZSk7XG4gIHJldHVybiB0IHx8IG8gPyBKU09OLnN0cmluZ2lmeShuKSA9PT0gSlNPTi5zdHJpbmdpZnkoZSkgOiBuID09PSBlO1xufVxuY2xhc3MgZCB7XG4gIC8qKlxuICAgKiBDaGVjayBpZiBwYXNzZWQgdGFnIGhhcyBubyBjbG9zZWQgdGFnXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhZyAtIGVsZW1lbnQgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNTaW5nbGVUYWcoZSkge1xuICAgIHJldHVybiBlLnRhZ05hbWUgJiYgW1xuICAgICAgXCJBUkVBXCIsXG4gICAgICBcIkJBU0VcIixcbiAgICAgIFwiQlJcIixcbiAgICAgIFwiQ09MXCIsXG4gICAgICBcIkNPTU1BTkRcIixcbiAgICAgIFwiRU1CRURcIixcbiAgICAgIFwiSFJcIixcbiAgICAgIFwiSU1HXCIsXG4gICAgICBcIklOUFVUXCIsXG4gICAgICBcIktFWUdFTlwiLFxuICAgICAgXCJMSU5LXCIsXG4gICAgICBcIk1FVEFcIixcbiAgICAgIFwiUEFSQU1cIixcbiAgICAgIFwiU09VUkNFXCIsXG4gICAgICBcIlRSQUNLXCIsXG4gICAgICBcIldCUlwiXG4gICAgXS5pbmNsdWRlcyhlLnRhZ05hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBlbGVtZW50IGlzIEJSIG9yIFdCUlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0xpbmVCcmVha1RhZyhlKSB7XG4gICAgcmV0dXJuIGUgJiYgZS50YWdOYW1lICYmIFtcbiAgICAgIFwiQlJcIixcbiAgICAgIFwiV0JSXCJcbiAgICBdLmluY2x1ZGVzKGUudGFnTmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEhlbHBlciBmb3IgbWFraW5nIEVsZW1lbnRzIHdpdGggY2xhc3MgbmFtZSBhbmQgYXR0cmlidXRlc1xuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZ05hbWUgLSBuZXcgRWxlbWVudCB0YWcgbmFtZVxuICAgKiBAcGFyYW0gIHtzdHJpbmdbXXxzdHJpbmd9IFtjbGFzc05hbWVzXSAtIGxpc3Qgb3IgbmFtZSBvZiBDU1MgY2xhc3MgbmFtZShzKVxuICAgKiBAcGFyYW0gIHtvYmplY3R9IFthdHRyaWJ1dGVzXSAtIGFueSBhdHRyaWJ1dGVzXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIHN0YXRpYyBtYWtlKGUsIHQgPSBudWxsLCBvID0ge30pIHtcbiAgICBjb25zdCBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgY29uc3QgcyA9IHQuZmlsdGVyKChyKSA9PiByICE9PSB2b2lkIDApO1xuICAgICAgaS5jbGFzc0xpc3QuYWRkKC4uLnMpO1xuICAgIH0gZWxzZVxuICAgICAgdCAmJiBpLmNsYXNzTGlzdC5hZGQodCk7XG4gICAgZm9yIChjb25zdCBzIGluIG8pXG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcykgJiYgKGlbc10gPSBvW3NdKTtcbiAgICByZXR1cm4gaTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBUZXh0IE5vZGUgd2l0aCB0aGUgcGFzc2VkIGNvbnRlbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgLSB0ZXh0IGNvbnRlbnRcbiAgICogQHJldHVybnMge1RleHR9XG4gICAqL1xuICBzdGF0aWMgdGV4dChlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBBcHBlbmQgb25lIG9yIHNldmVyYWwgZWxlbWVudHMgdG8gdGhlIHBhcmVudFxuICAgKlxuICAgKiBAcGFyYW0gIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IHBhcmVudCAtIHdoZXJlIHRvIGFwcGVuZFxuICAgKiBAcGFyYW0gIHtFbGVtZW50fEVsZW1lbnRbXXxEb2N1bWVudEZyYWdtZW50fFRleHR8VGV4dFtdfSBlbGVtZW50cyAtIGVsZW1lbnQgb3IgZWxlbWVudHMgbGlzdFxuICAgKi9cbiAgc3RhdGljIGFwcGVuZChlLCB0KSB7XG4gICAgQXJyYXkuaXNBcnJheSh0KSA/IHQuZm9yRWFjaCgobykgPT4gZS5hcHBlbmRDaGlsZChvKSkgOiBlLmFwcGVuZENoaWxkKHQpO1xuICB9XG4gIC8qKlxuICAgKiBBcHBlbmQgZWxlbWVudCBvciBhIGNvdXBsZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwYXJlbnQgZWxlbWVudHNcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnQgLSB3aGVyZSB0byBhcHBlbmRcbiAgICogQHBhcmFtIHtFbGVtZW50fEVsZW1lbnRbXX0gZWxlbWVudHMgLSBlbGVtZW50IG9yIGVsZW1lbnRzIGxpc3RcbiAgICovXG4gIHN0YXRpYyBwcmVwZW5kKGUsIHQpIHtcbiAgICBBcnJheS5pc0FycmF5KHQpID8gKHQgPSB0LnJldmVyc2UoKSwgdC5mb3JFYWNoKChvKSA9PiBlLnByZXBlbmQobykpKSA6IGUucHJlcGVuZCh0KTtcbiAgfVxuICAvKipcbiAgICogU3dhcCB0d28gZWxlbWVudHMgaW4gcGFyZW50XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsMSAtIGZyb21cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwyIC0gdG9cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHN0YXRpYyBzd2FwKGUsIHQpIHtcbiAgICBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgaSA9IGUucGFyZW50Tm9kZTtcbiAgICBpLmluc2VydEJlZm9yZShvLCBlKSwgaS5pbnNlcnRCZWZvcmUoZSwgdCksIGkuaW5zZXJ0QmVmb3JlKHQsIG8pLCBpLnJlbW92ZUNoaWxkKG8pO1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3RvciBEZWNvcmF0b3JcbiAgICpcbiAgICogUmV0dXJucyBmaXJzdCBtYXRjaFxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsIC0gZWxlbWVudCB3ZSBzZWFyY2hpbmcgaW5zaWRlLiBEZWZhdWx0IC0gRE9NIERvY3VtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciAtIHNlYXJjaGluZyBzdHJpbmdcbiAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAqL1xuICBzdGF0aWMgZmluZChlID0gZG9jdW1lbnQsIHQpIHtcbiAgICByZXR1cm4gZS5xdWVyeVNlbGVjdG9yKHQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgRWxlbWVudCBieSBJZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBpZCB0byBmaW5kXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuICBzdGF0aWMgZ2V0KGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbGVjdG9yIERlY29yYXRvci5cbiAgICpcbiAgICogUmV0dXJucyBhbGwgbWF0Y2hlc1xuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnR9IGVsIC0gZWxlbWVudCB3ZSBzZWFyY2hpbmcgaW5zaWRlLiBEZWZhdWx0IC0gRE9NIERvY3VtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciAtIHNlYXJjaGluZyBzdHJpbmdcbiAgICogQHJldHVybnMge05vZGVMaXN0fVxuICAgKi9cbiAgc3RhdGljIGZpbmRBbGwoZSA9IGRvY3VtZW50LCB0KSB7XG4gICAgcmV0dXJuIGUucXVlcnlTZWxlY3RvckFsbCh0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBDU1Mgc2VsZWN0b3IgZm9yIGFsbCB0ZXh0IGlucHV0c1xuICAgKi9cbiAgc3RhdGljIGdldCBhbGxJbnB1dHNTZWxlY3RvcigpIHtcbiAgICByZXR1cm4gXCJbY29udGVudGVkaXRhYmxlPXRydWVdLCB0ZXh0YXJlYSwgaW5wdXQ6bm90KFt0eXBlXSksIFwiICsgW1widGV4dFwiLCBcInBhc3N3b3JkXCIsIFwiZW1haWxcIiwgXCJudW1iZXJcIiwgXCJzZWFyY2hcIiwgXCJ0ZWxcIiwgXCJ1cmxcIl0ubWFwKCh0KSA9PiBgaW5wdXRbdHlwZT1cIiR7dH1cIl1gKS5qb2luKFwiLCBcIik7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgYWxsIGNvbnRlbnRlZGl0YWJsZSwgdGV4dGFyZWEgYW5kIGVkaXRhYmxlIGlucHV0IGVsZW1lbnRzIHBhc3NlZCBob2xkZXIgY29udGFpbnNcbiAgICpcbiAgICogQHBhcmFtIGhvbGRlciAtIGVsZW1lbnQgd2hlcmUgdG8gZmluZCBpbnB1dHNcbiAgICovXG4gIHN0YXRpYyBmaW5kQWxsSW5wdXRzKGUpIHtcbiAgICByZXR1cm4gTm8oZS5xdWVyeVNlbGVjdG9yQWxsKGQuYWxsSW5wdXRzU2VsZWN0b3IpKS5yZWR1Y2UoKHQsIG8pID0+IGQuaXNOYXRpdmVJbnB1dChvKSB8fCBkLmNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzKG8pID8gWy4uLnQsIG9dIDogWy4uLnQsIC4uLmQuZ2V0RGVlcGVzdEJsb2NrRWxlbWVudHMobyldLCBbXSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlYXJjaCBmb3IgZGVlcGVzdCBub2RlIHdoaWNoIGlzIExlYWYuXG4gICAqIExlYWYgaXMgdGhlIHZlcnRleCB0aGF0IGRvZXNuJ3QgaGF2ZSBhbnkgY2hpbGQgbm9kZXNcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCByZWN1cnNpdmVseSBnb2VzIHRocm93IHRoZSBhbGwgTm9kZSB1bnRpbCBpdCBmaW5kcyB0aGUgTGVhZlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSByb290IE5vZGUuIEZyb20gdGhpcyB2ZXJ0ZXggd2Ugc3RhcnQgRGVlcC1maXJzdCBzZWFyY2hcbiAgICogICAgICAgICAgICAgICAgICAgICAge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RlcHRoLWZpcnN0X3NlYXJjaH1cbiAgICogQHBhcmFtIHtib29sZWFufSBbYXRMYXN0XSAtIGZpbmQgbGFzdCB0ZXh0IG5vZGVcbiAgICogQHJldHVybnMgLSBpdCBjYW4gYmUgdGV4dCBOb2RlIG9yIEVsZW1lbnQgTm9kZSwgc28gdGhhdCBjYXJldCB3aWxsIGFibGUgdG8gd29yayB3aXRoIGl0XG4gICAqICAgICAgICAgICAgQ2FuIHJldHVybiBudWxsIGlmIG5vZGUgaXMgRG9jdW1lbnQgb3IgRG9jdW1lbnRGcmFnbWVudCwgb3Igbm9kZSBpcyBub3QgYXR0YWNoZWQgdG8gdGhlIERPTVxuICAgKi9cbiAgc3RhdGljIGdldERlZXBlc3ROb2RlKGUsIHQgPSAhMSkge1xuICAgIGNvbnN0IG8gPSB0ID8gXCJsYXN0Q2hpbGRcIiA6IFwiZmlyc3RDaGlsZFwiLCBpID0gdCA/IFwicHJldmlvdXNTaWJsaW5nXCIgOiBcIm5leHRTaWJsaW5nXCI7XG4gICAgaWYgKGUgJiYgZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgZVtvXSkge1xuICAgICAgbGV0IHMgPSBlW29dO1xuICAgICAgaWYgKGQuaXNTaW5nbGVUYWcocykgJiYgIWQuaXNOYXRpdmVJbnB1dChzKSAmJiAhZC5pc0xpbmVCcmVha1RhZyhzKSlcbiAgICAgICAgaWYgKHNbaV0pXG4gICAgICAgICAgcyA9IHNbaV07XG4gICAgICAgIGVsc2UgaWYgKHMucGFyZW50Tm9kZVtpXSlcbiAgICAgICAgICBzID0gcy5wYXJlbnROb2RlW2ldO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIHMucGFyZW50Tm9kZTtcbiAgICAgIHJldHVybiB0aGlzLmdldERlZXBlc3ROb2RlKHMsIHQpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgb2JqZWN0IGlzIERPTSBub2RlXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gbm9kZSAtIG9iamVjdCB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIHN0YXRpYyBpc0VsZW1lbnQoZSkge1xuICAgIHJldHVybiB5byhlKSA/ICExIDogZSAmJiBlLm5vZGVUeXBlICYmIGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBvYmplY3QgaXMgRG9jdW1lbnRGcmFnbWVudCBub2RlXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBub2RlIC0gb2JqZWN0IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgc3RhdGljIGlzRnJhZ21lbnQoZSkge1xuICAgIHJldHVybiB5byhlKSA/ICExIDogZSAmJiBlLm5vZGVUeXBlICYmIGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgcGFzc2VkIGVsZW1lbnQgaXMgY29udGVudGVkaXRhYmxlXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBodG1sIGVsZW1lbnQgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNDb250ZW50RWRpdGFibGUoZSkge1xuICAgIHJldHVybiBlLmNvbnRlbnRFZGl0YWJsZSA9PT0gXCJ0cnVlXCI7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB0YXJnZXQgaWYgaXQgaXMgbmF0aXZlIGlucHV0XG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IC0gSFRNTCBlbGVtZW50IG9yIHN0cmluZ1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIHN0YXRpYyBpc05hdGl2ZUlucHV0KGUpIHtcbiAgICBjb25zdCB0ID0gW1xuICAgICAgXCJJTlBVVFwiLFxuICAgICAgXCJURVhUQVJFQVwiXG4gICAgXTtcbiAgICByZXR1cm4gZSAmJiBlLnRhZ05hbWUgPyB0LmluY2x1ZGVzKGUudGFnTmFtZSkgOiAhMTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHdlIGNhbiBzZXQgY2FyZXRcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gdGFyZ2V0IHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGNhblNldENhcmV0KGUpIHtcbiAgICBsZXQgdCA9ICEwO1xuICAgIGlmIChkLmlzTmF0aXZlSW5wdXQoZSkpXG4gICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgICBjYXNlIFwiY2hlY2tib3hcIjpcbiAgICAgICAgY2FzZSBcInJhZGlvXCI6XG4gICAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgICAgY2FzZSBcInN1Ym1pdFwiOlxuICAgICAgICBjYXNlIFwiYnV0dG9uXCI6XG4gICAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgICBjYXNlIFwicmVzZXRcIjpcbiAgICAgICAgICB0ID0gITE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgdCA9IGQuaXNDb250ZW50RWRpdGFibGUoZSk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBub2RlIGlmIGl0IGlzIGVtcHR5XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgY2hlY2tzIHNpbXBsZSBOb2RlIHdpdGhvdXQgYW55IGNoaWxkcyBmb3IgZW1wdGluZXNzXG4gICAqIElmIHlvdSBoYXZlIE5vZGUgd2l0aCAyIG9yIG1vcmUgY2hpbGRyZW4gaWQgZGVwdGgsIHlvdSBiZXR0ZXIgdXNlIHtAbGluayBEb20jaXNFbXB0eX0gbWV0aG9kXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIG5vZGUgdG8gY2hlY2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtpZ25vcmVDaGFyc10gLSBjaGFyIG9yIHN1YnN0cmluZyB0byB0cmVhdCBhcyBlbXB0eVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBpdCBpcyBlbXB0eVxuICAgKi9cbiAgc3RhdGljIGlzTm9kZUVtcHR5KGUsIHQpIHtcbiAgICBsZXQgbztcbiAgICByZXR1cm4gdGhpcy5pc1NpbmdsZVRhZyhlKSAmJiAhdGhpcy5pc0xpbmVCcmVha1RhZyhlKSA/ICExIDogKHRoaXMuaXNFbGVtZW50KGUpICYmIHRoaXMuaXNOYXRpdmVJbnB1dChlKSA/IG8gPSBlLnZhbHVlIDogbyA9IGUudGV4dENvbnRlbnQucmVwbGFjZShcIuKAi1wiLCBcIlwiKSwgdCAmJiAobyA9IG8ucmVwbGFjZShuZXcgUmVnRXhwKHQsIFwiZ1wiKSwgXCJcIikpLCBvLmxlbmd0aCA9PT0gMCk7XG4gIH1cbiAgLyoqXG4gICAqIGNoZWNrcyBub2RlIGlmIGl0IGlzIGRvZXNuJ3QgaGF2ZSBhbnkgY2hpbGQgbm9kZXNcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gbm9kZSB0byBjaGVja1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0xlYWYoZSkge1xuICAgIHJldHVybiBlID8gZS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCA6ICExO1xuICB9XG4gIC8qKlxuICAgKiBicmVhZHRoLWZpcnN0IHNlYXJjaCAoQkZTKVxuICAgKiB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJlYWR0aC1maXJzdF9zZWFyY2h9XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvbiBQdXNoZXMgdG8gc3RhY2sgYWxsIERPTSBsZWFmcyBhbmQgY2hlY2tzIGZvciBlbXB0aW5lc3NcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gbm9kZSB0byBjaGVja1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2lnbm9yZUNoYXJzXSAtIGNoYXIgb3Igc3Vic3RyaW5nIHRvIHRyZWF0IGFzIGVtcHR5XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRW1wdHkoZSwgdCkge1xuICAgIGNvbnN0IG8gPSBbZV07XG4gICAgZm9yICg7IG8ubGVuZ3RoID4gMDsgKVxuICAgICAgaWYgKGUgPSBvLnNoaWZ0KCksICEhZSkge1xuICAgICAgICBpZiAodGhpcy5pc0xlYWYoZSkgJiYgIXRoaXMuaXNOb2RlRW1wdHkoZSwgdCkpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICBlLmNoaWxkTm9kZXMgJiYgby5wdXNoKC4uLkFycmF5LmZyb20oZS5jaGlsZE5vZGVzKSk7XG4gICAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBzdHJpbmcgY29udGFpbnMgaHRtbCBlbGVtZW50c1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gc3RyaW5nIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzSFRNTFN0cmluZyhlKSB7XG4gICAgY29uc3QgdCA9IGQubWFrZShcImRpdlwiKTtcbiAgICByZXR1cm4gdC5pbm5lckhUTUwgPSBlLCB0LmNoaWxkRWxlbWVudENvdW50ID4gMDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGxlbmd0aCBvZiBub2RlYHMgdGV4dCBjb250ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIG5vZGUgd2l0aCBjb250ZW50XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0Q29udGVudExlbmd0aChlKSB7XG4gICAgcmV0dXJuIGQuaXNOYXRpdmVJbnB1dChlKSA/IGUudmFsdWUubGVuZ3RoIDogZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgPyBlLmxlbmd0aCA6IGUudGV4dENvbnRlbnQubGVuZ3RoO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYXJyYXkgb2YgbmFtZXMgb2YgYmxvY2sgaHRtbCBlbGVtZW50c1xuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAqL1xuICBzdGF0aWMgZ2V0IGJsb2NrRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiYWRkcmVzc1wiLFxuICAgICAgXCJhcnRpY2xlXCIsXG4gICAgICBcImFzaWRlXCIsXG4gICAgICBcImJsb2NrcXVvdGVcIixcbiAgICAgIFwiY2FudmFzXCIsXG4gICAgICBcImRpdlwiLFxuICAgICAgXCJkbFwiLFxuICAgICAgXCJkdFwiLFxuICAgICAgXCJmaWVsZHNldFwiLFxuICAgICAgXCJmaWdjYXB0aW9uXCIsXG4gICAgICBcImZpZ3VyZVwiLFxuICAgICAgXCJmb290ZXJcIixcbiAgICAgIFwiZm9ybVwiLFxuICAgICAgXCJoMVwiLFxuICAgICAgXCJoMlwiLFxuICAgICAgXCJoM1wiLFxuICAgICAgXCJoNFwiLFxuICAgICAgXCJoNVwiLFxuICAgICAgXCJoNlwiLFxuICAgICAgXCJoZWFkZXJcIixcbiAgICAgIFwiaGdyb3VwXCIsXG4gICAgICBcImhyXCIsXG4gICAgICBcImxpXCIsXG4gICAgICBcIm1haW5cIixcbiAgICAgIFwibmF2XCIsXG4gICAgICBcIm5vc2NyaXB0XCIsXG4gICAgICBcIm9sXCIsXG4gICAgICBcIm91dHB1dFwiLFxuICAgICAgXCJwXCIsXG4gICAgICBcInByZVwiLFxuICAgICAgXCJydWJ5XCIsXG4gICAgICBcInNlY3Rpb25cIixcbiAgICAgIFwidGFibGVcIixcbiAgICAgIFwidGJvZHlcIixcbiAgICAgIFwidGhlYWRcIixcbiAgICAgIFwidHJcIixcbiAgICAgIFwidGZvb3RcIixcbiAgICAgIFwidWxcIixcbiAgICAgIFwidmlkZW9cIlxuICAgIF07XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCBjb250ZW50IGluY2x1ZGVzIG9ubHkgaW5saW5lIGVsZW1lbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxFbGVtZW50fSBkYXRhIC0gZWxlbWVudCBvciBodG1sIHN0cmluZ1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBjb250YWluc09ubHlJbmxpbmVFbGVtZW50cyhlKSB7XG4gICAgbGV0IHQ7XG4gICAgdGUoZSkgPyAodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHQuaW5uZXJIVE1MID0gZSkgOiB0ID0gZTtcbiAgICBjb25zdCBvID0gKGkpID0+ICFkLmJsb2NrRWxlbWVudHMuaW5jbHVkZXMoaS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICYmIEFycmF5LmZyb20oaS5jaGlsZHJlbikuZXZlcnkobyk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odC5jaGlsZHJlbikuZXZlcnkobyk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgYW5kIHJldHVybiBhbGwgYmxvY2sgZWxlbWVudHMgaW4gdGhlIHBhc3NlZCBwYXJlbnQgKGluY2x1ZGluZyBzdWJ0cmVlKVxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnQgLSByb290IGVsZW1lbnRcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50W119XG4gICAqL1xuICBzdGF0aWMgZ2V0RGVlcGVzdEJsb2NrRWxlbWVudHMoZSkge1xuICAgIHJldHVybiBkLmNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzKGUpID8gW2VdIDogQXJyYXkuZnJvbShlLmNoaWxkcmVuKS5yZWR1Y2UoKHQsIG8pID0+IFsuLi50LCAuLi5kLmdldERlZXBlc3RCbG9ja0VsZW1lbnRzKG8pXSwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgZm9yIGdldCBob2xkZXIgZnJvbSB7c3RyaW5nfSBvciByZXR1cm4gSFRNTEVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBIVE1MRWxlbWVudH0gZWxlbWVudCAtIGhvbGRlcidzIGlkIG9yIGhvbGRlcidzIEhUTUwgRWxlbWVudFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBzdGF0aWMgZ2V0SG9sZGVyKGUpIHtcbiAgICByZXR1cm4gdGUoZSkgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlKSA6IGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBlbGVtZW50IGlzIGFuY2hvciAoaXMgQSB0YWcpXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gY2hlY2tcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNBbmNob3IoZSkge1xuICAgIHJldHVybiBlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJhXCI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBlbGVtZW50J3Mgb2Zmc2V0IHJlbGF0ZWQgdG8gdGhlIGRvY3VtZW50XG4gICAqXG4gICAqIEB0b2RvIGhhbmRsZSBjYXNlIHdoZW4gZWRpdG9yIGluaXRpYWxpemVkIGluIHNjcm9sbGFibGUgcG9wdXBcbiAgICogQHBhcmFtIGVsIC0gZWxlbWVudCB0byBjb21wdXRlIG9mZnNldFxuICAgKi9cbiAgc3RhdGljIG9mZnNldChlKSB7XG4gICAgY29uc3QgdCA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG8gPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsIGkgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCwgcyA9IHQudG9wICsgaSwgciA9IHQubGVmdCArIG87XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogcyxcbiAgICAgIGxlZnQ6IHIsXG4gICAgICBib3R0b206IHMgKyB0LmhlaWdodCxcbiAgICAgIHJpZ2h0OiByICsgdC53aWR0aFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGFpKG4pIHtcbiAgcmV0dXJuICEvW15cXHRcXG5cXHIgXS8udGVzdChuKTtcbn1cbmZ1bmN0aW9uIGxpKG4pIHtcbiAgY29uc3QgZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG4pLCB0ID0gcGFyc2VGbG9hdChlLmZvbnRTaXplKSwgbyA9IHBhcnNlRmxvYXQoZS5saW5lSGVpZ2h0KSB8fCB0ICogMS4yLCBpID0gcGFyc2VGbG9hdChlLnBhZGRpbmdUb3ApLCBzID0gcGFyc2VGbG9hdChlLmJvcmRlclRvcFdpZHRoKSwgciA9IHBhcnNlRmxvYXQoZS5tYXJnaW5Ub3ApLCBhID0gdCAqIDAuOCwgbCA9IChvIC0gdCkgLyAyO1xuICByZXR1cm4gciArIHMgKyBpICsgbCArIGE7XG59XG5mdW5jdGlvbiBEbyhuKSB7XG4gIG4uZGF0YXNldC5lbXB0eSA9IGQuaXNFbXB0eShuKSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiO1xufVxuY29uc3QgY2kgPSB7XG4gIGJsb2NrVHVuZXM6IHtcbiAgICB0b2dnbGVyOiB7XG4gICAgICBcIkNsaWNrIHRvIHR1bmVcIjogXCJcIixcbiAgICAgIFwib3IgZHJhZyB0byBtb3ZlXCI6IFwiXCJcbiAgICB9XG4gIH0sXG4gIGlubGluZVRvb2xiYXI6IHtcbiAgICBjb252ZXJ0ZXI6IHtcbiAgICAgIFwiQ29udmVydCB0b1wiOiBcIlwiXG4gICAgfVxuICB9LFxuICB0b29sYmFyOiB7XG4gICAgdG9vbGJveDoge1xuICAgICAgQWRkOiBcIlwiXG4gICAgfVxuICB9LFxuICBwb3BvdmVyOiB7XG4gICAgRmlsdGVyOiBcIlwiLFxuICAgIFwiTm90aGluZyBmb3VuZFwiOiBcIlwiLFxuICAgIFwiQ29udmVydCB0b1wiOiBcIlwiXG4gIH1cbn0sIGRpID0ge1xuICBUZXh0OiBcIlwiLFxuICBMaW5rOiBcIlwiLFxuICBCb2xkOiBcIlwiLFxuICBJdGFsaWM6IFwiXCJcbn0sIHVpID0ge1xuICBsaW5rOiB7XG4gICAgXCJBZGQgYSBsaW5rXCI6IFwiXCJcbiAgfSxcbiAgc3R1Yjoge1xuICAgIFwiVGhlIGJsb2NrIGNhbiBub3QgYmUgZGlzcGxheWVkIGNvcnJlY3RseS5cIjogXCJcIlxuICB9XG59LCBoaSA9IHtcbiAgZGVsZXRlOiB7XG4gICAgRGVsZXRlOiBcIlwiLFxuICAgIFwiQ2xpY2sgdG8gZGVsZXRlXCI6IFwiXCJcbiAgfSxcbiAgbW92ZVVwOiB7XG4gICAgXCJNb3ZlIHVwXCI6IFwiXCJcbiAgfSxcbiAgbW92ZURvd246IHtcbiAgICBcIk1vdmUgZG93blwiOiBcIlwiXG4gIH1cbn0sIEZvID0ge1xuICB1aTogY2ksXG4gIHRvb2xOYW1lczogZGksXG4gIHRvb2xzOiB1aSxcbiAgYmxvY2tUdW5lczogaGlcbn0sIGpvID0gY2xhc3MgaGUge1xuICAvKipcbiAgICogVHlwZS1zYWZlIHRyYW5zbGF0aW9uIGZvciBpbnRlcm5hbCBVSSB0ZXh0czpcbiAgICogUGVyZm9ybSB0cmFuc2xhdGlvbiBvZiB0aGUgc3RyaW5nIGJ5IG5hbWVzcGFjZSBhbmQgYSBrZXlcbiAgICpcbiAgICogQGV4YW1wbGUgSTE4bi51aShJMThuSW50ZXJuYWxOUy51aS5ibG9ja1R1bmVzLnRvZ2dsZXIsICdDbGljayB0byB0dW5lJylcbiAgICogQHBhcmFtIGludGVybmFsTmFtZXNwYWNlIC0gcGF0aCB0byB0cmFuc2xhdGVkIHN0cmluZyBpbiBkaWN0aW9uYXJ5XG4gICAqIEBwYXJhbSBkaWN0S2V5IC0gZGljdGlvbmFyeSBrZXkuIEJldHRlciB0byB1c2UgZGVmYXVsdCBsb2NhbGUgb3JpZ2luYWwgdGV4dFxuICAgKi9cbiAgc3RhdGljIHVpKGUsIHQpIHtcbiAgICByZXR1cm4gaGUuX3QoZSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZSBmb3IgZXh0ZXJuYWwgc3RyaW5ncyB0aGF0IGlzIG5vdCBwcmVzZW50ZWQgaW4gZGVmYXVsdCBkaWN0aW9uYXJ5LlxuICAgKiBGb3IgZXhhbXBsZSwgZm9yIHVzZXItc3BlY2lmaWVkIHRvb2wgbmFtZXNcbiAgICpcbiAgICogQHBhcmFtIG5hbWVzcGFjZSAtIHBhdGggdG8gdHJhbnNsYXRlZCBzdHJpbmcgaW4gZGljdGlvbmFyeVxuICAgKiBAcGFyYW0gZGljdEtleSAtIGRpY3Rpb25hcnkga2V5LiBCZXR0ZXIgdG8gdXNlIGRlZmF1bHQgbG9jYWxlIG9yaWdpbmFsIHRleHRcbiAgICovXG4gIHN0YXRpYyB0KGUsIHQpIHtcbiAgICByZXR1cm4gaGUuX3QoZSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkanVzdCBtb2R1bGUgZm9yIHVzaW5nIGV4dGVybmFsIGRpY3Rpb25hcnlcbiAgICpcbiAgICogQHBhcmFtIGRpY3Rpb25hcnkgLSBuZXcgbWVzc2FnZXMgbGlzdCB0byBvdmVycmlkZSBkZWZhdWx0XG4gICAqL1xuICBzdGF0aWMgc2V0RGljdGlvbmFyeShlKSB7XG4gICAgaGUuY3VycmVudERpY3Rpb25hcnkgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIHRyYW5zbGF0aW9uIGJvdGggZm9yIGludGVybmFsIGFuZCBleHRlcm5hbCBuYW1lc3BhY2VzXG4gICAqIElmIHRoZXJlIGlzIG5vIHRyYW5zbGF0aW9uIGZvdW5kLCByZXR1cm5zIHBhc3NlZCBrZXkgYXMgYSB0cmFuc2xhdGVkIG1lc3NhZ2VcbiAgICpcbiAgICogQHBhcmFtIG5hbWVzcGFjZSAtIHBhdGggdG8gdHJhbnNsYXRlZCBzdHJpbmcgaW4gZGljdGlvbmFyeVxuICAgKiBAcGFyYW0gZGljdEtleSAtIGRpY3Rpb25hcnkga2V5LiBCZXR0ZXIgdG8gdXNlIGRlZmF1bHQgbG9jYWxlIG9yaWdpbmFsIHRleHRcbiAgICovXG4gIHN0YXRpYyBfdChlLCB0KSB7XG4gICAgY29uc3QgbyA9IGhlLmdldE5hbWVzcGFjZShlKTtcbiAgICByZXR1cm4gIW8gfHwgIW9bdF0gPyB0IDogb1t0XTtcbiAgfVxuICAvKipcbiAgICogRmluZCBtZXNzYWdlcyBzZWN0aW9uIGJ5IG5hbWVzcGFjZSBwYXRoXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBwYXRoIHRvIHNlY3Rpb25cbiAgICovXG4gIHN0YXRpYyBnZXROYW1lc3BhY2UoZSkge1xuICAgIHJldHVybiBlLnNwbGl0KFwiLlwiKS5yZWR1Y2UoKG8sIGkpID0+ICFvIHx8ICFPYmplY3Qua2V5cyhvKS5sZW5ndGggPyB7fSA6IG9baV0sIGhlLmN1cnJlbnREaWN0aW9uYXJ5KTtcbiAgfVxufTtcbmpvLmN1cnJlbnREaWN0aW9uYXJ5ID0gRm87XG5sZXQgeiA9IGpvO1xuY2xhc3MgSG8gZXh0ZW5kcyBFcnJvciB7XG59XG5jbGFzcyBPZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3Vic2NyaWJlcnMgPSB7fTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIGFueSBldmVudCBvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gZXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBzdWJzY3JpYmVyXG4gICAqL1xuICBvbihlLCB0KSB7XG4gICAgZSBpbiB0aGlzLnN1YnNjcmliZXJzIHx8ICh0aGlzLnN1YnNjcmliZXJzW2VdID0gW10pLCB0aGlzLnN1YnNjcmliZXJzW2VdLnB1c2godCk7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSBhbnkgZXZlbnQgb24gY2FsbGJhY2suIENhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIG9uY2UgYW5kIGJlIHJlbW92ZWQgZnJvbSBzdWJzY3JpYmVycyBhcnJheSBhZnRlciBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gZXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBzdWJzY3JpYmVyXG4gICAqL1xuICBvbmNlKGUsIHQpIHtcbiAgICBlIGluIHRoaXMuc3Vic2NyaWJlcnMgfHwgKHRoaXMuc3Vic2NyaWJlcnNbZV0gPSBbXSk7XG4gICAgY29uc3QgbyA9IChpKSA9PiB7XG4gICAgICBjb25zdCBzID0gdChpKSwgciA9IHRoaXMuc3Vic2NyaWJlcnNbZV0uaW5kZXhPZihvKTtcbiAgICAgIHJldHVybiByICE9PSAtMSAmJiB0aGlzLnN1YnNjcmliZXJzW2VdLnNwbGljZShyLCAxKSwgcztcbiAgICB9O1xuICAgIHRoaXMuc3Vic2NyaWJlcnNbZV0ucHVzaChvKTtcbiAgfVxuICAvKipcbiAgICogRW1pdCBjYWxsYmFja3Mgd2l0aCBwYXNzZWQgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gZXZlbnQgbmFtZVxuICAgKiBAcGFyYW0gZGF0YSAtIHN1YnNjcmliZXJzIGdldCB0aGlzIGRhdGEgd2hlbiB0aGV5IHdlcmUgZmlyZWRcbiAgICovXG4gIGVtaXQoZSwgdCkge1xuICAgIFYodGhpcy5zdWJzY3JpYmVycykgfHwgIXRoaXMuc3Vic2NyaWJlcnNbZV0gfHwgdGhpcy5zdWJzY3JpYmVyc1tlXS5yZWR1Y2UoKG8sIGkpID0+IHtcbiAgICAgIGNvbnN0IHMgPSBpKG8pO1xuICAgICAgcmV0dXJuIHMgIT09IHZvaWQgMCA/IHMgOiBvO1xuICAgIH0sIHQpO1xuICB9XG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBjYWxsYmFjayBmcm9tIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSBldmVudE5hbWUgLSBldmVudCBuYW1lXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIG9mZihlLCB0KSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaWJlcnNbZV0gPT09IHZvaWQgMCkge1xuICAgICAgY29uc29sZS53YXJuKGBFdmVudERpc3BhdGNoZXIgLm9mZigpOiB0aGVyZSBpcyBubyBzdWJzY3JpYmVycyBmb3IgZXZlbnQgXCIke2UudG9TdHJpbmcoKX1cIi4gUHJvYmFibHksIC5vZmYoKSBjYWxsZWQgYmVmb3JlIC5vbigpYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgdGhpcy5zdWJzY3JpYmVyc1tlXS5sZW5ndGg7IG8rKylcbiAgICAgIGlmICh0aGlzLnN1YnNjcmliZXJzW2VdW29dID09PSB0KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN1YnNjcmliZXJzW2VdW29dO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVzdHJveWVyXG4gICAqIGNsZWFycyBzdWJzY3JpYmVycyBsaXN0XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaWJlcnMgPSB7fTtcbiAgfVxufVxuZnVuY3Rpb24gSihuKSB7XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCB7XG4gICAgLyoqXG4gICAgICogQmxvY2sgaWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgcmV0dXJuIG4uaWQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUb29sIG5hbWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICByZXR1cm4gbi5uYW1lO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVG9vbCBjb25maWcgcGFzc2VkIG9uIEVkaXRvcidzIGluaXRpYWxpemF0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7VG9vbENvbmZpZ31cbiAgICAgKi9cbiAgICBnZXQgY29uZmlnKCkge1xuICAgICAgcmV0dXJuIG4uY29uZmlnO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogLmNlLWJsb2NrIGVsZW1lbnQsIHRoYXQgd3JhcHMgcGx1Z2luIGNvbnRlbnRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0IGhvbGRlcigpIHtcbiAgICAgIHJldHVybiBuLmhvbGRlcjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgQmxvY2sgY29udGVudCBpcyBlbXB0eVxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICByZXR1cm4gbi5pc0VtcHR5O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBCbG9jayBpcyBzZWxlY3RlZCB3aXRoIENyb3NzLUJsb2NrIHNlbGVjdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgcmV0dXJuIG4uc2VsZWN0ZWQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTZXQgQmxvY2sncyBzdHJldGNoIHN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXRlIOKAlCBzdGF0ZSB0byBzZXRcbiAgICAgKi9cbiAgICBzZXQgc3RyZXRjaGVkKHQpIHtcbiAgICAgIG4uc3RyZXRjaGVkID0gdDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgQmxvY2sgaXMgc3RyZXRjaGVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgc3RyZXRjaGVkKCkge1xuICAgICAgcmV0dXJuIG4uc3RyZXRjaGVkO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBCbG9jayBoYXMgaW5wdXRzIHRvIGJlIGZvY3VzZWRcbiAgICAgKi9cbiAgICBnZXQgZm9jdXNhYmxlKCkge1xuICAgICAgcmV0dXJuIG4uZm9jdXNhYmxlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2FsbCBUb29sIG1ldGhvZCB3aXRoIGVycm9ycyBoYW5kbGVyIHVuZGVyLXRoZS1ob29kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSAtIG1ldGhvZCB0byBjYWxsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtIC0gb2JqZWN0IHdpdGggcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIHt1bmtub3dufVxuICAgICAqL1xuICAgIGNhbGwodCwgbykge1xuICAgICAgcmV0dXJuIG4uY2FsbCh0LCBvKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNhdmUgQmxvY2sgY29udGVudFxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZHxTYXZlZERhdGE+fVxuICAgICAqL1xuICAgIHNhdmUoKSB7XG4gICAgICByZXR1cm4gbi5zYXZlKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBCbG9jayBkYXRhXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jsb2NrVG9vbERhdGF9IGRhdGEgLSBkYXRhIHRvIHZhbGlkYXRlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAgICovXG4gICAgdmFsaWRhdGUodCkge1xuICAgICAgcmV0dXJuIG4udmFsaWRhdGUodCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdG8gc2F5IEVkaXRvciB0aGF0IEJsb2NrIHdhcyBjaGFuZ2VkLiBVc2VkIHRvIG1hbnVhbGx5IHRyaWdnZXIgRWRpdG9yJ3MgJ29uQ2hhbmdlJyBjYWxsYmFja1xuICAgICAqIENhbiBiZSB1c2VmdWwgZm9yIGJsb2NrIGNoYW5nZXMgaW52aXNpYmxlIGZvciBlZGl0b3IgY29yZS5cbiAgICAgKi9cbiAgICBkaXNwYXRjaENoYW5nZSgpIHtcbiAgICAgIG4uZGlzcGF0Y2hDaGFuZ2UoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRvb2wgY291bGQgc3BlY2lmeSBzZXZlcmFsIGVudHJpZXMgdG8gYmUgZGlzcGxheWVkIGF0IHRoZSBUb29sYm94IChmb3IgZXhhbXBsZSwgXCJIZWFkaW5nIDFcIiwgXCJIZWFkaW5nIDJcIiwgXCJIZWFkaW5nIDNcIilcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbnRyeSB0aGF0IGlzIHJlbGF0ZWQgdG8gdGhlIEJsb2NrIChkZXBlbmRlZCBvbiB0aGUgQmxvY2sgZGF0YSlcbiAgICAgKi9cbiAgICBnZXRBY3RpdmVUb29sYm94RW50cnkoKSB7XG4gICAgICByZXR1cm4gbi5nZXRBY3RpdmVUb29sYm94RW50cnkoKTtcbiAgICB9XG4gIH0pO1xufVxuY2xhc3MgX2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmFsbExpc3RlbmVycyA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBBc3NpZ25zIGV2ZW50IGxpc3RlbmVyIG9uIGVsZW1lbnQgYW5kIHJldHVybnMgdW5pcXVlIGlkZW50aWZpZXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudCAtIERPTSBlbGVtZW50IHRoYXQgbmVlZHMgdG8gYmUgbGlzdGVuZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSAtIGV2ZW50IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciAtIG1ldGhvZCB0aGF0IHdpbGwgYmUgZmlyZWQgb24gZXZlbnRcbiAgICogQHBhcmFtIHtib29sZWFufEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zfSBvcHRpb25zIC0gdXNlQ2FwdHVyZSBvciB7Y2FwdHVyZSwgcGFzc2l2ZSwgb25jZX1cbiAgICovXG4gIG9uKGUsIHQsIG8sIGkgPSAhMSkge1xuICAgIGNvbnN0IHMgPSBzaShcImxcIiksIHIgPSB7XG4gICAgICBpZDogcyxcbiAgICAgIGVsZW1lbnQ6IGUsXG4gICAgICBldmVudFR5cGU6IHQsXG4gICAgICBoYW5kbGVyOiBvLFxuICAgICAgb3B0aW9uczogaVxuICAgIH07XG4gICAgaWYgKCF0aGlzLmZpbmRPbmUoZSwgdCwgbykpXG4gICAgICByZXR1cm4gdGhpcy5hbGxMaXN0ZW5lcnMucHVzaChyKSwgZS5hZGRFdmVudExpc3RlbmVyKHQsIG8sIGkpLCBzO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVyIGZyb20gZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbGVtZW50IC0gRE9NIGVsZW1lbnQgdGhhdCB3ZSByZW1vdmluZyBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIC0gZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIC0gcmVtb3ZlIGhhbmRsZXIsIGlmIGVsZW1lbnQgbGlzdGVucyBzZXZlcmFsIGhhbmRsZXJzIG9uIHRoZSBzYW1lIGV2ZW50IHR5cGVcbiAgICogQHBhcmFtIHtib29sZWFufEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zfSBvcHRpb25zIC0gdXNlQ2FwdHVyZSBvciB7Y2FwdHVyZSwgcGFzc2l2ZSwgb25jZX1cbiAgICovXG4gIG9mZihlLCB0LCBvLCBpKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuZmluZEFsbChlLCB0LCBvKTtcbiAgICBzLmZvckVhY2goKHIsIGEpID0+IHtcbiAgICAgIGNvbnN0IGwgPSB0aGlzLmFsbExpc3RlbmVycy5pbmRleE9mKHNbYV0pO1xuICAgICAgbCA+IC0xICYmICh0aGlzLmFsbExpc3RlbmVycy5zcGxpY2UobCwgMSksIHIuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHIuZXZlbnRUeXBlLCByLmhhbmRsZXIsIHIub3B0aW9ucykpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGxpc3RlbmVyIGJ5IGlkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIGxpc3RlbmVyIGlkZW50aWZpZXJcbiAgICovXG4gIG9mZkJ5SWQoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmZpbmRCeUlkKGUpO1xuICAgIHQgJiYgdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodC5ldmVudFR5cGUsIHQuaGFuZGxlciwgdC5vcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogRmluZHMgYW5kIHJldHVybnMgZmlyc3QgbGlzdGVuZXIgYnkgcGFzc2VkIHBhcmFtc1xuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbGVtZW50IC0gZXZlbnQgdGFyZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXZlbnRUeXBlXSAtIGV2ZW50IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdIC0gZXZlbnQgaGFuZGxlclxuICAgKiBAcmV0dXJucyB7TGlzdGVuZXJEYXRhfG51bGx9XG4gICAqL1xuICBmaW5kT25lKGUsIHQsIG8pIHtcbiAgICBjb25zdCBpID0gdGhpcy5maW5kQWxsKGUsIHQsIG8pO1xuICAgIHJldHVybiBpLmxlbmd0aCA+IDAgPyBpWzBdIDogbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFsbCBzdG9yZWQgbGlzdGVuZXJzIGJ5IHBhc3NlZCBwYXJhbXNcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudCAtIGV2ZW50IHRhcmdldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIC0gZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIC0gZXZlbnQgaGFuZGxlclxuICAgKiBAcmV0dXJucyB7TGlzdGVuZXJEYXRhW119XG4gICAqL1xuICBmaW5kQWxsKGUsIHQsIG8pIHtcbiAgICBsZXQgaTtcbiAgICBjb25zdCBzID0gZSA/IHRoaXMuZmluZEJ5RXZlbnRUYXJnZXQoZSkgOiBbXTtcbiAgICByZXR1cm4gZSAmJiB0ICYmIG8gPyBpID0gcy5maWx0ZXIoKHIpID0+IHIuZXZlbnRUeXBlID09PSB0ICYmIHIuaGFuZGxlciA9PT0gbykgOiBlICYmIHQgPyBpID0gcy5maWx0ZXIoKHIpID0+IHIuZXZlbnRUeXBlID09PSB0KSA6IGkgPSBzLCBpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnNcbiAgICovXG4gIHJlbW92ZUFsbCgpIHtcbiAgICB0aGlzLmFsbExpc3RlbmVycy5tYXAoKGUpID0+IHtcbiAgICAgIGUuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGUuZXZlbnRUeXBlLCBlLmhhbmRsZXIsIGUub3B0aW9ucyk7XG4gICAgfSksIHRoaXMuYWxsTGlzdGVuZXJzID0gW107XG4gIH1cbiAgLyoqXG4gICAqIE1vZHVsZSBjbGVhbnVwIG9uIGRlc3RydWN0aW9uXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVtb3ZlQWxsKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlYXJjaCBtZXRob2Q6IGxvb2tzIGZvciBsaXN0ZW5lciBieSBwYXNzZWQgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbGVtZW50IC0gc2VhcmNoaW5nIGVsZW1lbnRcbiAgICogQHJldHVybnMge0FycmF5fSBsaXN0ZW5lcnMgdGhhdCBmb3VuZCBvbiBlbGVtZW50XG4gICAqL1xuICBmaW5kQnlFdmVudFRhcmdldChlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsTGlzdGVuZXJzLmZpbHRlcigodCkgPT4ge1xuICAgICAgaWYgKHQuZWxlbWVudCA9PT0gZSlcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlYXJjaCBtZXRob2Q6IGxvb2tzIGZvciBsaXN0ZW5lciBieSBwYXNzZWQgZXZlbnQgdHlwZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIC0gZXZlbnQgdHlwZVxuICAgKiBAcmV0dXJucyB7TGlzdGVuZXJEYXRhW119IGxpc3RlbmVycyB0aGF0IGZvdW5kIG9uIGVsZW1lbnRcbiAgICovXG4gIGZpbmRCeVR5cGUoZSkge1xuICAgIHJldHVybiB0aGlzLmFsbExpc3RlbmVycy5maWx0ZXIoKHQpID0+IHtcbiAgICAgIGlmICh0LmV2ZW50VHlwZSA9PT0gZSlcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlYXJjaCBtZXRob2Q6IGxvb2tzIGZvciBsaXN0ZW5lciBieSBwYXNzZWQgaGFuZGxlclxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIC0gZXZlbnQgaGFuZGxlclxuICAgKiBAcmV0dXJucyB7TGlzdGVuZXJEYXRhW119IGxpc3RlbmVycyB0aGF0IGZvdW5kIG9uIGVsZW1lbnRcbiAgICovXG4gIGZpbmRCeUhhbmRsZXIoZSkge1xuICAgIHJldHVybiB0aGlzLmFsbExpc3RlbmVycy5maWx0ZXIoKHQpID0+IHtcbiAgICAgIGlmICh0LmhhbmRsZXIgPT09IGUpXG4gICAgICAgIHJldHVybiB0O1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGxpc3RlbmVyIGRhdGEgZm91bmQgYnkgaWRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gbGlzdGVuZXIgaWRlbnRpZmllclxuICAgKiBAcmV0dXJucyB7TGlzdGVuZXJEYXRhfVxuICAgKi9cbiAgZmluZEJ5SWQoZSkge1xuICAgIHJldHVybiB0aGlzLmFsbExpc3RlbmVycy5maW5kKCh0KSA9PiB0LmlkID09PSBlKTtcbiAgfVxufVxuY2xhc3MgRSB7XG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBNb2R1bGUgb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5jb25maWcgLSBNb2R1bGUgY29uZmlnXG4gICAqIEBwYXJhbSBvcHRpb25zLmV2ZW50c0Rpc3BhdGNoZXIgLSBDb21tb24gZXZlbnQgYnVzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGNvbmZpZzogZSwgZXZlbnRzRGlzcGF0Y2hlcjogdCB9KSB7XG4gICAgaWYgKHRoaXMubm9kZXMgPSB7fSwgdGhpcy5saXN0ZW5lcnMgPSBuZXcgX2UoKSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMgPSB7XG4gICAgICAvKipcbiAgICAgICAqIEFzc2lnbnMgZXZlbnQgbGlzdGVuZXIgb24gRE9NIGVsZW1lbnQgYW5kIHB1c2hlcyBpbnRvIHNwZWNpYWwgYXJyYXkgdGhhdCBtaWdodCBiZSByZW1vdmVkXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxlbWVudCAtIERPTSBFbGVtZW50XG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIC0gRXZlbnQgbmFtZVxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciAtIEV2ZW50IGhhbmRsZXJcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxBZGRFdmVudExpc3RlbmVyT3B0aW9uc30gb3B0aW9ucyAtIExpc3RlbmluZyBvcHRpb25zXG4gICAgICAgKi9cbiAgICAgIG9uOiAobywgaSwgcywgciA9ICExKSA9PiB7XG4gICAgICAgIHRoaXMubXV0YWJsZUxpc3RlbmVySWRzLnB1c2goXG4gICAgICAgICAgdGhpcy5saXN0ZW5lcnMub24obywgaSwgcywgcilcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIENsZWFycyBhbGwgbXV0YWJsZSBsaXN0ZW5lcnNcbiAgICAgICAqL1xuICAgICAgY2xlYXJBbGw6ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBvIG9mIHRoaXMubXV0YWJsZUxpc3RlbmVySWRzKVxuICAgICAgICAgIHRoaXMubGlzdGVuZXJzLm9mZkJ5SWQobyk7XG4gICAgICAgIHRoaXMubXV0YWJsZUxpc3RlbmVySWRzID0gW107XG4gICAgICB9XG4gICAgfSwgdGhpcy5tdXRhYmxlTGlzdGVuZXJJZHMgPSBbXSwgbmV3LnRhcmdldCA9PT0gRSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDb25zdHJ1Y3RvcnMgZm9yIGFic3RyYWN0IGNsYXNzIE1vZHVsZSBhcmUgbm90IGFsbG93ZWQuXCIpO1xuICAgIHRoaXMuY29uZmlnID0gZSwgdGhpcy5ldmVudHNEaXNwYXRjaGVyID0gdDtcbiAgfVxuICAvKipcbiAgICogRWRpdG9yIG1vZHVsZXMgc2V0dGVyXG4gICAqXG4gICAqIEBwYXJhbSB7RWRpdG9yTW9kdWxlc30gRWRpdG9yIC0gRWRpdG9yJ3MgTW9kdWxlc1xuICAgKi9cbiAgc2V0IHN0YXRlKGUpIHtcbiAgICB0aGlzLkVkaXRvciA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBtZW1vcml6ZWQgbm9kZXNcbiAgICovXG4gIHJlbW92ZUFsbE5vZGVzKCkge1xuICAgIGZvciAoY29uc3QgZSBpbiB0aGlzLm5vZGVzKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5ub2Rlc1tlXTtcbiAgICAgIHQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiB0LnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGN1cnJlbnQgZGlyZWN0aW9uIGlzIFJUTCAoUmlnaHQtVG8tTGVmdClcbiAgICovXG4gIGdldCBpc1J0bCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuaTE4bi5kaXJlY3Rpb24gPT09IFwicnRsXCI7XG4gIH1cbn1cbmNsYXNzIGIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmluc3RhbmNlID0gbnVsbCwgdGhpcy5zZWxlY3Rpb24gPSBudWxsLCB0aGlzLnNhdmVkU2VsZWN0aW9uUmFuZ2UgPSBudWxsLCB0aGlzLmlzRmFrZUJhY2tncm91bmRFbmFibGVkID0gITEsIHRoaXMuY29tbWFuZEJhY2tncm91bmQgPSBcImJhY2tDb2xvclwiLCB0aGlzLmNvbW1hbmRSZW1vdmVGb3JtYXQgPSBcInJlbW92ZUZvcm1hdFwiO1xuICB9XG4gIC8qKlxuICAgKiBFZGl0b3Igc3R5bGVzXG4gICAqXG4gICAqIEByZXR1cm5zIHt7ZWRpdG9yV3JhcHBlcjogc3RyaW5nLCBlZGl0b3Jab25lOiBzdHJpbmd9fVxuICAgKi9cbiAgc3RhdGljIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVkaXRvcldyYXBwZXI6IFwiY29kZXgtZWRpdG9yXCIsXG4gICAgICBlZGl0b3Jab25lOiBcImNvZGV4LWVkaXRvcl9fcmVkYWN0b3JcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgc2VsZWN0ZWQgYW5jaG9yXG4gICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9ydS9kb2NzL1dlYi9BUEkvU2VsZWN0aW9uL2FuY2hvck5vZGV9XG4gICAqXG4gICAqIEByZXR1cm5zIHtOb2RlfG51bGx9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGFuY2hvck5vZGUoKSB7XG4gICAgY29uc3QgZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4gZSA/IGUuYW5jaG9yTm9kZSA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgc2VsZWN0ZWQgYW5jaG9yIGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybnMge0VsZW1lbnR8bnVsbH1cbiAgICovXG4gIHN0YXRpYyBnZXQgYW5jaG9yRWxlbWVudCgpIHtcbiAgICBjb25zdCBlID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHQgPSBlLmFuY2hvck5vZGU7XG4gICAgcmV0dXJuIHQgPyBkLmlzRWxlbWVudCh0KSA/IHQgOiB0LnBhcmVudEVsZW1lbnQgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHNlbGVjdGlvbiBvZmZzZXQgYWNjb3JkaW5nIHRvIHRoZSBhbmNob3Igbm9kZVxuICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvcnUvZG9jcy9XZWIvQVBJL1NlbGVjdGlvbi9hbmNob3JPZmZzZXR9XG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ8bnVsbH1cbiAgICovXG4gIHN0YXRpYyBnZXQgYW5jaG9yT2Zmc2V0KCkge1xuICAgIGNvbnN0IGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIGUgPyBlLmFuY2hvck9mZnNldCA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIElzIGN1cnJlbnQgc2VsZWN0aW9uIHJhbmdlIGNvbGxhcHNlZFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxudWxsfVxuICAgKi9cbiAgc3RhdGljIGdldCBpc0NvbGxhcHNlZCgpIHtcbiAgICBjb25zdCBlID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiBlID8gZS5pc0NvbGxhcHNlZCA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGN1cnJlbnQgc2VsZWN0aW9uIGlmIGl0IGlzIGF0IEVkaXRvcidzIHpvbmVcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzQXRFZGl0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTZWxlY3Rpb25BdEVkaXRvcihiLmdldCgpKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgcGFzc2VkIHNlbGVjdGlvbiBpcyBhdCBFZGl0b3IncyB6b25lXG4gICAqXG4gICAqIEBwYXJhbSBzZWxlY3Rpb24gLSBTZWxlY3Rpb24gb2JqZWN0IHRvIGNoZWNrXG4gICAqL1xuICBzdGF0aWMgaXNTZWxlY3Rpb25BdEVkaXRvcihlKSB7XG4gICAgaWYgKCFlKVxuICAgICAgcmV0dXJuICExO1xuICAgIGxldCB0ID0gZS5hbmNob3JOb2RlIHx8IGUuZm9jdXNOb2RlO1xuICAgIHQgJiYgdC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgJiYgKHQgPSB0LnBhcmVudE5vZGUpO1xuICAgIGxldCBvID0gbnVsbDtcbiAgICByZXR1cm4gdCAmJiB0IGluc3RhbmNlb2YgRWxlbWVudCAmJiAobyA9IHQuY2xvc2VzdChgLiR7Yi5DU1MuZWRpdG9yWm9uZX1gKSksIG8gPyBvLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSA6ICExO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBwYXNzZWQgcmFuZ2UgYXQgRWRpdG9yIHpvbmVcbiAgICpcbiAgICogQHBhcmFtIHJhbmdlIC0gcmFuZ2UgdG8gY2hlY2tcbiAgICovXG4gIHN0YXRpYyBpc1JhbmdlQXRFZGl0b3IoZSkge1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgdCA9IGUuc3RhcnRDb250YWluZXI7XG4gICAgdCAmJiB0Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSAmJiAodCA9IHQucGFyZW50Tm9kZSk7XG4gICAgbGV0IG8gPSBudWxsO1xuICAgIHJldHVybiB0ICYmIHQgaW5zdGFuY2VvZiBFbGVtZW50ICYmIChvID0gdC5jbG9zZXN0KGAuJHtiLkNTUy5lZGl0b3Jab25lfWApKSwgbyA/IG8ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFIDogITE7XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZHMgcmV0dXJuIGJvb2xlYW4gdGhhdCB0cnVlIGlmIHNlbGVjdGlvbiBleGlzdHMgb24gdGhlIHBhZ2VcbiAgICovXG4gIHN0YXRpYyBnZXQgaXNTZWxlY3Rpb25FeGlzdHMoKSB7XG4gICAgcmV0dXJuICEhYi5nZXQoKS5hbmNob3JOb2RlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gZmlyc3QgcmFuZ2VcbiAgICpcbiAgICogQHJldHVybnMge1JhbmdlfG51bGx9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHJhbmdlKCkge1xuICAgIHJldHVybiB0aGlzLmdldFJhbmdlRnJvbVNlbGVjdGlvbih0aGlzLmdldCgpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyByYW5nZSBmcm9tIHBhc3NlZCBTZWxlY3Rpb24gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSBzZWxlY3Rpb24gLSBTZWxlY3Rpb24gb2JqZWN0IHRvIGdldCBSYW5nZSBmcm9tXG4gICAqL1xuICBzdGF0aWMgZ2V0UmFuZ2VGcm9tU2VsZWN0aW9uKGUpIHtcbiAgICByZXR1cm4gZSAmJiBlLnJhbmdlQ291bnQgPyBlLmdldFJhbmdlQXQoMCkgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHBvc2l0aW9uIGFuZCBzaXplIG9mIHNlbGVjdGVkIHRleHRcbiAgICpcbiAgICogQHJldHVybnMge0RPTVJlY3QgfCBDbGllbnRSZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCByZWN0KCkge1xuICAgIGxldCBlID0gZG9jdW1lbnQuc2VsZWN0aW9uLCB0LCBvID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgaWYgKGUgJiYgZS50eXBlICE9PSBcIkNvbnRyb2xcIilcbiAgICAgIHJldHVybiBlID0gZSwgdCA9IGUuY3JlYXRlUmFuZ2UoKSwgby54ID0gdC5ib3VuZGluZ0xlZnQsIG8ueSA9IHQuYm91bmRpbmdUb3AsIG8ud2lkdGggPSB0LmJvdW5kaW5nV2lkdGgsIG8uaGVpZ2h0ID0gdC5ib3VuZGluZ0hlaWdodCwgbztcbiAgICBpZiAoIXdpbmRvdy5nZXRTZWxlY3Rpb24pXG4gICAgICByZXR1cm4gUyhcIk1ldGhvZCB3aW5kb3cuZ2V0U2VsZWN0aW9uIGlzIG5vdCBzdXBwb3J0ZWRcIiwgXCJ3YXJuXCIpLCBvO1xuICAgIGlmIChlID0gd2luZG93LmdldFNlbGVjdGlvbigpLCBlLnJhbmdlQ291bnQgPT09IG51bGwgfHwgaXNOYU4oZS5yYW5nZUNvdW50KSlcbiAgICAgIHJldHVybiBTKFwiTWV0aG9kIFNlbGVjdGlvblV0aWxzLnJhbmdlQ291bnQgaXMgbm90IHN1cHBvcnRlZFwiLCBcIndhcm5cIiksIG87XG4gICAgaWYgKGUucmFuZ2VDb3VudCA9PT0gMClcbiAgICAgIHJldHVybiBvO1xuICAgIGlmICh0ID0gZS5nZXRSYW5nZUF0KDApLmNsb25lUmFuZ2UoKSwgdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgKG8gPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSwgby54ID09PSAwICYmIG8ueSA9PT0gMCkge1xuICAgICAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgaWYgKGkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgICAgIGkuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCLigItcIikpLCB0Lmluc2VydE5vZGUoaSksIG8gPSBpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBzID0gaS5wYXJlbnROb2RlO1xuICAgICAgICBzLnJlbW92ZUNoaWxkKGkpLCBzLm5vcm1hbGl6ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBzZWxlY3RlZCB0ZXh0IGFzIFN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB3aW5kb3cuZ2V0U2VsZWN0aW9uID8gd2luZG93LmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKCkgOiBcIlwiO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdpbmRvdyBTZWxlY3Rpb25VdGlsc1xuICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvcnUvZG9jcy9XZWIvQVBJL1dpbmRvdy9nZXRTZWxlY3Rpb259XG4gICAqXG4gICAqIEByZXR1cm5zIHtTZWxlY3Rpb259XG4gICAqL1xuICBzdGF0aWMgZ2V0KCkge1xuICAgIHJldHVybiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBmb2N1cyB0byBjb250ZW50ZWRpdGFibGUgb3IgbmF0aXZlIGlucHV0IGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgLSBlbGVtZW50IHdoZXJlIHRvIHNldCBmb2N1c1xuICAgKiBAcGFyYW0gb2Zmc2V0IC0gb2Zmc2V0IG9mIGN1cnNvclxuICAgKi9cbiAgc3RhdGljIHNldEN1cnNvcihlLCB0ID0gMCkge1xuICAgIGNvbnN0IG8gPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLCBpID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiBkLmlzTmF0aXZlSW5wdXQoZSkgPyBkLmNhblNldENhcmV0KGUpID8gKGUuZm9jdXMoKSwgZS5zZWxlY3Rpb25TdGFydCA9IGUuc2VsZWN0aW9uRW5kID0gdCwgZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkgOiB2b2lkIDAgOiAoby5zZXRTdGFydChlLCB0KSwgby5zZXRFbmQoZSwgdCksIGkucmVtb3ZlQWxsUmFuZ2VzKCksIGkuYWRkUmFuZ2UobyksIG8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBjdXJyZW50IHJhbmdlIGV4aXN0cyBhbmQgYmVsb25ncyB0byBjb250YWluZXJcbiAgICpcbiAgICogQHBhcmFtIGNvbnRhaW5lciAtIHdoZXJlIHJhbmdlIHNob3VsZCBiZVxuICAgKi9cbiAgc3RhdGljIGlzUmFuZ2VJbnNpZGVDb250YWluZXIoZSkge1xuICAgIGNvbnN0IHQgPSBiLnJhbmdlO1xuICAgIHJldHVybiB0ID09PSBudWxsID8gITEgOiBlLmNvbnRhaW5zKHQuc3RhcnRDb250YWluZXIpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGZha2UgY3Vyc29yIHRvIHRoZSBjdXJyZW50IHJhbmdlXG4gICAqL1xuICBzdGF0aWMgYWRkRmFrZUN1cnNvcigpIHtcbiAgICBjb25zdCBlID0gYi5yYW5nZTtcbiAgICBpZiAoZSA9PT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gZC5tYWtlKFwic3BhblwiLCBcImNvZGV4LWVkaXRvcl9fZmFrZS1jdXJzb3JcIik7XG4gICAgdC5kYXRhc2V0Lm11dGF0aW9uRnJlZSA9IFwidHJ1ZVwiLCBlLmNvbGxhcHNlKCksIGUuaW5zZXJ0Tm9kZSh0KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgcGFzc2VkIGVsZW1lbnQgY29udGFpbnMgYSBmYWtlIGN1cnNvclxuICAgKlxuICAgKiBAcGFyYW0gZWwgLSB3aGVyZSB0byBjaGVja1xuICAgKi9cbiAgc3RhdGljIGlzRmFrZUN1cnNvckluc2lkZUNvbnRhaW5lcihlKSB7XG4gICAgcmV0dXJuIGQuZmluZChlLCBcIi5jb2RleC1lZGl0b3JfX2Zha2UtY3Vyc29yXCIpICE9PSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGZha2UgY3Vyc29yIGZyb20gYSBjb250YWluZXJcbiAgICpcbiAgICogQHBhcmFtIGNvbnRhaW5lciAtIGNvbnRhaW5lciB0byBsb29rIGZvclxuICAgKi9cbiAgc3RhdGljIHJlbW92ZUZha2VDdXJzb3IoZSA9IGRvY3VtZW50LmJvZHkpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kKGUsIFwiLmNvZGV4LWVkaXRvcl9fZmFrZS1jdXJzb3JcIik7XG4gICAgdCAmJiB0LnJlbW92ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGZha2UgYmFja2dyb3VuZFxuICAgKi9cbiAgcmVtb3ZlRmFrZUJhY2tncm91bmQoKSB7XG4gICAgdGhpcy5pc0Zha2VCYWNrZ3JvdW5kRW5hYmxlZCAmJiAodGhpcy5pc0Zha2VCYWNrZ3JvdW5kRW5hYmxlZCA9ICExLCBkb2N1bWVudC5leGVjQ29tbWFuZCh0aGlzLmNvbW1hbmRSZW1vdmVGb3JtYXQpKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBmYWtlIGJhY2tncm91bmRcbiAgICovXG4gIHNldEZha2VCYWNrZ3JvdW5kKCkge1xuICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKHRoaXMuY29tbWFuZEJhY2tncm91bmQsICExLCBcIiNhOGQ2ZmZcIiksIHRoaXMuaXNGYWtlQmFja2dyb3VuZEVuYWJsZWQgPSAhMDtcbiAgfVxuICAvKipcbiAgICogU2F2ZSBTZWxlY3Rpb25VdGlscydzIHJhbmdlXG4gICAqL1xuICBzYXZlKCkge1xuICAgIHRoaXMuc2F2ZWRTZWxlY3Rpb25SYW5nZSA9IGIucmFuZ2U7XG4gIH1cbiAgLyoqXG4gICAqIFJlc3RvcmUgc2F2ZWQgU2VsZWN0aW9uVXRpbHMncyByYW5nZVxuICAgKi9cbiAgcmVzdG9yZSgpIHtcbiAgICBpZiAoIXRoaXMuc2F2ZWRTZWxlY3Rpb25SYW5nZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGUucmVtb3ZlQWxsUmFuZ2VzKCksIGUuYWRkUmFuZ2UodGhpcy5zYXZlZFNlbGVjdGlvblJhbmdlKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIHNhdmVkIHNlbGVjdGlvblxuICAgKi9cbiAgY2xlYXJTYXZlZCgpIHtcbiAgICB0aGlzLnNhdmVkU2VsZWN0aW9uUmFuZ2UgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDb2xsYXBzZSBjdXJyZW50IHNlbGVjdGlvblxuICAgKi9cbiAgY29sbGFwc2VUb0VuZCgpIHtcbiAgICBjb25zdCBlID0gd2luZG93LmdldFNlbGVjdGlvbigpLCB0ID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICB0LnNlbGVjdE5vZGVDb250ZW50cyhlLmZvY3VzTm9kZSksIHQuY29sbGFwc2UoITEpLCBlLnJlbW92ZUFsbFJhbmdlcygpLCBlLmFkZFJhbmdlKHQpO1xuICB9XG4gIC8qKlxuICAgKiBMb29rcyBhaGVhZCB0byBmaW5kIHBhc3NlZCB0YWcgZnJvbSBjdXJyZW50IHNlbGVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZ05hbWUgICAgICAgLSB0YWcgdG8gZm91bmRcbiAgICogQHBhcmFtICB7c3RyaW5nfSBbY2xhc3NOYW1lXSAgIC0gdGFnJ3MgY2xhc3MgbmFtZVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtzZWFyY2hEZXB0aF0gLSBjb3VudCBvZiB0YWdzIHRoYXQgY2FuIGJlIGluY2x1ZGVkLiBGb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8bnVsbH1cbiAgICovXG4gIGZpbmRQYXJlbnRUYWcoZSwgdCwgbyA9IDEwKSB7XG4gICAgY29uc3QgaSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBsZXQgcyA9IG51bGw7XG4gICAgcmV0dXJuICFpIHx8ICFpLmFuY2hvck5vZGUgfHwgIWkuZm9jdXNOb2RlID8gbnVsbCA6IChbXG4gICAgICAvKiogdGhlIE5vZGUgaW4gd2hpY2ggdGhlIHNlbGVjdGlvbiBiZWdpbnMgKi9cbiAgICAgIGkuYW5jaG9yTm9kZSxcbiAgICAgIC8qKiB0aGUgTm9kZSBpbiB3aGljaCB0aGUgc2VsZWN0aW9uIGVuZHMgKi9cbiAgICAgIGkuZm9jdXNOb2RlXG4gICAgXS5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBsZXQgbCA9IG87XG4gICAgICBmb3IgKDsgbCA+IDAgJiYgYS5wYXJlbnROb2RlICYmICEoYS50YWdOYW1lID09PSBlICYmIChzID0gYSwgdCAmJiBhLmNsYXNzTGlzdCAmJiAhYS5jbGFzc0xpc3QuY29udGFpbnModCkgJiYgKHMgPSBudWxsKSwgcykpOyApXG4gICAgICAgIGEgPSBhLnBhcmVudE5vZGUsIGwtLTtcbiAgICB9KSwgcyk7XG4gIH1cbiAgLyoqXG4gICAqIEV4cGFuZHMgc2VsZWN0aW9uIHJhbmdlIHRvIHRoZSBwYXNzZWQgcGFyZW50IG5vZGVcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgd2hpY2ggY29udGVudHMgc2hvdWxkIGJlIHNlbGVjdGVkXG4gICAqL1xuICBleHBhbmRUb1RhZyhlKSB7XG4gICAgY29uc3QgdCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICB0LnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIGNvbnN0IG8gPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIG8uc2VsZWN0Tm9kZUNvbnRlbnRzKGUpLCB0LmFkZFJhbmdlKG8pO1xuICB9XG59XG5mdW5jdGlvbiBwaShuLCBlKSB7XG4gIGNvbnN0IHsgdHlwZTogdCwgdGFyZ2V0OiBvLCBhZGRlZE5vZGVzOiBpLCByZW1vdmVkTm9kZXM6IHMgfSA9IG47XG4gIHJldHVybiBuLnR5cGUgPT09IFwiYXR0cmlidXRlc1wiICYmIG4uYXR0cmlidXRlTmFtZSA9PT0gXCJkYXRhLWVtcHR5XCIgPyAhMSA6ICEhKGUuY29udGFpbnMobykgfHwgdCA9PT0gXCJjaGlsZExpc3RcIiAmJiAoQXJyYXkuZnJvbShpKS5zb21lKChsKSA9PiBsID09PSBlKSB8fCBBcnJheS5mcm9tKHMpLnNvbWUoKGwpID0+IGwgPT09IGUpKSk7XG59XG5jb25zdCBmdCA9IFwicmVkYWN0b3IgZG9tIGNoYW5nZWRcIiwgJG8gPSBcImJsb2NrIGNoYW5nZWRcIiwgem8gPSBcImZha2UgY3Vyc29yIGlzIGFib3V0IHRvIGJlIHRvZ2dsZWRcIiwgVW8gPSBcImZha2UgY3Vyc29yIGhhdmUgYmVlbiBzZXRcIiwgVGUgPSBcImVkaXRvciBtb2JpbGUgbGF5b3V0IHRvZ2dsZWRcIjtcbmZ1bmN0aW9uIGd0KG4sIGUpIHtcbiAgaWYgKCFuLmNvbnZlcnNpb25Db25maWcpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCB0ID0gbi5jb252ZXJzaW9uQ29uZmlnW2VdO1xuICByZXR1cm4gQSh0KSB8fCB0ZSh0KTtcbn1cbmZ1bmN0aW9uIEhlKG4sIGUpIHtcbiAgcmV0dXJuIGd0KG4udG9vbCwgZSk7XG59XG5mdW5jdGlvbiBXbyhuLCBlKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhuKS5zb21lKChbdCwgb10pID0+IGVbdF0gJiYgcmkoZVt0XSwgbykpO1xufVxuYXN5bmMgZnVuY3Rpb24gWW8obiwgZSkge1xuICBjb25zdCBvID0gKGF3YWl0IG4uc2F2ZSgpKS5kYXRhLCBpID0gZS5maW5kKChzKSA9PiBzLm5hbWUgPT09IG4ubmFtZSk7XG4gIHJldHVybiBpICE9PSB2b2lkIDAgJiYgIWd0KGksIFwiZXhwb3J0XCIpID8gW10gOiBlLnJlZHVjZSgocywgcikgPT4ge1xuICAgIGlmICghZ3QociwgXCJpbXBvcnRcIikgfHwgci50b29sYm94ID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gcztcbiAgICBjb25zdCBhID0gci50b29sYm94LmZpbHRlcigobCkgPT4ge1xuICAgICAgaWYgKFYobCkgfHwgbC5pY29uID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGlmIChsLmRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoV28obC5kYXRhLCBvKSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9IGVsc2UgaWYgKHIubmFtZSA9PT0gbi5uYW1lKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICByZXR1cm4gITA7XG4gICAgfSk7XG4gICAgcmV0dXJuIHMucHVzaCh7XG4gICAgICAuLi5yLFxuICAgICAgdG9vbGJveDogYVxuICAgIH0pLCBzO1xuICB9LCBbXSk7XG59XG5mdW5jdGlvbiB4byhuLCBlKSB7XG4gIHJldHVybiBuLm1lcmdlYWJsZSA/IG4ubmFtZSA9PT0gZS5uYW1lID8gITAgOiBIZShlLCBcImV4cG9ydFwiKSAmJiBIZShuLCBcImltcG9ydFwiKSA6ICExO1xufVxuZnVuY3Rpb24gZmkobiwgZSkge1xuICBjb25zdCB0ID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS5leHBvcnQ7XG4gIHJldHVybiBBKHQpID8gdChuKSA6IHRlKHQpID8gblt0XSA6ICh0ICE9PSB2b2lkIDAgJiYgUyhcIkNvbnZlcnNpb24gwqtleHBvcnTCuyBwcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nIG9yIGZ1bmN0aW9uLiBTdHJpbmcgbWVhbnMga2V5IG9mIHNhdmVkIGRhdGEgb2JqZWN0IHRvIGV4cG9ydC4gRnVuY3Rpb24gc2hvdWxkIGV4cG9ydCBwcm9jZXNzZWQgc3RyaW5nIHRvIGV4cG9ydC5cIiksIFwiXCIpO1xufVxuZnVuY3Rpb24gQm8obiwgZSwgdCkge1xuICBjb25zdCBvID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS5pbXBvcnQ7XG4gIHJldHVybiBBKG8pID8gbyhuLCB0KSA6IHRlKG8pID8ge1xuICAgIFtvXTogblxuICB9IDogKG8gIT09IHZvaWQgMCAmJiBTKFwiQ29udmVyc2lvbiDCq2ltcG9ydMK7IHByb3BlcnR5IG11c3QgYmUgYSBzdHJpbmcgb3IgZnVuY3Rpb24uIFN0cmluZyBtZWFucyBrZXkgb2YgdG9vbCBkYXRhIHRvIGltcG9ydC4gRnVuY3Rpb24gYWNjZXB0cyBhIGltcG9ydGVkIHN0cmluZyBhbmQgcmV0dXJuIGNvbXBvc2VkIHRvb2wgZGF0YS5cIiksIHt9KTtcbn1cbnZhciBfID0gLyogQF9fUFVSRV9fICovICgobikgPT4gKG4uRGVmYXVsdCA9IFwiZGVmYXVsdFwiLCBuLlNlcGFyYXRvciA9IFwic2VwYXJhdG9yXCIsIG4uSHRtbCA9IFwiaHRtbFwiLCBuKSkoXyB8fCB7fSksIGVlID0gLyogQF9fUFVSRV9fICovICgobikgPT4gKG4uQVBQRU5EX0NBTExCQUNLID0gXCJhcHBlbmRDYWxsYmFja1wiLCBuLlJFTkRFUkVEID0gXCJyZW5kZXJlZFwiLCBuLk1PVkVEID0gXCJtb3ZlZFwiLCBuLlVQREFURUQgPSBcInVwZGF0ZWRcIiwgbi5SRU1PVkVEID0gXCJyZW1vdmVkXCIsIG4uT05fUEFTVEUgPSBcIm9uUGFzdGVcIiwgbikpKGVlIHx8IHt9KTtcbmNsYXNzIFIgZXh0ZW5kcyBPZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIGJsb2NrIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAgICogQHBhcmFtIFtvcHRpb25zLmlkXSAtIGJsb2NrJ3MgaWQuIFdpbGwgYmUgZ2VuZXJhdGVkIGlmIG9taXR0ZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zLmRhdGEgLSBUb29sJ3MgaW5pdGlhbCBkYXRhXG4gICAqIEBwYXJhbSBvcHRpb25zLnRvb2wg4oCUIGJsb2NrJ3MgdG9vbFxuICAgKiBAcGFyYW0gb3B0aW9ucy5hcGkgLSBFZGl0b3IgQVBJIG1vZHVsZSBmb3IgcGFzcyBpdCB0byB0aGUgQmxvY2sgVHVuZXNcbiAgICogQHBhcmFtIG9wdGlvbnMucmVhZE9ubHkgLSBSZWFkLU9ubHkgZmxhZ1xuICAgKiBAcGFyYW0gW2V2ZW50QnVzXSAtIEVkaXRvciBjb21tb24gZXZlbnQgYnVzLiBBbGxvd3MgdG8gc3Vic2NyaWJlIG9uIHNvbWUgRWRpdG9yIGV2ZW50cy4gQ291bGQgYmUgb21pdHRlZCB3aGVuIFwidmlydHVhbFwiIEJsb2NrIGlzIGNyZWF0ZWQuIFNlZSBCbG9ja3NBUElAY29tcG9zZUJsb2NrRGF0YS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBpZDogZSA9IG5pKCksXG4gICAgZGF0YTogdCxcbiAgICB0b29sOiBvLFxuICAgIHJlYWRPbmx5OiBpLFxuICAgIHR1bmVzRGF0YTogc1xuICB9LCByKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5jYWNoZWRJbnB1dHMgPSBbXSwgdGhpcy50b29sUmVuZGVyZWRFbGVtZW50ID0gbnVsbCwgdGhpcy50dW5lc0luc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuZGVmYXVsdFR1bmVzSW5zdGFuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy51bmF2YWlsYWJsZVR1bmVzRGF0YSA9IHt9LCB0aGlzLmlucHV0SW5kZXggPSAwLCB0aGlzLmVkaXRvckV2ZW50QnVzID0gbnVsbCwgdGhpcy5oYW5kbGVGb2N1cyA9ICgpID0+IHtcbiAgICAgIHRoaXMuZHJvcElucHV0c0NhY2hlKCksIHRoaXMudXBkYXRlQ3VycmVudElucHV0KCk7XG4gICAgfSwgdGhpcy5kaWRNdXRhdGVkID0gKGEgPSB2b2lkIDApID0+IHtcbiAgICAgIGNvbnN0IGwgPSBhID09PSB2b2lkIDAsIGMgPSBhIGluc3RhbmNlb2YgSW5wdXRFdmVudDtcbiAgICAgICFsICYmICFjICYmIHRoaXMuZGV0ZWN0VG9vbFJvb3RDaGFuZ2UoYSk7XG4gICAgICBsZXQgdTtcbiAgICAgIGwgfHwgYyA/IHUgPSAhMCA6IHUgPSAhKGEubGVuZ3RoID4gMCAmJiBhLmV2ZXJ5KChwKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYWRkZWROb2RlczogZywgcmVtb3ZlZE5vZGVzOiBmLCB0YXJnZXQ6IHYgfSA9IHA7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgLi4uQXJyYXkuZnJvbShnKSxcbiAgICAgICAgICAuLi5BcnJheS5mcm9tKGYpLFxuICAgICAgICAgIHZcbiAgICAgICAgXS5zb21lKChUKSA9PiAoZC5pc0VsZW1lbnQoVCkgfHwgKFQgPSBULnBhcmVudEVsZW1lbnQpLCBUICYmIFQuY2xvc2VzdCgnW2RhdGEtbXV0YXRpb24tZnJlZT1cInRydWVcIl0nKSAhPT0gbnVsbCkpO1xuICAgICAgfSkpLCB1ICYmICh0aGlzLmRyb3BJbnB1dHNDYWNoZSgpLCB0aGlzLnVwZGF0ZUN1cnJlbnRJbnB1dCgpLCB0aGlzLnRvZ2dsZUlucHV0c0VtcHR5TWFyaygpLCB0aGlzLmNhbGwoXG4gICAgICAgIFwidXBkYXRlZFwiXG4gICAgICAgIC8qIFVQREFURUQgKi9cbiAgICAgICksIHRoaXMuZW1pdChcImRpZE11dGF0ZWRcIiwgdGhpcykpO1xuICAgIH0sIHRoaXMubmFtZSA9IG8ubmFtZSwgdGhpcy5pZCA9IGUsIHRoaXMuc2V0dGluZ3MgPSBvLnNldHRpbmdzLCB0aGlzLmNvbmZpZyA9IG8uc2V0dGluZ3MuY29uZmlnIHx8IHt9LCB0aGlzLmVkaXRvckV2ZW50QnVzID0gciB8fCBudWxsLCB0aGlzLmJsb2NrQVBJID0gbmV3IEoodGhpcyksIHRoaXMudG9vbCA9IG8sIHRoaXMudG9vbEluc3RhbmNlID0gby5jcmVhdGUodCwgdGhpcy5ibG9ja0FQSSwgaSksIHRoaXMudHVuZXMgPSBvLnR1bmVzLCB0aGlzLmNvbXBvc2VUdW5lcyhzKSwgdGhpcy5ob2xkZXIgPSB0aGlzLmNvbXBvc2UoKSwgd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgdGhpcy53YXRjaEJsb2NrTXV0YXRpb25zKCksIHRoaXMuYWRkSW5wdXRFdmVudHMoKSwgdGhpcy50b2dnbGVJbnB1dHNFbXB0eU1hcmsoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ1NTIGNsYXNzZXMgZm9yIHRoZSBCbG9ja1xuICAgKlxuICAgKiBAcmV0dXJucyB7e3dyYXBwZXI6IHN0cmluZywgY29udGVudDogc3RyaW5nfX1cbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cmFwcGVyOiBcImNlLWJsb2NrXCIsXG4gICAgICB3cmFwcGVyU3RyZXRjaGVkOiBcImNlLWJsb2NrLS1zdHJldGNoZWRcIixcbiAgICAgIGNvbnRlbnQ6IFwiY2UtYmxvY2tfX2NvbnRlbnRcIixcbiAgICAgIHNlbGVjdGVkOiBcImNlLWJsb2NrLS1zZWxlY3RlZFwiLFxuICAgICAgZHJvcFRhcmdldDogXCJjZS1ibG9jay0tZHJvcC10YXJnZXRcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgYW5kIHJldHVybiBhbGwgZWRpdGFibGUgZWxlbWVudHMgKGNvbnRlbnRlZGl0YWJsZSBhbmQgbmF0aXZlIGlucHV0cykgaW4gdGhlIFRvb2wgSFRNTFxuICAgKi9cbiAgZ2V0IGlucHV0cygpIHtcbiAgICBpZiAodGhpcy5jYWNoZWRJbnB1dHMubGVuZ3RoICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkSW5wdXRzO1xuICAgIGNvbnN0IGUgPSBkLmZpbmRBbGxJbnB1dHModGhpcy5ob2xkZXIpO1xuICAgIHJldHVybiB0aGlzLmlucHV0SW5kZXggPiBlLmxlbmd0aCAtIDEgJiYgKHRoaXMuaW5wdXRJbmRleCA9IGUubGVuZ3RoIC0gMSksIHRoaXMuY2FjaGVkSW5wdXRzID0gZSwgZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGN1cnJlbnQgVG9vbGBzIGlucHV0XG4gICAqIElmIEJsb2NrIGRvZXNuJ3QgY29udGFpbiBpbnB1dHMsIHJldHVybiB1bmRlZmluZWRcbiAgICovXG4gIGdldCBjdXJyZW50SW5wdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRzW3RoaXMuaW5wdXRJbmRleF07XG4gIH1cbiAgLyoqXG4gICAqIFNldCBpbnB1dCBpbmRleCB0byB0aGUgcGFzc2VkIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgLSBIVE1MIEVsZW1lbnQgdG8gc2V0IGFzIGN1cnJlbnQgaW5wdXRcbiAgICovXG4gIHNldCBjdXJyZW50SW5wdXQoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmlucHV0cy5maW5kSW5kZXgoKG8pID0+IG8gPT09IGUgfHwgby5jb250YWlucyhlKSk7XG4gICAgdCAhPT0gLTEgJiYgKHRoaXMuaW5wdXRJbmRleCA9IHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gZmlyc3QgVG9vbGBzIGlucHV0XG4gICAqIElmIEJsb2NrIGRvZXNuJ3QgY29udGFpbiBpbnB1dHMsIHJldHVybiB1bmRlZmluZWRcbiAgICovXG4gIGdldCBmaXJzdElucHV0KCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0c1swXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGZpcnN0IFRvb2xgcyBpbnB1dFxuICAgKiBJZiBCbG9jayBkb2Vzbid0IGNvbnRhaW4gaW5wdXRzLCByZXR1cm4gdW5kZWZpbmVkXG4gICAqL1xuICBnZXQgbGFzdElucHV0KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmlucHV0cztcbiAgICByZXR1cm4gZVtlLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gbmV4dCBUb29sYHMgaW5wdXQgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICogSWYgQmxvY2sgZG9lc24ndCBjb250YWluIGlucHV0cywgcmV0dXJuIHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0IG5leHRJbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dHNbdGhpcy5pbnB1dEluZGV4ICsgMV07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBwcmV2aW91cyBUb29sYHMgaW5wdXQgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICogSWYgQmxvY2sgZG9lc24ndCBjb250YWluIGlucHV0cywgcmV0dXJuIHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0IHByZXZpb3VzSW5wdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRzW3RoaXMuaW5wdXRJbmRleCAtIDFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgQmxvY2sncyBKU09OIGRhdGFcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnNhdmUoKS50aGVuKChlKSA9PiBlICYmICFWKGUuZGF0YSkgPyBlLmRhdGEgOiB7fSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdG9vbCdzIHNhbml0aXplciBjb25maWdcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIGdldCBzYW5pdGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50b29sLnNhbml0aXplQ29uZmlnO1xuICB9XG4gIC8qKlxuICAgKiBpcyBibG9jayBtZXJnZWFibGVcbiAgICogV2UgcGx1Z2luIGhhdmUgbWVyZ2UgZnVuY3Rpb24gdGhlbiB3ZSBjYWxsIGl0IG1lcmdlYWJsZVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBtZXJnZWFibGUoKSB7XG4gICAgcmV0dXJuIEEodGhpcy50b29sSW5zdGFuY2UubWVyZ2UpO1xuICB9XG4gIC8qKlxuICAgKiBJZiBCbG9jayBjb250YWlucyBpbnB1dHMsIGl0IGlzIGZvY3VzYWJsZVxuICAgKi9cbiAgZ2V0IGZvY3VzYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dHMubGVuZ3RoICE9PSAwO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBibG9jayBmb3IgZW1wdGluZXNzXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgY29uc3QgZSA9IGQuaXNFbXB0eSh0aGlzLnBsdWdpbnNDb250ZW50LCBcIi9cIiksIHQgPSAhdGhpcy5oYXNNZWRpYTtcbiAgICByZXR1cm4gZSAmJiB0O1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBibG9jayBoYXMgYSBtZWRpYSBjb250ZW50IHN1Y2ggYXMgaW1hZ2VzLCBpZnJhbWUgYW5kIG90aGVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGhhc01lZGlhKCkge1xuICAgIGNvbnN0IGUgPSBbXG4gICAgICBcImltZ1wiLFxuICAgICAgXCJpZnJhbWVcIixcbiAgICAgIFwidmlkZW9cIixcbiAgICAgIFwiYXVkaW9cIixcbiAgICAgIFwic291cmNlXCIsXG4gICAgICBcImlucHV0XCIsXG4gICAgICBcInRleHRhcmVhXCIsXG4gICAgICBcInR3aXR0ZXJ3aWRnZXRcIlxuICAgIF07XG4gICAgcmV0dXJuICEhdGhpcy5ob2xkZXIucXVlcnlTZWxlY3RvcihlLmpvaW4oXCIsXCIpKTtcbiAgfVxuICAvKipcbiAgICogU2V0IHNlbGVjdGVkIHN0YXRlXG4gICAqIFdlIGRvbid0IG5lZWQgdG8gbWFyayBCbG9jayBhcyBTZWxlY3RlZCB3aGVuIGl0IGlzIGVtcHR5XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdGUgLSAndHJ1ZScgdG8gc2VsZWN0LCAnZmFsc2UnIHRvIHJlbW92ZSBzZWxlY3Rpb25cbiAgICovXG4gIHNldCBzZWxlY3RlZChlKSB7XG4gICAgdmFyIGksIHM7XG4gICAgdGhpcy5ob2xkZXIuY2xhc3NMaXN0LnRvZ2dsZShSLkNTUy5zZWxlY3RlZCwgZSk7XG4gICAgY29uc3QgdCA9IGUgPT09ICEwICYmIGIuaXNSYW5nZUluc2lkZUNvbnRhaW5lcih0aGlzLmhvbGRlciksIG8gPSBlID09PSAhMSAmJiBiLmlzRmFrZUN1cnNvckluc2lkZUNvbnRhaW5lcih0aGlzLmhvbGRlcik7XG4gICAgKHQgfHwgbykgJiYgKChpID0gdGhpcy5lZGl0b3JFdmVudEJ1cykgPT0gbnVsbCB8fCBpLmVtaXQoem8sIHsgc3RhdGU6IGUgfSksIHQgPyBiLmFkZEZha2VDdXJzb3IoKSA6IGIucmVtb3ZlRmFrZUN1cnNvcih0aGlzLmhvbGRlciksIChzID0gdGhpcy5lZGl0b3JFdmVudEJ1cykgPT0gbnVsbCB8fCBzLmVtaXQoVW8sIHsgc3RhdGU6IGUgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIFRydWUgaWYgaXQgaXMgU2VsZWN0ZWRcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC5jb250YWlucyhSLkNTUy5zZWxlY3RlZCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBzdHJldGNoZWQgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBzdGF0ZSAtICd0cnVlJyB0byBlbmFibGUsICdmYWxzZScgdG8gZGlzYWJsZSBzdHJldGNoZWQgc3RhdGVcbiAgICovXG4gIHNldCBzdHJldGNoZWQoZSkge1xuICAgIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC50b2dnbGUoUi5DU1Mud3JhcHBlclN0cmV0Y2hlZCwgZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBCbG9jaydzIHN0cmV0Y2hlZCBzdGF0ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBzdHJldGNoZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC5jb250YWlucyhSLkNTUy53cmFwcGVyU3RyZXRjaGVkKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlIGRyb3AgdGFyZ2V0IHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdGUgLSAndHJ1ZScgaWYgYmxvY2sgaXMgZHJvcCB0YXJnZXQsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgc2V0IGRyb3BUYXJnZXQoZSkge1xuICAgIHRoaXMuaG9sZGVyLmNsYXNzTGlzdC50b2dnbGUoUi5DU1MuZHJvcFRhcmdldCwgZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgUGx1Z2lucyBjb250ZW50XG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIGdldCBwbHVnaW5zQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy50b29sUmVuZGVyZWRFbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBDYWxscyBUb29sJ3MgbWV0aG9kXG4gICAqXG4gICAqIE1ldGhvZCBjaGVja3MgdG9vbCBwcm9wZXJ0eSB7TWV0aG9kTmFtZX0uIEZpcmVzIG1ldGhvZCB3aXRoIHBhc3NlcyBwYXJhbXMgSWYgaXQgaXMgaW5zdGFuY2Ugb2YgRnVuY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgLSBtZXRob2QgdG8gY2FsbFxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gbWV0aG9kIGFyZ3VtZW50XG4gICAqL1xuICBjYWxsKGUsIHQpIHtcbiAgICBpZiAoQSh0aGlzLnRvb2xJbnN0YW5jZVtlXSkpIHtcbiAgICAgIGUgPT09IFwiYXBwZW5kQ2FsbGJhY2tcIiAmJiBTKFxuICAgICAgICBcImBhcHBlbmRDYWxsYmFja2AgaG9vayBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gVXNlIGByZW5kZXJlZGAgaG9vayBpbnN0ZWFkXCIsXG4gICAgICAgIFwid2FyblwiXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy50b29sSW5zdGFuY2VbZV0uY2FsbCh0aGlzLnRvb2xJbnN0YW5jZSwgdCk7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIFMoYEVycm9yIGR1cmluZyAnJHtlfScgY2FsbDogJHtvLm1lc3NhZ2V9YCwgXCJlcnJvclwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgcGx1Z2lucyBtZXJnZSBtZXRob2RcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja1Rvb2xEYXRhfSBkYXRhIC0gZGF0YSB0byBtZXJnZVxuICAgKi9cbiAgYXN5bmMgbWVyZ2VXaXRoKGUpIHtcbiAgICBhd2FpdCB0aGlzLnRvb2xJbnN0YW5jZS5tZXJnZShlKTtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdHMgZGF0YSBmcm9tIEJsb2NrXG4gICAqIEdyb3VwcyBUb29sJ3Mgc2F2ZSBwcm9jZXNzaW5nIHRpbWVcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIGFzeW5jIHNhdmUoKSB7XG4gICAgY29uc3QgZSA9IGF3YWl0IHRoaXMudG9vbEluc3RhbmNlLnNhdmUodGhpcy5wbHVnaW5zQ29udGVudCksIHQgPSB0aGlzLnVuYXZhaWxhYmxlVHVuZXNEYXRhO1xuICAgIFtcbiAgICAgIC4uLnRoaXMudHVuZXNJbnN0YW5jZXMuZW50cmllcygpLFxuICAgICAgLi4udGhpcy5kZWZhdWx0VHVuZXNJbnN0YW5jZXMuZW50cmllcygpXG4gICAgXS5mb3JFYWNoKChbcywgcl0pID0+IHtcbiAgICAgIGlmIChBKHIuc2F2ZSkpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdFtzXSA9IHIuc2F2ZSgpO1xuICAgICAgICB9IGNhdGNoIChhKSB7XG4gICAgICAgICAgUyhgVHVuZSAke3IuY29uc3RydWN0b3IubmFtZX0gc2F2ZSBtZXRob2QgdGhyb3dzIGFuIEVycm9yICVvYCwgXCJ3YXJuXCIsIGEpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgbyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBsZXQgaTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUpLnRoZW4oKHMpID0+IChpID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpLCB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIHRvb2w6IHRoaXMubmFtZSxcbiAgICAgIGRhdGE6IHMsXG4gICAgICB0dW5lczogdCxcbiAgICAgIHRpbWU6IGkgLSBvXG4gICAgfSkpLmNhdGNoKChzKSA9PiB7XG4gICAgICBTKGBTYXZpbmcgcHJvY2VzcyBmb3IgJHt0aGlzLm5hbWV9IHRvb2wgZmFpbGVkIGR1ZSB0byB0aGUgJHtzfWAsIFwibG9nXCIsIFwicmVkXCIpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVc2VzIFRvb2wncyB2YWxpZGF0aW9uIG1ldGhvZCB0byBjaGVjayB0aGUgY29ycmVjdG5lc3Mgb2Ygb3V0cHV0IGRhdGFcbiAgICogVG9vbCdzIHZhbGlkYXRpb24gbWV0aG9kIGlzIG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgcmV0dXJucyB0cnVlfGZhbHNlIHdoZXRoZXIgZGF0YSBwYXNzZWQgdGhlIHZhbGlkYXRpb24gb3Igbm90XG4gICAqIEBwYXJhbSB7QmxvY2tUb29sRGF0YX0gZGF0YSAtIGRhdGEgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IHZhbGlkXG4gICAqL1xuICBhc3luYyB2YWxpZGF0ZShlKSB7XG4gICAgbGV0IHQgPSAhMDtcbiAgICByZXR1cm4gdGhpcy50b29sSW5zdGFuY2UudmFsaWRhdGUgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiAodCA9IGF3YWl0IHRoaXMudG9vbEluc3RhbmNlLnZhbGlkYXRlKGUpKSwgdDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBkYXRhIHRvIHJlbmRlciBpbiBCbG9jayBUdW5lcyBtZW51LlxuICAgKiBTcGxpdHMgYmxvY2sgdHVuZXMgaW50byAyIGdyb3VwczogYmxvY2sgc3BlY2lmaWMgdHVuZXMgYW5kIGNvbW1vbiB0dW5lc1xuICAgKi9cbiAgZ2V0VHVuZXMoKSB7XG4gICAgY29uc3QgZSA9IFtdLCB0ID0gW10sIG8gPSB0eXBlb2YgdGhpcy50b29sSW5zdGFuY2UucmVuZGVyU2V0dGluZ3MgPT0gXCJmdW5jdGlvblwiID8gdGhpcy50b29sSW5zdGFuY2UucmVuZGVyU2V0dGluZ3MoKSA6IFtdO1xuICAgIHJldHVybiBkLmlzRWxlbWVudChvKSA/IGUucHVzaCh7XG4gICAgICB0eXBlOiBfLkh0bWwsXG4gICAgICBlbGVtZW50OiBvXG4gICAgfSkgOiBBcnJheS5pc0FycmF5KG8pID8gZS5wdXNoKC4uLm8pIDogZS5wdXNoKG8pLCBbXG4gICAgICAuLi50aGlzLnR1bmVzSW5zdGFuY2VzLnZhbHVlcygpLFxuICAgICAgLi4udGhpcy5kZWZhdWx0VHVuZXNJbnN0YW5jZXMudmFsdWVzKClcbiAgICBdLm1hcCgocykgPT4gcy5yZW5kZXIoKSkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgZC5pc0VsZW1lbnQocykgPyB0LnB1c2goe1xuICAgICAgICB0eXBlOiBfLkh0bWwsXG4gICAgICAgIGVsZW1lbnQ6IHNcbiAgICAgIH0pIDogQXJyYXkuaXNBcnJheShzKSA/IHQucHVzaCguLi5zKSA6IHQucHVzaChzKTtcbiAgICB9KSwge1xuICAgICAgdG9vbFR1bmVzOiBlLFxuICAgICAgY29tbW9uVHVuZXM6IHRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgY3VycmVudCBpbnB1dCBpbmRleCB3aXRoIHNlbGVjdGlvbiBhbmNob3Igbm9kZVxuICAgKi9cbiAgdXBkYXRlQ3VycmVudElucHV0KCkge1xuICAgIHRoaXMuY3VycmVudElucHV0ID0gZC5pc05hdGl2ZUlucHV0KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHx8ICFiLmFuY2hvck5vZGUgPyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IDogYi5hbmNob3JOb2RlO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvd3MgdG8gc2F5IEVkaXRvciB0aGF0IEJsb2NrIHdhcyBjaGFuZ2VkLiBVc2VkIHRvIG1hbnVhbGx5IHRyaWdnZXIgRWRpdG9yJ3MgJ29uQ2hhbmdlJyBjYWxsYmFja1xuICAgKiBDYW4gYmUgdXNlZnVsIGZvciBibG9jayBjaGFuZ2VzIGludmlzaWJsZSBmb3IgZWRpdG9yIGNvcmUuXG4gICAqL1xuICBkaXNwYXRjaENoYW5nZSgpIHtcbiAgICB0aGlzLmRpZE11dGF0ZWQoKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBUb29sIGluc3RhbmNlIGRlc3Ryb3kgbWV0aG9kXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW53YXRjaEJsb2NrTXV0YXRpb25zKCksIHRoaXMucmVtb3ZlSW5wdXRFdmVudHMoKSwgc3VwZXIuZGVzdHJveSgpLCBBKHRoaXMudG9vbEluc3RhbmNlLmRlc3Ryb3kpICYmIHRoaXMudG9vbEluc3RhbmNlLmRlc3Ryb3koKTtcbiAgfVxuICAvKipcbiAgICogVG9vbCBjb3VsZCBzcGVjaWZ5IHNldmVyYWwgZW50cmllcyB0byBiZSBkaXNwbGF5ZWQgYXQgdGhlIFRvb2xib3ggKGZvciBleGFtcGxlLCBcIkhlYWRpbmcgMVwiLCBcIkhlYWRpbmcgMlwiLCBcIkhlYWRpbmcgM1wiKVxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbnRyeSB0aGF0IGlzIHJlbGF0ZWQgdG8gdGhlIEJsb2NrIChkZXBlbmRlZCBvbiB0aGUgQmxvY2sgZGF0YSlcbiAgICovXG4gIGFzeW5jIGdldEFjdGl2ZVRvb2xib3hFbnRyeSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy50b29sLnRvb2xib3g7XG4gICAgaWYgKGUubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnRvb2wudG9vbGJveFswXSk7XG4gICAgY29uc3QgdCA9IGF3YWl0IHRoaXMuZGF0YSwgbyA9IGU7XG4gICAgcmV0dXJuIG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uZmluZCgoaSkgPT4gV28oaS5kYXRhLCB0KSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4cG9ydHMgQmxvY2sgZGF0YSBhcyBzdHJpbmcgdXNpbmcgY29udmVyc2lvbiBjb25maWdcbiAgICovXG4gIGFzeW5jIGV4cG9ydERhdGFBc1N0cmluZygpIHtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5kYXRhO1xuICAgIHJldHVybiBmaShlLCB0aGlzLnRvb2wuY29udmVyc2lvbkNvbmZpZyk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2UgZGVmYXVsdCBCbG9jayB3cmFwcGVycyBhbmQgcHV0IFRvb2xgcyBjb250ZW50IHRoZXJlXG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRGl2RWxlbWVudH1cbiAgICovXG4gIGNvbXBvc2UoKSB7XG4gICAgY29uc3QgZSA9IGQubWFrZShcImRpdlwiLCBSLkNTUy53cmFwcGVyKSwgdCA9IGQubWFrZShcImRpdlwiLCBSLkNTUy5jb250ZW50KSwgbyA9IHRoaXMudG9vbEluc3RhbmNlLnJlbmRlcigpO1xuICAgIGUuc2V0QXR0cmlidXRlKFwiZGF0YS1jeVwiLCBcImJsb2NrLXdyYXBwZXJcIiksIGUuZGF0YXNldC5pZCA9IHRoaXMuaWQsIHRoaXMudG9vbFJlbmRlcmVkRWxlbWVudCA9IG8sIHQuYXBwZW5kQ2hpbGQodGhpcy50b29sUmVuZGVyZWRFbGVtZW50KTtcbiAgICBsZXQgaSA9IHQ7XG4gICAgcmV0dXJuIFsuLi50aGlzLnR1bmVzSW5zdGFuY2VzLnZhbHVlcygpLCAuLi50aGlzLmRlZmF1bHRUdW5lc0luc3RhbmNlcy52YWx1ZXMoKV0uZm9yRWFjaCgocykgPT4ge1xuICAgICAgaWYgKEEocy53cmFwKSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpID0gcy53cmFwKGkpO1xuICAgICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgICAgUyhgVHVuZSAke3MuY29uc3RydWN0b3IubmFtZX0gd3JhcCBtZXRob2QgdGhyb3dzIGFuIEVycm9yICVvYCwgXCJ3YXJuXCIsIHIpO1xuICAgICAgICB9XG4gICAgfSksIGUuYXBwZW5kQ2hpbGQoaSksIGU7XG4gIH1cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIEJsb2NrIFR1bmVzXG4gICAqXG4gICAqIEBwYXJhbSB0dW5lc0RhdGEgLSBjdXJyZW50IEJsb2NrIHR1bmVzIGRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbXBvc2VUdW5lcyhlKSB7XG4gICAgQXJyYXkuZnJvbSh0aGlzLnR1bmVzLnZhbHVlcygpKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAodC5pc0ludGVybmFsID8gdGhpcy5kZWZhdWx0VHVuZXNJbnN0YW5jZXMgOiB0aGlzLnR1bmVzSW5zdGFuY2VzKS5zZXQodC5uYW1lLCB0LmNyZWF0ZShlW3QubmFtZV0sIHRoaXMuYmxvY2tBUEkpKTtcbiAgICB9KSwgT2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW3QsIG9dKSA9PiB7XG4gICAgICB0aGlzLnR1bmVzSW5zdGFuY2VzLmhhcyh0KSB8fCAodGhpcy51bmF2YWlsYWJsZVR1bmVzRGF0YVt0XSA9IG8pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGZvY3VzIGV2ZW50IGxpc3RlbmVycyB0byBhbGwgaW5wdXRzIGFuZCBjb250ZW50ZWRpdGFibGVcbiAgICovXG4gIGFkZElucHV0RXZlbnRzKCkge1xuICAgIHRoaXMuaW5wdXRzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuaGFuZGxlRm9jdXMpLCBkLmlzTmF0aXZlSW5wdXQoZSkgJiYgZS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5kaWRNdXRhdGVkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogcmVtb3ZlcyBmb2N1cyBldmVudCBsaXN0ZW5lcnMgZnJvbSBhbGwgaW5wdXRzIGFuZCBjb250ZW50ZWRpdGFibGVcbiAgICovXG4gIHJlbW92ZUlucHV0RXZlbnRzKCkge1xuICAgIHRoaXMuaW5wdXRzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuaGFuZGxlRm9jdXMpLCBkLmlzTmF0aXZlSW5wdXQoZSkgJiYgZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5kaWRNdXRhdGVkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTGlzdGVuIGNvbW1vbiBlZGl0b3IgRG9tIENoYW5nZWQgZXZlbnQgYW5kIGRldGVjdCBtdXRhdGlvbnMgcmVsYXRlZCB0byB0aGUgIEJsb2NrXG4gICAqL1xuICB3YXRjaEJsb2NrTXV0YXRpb25zKCkge1xuICAgIHZhciBlO1xuICAgIHRoaXMucmVkYWN0b3JEb21DaGFuZ2VkQ2FsbGJhY2sgPSAodCkgPT4ge1xuICAgICAgY29uc3QgeyBtdXRhdGlvbnM6IG8gfSA9IHQ7XG4gICAgICBvLnNvbWUoKHMpID0+IHBpKHMsIHRoaXMudG9vbFJlbmRlcmVkRWxlbWVudCkpICYmIHRoaXMuZGlkTXV0YXRlZChvKTtcbiAgICB9LCAoZSA9IHRoaXMuZWRpdG9yRXZlbnRCdXMpID09IG51bGwgfHwgZS5vbihmdCwgdGhpcy5yZWRhY3RvckRvbUNoYW5nZWRDYWxsYmFjayk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSByZWRhY3RvciBkb20gY2hhbmdlIGV2ZW50IGxpc3RlbmVyXG4gICAqL1xuICB1bndhdGNoQmxvY2tNdXRhdGlvbnMoKSB7XG4gICAgdmFyIGU7XG4gICAgKGUgPSB0aGlzLmVkaXRvckV2ZW50QnVzKSA9PSBudWxsIHx8IGUub2ZmKGZ0LCB0aGlzLnJlZGFjdG9yRG9tQ2hhbmdlZENhbGxiYWNrKTtcbiAgfVxuICAvKipcbiAgICogU29tZXRpbWVzIFRvb2wgY2FuIHJlcGxhY2Ugb3duIG1haW4gZWxlbWVudCwgZm9yIGV4YW1wbGUgSDIgLT4gSDQgb3IgVUwgLT4gT0xcbiAgICogV2UgbmVlZCB0byBkZXRlY3Qgc3VjaCBjaGFuZ2VzIGFuZCB1cGRhdGUgYSBsaW5rIHRvIHRvb2xzIG1haW4gZWxlbWVudCB3aXRoIHRoZSBuZXcgb25lXG4gICAqXG4gICAqIEBwYXJhbSBtdXRhdGlvbnMgLSByZWNvcmRzIG9mIGJsb2NrIGNvbnRlbnQgbXV0YXRpb25zXG4gICAqL1xuICBkZXRlY3RUb29sUm9vdENoYW5nZShlKSB7XG4gICAgZS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBpZiAoQXJyYXkuZnJvbSh0LnJlbW92ZWROb2RlcykuaW5jbHVkZXModGhpcy50b29sUmVuZGVyZWRFbGVtZW50KSkge1xuICAgICAgICBjb25zdCBpID0gdC5hZGRlZE5vZGVzW3QuYWRkZWROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy50b29sUmVuZGVyZWRFbGVtZW50ID0gaTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIGlucHV0cyBjYWNoZWQgdmFsdWVcbiAgICovXG4gIGRyb3BJbnB1dHNDYWNoZSgpIHtcbiAgICB0aGlzLmNhY2hlZElucHV0cyA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBNYXJrIGlucHV0cyB3aXRoICdkYXRhLWVtcHR5JyBhdHRyaWJ1dGUgd2l0aCB0aGUgZW1wdHkgc3RhdGVcbiAgICovXG4gIHRvZ2dsZUlucHV0c0VtcHR5TWFyaygpIHtcbiAgICB0aGlzLmlucHV0cy5mb3JFYWNoKERvKTtcbiAgfVxufVxuY2xhc3MgZ2kgZXh0ZW5kcyBFIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5pbnNlcnQgPSAoZSA9IHRoaXMuY29uZmlnLmRlZmF1bHRCbG9jaywgdCA9IHt9LCBvID0ge30sIGksIHMsIHIsIGEpID0+IHtcbiAgICAgIGNvbnN0IGwgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuaW5zZXJ0KHtcbiAgICAgICAgaWQ6IGEsXG4gICAgICAgIHRvb2w6IGUsXG4gICAgICAgIGRhdGE6IHQsXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICBuZWVkVG9Gb2N1czogcyxcbiAgICAgICAgcmVwbGFjZTogclxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IEoobCk7XG4gICAgfSwgdGhpcy5jb21wb3NlQmxvY2tEYXRhID0gYXN5bmMgKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLkVkaXRvci5Ub29scy5ibG9ja1Rvb2xzLmdldChlKTtcbiAgICAgIHJldHVybiBuZXcgUih7XG4gICAgICAgIHRvb2w6IHQsXG4gICAgICAgIGFwaTogdGhpcy5FZGl0b3IuQVBJLFxuICAgICAgICByZWFkT25seTogITAsXG4gICAgICAgIGRhdGE6IHt9LFxuICAgICAgICB0dW5lc0RhdGE6IHt9XG4gICAgICB9KS5kYXRhO1xuICAgIH0sIHRoaXMudXBkYXRlID0gYXN5bmMgKGUsIHQsIG8pID0+IHtcbiAgICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBpIH0gPSB0aGlzLkVkaXRvciwgcyA9IGkuZ2V0QmxvY2tCeUlkKGUpO1xuICAgICAgaWYgKHMgPT09IHZvaWQgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbG9jayB3aXRoIGlkIFwiJHtlfVwiIG5vdCBmb3VuZGApO1xuICAgICAgY29uc3QgciA9IGF3YWl0IGkudXBkYXRlKHMsIHQsIG8pO1xuICAgICAgcmV0dXJuIG5ldyBKKHIpO1xuICAgIH0sIHRoaXMuY29udmVydCA9IGFzeW5jIChlLCB0LCBvKSA9PiB7XG4gICAgICB2YXIgaCwgcDtcbiAgICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBpLCBUb29sczogcyB9ID0gdGhpcy5FZGl0b3IsIHIgPSBpLmdldEJsb2NrQnlJZChlKTtcbiAgICAgIGlmICghcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbG9jayB3aXRoIGlkIFwiJHtlfVwiIG5vdCBmb3VuZGApO1xuICAgICAgY29uc3QgYSA9IHMuYmxvY2tUb29scy5nZXQoci5uYW1lKSwgbCA9IHMuYmxvY2tUb29scy5nZXQodCk7XG4gICAgICBpZiAoIWwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQmxvY2sgVG9vbCB3aXRoIHR5cGUgXCIke3R9XCIgbm90IGZvdW5kYCk7XG4gICAgICBjb25zdCBjID0gKChoID0gYSA9PSBudWxsID8gdm9pZCAwIDogYS5jb252ZXJzaW9uQ29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogaC5leHBvcnQpICE9PSB2b2lkIDAsIHUgPSAoKHAgPSBsLmNvbnZlcnNpb25Db25maWcpID09IG51bGwgPyB2b2lkIDAgOiBwLmltcG9ydCkgIT09IHZvaWQgMDtcbiAgICAgIGlmIChjICYmIHUpIHtcbiAgICAgICAgY29uc3QgZyA9IGF3YWl0IGkuY29udmVydChyLCB0LCBvKTtcbiAgICAgICAgcmV0dXJuIG5ldyBKKGcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZyA9IFtcbiAgICAgICAgICBjID8gITEgOiBqZShyLm5hbWUpLFxuICAgICAgICAgIHUgPyAhMSA6IGplKHQpXG4gICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgYW5kIFwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb252ZXJzaW9uIGZyb20gXCIke3IubmFtZX1cIiB0byBcIiR7dH1cIiBpcyBub3QgcG9zc2libGUuICR7Z30gdG9vbChzKSBzaG91bGQgcHJvdmlkZSBhIFwiY29udmVyc2lvbkNvbmZpZ1wiYCk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5pbnNlcnRNYW55ID0gKGUsIHQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuYmxvY2tzLmxlbmd0aCAtIDEpID0+IHtcbiAgICAgIHRoaXMudmFsaWRhdGVJbmRleCh0KTtcbiAgICAgIGNvbnN0IG8gPSBlLm1hcCgoeyBpZDogaSwgdHlwZTogcywgZGF0YTogciB9KSA9PiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY29tcG9zZUJsb2NrKHtcbiAgICAgICAgaWQ6IGksXG4gICAgICAgIHRvb2w6IHMgfHwgdGhpcy5jb25maWcuZGVmYXVsdEJsb2NrLFxuICAgICAgICBkYXRhOiByXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmluc2VydE1hbnkobywgdCksIG8ubWFwKChpKSA9PiBuZXcgSihpKSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2Nrc31cbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGVhcjogKCkgPT4gdGhpcy5jbGVhcigpLFxuICAgICAgcmVuZGVyOiAoZSkgPT4gdGhpcy5yZW5kZXIoZSksXG4gICAgICByZW5kZXJGcm9tSFRNTDogKGUpID0+IHRoaXMucmVuZGVyRnJvbUhUTUwoZSksXG4gICAgICBkZWxldGU6IChlKSA9PiB0aGlzLmRlbGV0ZShlKSxcbiAgICAgIHN3YXA6IChlLCB0KSA9PiB0aGlzLnN3YXAoZSwgdCksXG4gICAgICBtb3ZlOiAoZSwgdCkgPT4gdGhpcy5tb3ZlKGUsIHQpLFxuICAgICAgZ2V0QmxvY2tCeUluZGV4OiAoZSkgPT4gdGhpcy5nZXRCbG9ja0J5SW5kZXgoZSksXG4gICAgICBnZXRCeUlkOiAoZSkgPT4gdGhpcy5nZXRCeUlkKGUpLFxuICAgICAgZ2V0Q3VycmVudEJsb2NrSW5kZXg6ICgpID0+IHRoaXMuZ2V0Q3VycmVudEJsb2NrSW5kZXgoKSxcbiAgICAgIGdldEJsb2NrSW5kZXg6IChlKSA9PiB0aGlzLmdldEJsb2NrSW5kZXgoZSksXG4gICAgICBnZXRCbG9ja3NDb3VudDogKCkgPT4gdGhpcy5nZXRCbG9ja3NDb3VudCgpLFxuICAgICAgZ2V0QmxvY2tCeUVsZW1lbnQ6IChlKSA9PiB0aGlzLmdldEJsb2NrQnlFbGVtZW50KGUpLFxuICAgICAgc3RyZXRjaEJsb2NrOiAoZSwgdCA9ICEwKSA9PiB0aGlzLnN0cmV0Y2hCbG9jayhlLCB0KSxcbiAgICAgIGluc2VydE5ld0Jsb2NrOiAoKSA9PiB0aGlzLmluc2VydE5ld0Jsb2NrKCksXG4gICAgICBpbnNlcnQ6IHRoaXMuaW5zZXJ0LFxuICAgICAgaW5zZXJ0TWFueTogdGhpcy5pbnNlcnRNYW55LFxuICAgICAgdXBkYXRlOiB0aGlzLnVwZGF0ZSxcbiAgICAgIGNvbXBvc2VCbG9ja0RhdGE6IHRoaXMuY29tcG9zZUJsb2NrRGF0YSxcbiAgICAgIGNvbnZlcnQ6IHRoaXMuY29udmVydFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgQmxvY2tzIGNvdW50XG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBnZXRCbG9ja3NDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmJsb2Nrcy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgY3VycmVudCBibG9jayBpbmRleFxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0Q3VycmVudEJsb2NrSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2tJbmRleDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgQmxvY2sgYnkgaWQ7XG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIGJsb2NrIGlkXG4gICAqL1xuICBnZXRCbG9ja0luZGV4KGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlJZChlKTtcbiAgICBpZiAoIXQpIHtcbiAgICAgIFgoXCJUaGVyZSBpcyBubyBibG9jayB3aXRoIGlkIGBcIiArIGUgKyBcImBcIiwgXCJ3YXJuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrSW5kZXgodCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgQmxvY2tBUEkgb2JqZWN0IGJ5IEJsb2NrIGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IHRvIGdldFxuICAgKi9cbiAgZ2V0QmxvY2tCeUluZGV4KGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlJbmRleChlKTtcbiAgICBpZiAodCA9PT0gdm9pZCAwKSB7XG4gICAgICBYKFwiVGhlcmUgaXMgbm8gYmxvY2sgYXQgaW5kZXggYFwiICsgZSArIFwiYFwiLCBcIndhcm5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBuZXcgSih0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBCbG9ja0FQSSBvYmplY3QgYnkgQmxvY2sgaWRcbiAgICpcbiAgICogQHBhcmFtIGlkIC0gaWQgb2YgYmxvY2sgdG8gZ2V0XG4gICAqL1xuICBnZXRCeUlkKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlJZChlKTtcbiAgICByZXR1cm4gdCA9PT0gdm9pZCAwID8gKFgoXCJUaGVyZSBpcyBubyBibG9jayB3aXRoIGlkIGBcIiArIGUgKyBcImBcIiwgXCJ3YXJuXCIpLCBudWxsKSA6IG5ldyBKKHQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgQmxvY2sgQVBJIG9iamVjdCBieSBhbnkgY2hpbGQgaHRtbCBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSBlbGVtZW50IC0gaHRtbCBlbGVtZW50IHRvIGdldCBCbG9jayBieVxuICAgKi9cbiAgZ2V0QmxvY2tCeUVsZW1lbnQoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2soZSk7XG4gICAgaWYgKHQgPT09IHZvaWQgMCkge1xuICAgICAgWChcIlRoZXJlIGlzIG5vIGJsb2NrIGNvcnJlc3BvbmRpbmcgdG8gZWxlbWVudCBgXCIgKyBlICsgXCJgXCIsIFwid2FyblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBKKHQpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIEJsb2NrIE1hbmFnZXIgbWV0aG9kIHRoYXQgc3dhcCBCbG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCAtIHBvc2l0aW9uIG9mIGZpcnN0IEJsb2NrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IC0gcG9zaXRpb24gb2Ygc2Vjb25kIEJsb2NrXG4gICAqIEBkZXByZWNhdGVkIOKAlCB1c2UgJ21vdmUnIGluc3RlYWRcbiAgICovXG4gIHN3YXAoZSwgdCkge1xuICAgIFMoXG4gICAgICBcImBibG9ja3Muc3dhcCgpYCBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuIFVzZSBgYmxvY2subW92ZSgpYCBtZXRob2QgaW5zdGVhZFwiLFxuICAgICAgXCJpbmZvXCJcbiAgICApLCB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuc3dhcChlLCB0KTtcbiAgfVxuICAvKipcbiAgICogTW92ZSBibG9jayBmcm9tIG9uZSBpbmRleCB0byBhbm90aGVyXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IC0gaW5kZXggdG8gbW92ZSB0b1xuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IC0gaW5kZXggdG8gbW92ZSBmcm9tXG4gICAqL1xuICBtb3ZlKGUsIHQpIHtcbiAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIubW92ZShlLCB0KTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tJbmRleCAtIGluZGV4IG9mIEJsb2NrIHRvIGRlbGV0ZVxuICAgKi9cbiAgZGVsZXRlKGUgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrSW5kZXgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0J5SW5kZXgoZSk7XG4gICAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIucmVtb3ZlQmxvY2sodCk7XG4gICAgfSBjYXRjaCAodCkge1xuICAgICAgWCh0LCBcIndhcm5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5ibG9ja3MubGVuZ3RoID09PSAwICYmIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5pbnNlcnQoKSwgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jayAmJiB0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2ssIHRoaXMuRWRpdG9yLkNhcmV0LnBvc2l0aW9ucy5FTkQpLCB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIEVkaXRvcidzIGFyZWFcbiAgICovXG4gIGFzeW5jIGNsZWFyKCkge1xuICAgIGF3YWl0IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jbGVhcighMCksIHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogRmlsbHMgRWRpdG9yIHdpdGggQmxvY2tzIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtPdXRwdXREYXRhfSBkYXRhIOKAlCBTYXZlZCBFZGl0b3IgZGF0YVxuICAgKi9cbiAgYXN5bmMgcmVuZGVyKGUpIHtcbiAgICBpZiAoZSA9PT0gdm9pZCAwIHx8IGUuYmxvY2tzID09PSB2b2lkIDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvcnJlY3QgZGF0YSBwYXNzZWQgdG8gdGhlIHJlbmRlcigpIG1ldGhvZFwiKTtcbiAgICB0aGlzLkVkaXRvci5Nb2RpZmljYXRpb25zT2JzZXJ2ZXIuZGlzYWJsZSgpLCBhd2FpdCB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY2xlYXIoKSwgYXdhaXQgdGhpcy5FZGl0b3IuUmVuZGVyZXIucmVuZGVyKGUuYmxvY2tzKSwgdGhpcy5FZGl0b3IuTW9kaWZpY2F0aW9uc09ic2VydmVyLmVuYWJsZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXIgcGFzc2VkIEhUTUwgc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gSFRNTCBzdHJpbmcgdG8gcmVuZGVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgcmVuZGVyRnJvbUhUTUwoZSkge1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY2xlYXIoKSwgdGhpcy5FZGl0b3IuUGFzdGUucHJvY2Vzc1RleHQoZSwgITApO1xuICB9XG4gIC8qKlxuICAgKiBTdHJldGNoIEJsb2NrJ3MgY29udGVudFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCBvZiBCbG9jayB0byBzdHJldGNoXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdHVzIC0gdHJ1ZSB0byBlbmFibGUsIGZhbHNlIHRvIGRpc2FibGVcbiAgICogQGRlcHJlY2F0ZWQgVXNlIEJsb2NrQVBJIGludGVyZmFjZSB0byBzdHJldGNoIEJsb2Nrc1xuICAgKi9cbiAgc3RyZXRjaEJsb2NrKGUsIHQgPSAhMCkge1xuICAgIGh0KFxuICAgICAgITAsXG4gICAgICBcImJsb2Nrcy5zdHJldGNoQmxvY2soKVwiLFxuICAgICAgXCJCbG9ja0FQSVwiXG4gICAgKTtcbiAgICBjb25zdCBvID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlJbmRleChlKTtcbiAgICBvICYmIChvLnN0cmV0Y2hlZCA9IHQpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgbmV3IEJsb2NrXG4gICAqIEFmdGVyIHNldCBjYXJldCB0byB0aGlzIEJsb2NrXG4gICAqXG4gICAqIEB0b2RvIHJlbW92ZSBpbiAzLjAuMFxuICAgKiBAZGVwcmVjYXRlZCB3aXRoIGluc2VydCgpIG1ldGhvZFxuICAgKi9cbiAgaW5zZXJ0TmV3QmxvY2soKSB7XG4gICAgUyhcIk1ldGhvZCBibG9ja3MuaW5zZXJ0TmV3QmxvY2soKSBpcyBkZXByZWNhdGVkIGFuZCBpdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gVXNlIGJsb2Nrcy5pbnNlcnQoKSBpbnN0ZWFkLlwiLCBcIndhcm5cIiksIHRoaXMuaW5zZXJ0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlZCBibG9jayBpbmRleCBhbmQgdGhyb3dzIGFuIGVycm9yIGlmIGl0J3MgaW52YWxpZFxuICAgKlxuICAgKiBAcGFyYW0gaW5kZXggLSBpbmRleCB0byB2YWxpZGF0ZVxuICAgKi9cbiAgdmFsaWRhdGVJbmRleChlKSB7XG4gICAgaWYgKHR5cGVvZiBlICE9IFwibnVtYmVyXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmRleCBzaG91bGQgYmUgYSBudW1iZXJcIik7XG4gICAgaWYgKGUgPCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwXCIpO1xuICAgIGlmIChlID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwXCIpO1xuICB9XG59XG5mdW5jdGlvbiBtaShuLCBlKSB7XG4gIHJldHVybiB0eXBlb2YgbiA9PSBcIm51bWJlclwiID8gZS5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUluZGV4KG4pIDogdHlwZW9mIG4gPT0gXCJzdHJpbmdcIiA/IGUuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlJZChuKSA6IGUuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlJZChuLmlkKTtcbn1cbmNsYXNzIGJpIGV4dGVuZHMgRSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuc2V0VG9GaXJzdEJsb2NrID0gKGUgPSB0aGlzLkVkaXRvci5DYXJldC5wb3NpdGlvbnMuREVGQVVMVCwgdCA9IDApID0+IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5maXJzdEJsb2NrID8gKHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2sodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmZpcnN0QmxvY2ssIGUsIHQpLCAhMCkgOiAhMSwgdGhpcy5zZXRUb0xhc3RCbG9jayA9IChlID0gdGhpcy5FZGl0b3IuQ2FyZXQucG9zaXRpb25zLkRFRkFVTFQsIHQgPSAwKSA9PiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIubGFzdEJsb2NrID8gKHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2sodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmxhc3RCbG9jaywgZSwgdCksICEwKSA6ICExLCB0aGlzLnNldFRvUHJldmlvdXNCbG9jayA9IChlID0gdGhpcy5FZGl0b3IuQ2FyZXQucG9zaXRpb25zLkRFRkFVTFQsIHQgPSAwKSA9PiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIucHJldmlvdXNCbG9jayA/ICh0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5wcmV2aW91c0Jsb2NrLCBlLCB0KSwgITApIDogITEsIHRoaXMuc2V0VG9OZXh0QmxvY2sgPSAoZSA9IHRoaXMuRWRpdG9yLkNhcmV0LnBvc2l0aW9ucy5ERUZBVUxULCB0ID0gMCkgPT4gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLm5leHRCbG9jayA/ICh0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5uZXh0QmxvY2ssIGUsIHQpLCAhMCkgOiAhMSwgdGhpcy5zZXRUb0Jsb2NrID0gKGUsIHQgPSB0aGlzLkVkaXRvci5DYXJldC5wb3NpdGlvbnMuREVGQVVMVCwgbyA9IDApID0+IHtcbiAgICAgIGNvbnN0IGkgPSBtaShlLCB0aGlzLkVkaXRvcik7XG4gICAgICByZXR1cm4gaSA9PT0gdm9pZCAwID8gITEgOiAodGhpcy5FZGl0b3IuQ2FyZXQuc2V0VG9CbG9jayhpLCB0LCBvKSwgITApO1xuICAgIH0sIHRoaXMuZm9jdXMgPSAoZSA9ICExKSA9PiBlID8gdGhpcy5zZXRUb0xhc3RCbG9jayh0aGlzLkVkaXRvci5DYXJldC5wb3NpdGlvbnMuRU5EKSA6IHRoaXMuc2V0VG9GaXJzdEJsb2NrKHRoaXMuRWRpdG9yLkNhcmV0LnBvc2l0aW9ucy5TVEFSVCk7XG4gIH1cbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzXG4gICAqXG4gICAqIEByZXR1cm5zIHtDYXJldH1cbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRUb0ZpcnN0QmxvY2s6IHRoaXMuc2V0VG9GaXJzdEJsb2NrLFxuICAgICAgc2V0VG9MYXN0QmxvY2s6IHRoaXMuc2V0VG9MYXN0QmxvY2ssXG4gICAgICBzZXRUb1ByZXZpb3VzQmxvY2s6IHRoaXMuc2V0VG9QcmV2aW91c0Jsb2NrLFxuICAgICAgc2V0VG9OZXh0QmxvY2s6IHRoaXMuc2V0VG9OZXh0QmxvY2ssXG4gICAgICBzZXRUb0Jsb2NrOiB0aGlzLnNldFRvQmxvY2ssXG4gICAgICBmb2N1czogdGhpcy5mb2N1c1xuICAgIH07XG4gIH1cbn1cbmNsYXNzIHZpIGV4dGVuZHMgRSB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKlxuICAgKiBAcmV0dXJucyB7RXZlbnRzfVxuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVtaXQ6IChlLCB0KSA9PiB0aGlzLmVtaXQoZSwgdCksXG4gICAgICBvZmY6IChlLCB0KSA9PiB0aGlzLm9mZihlLCB0KSxcbiAgICAgIG9uOiAoZSwgdCkgPT4gdGhpcy5vbihlLCB0KVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSBvbiBFdmVudHNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIGV2ZW50IG5hbWUgdG8gc3Vic2NyaWJlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgb24oZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5vbihlLCB0KTtcbiAgfVxuICAvKipcbiAgICogRW1pdCBldmVudCB3aXRoIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIGV2ZW50IHRvIGVtaXRcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBldmVudCdzIGRhdGFcbiAgICovXG4gIGVtaXQoZSwgdCkge1xuICAgIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5lbWl0KGUsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBmcm9tIEV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBldmVudCB0byB1bnN1YnNjcmliZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIG9mZihlLCB0KSB7XG4gICAgdGhpcy5ldmVudHNEaXNwYXRjaGVyLm9mZihlLCB0KTtcbiAgfVxufVxuY2xhc3Mga3QgZXh0ZW5kcyBFIHtcbiAgLyoqXG4gICAqIFJldHVybiBuYW1lc3BhY2Ugc2VjdGlvbiBmb3IgdG9vbCBvciBibG9jayB0dW5lXG4gICAqXG4gICAqIEBwYXJhbSB0b29sTmFtZSAtIHRvb2wgbmFtZVxuICAgKiBAcGFyYW0gaXNUdW5lIC0gaXMgdG9vbCBhIGJsb2NrIHR1bmVcbiAgICovXG4gIHN0YXRpYyBnZXROYW1lc3BhY2UoZSwgdCkge1xuICAgIHJldHVybiB0ID8gYGJsb2NrVHVuZXMuJHtlfWAgOiBgdG9vbHMuJHtlfWA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBJMThuIEFQSSBtZXRob2RzIHdpdGggZ2xvYmFsIGRpY3Rpb25hcnkgYWNjZXNzXG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdDogKCkgPT4ge1xuICAgICAgICBYKFwiSTE4bi50KCkgbWV0aG9kIGNhbiBiZSBhY2Nlc3NlZCBvbmx5IGZyb20gVG9vbHNcIiwgXCJ3YXJuXCIpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBJMThuIEFQSSBtZXRob2RzIHdpdGggdG9vbCBuYW1lc3BhY2VkIGRpY3Rpb25hcnlcbiAgICpcbiAgICogQHBhcmFtIHRvb2xOYW1lIC0gdG9vbCBuYW1lXG4gICAqIEBwYXJhbSBpc1R1bmUgLSBpcyB0b29sIGEgYmxvY2sgdHVuZVxuICAgKi9cbiAgZ2V0TWV0aG9kc0ZvclRvb2woZSwgdCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgdGhpcy5tZXRob2RzLFxuICAgICAge1xuICAgICAgICB0OiAobykgPT4gei50KGt0LmdldE5hbWVzcGFjZShlLCB0KSwgbylcbiAgICAgIH1cbiAgICApO1xuICB9XG59XG5jbGFzcyBraSBleHRlbmRzIEUge1xuICAvKipcbiAgICogRWRpdG9yLmpzIENvcmUgQVBJIG1vZHVsZXNcbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBibG9ja3M6IHRoaXMuRWRpdG9yLkJsb2Nrc0FQSS5tZXRob2RzLFxuICAgICAgY2FyZXQ6IHRoaXMuRWRpdG9yLkNhcmV0QVBJLm1ldGhvZHMsXG4gICAgICB0b29sczogdGhpcy5FZGl0b3IuVG9vbHNBUEkubWV0aG9kcyxcbiAgICAgIGV2ZW50czogdGhpcy5FZGl0b3IuRXZlbnRzQVBJLm1ldGhvZHMsXG4gICAgICBsaXN0ZW5lcnM6IHRoaXMuRWRpdG9yLkxpc3RlbmVyc0FQSS5tZXRob2RzLFxuICAgICAgbm90aWZpZXI6IHRoaXMuRWRpdG9yLk5vdGlmaWVyQVBJLm1ldGhvZHMsXG4gICAgICBzYW5pdGl6ZXI6IHRoaXMuRWRpdG9yLlNhbml0aXplckFQSS5tZXRob2RzLFxuICAgICAgc2F2ZXI6IHRoaXMuRWRpdG9yLlNhdmVyQVBJLm1ldGhvZHMsXG4gICAgICBzZWxlY3Rpb246IHRoaXMuRWRpdG9yLlNlbGVjdGlvbkFQSS5tZXRob2RzLFxuICAgICAgc3R5bGVzOiB0aGlzLkVkaXRvci5TdHlsZXNBUEkuY2xhc3NlcyxcbiAgICAgIHRvb2xiYXI6IHRoaXMuRWRpdG9yLlRvb2xiYXJBUEkubWV0aG9kcyxcbiAgICAgIGlubGluZVRvb2xiYXI6IHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXJBUEkubWV0aG9kcyxcbiAgICAgIHRvb2x0aXA6IHRoaXMuRWRpdG9yLlRvb2x0aXBBUEkubWV0aG9kcyxcbiAgICAgIGkxOG46IHRoaXMuRWRpdG9yLkkxOG5BUEkubWV0aG9kcyxcbiAgICAgIHJlYWRPbmx5OiB0aGlzLkVkaXRvci5SZWFkT25seUFQSS5tZXRob2RzLFxuICAgICAgdWk6IHRoaXMuRWRpdG9yLlVpQVBJLm1ldGhvZHNcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEVkaXRvci5qcyBDb3JlIEFQSSBtZXRob2RzIGZvciBwYXNzZWQgdG9vbFxuICAgKlxuICAgKiBAcGFyYW0gdG9vbE5hbWUgLSB0b29sIG5hbWVcbiAgICogQHBhcmFtIGlzVHVuZSAtIGlzIHRvb2wgYSBibG9jayB0dW5lXG4gICAqL1xuICBnZXRNZXRob2RzRm9yVG9vbChlLCB0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICB0aGlzLm1ldGhvZHMsXG4gICAgICB7XG4gICAgICAgIGkxOG46IHRoaXMuRWRpdG9yLkkxOG5BUEkuZ2V0TWV0aG9kc0ZvclRvb2woZSwgdClcbiAgICAgIH1cbiAgICApO1xuICB9XG59XG5jbGFzcyB5aSBleHRlbmRzIEUge1xuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICpcbiAgICogQHJldHVybnMge0lubGluZVRvb2xiYXJ9XG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xvc2U6ICgpID0+IHRoaXMuY2xvc2UoKSxcbiAgICAgIG9wZW46ICgpID0+IHRoaXMub3BlbigpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogT3BlbiBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgb3BlbigpIHtcbiAgICB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLnRyeVRvU2hvdygpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5FZGl0b3IuSW5saW5lVG9vbGJhci5jbG9zZSgpO1xuICB9XG59XG5jbGFzcyB3aSBleHRlbmRzIEUge1xuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICpcbiAgICogQHJldHVybnMge0xpc3RlbmVyc31cbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbjogKGUsIHQsIG8sIGkpID0+IHRoaXMub24oZSwgdCwgbywgaSksXG4gICAgICBvZmY6IChlLCB0LCBvLCBpKSA9PiB0aGlzLm9mZihlLCB0LCBvLCBpKSxcbiAgICAgIG9mZkJ5SWQ6IChlKSA9PiB0aGlzLm9mZkJ5SWQoZSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBZHMgYSBET00gZXZlbnQgbGlzdGVuZXIuIFJldHVybiBpdCdzIGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBzZXQgaGFuZGxlciB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIC0gZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0geygpID0+IHZvaWR9IGhhbmRsZXIgLSBldmVudCBoYW5kbGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQ2FwdHVyZSAtIGNhcHR1cmUgZXZlbnQgb3Igbm90XG4gICAqL1xuICBvbihlLCB0LCBvLCBpKSB7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLm9uKGUsIHQsIG8sIGkpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIERPTSBsaXN0ZW5lciBmcm9tIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byByZW1vdmUgaGFuZGxlciBmcm9tXG4gICAqIEBwYXJhbSBldmVudFR5cGUgLSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSBoYW5kbGVyIC0gZXZlbnQgaGFuZGxlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUNhcHR1cmUgLSBjYXB0dXJlIGV2ZW50IG9yIG5vdFxuICAgKi9cbiAgb2ZmKGUsIHQsIG8sIGkpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5vZmYoZSwgdCwgbywgaSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgRE9NIGxpc3RlbmVyIGJ5IHRoZSBsaXN0ZW5lciBpZFxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBpZCBvZiB0aGUgbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqL1xuICBvZmZCeUlkKGUpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5vZmZCeUlkKGUpO1xuICB9XG59XG52YXIgS28gPSB7IGV4cG9ydHM6IHt9IH07XG4oZnVuY3Rpb24obiwgZSkge1xuICAoZnVuY3Rpb24odCwgbykge1xuICAgIG4uZXhwb3J0cyA9IG8oKTtcbiAgfSkod2luZG93LCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIG8gPSB7fTtcbiAgICAgIGZ1bmN0aW9uIGkocykge1xuICAgICAgICBpZiAob1tzXSlcbiAgICAgICAgICByZXR1cm4gb1tzXS5leHBvcnRzO1xuICAgICAgICB2YXIgciA9IG9bc10gPSB7IGk6IHMsIGw6ICExLCBleHBvcnRzOiB7fSB9O1xuICAgICAgICByZXR1cm4gdFtzXS5jYWxsKHIuZXhwb3J0cywgciwgci5leHBvcnRzLCBpKSwgci5sID0gITAsIHIuZXhwb3J0cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBpLm0gPSB0LCBpLmMgPSBvLCBpLmQgPSBmdW5jdGlvbihzLCByLCBhKSB7XG4gICAgICAgIGkubyhzLCByKSB8fCBPYmplY3QuZGVmaW5lUHJvcGVydHkocywgciwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBhIH0pO1xuICAgICAgfSwgaS5yID0gZnVuY3Rpb24ocykge1xuICAgICAgICB0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gICAgICB9LCBpLnQgPSBmdW5jdGlvbihzLCByKSB7XG4gICAgICAgIGlmICgxICYgciAmJiAocyA9IGkocykpLCA4ICYgciB8fCA0ICYgciAmJiB0eXBlb2YgcyA9PSBcIm9iamVjdFwiICYmIHMgJiYgcy5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB2YXIgYSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBpZiAoaS5yKGEpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogITAsIHZhbHVlOiBzIH0pLCAyICYgciAmJiB0eXBlb2YgcyAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgIGZvciAodmFyIGwgaW4gcylcbiAgICAgICAgICAgIGkuZChhLCBsLCAoZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICByZXR1cm4gc1tjXTtcbiAgICAgICAgICAgIH0pLmJpbmQobnVsbCwgbCkpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sIGkubiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHIgPSBzICYmIHMuX19lc01vZHVsZSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzLmRlZmF1bHQ7XG4gICAgICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGkuZChyLCBcImFcIiwgciksIHI7XG4gICAgICB9LCBpLm8gPSBmdW5jdGlvbihzLCByKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcik7XG4gICAgICB9LCBpLnAgPSBcIi9cIiwgaShpLnMgPSAwKTtcbiAgICB9KFtmdW5jdGlvbih0LCBvLCBpKSB7XG4gICAgICBpKDEpLCAvKiFcbiAgICAgICAqIENvZGV4IEphdmFTY3JpcHQgTm90aWZpY2F0aW9uIG1vZHVsZVxuICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL2NvZGV4LXRlYW0vanMtbm90aWZpZXJcbiAgICAgICAqL1xuICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzID0gaSg2KSwgciA9IFwiY2R4LW5vdGlmeS0tYm91bmNlLWluXCIsIGEgPSBudWxsO1xuICAgICAgICByZXR1cm4geyBzaG93OiBmdW5jdGlvbihsKSB7XG4gICAgICAgICAgaWYgKGwubWVzc2FnZSkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoYSlcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgIGEgPSBzLmdldFdyYXBwZXIoKSwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB2YXIgYyA9IG51bGwsIHUgPSBsLnRpbWUgfHwgOGUzO1xuICAgICAgICAgICAgc3dpdGNoIChsLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImNvbmZpcm1cIjpcbiAgICAgICAgICAgICAgICBjID0gcy5jb25maXJtKGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwicHJvbXB0XCI6XG4gICAgICAgICAgICAgICAgYyA9IHMucHJvbXB0KGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGMgPSBzLmFsZXJ0KGwpLCB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGMucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfSwgdSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhLmFwcGVuZENoaWxkKGMpLCBjLmNsYXNzTGlzdC5hZGQocik7XG4gICAgICAgICAgfVxuICAgICAgICB9IH07XG4gICAgICB9KCk7XG4gICAgfSwgZnVuY3Rpb24odCwgbywgaSkge1xuICAgICAgdmFyIHMgPSBpKDIpO1xuICAgICAgdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiAmJiAocyA9IFtbdC5pLCBzLCBcIlwiXV0pO1xuICAgICAgdmFyIHIgPSB7IGhtcjogITAsIHRyYW5zZm9ybTogdm9pZCAwLCBpbnNlcnRJbnRvOiB2b2lkIDAgfTtcbiAgICAgIGkoNCkocywgciksIHMubG9jYWxzICYmICh0LmV4cG9ydHMgPSBzLmxvY2Fscyk7XG4gICAgfSwgZnVuY3Rpb24odCwgbywgaSkge1xuICAgICAgKHQuZXhwb3J0cyA9IGkoMykoITEpKS5wdXNoKFt0LmksIGAuY2R4LW5vdGlmeS0tZXJyb3J7YmFja2dyb3VuZDojZmZmYmZiIWltcG9ydGFudH0uY2R4LW5vdGlmeS0tZXJyb3I6OmJlZm9yZXtiYWNrZ3JvdW5kOiNmYjVkNWQhaW1wb3J0YW50fS5jZHgtbm90aWZ5X19pbnB1dHttYXgtd2lkdGg6MTMwcHg7cGFkZGluZzo1cHggMTBweDtiYWNrZ3JvdW5kOiNmN2Y3Zjc7Ym9yZGVyOjA7Ym9yZGVyLXJhZGl1czozcHg7Zm9udC1zaXplOjEzcHg7Y29sb3I6IzY1NmI3YztvdXRsaW5lOjB9LmNkeC1ub3RpZnlfX2lucHV0Oi1tcy1pbnB1dC1wbGFjZWhvbGRlcntjb2xvcjojNjU2YjdjfS5jZHgtbm90aWZ5X19pbnB1dDo6cGxhY2Vob2xkZXJ7Y29sb3I6IzY1NmI3Y30uY2R4LW5vdGlmeV9faW5wdXQ6Zm9jdXM6LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOnJnYmEoMTAxLDEwNywxMjQsLjMpfS5jZHgtbm90aWZ5X19pbnB1dDpmb2N1czo6cGxhY2Vob2xkZXJ7Y29sb3I6cmdiYSgxMDEsMTA3LDEyNCwuMyl9LmNkeC1ub3RpZnlfX2J1dHRvbntib3JkZXI6bm9uZTtib3JkZXItcmFkaXVzOjNweDtmb250LXNpemU6MTNweDtwYWRkaW5nOjVweCAxMHB4O2N1cnNvcjpwb2ludGVyfS5jZHgtbm90aWZ5X19idXR0b246bGFzdC1jaGlsZHttYXJnaW4tbGVmdDoxMHB4fS5jZHgtbm90aWZ5X19idXR0b24tLWNhbmNlbHtiYWNrZ3JvdW5kOiNmMmY1Zjc7Ym94LXNoYWRvdzowIDJweCAxcHggMCByZ2JhKDE2LDE5LDI5LDApO2NvbG9yOiM2NTZiN2N9LmNkeC1ub3RpZnlfX2J1dHRvbi0tY2FuY2VsOmhvdmVye2JhY2tncm91bmQ6I2VlZX0uY2R4LW5vdGlmeV9fYnV0dG9uLS1jb25maXJte2JhY2tncm91bmQ6IzM0Yzk5Mjtib3gtc2hhZG93OjAgMXB4IDFweCAwIHJnYmEoMTgsNDksMzUsLjA1KTtjb2xvcjojZmZmfS5jZHgtbm90aWZ5X19idXR0b24tLWNvbmZpcm06aG92ZXJ7YmFja2dyb3VuZDojMzNiMDgyfS5jZHgtbm90aWZ5X19idG5zLXdyYXBwZXJ7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LW1zLWZsZXgtZmxvdzpyb3cgbm93cmFwO2ZsZXgtZmxvdzpyb3cgbm93cmFwO21hcmdpbi10b3A6NXB4fS5jZHgtbm90aWZ5X19jcm9zc3twb3NpdGlvbjphYnNvbHV0ZTt0b3A6NXB4O3JpZ2h0OjVweDt3aWR0aDoxMHB4O2hlaWdodDoxMHB4O3BhZGRpbmc6NXB4O29wYWNpdHk6LjU0O2N1cnNvcjpwb2ludGVyfS5jZHgtbm90aWZ5X19jcm9zczo6YWZ0ZXIsLmNkeC1ub3RpZnlfX2Nyb3NzOjpiZWZvcmV7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjlweDt0b3A6NXB4O2hlaWdodDoxMnB4O3dpZHRoOjJweDtiYWNrZ3JvdW5kOiM1NzVkNjd9LmNkeC1ub3RpZnlfX2Nyb3NzOjpiZWZvcmV7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfS5jZHgtbm90aWZ5X19jcm9zczo6YWZ0ZXJ7dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9LmNkeC1ub3RpZnlfX2Nyb3NzOmhvdmVye29wYWNpdHk6MX0uY2R4LW5vdGlmaWVze3Bvc2l0aW9uOmZpeGVkO3otaW5kZXg6Mjtib3R0b206MjBweDtsZWZ0OjIwcHg7Zm9udC1mYW1pbHk6LWFwcGxlLXN5c3RlbSxCbGlua01hY1N5c3RlbUZvbnQsXCJTZWdvZSBVSVwiLFJvYm90byxPeHlnZW4sVWJ1bnR1LENhbnRhcmVsbCxcIkZpcmEgU2Fuc1wiLFwiRHJvaWQgU2Fuc1wiLFwiSGVsdmV0aWNhIE5ldWVcIixzYW5zLXNlcmlmfS5jZHgtbm90aWZ5e3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjIyMHB4O21hcmdpbi10b3A6MTVweDtwYWRkaW5nOjEzcHggMTZweDtiYWNrZ3JvdW5kOiNmZmY7Ym94LXNoYWRvdzowIDExcHggMTdweCAwIHJnYmEoMjMsMzIsNjEsLjEzKTtib3JkZXItcmFkaXVzOjVweDtmb250LXNpemU6MTRweDtsaW5lLWhlaWdodDoxLjRlbTt3b3JkLXdyYXA6YnJlYWstd29yZH0uY2R4LW5vdGlmeTo6YmVmb3Jle2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jazt0b3A6MDtsZWZ0OjA7d2lkdGg6M3B4O2hlaWdodDpjYWxjKDEwMCUgLSA2cHgpO21hcmdpbjozcHg7Ym9yZGVyLXJhZGl1czo1cHg7YmFja2dyb3VuZDowIDB9QGtleWZyYW1lcyBib3VuY2VJbnswJXtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlKC4zKX01MCV7b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZSgxLjA1KX03MCV7dHJhbnNmb3JtOnNjYWxlKC45KX0xMDAle3RyYW5zZm9ybTpzY2FsZSgxKX19LmNkeC1ub3RpZnktLWJvdW5jZS1pbnthbmltYXRpb24tbmFtZTpib3VuY2VJbjthbmltYXRpb24tZHVyYXRpb246LjZzO2FuaW1hdGlvbi1pdGVyYXRpb24tY291bnQ6MX0uY2R4LW5vdGlmeS0tc3VjY2Vzc3tiYWNrZ3JvdW5kOiNmYWZmZmUhaW1wb3J0YW50fS5jZHgtbm90aWZ5LS1zdWNjZXNzOjpiZWZvcmV7YmFja2dyb3VuZDojNDFmZmIxIWltcG9ydGFudH1gLCBcIlwiXSk7XG4gICAgfSwgZnVuY3Rpb24odCwgbykge1xuICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24oaSkge1xuICAgICAgICB2YXIgcyA9IFtdO1xuICAgICAgICByZXR1cm4gcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGZ1bmN0aW9uKGwsIGMpIHtcbiAgICAgICAgICAgICAgdmFyIHUgPSBsWzFdIHx8IFwiXCIsIGggPSBsWzNdO1xuICAgICAgICAgICAgICBpZiAoIWgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHU7XG4gICAgICAgICAgICAgIGlmIChjICYmIHR5cGVvZiBidG9hID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBwID0gKGYgPSBoLCBcIi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGYpKSkpICsgXCIgKi9cIiksIGcgPSBoLnNvdXJjZXMubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIgKyBoLnNvdXJjZVJvb3QgKyB2ICsgXCIgKi9cIjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3VdLmNvbmNhdChnKS5jb25jYXQoW3BdKS5qb2luKGBcbmApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBmO1xuICAgICAgICAgICAgICByZXR1cm4gW3VdLmpvaW4oYFxuYCk7XG4gICAgICAgICAgICB9KHIsIGkpO1xuICAgICAgICAgICAgcmV0dXJuIHJbMl0gPyBcIkBtZWRpYSBcIiArIHJbMl0gKyBcIntcIiArIGEgKyBcIn1cIiA6IGE7XG4gICAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgICAgfSwgcy5pID0gZnVuY3Rpb24ociwgYSkge1xuICAgICAgICAgIHR5cGVvZiByID09IFwic3RyaW5nXCIgJiYgKHIgPSBbW251bGwsIHIsIFwiXCJdXSk7XG4gICAgICAgICAgZm9yICh2YXIgbCA9IHt9LCBjID0gMDsgYyA8IHRoaXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIHZhciB1ID0gdGhpc1tjXVswXTtcbiAgICAgICAgICAgIHR5cGVvZiB1ID09IFwibnVtYmVyXCIgJiYgKGxbdV0gPSAhMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoYyA9IDA7IGMgPCByLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICB2YXIgaCA9IHJbY107XG4gICAgICAgICAgICB0eXBlb2YgaFswXSA9PSBcIm51bWJlclwiICYmIGxbaFswXV0gfHwgKGEgJiYgIWhbMl0gPyBoWzJdID0gYSA6IGEgJiYgKGhbMl0gPSBcIihcIiArIGhbMl0gKyBcIikgYW5kIChcIiArIGEgKyBcIilcIiksIHMucHVzaChoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBzO1xuICAgICAgfTtcbiAgICB9LCBmdW5jdGlvbih0LCBvLCBpKSB7XG4gICAgICB2YXIgcywgciwgYSA9IHt9LCBsID0gKHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xuICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByID09PSB2b2lkIDAgJiYgKHIgPSBzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLCByO1xuICAgICAgfSksIGMgPSBmdW5jdGlvbihrKSB7XG4gICAgICAgIHZhciBtID0ge307XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih3KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHJldHVybiB3KCk7XG4gICAgICAgICAgaWYgKG1bd10gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdmFyIHggPSAoZnVuY3Rpb24oSSkge1xuICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihJKTtcbiAgICAgICAgICAgIH0pLmNhbGwodGhpcywgdyk7XG4gICAgICAgICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHggaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeCA9IHguY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgIHggPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBtW3ddID0geDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1bd107XG4gICAgICAgIH07XG4gICAgICB9KCksIHUgPSBudWxsLCBoID0gMCwgcCA9IFtdLCBnID0gaSg1KTtcbiAgICAgIGZ1bmN0aW9uIGYoaywgbSkge1xuICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IGsubGVuZ3RoOyB3KyspIHtcbiAgICAgICAgICB2YXIgeCA9IGtbd10sIEkgPSBhW3guaWRdO1xuICAgICAgICAgIGlmIChJKSB7XG4gICAgICAgICAgICBJLnJlZnMrKztcbiAgICAgICAgICAgIGZvciAodmFyIEMgPSAwOyBDIDwgSS5wYXJ0cy5sZW5ndGg7IEMrKylcbiAgICAgICAgICAgICAgSS5wYXJ0c1tDXSh4LnBhcnRzW0NdKTtcbiAgICAgICAgICAgIGZvciAoOyBDIDwgeC5wYXJ0cy5sZW5ndGg7IEMrKylcbiAgICAgICAgICAgICAgSS5wYXJ0cy5wdXNoKEYoeC5wYXJ0c1tDXSwgbSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgTiA9IFtdO1xuICAgICAgICAgICAgZm9yIChDID0gMDsgQyA8IHgucGFydHMubGVuZ3RoOyBDKyspXG4gICAgICAgICAgICAgIE4ucHVzaChGKHgucGFydHNbQ10sIG0pKTtcbiAgICAgICAgICAgIGFbeC5pZF0gPSB7IGlkOiB4LmlkLCByZWZzOiAxLCBwYXJ0czogTiB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdihrLCBtKSB7XG4gICAgICAgIGZvciAodmFyIHcgPSBbXSwgeCA9IHt9LCBJID0gMDsgSSA8IGsubGVuZ3RoOyBJKyspIHtcbiAgICAgICAgICB2YXIgQyA9IGtbSV0sIE4gPSBtLmJhc2UgPyBDWzBdICsgbS5iYXNlIDogQ1swXSwgQiA9IHsgY3NzOiBDWzFdLCBtZWRpYTogQ1syXSwgc291cmNlTWFwOiBDWzNdIH07XG4gICAgICAgICAgeFtOXSA/IHhbTl0ucGFydHMucHVzaChCKSA6IHcucHVzaCh4W05dID0geyBpZDogTiwgcGFydHM6IFtCXSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIE8oaywgbSkge1xuICAgICAgICB2YXIgdyA9IGMoay5pbnNlcnRJbnRvKTtcbiAgICAgICAgaWYgKCF3KVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgICAgICB2YXIgeCA9IHBbcC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGsuaW5zZXJ0QXQgPT09IFwidG9wXCIpXG4gICAgICAgICAgeCA/IHgubmV4dFNpYmxpbmcgPyB3Lmluc2VydEJlZm9yZShtLCB4Lm5leHRTaWJsaW5nKSA6IHcuYXBwZW5kQ2hpbGQobSkgOiB3Lmluc2VydEJlZm9yZShtLCB3LmZpcnN0Q2hpbGQpLCBwLnB1c2gobSk7XG4gICAgICAgIGVsc2UgaWYgKGsuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpXG4gICAgICAgICAgdy5hcHBlbmRDaGlsZChtKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBrLmluc2VydEF0ICE9IFwib2JqZWN0XCIgfHwgIWsuaW5zZXJ0QXQuYmVmb3JlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbU3R5bGUgTG9hZGVyXVxuXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXG5gKTtcbiAgICAgICAgICB2YXIgSSA9IGMoay5pbnNlcnRJbnRvICsgXCIgXCIgKyBrLmluc2VydEF0LmJlZm9yZSk7XG4gICAgICAgICAgdy5pbnNlcnRCZWZvcmUobSwgSSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFQoaykge1xuICAgICAgICBpZiAoay5wYXJlbnROb2RlID09PSBudWxsKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgay5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGspO1xuICAgICAgICB2YXIgbSA9IHAuaW5kZXhPZihrKTtcbiAgICAgICAgbSA+PSAwICYmIHAuc3BsaWNlKG0sIDEpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gTShrKSB7XG4gICAgICAgIHZhciBtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICByZXR1cm4gay5hdHRycy50eXBlID09PSB2b2lkIDAgJiYgKGsuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIiksIHEobSwgay5hdHRycyksIE8oaywgbSksIG07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBxKGssIG0pIHtcbiAgICAgICAgT2JqZWN0LmtleXMobSkuZm9yRWFjaChmdW5jdGlvbih3KSB7XG4gICAgICAgICAgay5zZXRBdHRyaWJ1dGUodywgbVt3XSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gRihrLCBtKSB7XG4gICAgICAgIHZhciB3LCB4LCBJLCBDO1xuICAgICAgICBpZiAobS50cmFuc2Zvcm0gJiYgay5jc3MpIHtcbiAgICAgICAgICBpZiAoIShDID0gbS50cmFuc2Zvcm0oay5jc3MpKSlcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgay5jc3MgPSBDO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtLnNpbmdsZXRvbikge1xuICAgICAgICAgIHZhciBOID0gaCsrO1xuICAgICAgICAgIHcgPSB1IHx8ICh1ID0gTShtKSksIHggPSBpZS5iaW5kKG51bGwsIHcsIE4sICExKSwgSSA9IGllLmJpbmQobnVsbCwgdywgTiwgITApO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBrLnNvdXJjZU1hcCAmJiB0eXBlb2YgVVJMID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBCbG9iID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgYnRvYSA9PSBcImZ1bmN0aW9uXCIgPyAodyA9IGZ1bmN0aW9uKEIpIHtcbiAgICAgICAgICAgIHZhciBXID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgICAgICAgICByZXR1cm4gQi5hdHRycy50eXBlID09PSB2b2lkIDAgJiYgKEIuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIiksIEIuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCIsIHEoVywgQi5hdHRycyksIE8oQiwgVyksIFc7XG4gICAgICAgICAgfShtKSwgeCA9IChmdW5jdGlvbihCLCBXLCB2ZSkge1xuICAgICAgICAgICAgdmFyIHNlID0gdmUuY3NzLCB0dCA9IHZlLnNvdXJjZU1hcCwgWW4gPSBXLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdm9pZCAwICYmIHR0O1xuICAgICAgICAgICAgKFcuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IFluKSAmJiAoc2UgPSBnKHNlKSksIHR0ICYmIChzZSArPSBgXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGAgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh0dCkpKSkgKyBcIiAqL1wiKTtcbiAgICAgICAgICAgIHZhciBLbiA9IG5ldyBCbG9iKFtzZV0sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pLCBrbyA9IEIuaHJlZjtcbiAgICAgICAgICAgIEIuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoS24pLCBrbyAmJiBVUkwucmV2b2tlT2JqZWN0VVJMKGtvKTtcbiAgICAgICAgICB9KS5iaW5kKG51bGwsIHcsIG0pLCBJID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBUKHcpLCB3LmhyZWYgJiYgVVJMLnJldm9rZU9iamVjdFVSTCh3LmhyZWYpO1xuICAgICAgICAgIH0pIDogKHcgPSBNKG0pLCB4ID0gKGZ1bmN0aW9uKEIsIFcpIHtcbiAgICAgICAgICAgIHZhciB2ZSA9IFcuY3NzLCBzZSA9IFcubWVkaWE7XG4gICAgICAgICAgICBpZiAoc2UgJiYgQi5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBzZSksIEIuc3R5bGVTaGVldClcbiAgICAgICAgICAgICAgQi5zdHlsZVNoZWV0LmNzc1RleHQgPSB2ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKDsgQi5maXJzdENoaWxkOyApXG4gICAgICAgICAgICAgICAgQi5yZW1vdmVDaGlsZChCLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICBCLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuYmluZChudWxsLCB3KSwgSSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgVCh3KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHgoayksIGZ1bmN0aW9uKEIpIHtcbiAgICAgICAgICBpZiAoQikge1xuICAgICAgICAgICAgaWYgKEIuY3NzID09PSBrLmNzcyAmJiBCLm1lZGlhID09PSBrLm1lZGlhICYmIEIuc291cmNlTWFwID09PSBrLnNvdXJjZU1hcClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgeChrID0gQik7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBJKCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0LmV4cG9ydHMgPSBmdW5jdGlvbihrLCBtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgREVCVUcgPCBcInVcIiAmJiBERUJVRyAmJiB0eXBlb2YgZG9jdW1lbnQgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG4gICAgICAgIChtID0gbSB8fCB7fSkuYXR0cnMgPSB0eXBlb2YgbS5hdHRycyA9PSBcIm9iamVjdFwiID8gbS5hdHRycyA6IHt9LCBtLnNpbmdsZXRvbiB8fCB0eXBlb2YgbS5zaW5nbGV0b24gPT0gXCJib29sZWFuXCIgfHwgKG0uc2luZ2xldG9uID0gbCgpKSwgbS5pbnNlcnRJbnRvIHx8IChtLmluc2VydEludG8gPSBcImhlYWRcIiksIG0uaW5zZXJ0QXQgfHwgKG0uaW5zZXJ0QXQgPSBcImJvdHRvbVwiKTtcbiAgICAgICAgdmFyIHcgPSB2KGssIG0pO1xuICAgICAgICByZXR1cm4gZih3LCBtKSwgZnVuY3Rpb24oeCkge1xuICAgICAgICAgIGZvciAodmFyIEkgPSBbXSwgQyA9IDA7IEMgPCB3Lmxlbmd0aDsgQysrKSB7XG4gICAgICAgICAgICB2YXIgTiA9IHdbQ107XG4gICAgICAgICAgICAoQiA9IGFbTi5pZF0pLnJlZnMtLSwgSS5wdXNoKEIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHggJiYgZih2KHgsIG0pLCBtKSwgQyA9IDA7IEMgPCBJLmxlbmd0aDsgQysrKSB7XG4gICAgICAgICAgICB2YXIgQjtcbiAgICAgICAgICAgIGlmICgoQiA9IElbQ10pLnJlZnMgPT09IDApIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgVyA9IDA7IFcgPCBCLnBhcnRzLmxlbmd0aDsgVysrKVxuICAgICAgICAgICAgICAgIEIucGFydHNbV10oKTtcbiAgICAgICAgICAgICAgZGVsZXRlIGFbQi5pZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHZhciBILCBRID0gKEggPSBbXSwgZnVuY3Rpb24oaywgbSkge1xuICAgICAgICByZXR1cm4gSFtrXSA9IG0sIEguZmlsdGVyKEJvb2xlYW4pLmpvaW4oYFxuYCk7XG4gICAgICB9KTtcbiAgICAgIGZ1bmN0aW9uIGllKGssIG0sIHcsIHgpIHtcbiAgICAgICAgdmFyIEkgPSB3ID8gXCJcIiA6IHguY3NzO1xuICAgICAgICBpZiAoay5zdHlsZVNoZWV0KVxuICAgICAgICAgIGsuc3R5bGVTaGVldC5jc3NUZXh0ID0gUShtLCBJKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIEMgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShJKSwgTiA9IGsuY2hpbGROb2RlcztcbiAgICAgICAgICBOW21dICYmIGsucmVtb3ZlQ2hpbGQoTlttXSksIE4ubGVuZ3RoID8gay5pbnNlcnRCZWZvcmUoQywgTlttXSkgOiBrLmFwcGVuZENoaWxkKEMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24odCwgbykge1xuICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24oaSkge1xuICAgICAgICB2YXIgcyA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB3aW5kb3cubG9jYXRpb247XG4gICAgICAgIGlmICghcylcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgICAgICAgaWYgKCFpIHx8IHR5cGVvZiBpICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIHZhciByID0gcy5wcm90b2NvbCArIFwiLy9cIiArIHMuaG9zdCwgYSA9IHIgKyBzLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuICAgICAgICByZXR1cm4gaS5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24obCwgYykge1xuICAgICAgICAgIHZhciB1LCBoID0gYy50cmltKCkucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKHAsIGcpIHtcbiAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICAgIH0pLnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24ocCwgZykge1xuICAgICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QoaCkgPyBsIDogKHUgPSBoLmluZGV4T2YoXCIvL1wiKSA9PT0gMCA/IGggOiBoLmluZGV4T2YoXCIvXCIpID09PSAwID8gciArIGggOiBhICsgaC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIiksIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkodSkgKyBcIilcIik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9LCBmdW5jdGlvbih0LCBvLCBpKSB7XG4gICAgICB2YXIgcywgciwgYSwgbCwgYywgdSwgaCwgcCwgZztcbiAgICAgIHQuZXhwb3J0cyA9IChzID0gXCJjZHgtbm90aWZpZXNcIiwgciA9IFwiY2R4LW5vdGlmeVwiLCBhID0gXCJjZHgtbm90aWZ5X19jcm9zc1wiLCBsID0gXCJjZHgtbm90aWZ5X19idXR0b24tLWNvbmZpcm1cIiwgYyA9IFwiY2R4LW5vdGlmeV9fYnV0dG9uLS1jYW5jZWxcIiwgdSA9IFwiY2R4LW5vdGlmeV9faW5wdXRcIiwgaCA9IFwiY2R4LW5vdGlmeV9fYnV0dG9uXCIsIHAgPSBcImNkeC1ub3RpZnlfX2J0bnMtd3JhcHBlclwiLCB7IGFsZXJ0OiBnID0gZnVuY3Rpb24oZikge1xuICAgICAgICB2YXIgdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIiksIE8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpLCBUID0gZi5tZXNzYWdlLCBNID0gZi5zdHlsZTtcbiAgICAgICAgcmV0dXJuIHYuY2xhc3NMaXN0LmFkZChyKSwgTSAmJiB2LmNsYXNzTGlzdC5hZGQociArIFwiLS1cIiArIE0pLCB2LmlubmVySFRNTCA9IFQsIE8uY2xhc3NMaXN0LmFkZChhKSwgTy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdi5yZW1vdmUuYmluZCh2KSksIHYuYXBwZW5kQ2hpbGQoTyksIHY7XG4gICAgICB9LCBjb25maXJtOiBmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciB2ID0gZyhmKSwgTyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIFQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpLCBNID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSwgcSA9IHYucXVlcnlTZWxlY3RvcihcIi5cIiArIGEpLCBGID0gZi5jYW5jZWxIYW5kbGVyLCBIID0gZi5va0hhbmRsZXI7XG4gICAgICAgIHJldHVybiBPLmNsYXNzTGlzdC5hZGQocCksIFQuaW5uZXJIVE1MID0gZi5va1RleHQgfHwgXCJDb25maXJtXCIsIE0uaW5uZXJIVE1MID0gZi5jYW5jZWxUZXh0IHx8IFwiQ2FuY2VsXCIsIFQuY2xhc3NMaXN0LmFkZChoKSwgTS5jbGFzc0xpc3QuYWRkKGgpLCBULmNsYXNzTGlzdC5hZGQobCksIE0uY2xhc3NMaXN0LmFkZChjKSwgRiAmJiB0eXBlb2YgRiA9PSBcImZ1bmN0aW9uXCIgJiYgKE0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIEYpLCBxLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBGKSksIEggJiYgdHlwZW9mIEggPT0gXCJmdW5jdGlvblwiICYmIFQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIEgpLCBULmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB2LnJlbW92ZS5iaW5kKHYpKSwgTS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdi5yZW1vdmUuYmluZCh2KSksIE8uYXBwZW5kQ2hpbGQoVCksIE8uYXBwZW5kQ2hpbGQoTSksIHYuYXBwZW5kQ2hpbGQoTyksIHY7XG4gICAgICB9LCBwcm9tcHQ6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgdmFyIHYgPSBnKGYpLCBPID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgVCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiksIE0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksIHEgPSB2LnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBhKSwgRiA9IGYuY2FuY2VsSGFuZGxlciwgSCA9IGYub2tIYW5kbGVyO1xuICAgICAgICByZXR1cm4gTy5jbGFzc0xpc3QuYWRkKHApLCBULmlubmVySFRNTCA9IGYub2tUZXh0IHx8IFwiT2tcIiwgVC5jbGFzc0xpc3QuYWRkKGgpLCBULmNsYXNzTGlzdC5hZGQobCksIE0uY2xhc3NMaXN0LmFkZCh1KSwgZi5wbGFjZWhvbGRlciAmJiBNLnNldEF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIsIGYucGxhY2Vob2xkZXIpLCBmLmRlZmF1bHQgJiYgKE0udmFsdWUgPSBmLmRlZmF1bHQpLCBmLmlucHV0VHlwZSAmJiAoTS50eXBlID0gZi5pbnB1dFR5cGUpLCBGICYmIHR5cGVvZiBGID09IFwiZnVuY3Rpb25cIiAmJiBxLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBGKSwgSCAmJiB0eXBlb2YgSCA9PSBcImZ1bmN0aW9uXCIgJiYgVC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgSChNLnZhbHVlKTtcbiAgICAgICAgfSksIFQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHYucmVtb3ZlLmJpbmQodikpLCBPLmFwcGVuZENoaWxkKE0pLCBPLmFwcGVuZENoaWxkKFQpLCB2LmFwcGVuZENoaWxkKE8pLCB2O1xuICAgICAgfSwgZ2V0V3JhcHBlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcbiAgICAgICAgcmV0dXJuIGYuY2xhc3NMaXN0LmFkZChzKSwgZjtcbiAgICAgIH0gfSk7XG4gICAgfV0pO1xuICB9KTtcbn0pKEtvKTtcbnZhciBFaSA9IEtvLmV4cG9ydHM7XG5jb25zdCB4aSA9IC8qIEBfX1BVUkVfXyAqLyBLZShFaSk7XG5jbGFzcyBCaSB7XG4gIC8qKlxuICAgKiBTaG93IHdlYiBub3RpZmljYXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtOb3RpZmllck9wdGlvbnMgfCBDb25maXJtTm90aWZpZXJPcHRpb25zIHwgUHJvbXB0Tm90aWZpZXJPcHRpb25zfSBvcHRpb25zIC0gbm90aWZpY2F0aW9uIG9wdGlvbnNcbiAgICovXG4gIHNob3coZSkge1xuICAgIHhpLnNob3coZSk7XG4gIH1cbn1cbmNsYXNzIENpIGV4dGVuZHMgRSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbiAtIE1vZHVsZSBDb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uLmNvbmZpZyAtIEVkaXRvcidzIGNvbmZpZ1xuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbi5ldmVudHNEaXNwYXRjaGVyIC0gRWRpdG9yJ3MgZXZlbnQgZGlzcGF0Y2hlclxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBjb25maWc6IGUsIGV2ZW50c0Rpc3BhdGNoZXI6IHQgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZzogZSxcbiAgICAgIGV2ZW50c0Rpc3BhdGNoZXI6IHRcbiAgICB9KSwgdGhpcy5ub3RpZmllciA9IG5ldyBCaSgpO1xuICB9XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNob3c6IChlKSA9PiB0aGlzLnNob3coZSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTaG93IG5vdGlmaWNhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge05vdGlmaWVyT3B0aW9uc30gb3B0aW9ucyAtIG1lc3NhZ2Ugb3B0aW9uXG4gICAqL1xuICBzaG93KGUpIHtcbiAgICByZXR1cm4gdGhpcy5ub3RpZmllci5zaG93KGUpO1xuICB9XG59XG5jbGFzcyBUaSBleHRlbmRzIEUge1xuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHNcbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIGNvbnN0IGUgPSAoKSA9PiB0aGlzLmlzRW5hYmxlZDtcbiAgICByZXR1cm4ge1xuICAgICAgdG9nZ2xlOiAodCkgPT4gdGhpcy50b2dnbGUodCksXG4gICAgICBnZXQgaXNFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNldCBvciB0b2dnbGUgcmVhZC1vbmx5IHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnx1bmRlZmluZWR9IHN0YXRlIC0gc2V0IG9yIHRvZ2dsZSBzdGF0ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gY3VycmVudCB2YWx1ZVxuICAgKi9cbiAgdG9nZ2xlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5FZGl0b3IuUmVhZE9ubHkudG9nZ2xlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGN1cnJlbnQgcmVhZC1vbmx5IHN0YXRlXG4gICAqL1xuICBnZXQgaXNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5SZWFkT25seS5pc0VuYWJsZWQ7XG4gIH1cbn1cbnZhciBYbyA9IHsgZXhwb3J0czoge30gfTtcbihmdW5jdGlvbihuLCBlKSB7XG4gIChmdW5jdGlvbih0LCBvKSB7XG4gICAgbi5leHBvcnRzID0gbygpO1xuICB9KShDZSwgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gdChoKSB7XG4gICAgICB2YXIgcCA9IGgudGFncywgZyA9IE9iamVjdC5rZXlzKHApLCBmID0gZy5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHBbdl07XG4gICAgICB9KS5ldmVyeShmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2ID09PSBcIm9iamVjdFwiIHx8IHYgPT09IFwiYm9vbGVhblwiIHx8IHYgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFmKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29uZmlndXJhdGlvbiB3YXMgaW52YWxpZFwiKTtcbiAgICAgIHRoaXMuY29uZmlnID0gaDtcbiAgICB9XG4gICAgdmFyIG8gPSBbXCJQXCIsIFwiTElcIiwgXCJURFwiLCBcIlRIXCIsIFwiRElWXCIsIFwiSDFcIiwgXCJIMlwiLCBcIkgzXCIsIFwiSDRcIiwgXCJINVwiLCBcIkg2XCIsIFwiUFJFXCJdO1xuICAgIGZ1bmN0aW9uIGkoaCkge1xuICAgICAgcmV0dXJuIG8uaW5kZXhPZihoLm5vZGVOYW1lKSAhPT0gLTE7XG4gICAgfVxuICAgIHZhciBzID0gW1wiQVwiLCBcIkJcIiwgXCJTVFJPTkdcIiwgXCJJXCIsIFwiRU1cIiwgXCJTVUJcIiwgXCJTVVBcIiwgXCJVXCIsIFwiU1RSSUtFXCJdO1xuICAgIGZ1bmN0aW9uIHIoaCkge1xuICAgICAgcmV0dXJuIHMuaW5kZXhPZihoLm5vZGVOYW1lKSAhPT0gLTE7XG4gICAgfVxuICAgIHQucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24oaCkge1xuICAgICAgY29uc3QgcCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgpLCBnID0gcC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgcmV0dXJuIGcuaW5uZXJIVE1MID0gaCwgdGhpcy5fc2FuaXRpemUocCwgZyksIGcuaW5uZXJIVE1MO1xuICAgIH0sIHQucHJvdG90eXBlLl9zYW5pdGl6ZSA9IGZ1bmN0aW9uKGgsIHApIHtcbiAgICAgIHZhciBnID0gYShoLCBwKSwgZiA9IGcuZmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKGYpXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAoZi5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpXG4gICAgICAgICAgICBpZiAoZi5kYXRhLnRyaW0oKSA9PT0gXCJcIiAmJiAoZi5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICYmIGkoZi5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB8fCBmLm5leHRFbGVtZW50U2libGluZyAmJiBpKGYubmV4dEVsZW1lbnRTaWJsaW5nKSkpIHtcbiAgICAgICAgICAgICAgcC5yZW1vdmVDaGlsZChmKSwgdGhpcy5fc2FuaXRpemUoaCwgcCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChmLm5vZGVUeXBlID09PSBOb2RlLkNPTU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgcC5yZW1vdmVDaGlsZChmKSwgdGhpcy5fc2FuaXRpemUoaCwgcCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHYgPSByKGYpLCBPO1xuICAgICAgICAgIHYgJiYgKE8gPSBBcnJheS5wcm90b3R5cGUuc29tZS5jYWxsKGYuY2hpbGROb2RlcywgaSkpO1xuICAgICAgICAgIHZhciBUID0gISFwLnBhcmVudE5vZGUsIE0gPSBpKHApICYmIGkoZikgJiYgVCwgcSA9IGYubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgRiA9IGwodGhpcy5jb25maWcsIHEsIGYpLCBIID0gdiAmJiBPO1xuICAgICAgICAgIGlmIChIIHx8IGMoZiwgRikgfHwgIXRoaXMuY29uZmlnLmtlZXBOZXN0ZWRCbG9ja0VsZW1lbnRzICYmIE0pIHtcbiAgICAgICAgICAgIGlmICghKGYubm9kZU5hbWUgPT09IFwiU0NSSVBUXCIgfHwgZi5ub2RlTmFtZSA9PT0gXCJTVFlMRVwiKSlcbiAgICAgICAgICAgICAgZm9yICg7IGYuY2hpbGROb2Rlcy5sZW5ndGggPiAwOyApXG4gICAgICAgICAgICAgICAgcC5pbnNlcnRCZWZvcmUoZi5jaGlsZE5vZGVzWzBdLCBmKTtcbiAgICAgICAgICAgIHAucmVtb3ZlQ2hpbGQoZiksIHRoaXMuX3Nhbml0aXplKGgsIHApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIFEgPSAwOyBRIDwgZi5hdHRyaWJ1dGVzLmxlbmd0aDsgUSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgaWUgPSBmLmF0dHJpYnV0ZXNbUV07XG4gICAgICAgICAgICB1KGllLCBGLCBmKSAmJiAoZi5yZW1vdmVBdHRyaWJ1dGUoaWUubmFtZSksIFEgPSBRIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3Nhbml0aXplKGgsIGYpO1xuICAgICAgICB9IHdoaWxlIChmID0gZy5uZXh0U2libGluZygpKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGEoaCwgcCkge1xuICAgICAgcmV0dXJuIGguY3JlYXRlVHJlZVdhbGtlcihcbiAgICAgICAgcCxcbiAgICAgICAgTm9kZUZpbHRlci5TSE9XX1RFWFQgfCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCB8IE5vZGVGaWx0ZXIuU0hPV19DT01NRU5ULFxuICAgICAgICBudWxsLFxuICAgICAgICAhMVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbChoLCBwLCBnKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGgudGFnc1twXSA9PSBcImZ1bmN0aW9uXCIgPyBoLnRhZ3NbcF0oZykgOiBoLnRhZ3NbcF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGMoaCwgcCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBwID4gXCJ1XCIgPyAhMCA6IHR5cGVvZiBwID09IFwiYm9vbGVhblwiID8gIXAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdShoLCBwLCBnKSB7XG4gICAgICB2YXIgZiA9IGgubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHAgPT09ICEwID8gITEgOiB0eXBlb2YgcFtmXSA9PSBcImZ1bmN0aW9uXCIgPyAhcFtmXShoLnZhbHVlLCBnKSA6IHR5cGVvZiBwW2ZdID4gXCJ1XCIgfHwgcFtmXSA9PT0gITEgPyAhMCA6IHR5cGVvZiBwW2ZdID09IFwic3RyaW5nXCIgPyBwW2ZdICE9PSBoLnZhbHVlIDogITE7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9KTtcbn0pKFhvKTtcbnZhciBTaSA9IFhvLmV4cG9ydHM7XG5jb25zdCBJaSA9IC8qIEBfX1BVUkVfXyAqLyBLZShTaSk7XG5mdW5jdGlvbiB5dChuLCBlKSB7XG4gIHJldHVybiBuLm1hcCgodCkgPT4ge1xuICAgIGNvbnN0IG8gPSBBKGUpID8gZSh0LnRvb2wpIDogZTtcbiAgICByZXR1cm4gVihvKSB8fCAodC5kYXRhID0gd3QodC5kYXRhLCBvKSksIHQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gWihuLCBlID0ge30pIHtcbiAgY29uc3QgdCA9IHtcbiAgICB0YWdzOiBlXG4gIH07XG4gIHJldHVybiBuZXcgSWkodCkuY2xlYW4obik7XG59XG5mdW5jdGlvbiB3dChuLCBlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG4pID8gT2kobiwgZSkgOiBEKG4pID8gX2kobiwgZSkgOiB0ZShuKSA/IE1pKG4sIGUpIDogbjtcbn1cbmZ1bmN0aW9uIE9pKG4sIGUpIHtcbiAgcmV0dXJuIG4ubWFwKCh0KSA9PiB3dCh0LCBlKSk7XG59XG5mdW5jdGlvbiBfaShuLCBlKSB7XG4gIGNvbnN0IHQgPSB7fTtcbiAgZm9yIChjb25zdCBvIGluIG4pIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCBvKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGkgPSBuW29dLCBzID0gQWkoZVtvXSkgPyBlW29dIDogZTtcbiAgICB0W29dID0gd3QoaSwgcyk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBNaShuLCBlKSB7XG4gIHJldHVybiBEKGUpID8gWihuLCBlKSA6IGUgPT09ICExID8gWihuLCB7fSkgOiBuO1xufVxuZnVuY3Rpb24gQWkobikge1xuICByZXR1cm4gRChuKSB8fCBHbihuKSB8fCBBKG4pO1xufVxuY2xhc3MgTGkgZXh0ZW5kcyBFIHtcbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzXG4gICAqXG4gICAqIEByZXR1cm5zIHtTYW5pdGl6ZXJDb25maWd9XG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xlYW46IChlLCB0KSA9PiB0aGlzLmNsZWFuKGUsIHQpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybSBzYW5pdGl6aW5nIG9mIGEgc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWludFN0cmluZyAtIHdoYXQgdG8gc2FuaXRpemVcbiAgICogQHBhcmFtIHtTYW5pdGl6ZXJDb25maWd9IGNvbmZpZyAtIHNhbml0aXplciBjb25maWdcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGNsZWFuKGUsIHQpIHtcbiAgICByZXR1cm4gWihlLCB0KTtcbiAgfVxufVxuY2xhc3MgUGkgZXh0ZW5kcyBFIHtcbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzXG4gICAqXG4gICAqIEByZXR1cm5zIHtTYXZlcn1cbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzYXZlOiAoKSA9PiB0aGlzLnNhdmUoKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBFZGl0b3IncyBkYXRhXG4gICAqXG4gICAqIEByZXR1cm5zIHtPdXRwdXREYXRhfVxuICAgKi9cbiAgc2F2ZSgpIHtcbiAgICBjb25zdCBlID0gXCJFZGl0b3IncyBjb250ZW50IGNhbiBub3QgYmUgc2F2ZWQgaW4gcmVhZC1vbmx5IG1vZGVcIjtcbiAgICByZXR1cm4gdGhpcy5FZGl0b3IuUmVhZE9ubHkuaXNFbmFibGVkID8gKFgoZSwgXCJ3YXJuXCIpLCBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoZSkpKSA6IHRoaXMuRWRpdG9yLlNhdmVyLnNhdmUoKTtcbiAgfVxufVxuY2xhc3MgTmkgZXh0ZW5kcyBFIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5zZWxlY3Rpb25VdGlscyA9IG5ldyBiKCk7XG4gIH1cbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzXG4gICAqXG4gICAqIEByZXR1cm5zIHtTZWxlY3Rpb25BUElJbnRlcmZhY2V9XG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmluZFBhcmVudFRhZzogKGUsIHQpID0+IHRoaXMuZmluZFBhcmVudFRhZyhlLCB0KSxcbiAgICAgIGV4cGFuZFRvVGFnOiAoZSkgPT4gdGhpcy5leHBhbmRUb1RhZyhlKSxcbiAgICAgIHNhdmU6ICgpID0+IHRoaXMuc2VsZWN0aW9uVXRpbHMuc2F2ZSgpLFxuICAgICAgcmVzdG9yZTogKCkgPT4gdGhpcy5zZWxlY3Rpb25VdGlscy5yZXN0b3JlKCksXG4gICAgICBzZXRGYWtlQmFja2dyb3VuZDogKCkgPT4gdGhpcy5zZWxlY3Rpb25VdGlscy5zZXRGYWtlQmFja2dyb3VuZCgpLFxuICAgICAgcmVtb3ZlRmFrZUJhY2tncm91bmQ6ICgpID0+IHRoaXMuc2VsZWN0aW9uVXRpbHMucmVtb3ZlRmFrZUJhY2tncm91bmQoKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIExvb2tzIGFoZWFkIGZyb20gc2VsZWN0aW9uIGFuZCBmaW5kIHBhc3NlZCB0YWcgd2l0aCBjbGFzcyBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIC0gdGFnIHRvIGZpbmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAtIHRhZydzIGNsYXNzIG5hbWVcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fG51bGx9XG4gICAqL1xuICBmaW5kUGFyZW50VGFnKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25VdGlscy5maW5kUGFyZW50VGFnKGUsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBFeHBhbmQgc2VsZWN0aW9uIHRvIHBhc3NlZCB0YWdcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSAtIHRhZyB0aGF0IHNob3VsZCBjb250YWluIHNlbGVjdGlvblxuICAgKi9cbiAgZXhwYW5kVG9UYWcoZSkge1xuICAgIHRoaXMuc2VsZWN0aW9uVXRpbHMuZXhwYW5kVG9UYWcoZSk7XG4gIH1cbn1cbmNsYXNzIFJpIGV4dGVuZHMgRSB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKi9cbiAgZ2V0IG1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldEJsb2NrVG9vbHM6ICgpID0+IEFycmF5LmZyb20odGhpcy5FZGl0b3IuVG9vbHMuYmxvY2tUb29scy52YWx1ZXMoKSlcbiAgICB9O1xuICB9XG59XG5jbGFzcyBEaSBleHRlbmRzIEUge1xuICAvKipcbiAgICogRXhwb3J0ZWQgY2xhc3Nlc1xuICAgKi9cbiAgZ2V0IGNsYXNzZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogQmFzZSBCbG9jayBzdHlsZXNcbiAgICAgICAqL1xuICAgICAgYmxvY2s6IFwiY2R4LWJsb2NrXCIsXG4gICAgICAvKipcbiAgICAgICAqIElubGluZSBUb29scyBzdHlsZXNcbiAgICAgICAqL1xuICAgICAgaW5saW5lVG9vbEJ1dHRvbjogXCJjZS1pbmxpbmUtdG9vbFwiLFxuICAgICAgaW5saW5lVG9vbEJ1dHRvbkFjdGl2ZTogXCJjZS1pbmxpbmUtdG9vbC0tYWN0aXZlXCIsXG4gICAgICAvKipcbiAgICAgICAqIFVJIGVsZW1lbnRzXG4gICAgICAgKi9cbiAgICAgIGlucHV0OiBcImNkeC1pbnB1dFwiLFxuICAgICAgbG9hZGVyOiBcImNkeC1sb2FkZXJcIixcbiAgICAgIGJ1dHRvbjogXCJjZHgtYnV0dG9uXCIsXG4gICAgICAvKipcbiAgICAgICAqIFNldHRpbmdzIHN0eWxlc1xuICAgICAgICovXG4gICAgICBzZXR0aW5nc0J1dHRvbjogXCJjZHgtc2V0dGluZ3MtYnV0dG9uXCIsXG4gICAgICBzZXR0aW5nc0J1dHRvbkFjdGl2ZTogXCJjZHgtc2V0dGluZ3MtYnV0dG9uLS1hY3RpdmVcIlxuICAgIH07XG4gIH1cbn1cbmNsYXNzIEZpIGV4dGVuZHMgRSB7XG4gIC8qKlxuICAgKiBBdmFpbGFibGUgbWV0aG9kc1xuICAgKlxuICAgKiBAcmV0dXJucyB7VG9vbGJhcn1cbiAgICovXG4gIGdldCBtZXRob2RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbG9zZTogKCkgPT4gdGhpcy5jbG9zZSgpLFxuICAgICAgb3BlbjogKCkgPT4gdGhpcy5vcGVuKCksXG4gICAgICB0b2dnbGVCbG9ja1NldHRpbmdzOiAoZSkgPT4gdGhpcy50b2dnbGVCbG9ja1NldHRpbmdzKGUpLFxuICAgICAgdG9nZ2xlVG9vbGJveDogKGUpID0+IHRoaXMudG9nZ2xlVG9vbGJveChlKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE9wZW4gdG9vbGJhclxuICAgKi9cbiAgb3BlbigpIHtcbiAgICB0aGlzLkVkaXRvci5Ub29sYmFyLm1vdmVBbmRPcGVuKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlIHRvb2xiYXIgYW5kIGFsbCBpbmNsdWRlZCBlbGVtZW50c1xuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5FZGl0b3IuVG9vbGJhci5jbG9zZSgpO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGVzIEJsb2NrIFNldHRpbmcgb2YgdGhlIGN1cnJlbnQgYmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBvcGVuaW5nU3RhdGUg4oCUICBvcGVuaW5nIHN0YXRlIG9mIEJsb2NrIFNldHRpbmdcbiAgICovXG4gIHRvZ2dsZUJsb2NrU2V0dGluZ3MoZSkge1xuICAgIGlmICh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrSW5kZXggPT09IC0xKSB7XG4gICAgICBYKFwiQ291bGQndCB0b2dnbGUgdGhlIFRvb2xiYXIgYmVjYXVzZSB0aGVyZSBpcyBubyBibG9jayBzZWxlY3RlZCBcIiwgXCJ3YXJuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlID8/ICF0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLm9wZW5lZCA/ICh0aGlzLkVkaXRvci5Ub29sYmFyLm1vdmVBbmRPcGVuKCksIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbigpKSA6IHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3MuY2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogT3BlbiB0b29sYm94XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3BlbmluZ1N0YXRlIC0gT3BlbmluZyBzdGF0ZSBvZiB0b29sYm94XG4gICAqL1xuICB0b2dnbGVUb29sYm94KGUpIHtcbiAgICBpZiAodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9ja0luZGV4ID09PSAtMSkge1xuICAgICAgWChcIkNvdWxkJ3QgdG9nZ2xlIHRoZSBUb29sYm94IGJlY2F1c2UgdGhlcmUgaXMgbm8gYmxvY2sgc2VsZWN0ZWQgXCIsIFwid2FyblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZSA/PyAhdGhpcy5FZGl0b3IuVG9vbGJhci50b29sYm94Lm9wZW5lZCA/ICh0aGlzLkVkaXRvci5Ub29sYmFyLm1vdmVBbmRPcGVuKCksIHRoaXMuRWRpdG9yLlRvb2xiYXIudG9vbGJveC5vcGVuKCkpIDogdGhpcy5FZGl0b3IuVG9vbGJhci50b29sYm94LmNsb3NlKCk7XG4gIH1cbn1cbnZhciBWbyA9IHsgZXhwb3J0czoge30gfTtcbi8qIVxuICogQ29kZVguVG9vbHRpcHNcbiAqIFxuICogQHZlcnNpb24gMS4wLjVcbiAqIFxuICogQGxpY2VuY2UgTUlUXG4gKiBAYXV0aG9yIENvZGVYIDxodHRwczovL2NvZGV4LnNvPlxuICogXG4gKiBcbiAqL1xuKGZ1bmN0aW9uKG4sIGUpIHtcbiAgKGZ1bmN0aW9uKHQsIG8pIHtcbiAgICBuLmV4cG9ydHMgPSBvKCk7XG4gIH0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBvID0ge307XG4gICAgICBmdW5jdGlvbiBpKHMpIHtcbiAgICAgICAgaWYgKG9bc10pXG4gICAgICAgICAgcmV0dXJuIG9bc10uZXhwb3J0cztcbiAgICAgICAgdmFyIHIgPSBvW3NdID0geyBpOiBzLCBsOiAhMSwgZXhwb3J0czoge30gfTtcbiAgICAgICAgcmV0dXJuIHRbc10uY2FsbChyLmV4cG9ydHMsIHIsIHIuZXhwb3J0cywgaSksIHIubCA9ICEwLCByLmV4cG9ydHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gaS5tID0gdCwgaS5jID0gbywgaS5kID0gZnVuY3Rpb24ocywgciwgYSkge1xuICAgICAgICBpLm8ocywgcikgfHwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsIHIsIHsgZW51bWVyYWJsZTogITAsIGdldDogYSB9KTtcbiAgICAgIH0sIGkuciA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdHlwZW9mIFN5bWJvbCA8IFwidVwiICYmIFN5bWJvbC50b1N0cmluZ1RhZyAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkocywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkocywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICAgICAgfSwgaS50ID0gZnVuY3Rpb24ocywgcikge1xuICAgICAgICBpZiAoMSAmIHIgJiYgKHMgPSBpKHMpKSwgOCAmIHIgfHwgNCAmIHIgJiYgdHlwZW9mIHMgPT0gXCJvYmplY3RcIiAmJiBzICYmIHMuX19lc01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgdmFyIGEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgaWYgKGkucihhKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6ICEwLCB2YWx1ZTogcyB9KSwgMiAmIHIgJiYgdHlwZW9mIHMgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICBmb3IgKHZhciBsIGluIHMpXG4gICAgICAgICAgICBpLmQoYSwgbCwgKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNbY107XG4gICAgICAgICAgICB9KS5iaW5kKG51bGwsIGwpKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9LCBpLm4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhciByID0gcyAmJiBzLl9fZXNNb2R1bGUgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gcy5kZWZhdWx0O1xuICAgICAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpLmQociwgXCJhXCIsIHIpLCByO1xuICAgICAgfSwgaS5vID0gZnVuY3Rpb24ocywgcikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHIpO1xuICAgICAgfSwgaS5wID0gXCJcIiwgaShpLnMgPSAwKTtcbiAgICB9KFtmdW5jdGlvbih0LCBvLCBpKSB7XG4gICAgICB0LmV4cG9ydHMgPSBpKDEpO1xuICAgIH0sIGZ1bmN0aW9uKHQsIG8sIGkpIHtcbiAgICAgIGkucihvKSwgaS5kKG8sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9KTtcbiAgICAgIGNsYXNzIHMge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICB0aGlzLm5vZGVzID0geyB3cmFwcGVyOiBudWxsLCBjb250ZW50OiBudWxsIH0sIHRoaXMuc2hvd2VkID0gITEsIHRoaXMub2Zmc2V0VG9wID0gMTAsIHRoaXMub2Zmc2V0TGVmdCA9IDEwLCB0aGlzLm9mZnNldFJpZ2h0ID0gMTAsIHRoaXMuaGlkaW5nRGVsYXkgPSAwLCB0aGlzLmhhbmRsZVdpbmRvd1Njcm9sbCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2hvd2VkICYmIHRoaXMuaGlkZSghMCk7XG4gICAgICAgICAgfSwgdGhpcy5sb2FkU3R5bGVzKCksIHRoaXMucHJlcGFyZSgpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLmhhbmRsZVdpbmRvd1Njcm9sbCwgeyBwYXNzaXZlOiAhMCB9KTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgQ1NTKCkge1xuICAgICAgICAgIHJldHVybiB7IHRvb2x0aXA6IFwiY3RcIiwgdG9vbHRpcENvbnRlbnQ6IFwiY3RfX2NvbnRlbnRcIiwgdG9vbHRpcFNob3duOiBcImN0LS1zaG93blwiLCBwbGFjZW1lbnQ6IHsgbGVmdDogXCJjdC0tbGVmdFwiLCBib3R0b206IFwiY3QtLWJvdHRvbVwiLCByaWdodDogXCJjdC0tcmlnaHRcIiwgdG9wOiBcImN0LS10b3BcIiB9IH07XG4gICAgICAgIH1cbiAgICAgICAgc2hvdyhhLCBsLCBjKSB7XG4gICAgICAgICAgdGhpcy5ub2Rlcy53cmFwcGVyIHx8IHRoaXMucHJlcGFyZSgpLCB0aGlzLmhpZGluZ1RpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMuaGlkaW5nVGltZW91dCk7XG4gICAgICAgICAgY29uc3QgdSA9IE9iamVjdC5hc3NpZ24oeyBwbGFjZW1lbnQ6IFwiYm90dG9tXCIsIG1hcmdpblRvcDogMCwgbWFyZ2luTGVmdDogMCwgbWFyZ2luUmlnaHQ6IDAsIG1hcmdpbkJvdHRvbTogMCwgZGVsYXk6IDcwLCBoaWRpbmdEZWxheTogMCB9LCBjKTtcbiAgICAgICAgICBpZiAodS5oaWRpbmdEZWxheSAmJiAodGhpcy5oaWRpbmdEZWxheSA9IHUuaGlkaW5nRGVsYXkpLCB0aGlzLm5vZGVzLmNvbnRlbnQuaW5uZXJIVE1MID0gXCJcIiwgdHlwZW9mIGwgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRoaXMubm9kZXMuY29udGVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsKSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIShsIGluc3RhbmNlb2YgTm9kZSkpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFwiW0NvZGVYIFRvb2x0aXBdIFdyb25nIHR5cGUgb2Ygwqtjb250ZW50wrsgcGFzc2VkLiBJdCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgTm9kZSBvciBTdHJpbmcuIEJ1dCBcIiArIHR5cGVvZiBsICsgXCIgZ2l2ZW4uXCIpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5jb250ZW50LmFwcGVuZENoaWxkKGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKC4uLk9iamVjdC52YWx1ZXModGhpcy5DU1MucGxhY2VtZW50KSksIHUucGxhY2VtZW50KSB7XG4gICAgICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICAgIHRoaXMucGxhY2VUb3AoYSwgdSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgdGhpcy5wbGFjZUxlZnQoYSwgdSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgIHRoaXMucGxhY2VSaWdodChhLCB1KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aGlzLnBsYWNlQm90dG9tKGEsIHUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1ICYmIHUuZGVsYXkgPyB0aGlzLnNob3dpbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy50b29sdGlwU2hvd24pLCB0aGlzLnNob3dlZCA9ICEwO1xuICAgICAgICAgIH0sIHUuZGVsYXkpIDogKHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLnRvb2x0aXBTaG93biksIHRoaXMuc2hvd2VkID0gITApO1xuICAgICAgICB9XG4gICAgICAgIGhpZGUoYSA9ICExKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaGlkaW5nRGVsYXkgJiYgIWEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRpbmdUaW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aGlzLmhpZGluZ1RpbWVvdXQpLCB2b2lkICh0aGlzLmhpZGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5oaWRlKCEwKTtcbiAgICAgICAgICAgIH0sIHRoaXMuaGlkaW5nRGVsYXkpKTtcbiAgICAgICAgICB0aGlzLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLkNTUy50b29sdGlwU2hvd24pLCB0aGlzLnNob3dlZCA9ICExLCB0aGlzLnNob3dpbmdUaW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aGlzLnNob3dpbmdUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBvbkhvdmVyKGEsIGwsIGMpIHtcbiAgICAgICAgICBhLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2hvdyhhLCBsLCBjKTtcbiAgICAgICAgICB9KSwgYS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZXN0cm95KCkge1xuICAgICAgICAgIHRoaXMubm9kZXMud3JhcHBlci5yZW1vdmUoKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5oYW5kbGVXaW5kb3dTY3JvbGwpO1xuICAgICAgICB9XG4gICAgICAgIHByZXBhcmUoKSB7XG4gICAgICAgICAgdGhpcy5ub2Rlcy53cmFwcGVyID0gdGhpcy5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLnRvb2x0aXApLCB0aGlzLm5vZGVzLmNvbnRlbnQgPSB0aGlzLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MudG9vbHRpcENvbnRlbnQpLCB0aGlzLmFwcGVuZCh0aGlzLm5vZGVzLndyYXBwZXIsIHRoaXMubm9kZXMuY29udGVudCksIHRoaXMuYXBwZW5kKGRvY3VtZW50LmJvZHksIHRoaXMubm9kZXMud3JhcHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgbG9hZFN0eWxlcygpIHtcbiAgICAgICAgICBjb25zdCBhID0gXCJjb2RleC10b29sdGlwcy1zdHlsZVwiO1xuICAgICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjb25zdCBsID0gaSgyKSwgYyA9IHRoaXMubWFrZShcInN0eWxlXCIsIG51bGwsIHsgdGV4dENvbnRlbnQ6IGwudG9TdHJpbmcoKSwgaWQ6IGEgfSk7XG4gICAgICAgICAgdGhpcy5wcmVwZW5kKGRvY3VtZW50LmhlYWQsIGMpO1xuICAgICAgICB9XG4gICAgICAgIHBsYWNlQm90dG9tKGEsIGwpIHtcbiAgICAgICAgICBjb25zdCBjID0gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdSA9IGMubGVmdCArIGEuY2xpZW50V2lkdGggLyAyIC0gdGhpcy5ub2Rlcy53cmFwcGVyLm9mZnNldFdpZHRoIC8gMiwgaCA9IGMuYm90dG9tICsgd2luZG93LnBhZ2VZT2Zmc2V0ICsgdGhpcy5vZmZzZXRUb3AgKyBsLm1hcmdpblRvcDtcbiAgICAgICAgICB0aGlzLmFwcGx5UGxhY2VtZW50KFwiYm90dG9tXCIsIHUsIGgpO1xuICAgICAgICB9XG4gICAgICAgIHBsYWNlVG9wKGEsIGwpIHtcbiAgICAgICAgICBjb25zdCBjID0gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdSA9IGMubGVmdCArIGEuY2xpZW50V2lkdGggLyAyIC0gdGhpcy5ub2Rlcy53cmFwcGVyLm9mZnNldFdpZHRoIC8gMiwgaCA9IGMudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0IC0gdGhpcy5ub2Rlcy53cmFwcGVyLmNsaWVudEhlaWdodCAtIHRoaXMub2Zmc2V0VG9wO1xuICAgICAgICAgIHRoaXMuYXBwbHlQbGFjZW1lbnQoXCJ0b3BcIiwgdSwgaCk7XG4gICAgICAgIH1cbiAgICAgICAgcGxhY2VMZWZ0KGEsIGwpIHtcbiAgICAgICAgICBjb25zdCBjID0gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdSA9IGMubGVmdCAtIHRoaXMubm9kZXMud3JhcHBlci5vZmZzZXRXaWR0aCAtIHRoaXMub2Zmc2V0TGVmdCAtIGwubWFyZ2luTGVmdCwgaCA9IGMudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0ICsgYS5jbGllbnRIZWlnaHQgLyAyIC0gdGhpcy5ub2Rlcy53cmFwcGVyLm9mZnNldEhlaWdodCAvIDI7XG4gICAgICAgICAgdGhpcy5hcHBseVBsYWNlbWVudChcImxlZnRcIiwgdSwgaCk7XG4gICAgICAgIH1cbiAgICAgICAgcGxhY2VSaWdodChhLCBsKSB7XG4gICAgICAgICAgY29uc3QgYyA9IGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHUgPSBjLnJpZ2h0ICsgdGhpcy5vZmZzZXRSaWdodCArIGwubWFyZ2luUmlnaHQsIGggPSBjLnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCArIGEuY2xpZW50SGVpZ2h0IC8gMiAtIHRoaXMubm9kZXMud3JhcHBlci5vZmZzZXRIZWlnaHQgLyAyO1xuICAgICAgICAgIHRoaXMuYXBwbHlQbGFjZW1lbnQoXCJyaWdodFwiLCB1LCBoKTtcbiAgICAgICAgfVxuICAgICAgICBhcHBseVBsYWNlbWVudChhLCBsLCBjKSB7XG4gICAgICAgICAgdGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5hZGQodGhpcy5DU1MucGxhY2VtZW50W2FdKSwgdGhpcy5ub2Rlcy53cmFwcGVyLnN0eWxlLmxlZnQgPSBsICsgXCJweFwiLCB0aGlzLm5vZGVzLndyYXBwZXIuc3R5bGUudG9wID0gYyArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBtYWtlKGEsIGwgPSBudWxsLCBjID0ge30pIHtcbiAgICAgICAgICBjb25zdCB1ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChhKTtcbiAgICAgICAgICBBcnJheS5pc0FycmF5KGwpID8gdS5jbGFzc0xpc3QuYWRkKC4uLmwpIDogbCAmJiB1LmNsYXNzTGlzdC5hZGQobCk7XG4gICAgICAgICAgZm9yIChjb25zdCBoIGluIGMpXG4gICAgICAgICAgICBjLmhhc093blByb3BlcnR5KGgpICYmICh1W2hdID0gY1toXSk7XG4gICAgICAgICAgcmV0dXJuIHU7XG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kKGEsIGwpIHtcbiAgICAgICAgICBBcnJheS5pc0FycmF5KGwpID8gbC5mb3JFYWNoKChjKSA9PiBhLmFwcGVuZENoaWxkKGMpKSA6IGEuYXBwZW5kQ2hpbGQobCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJlcGVuZChhLCBsKSB7XG4gICAgICAgICAgQXJyYXkuaXNBcnJheShsKSA/IChsID0gbC5yZXZlcnNlKCkpLmZvckVhY2goKGMpID0+IGEucHJlcGVuZChjKSkgOiBhLnByZXBlbmQobCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbih0LCBvKSB7XG4gICAgICB0LmV4cG9ydHMgPSBgLmN0e3otaW5kZXg6OTk5O29wYWNpdHk6MDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7cG9pbnRlci1ldmVudHM6bm9uZTstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSA1MG1zIGVhc2UtaW4sLXdlYmtpdC10cmFuc2Zvcm0gNzBtcyBjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTt0cmFuc2l0aW9uOm9wYWNpdHkgNTBtcyBlYXNlLWluLC13ZWJraXQtdHJhbnNmb3JtIDcwbXMgY3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSk7dHJhbnNpdGlvbjpvcGFjaXR5IDUwbXMgZWFzZS1pbix0cmFuc2Zvcm0gNzBtcyBjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTt0cmFuc2l0aW9uOm9wYWNpdHkgNTBtcyBlYXNlLWluLHRyYW5zZm9ybSA3MG1zIGN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpLC13ZWJraXQtdHJhbnNmb3JtIDcwbXMgY3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSk7d2lsbC1jaGFuZ2U6b3BhY2l0eSx0b3AsbGVmdDstd2Via2l0LWJveC1zaGFkb3c6MCA4cHggMTJweCAwIHJnYmEoMjksMzIsNDMsLjE3KSwwIDRweCA1cHggLTNweCByZ2JhKDUsNiwxMiwuNDkpO2JveC1zaGFkb3c6MCA4cHggMTJweCAwIHJnYmEoMjksMzIsNDMsLjE3KSwwIDRweCA1cHggLTNweCByZ2JhKDUsNiwxMiwuNDkpO2JvcmRlci1yYWRpdXM6OXB4fS5jdCwuY3Q6YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MH0uY3Q6YmVmb3Jle2NvbnRlbnQ6XCJcIjtib3R0b206MDtyaWdodDowO2JhY2tncm91bmQtY29sb3I6IzFkMjAyYjt6LWluZGV4Oi0xO2JvcmRlci1yYWRpdXM6NHB4fUBzdXBwb3J0cygtd2Via2l0LW1hc2stYm94LWltYWdlOnVybChcIlwiKSl7LmN0OmJlZm9yZXtib3JkZXItcmFkaXVzOjA7LXdlYmtpdC1tYXNrLWJveC1pbWFnZTp1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04LDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiPjxwYXRoIGQ9XCJNMTAuNzEgMGgyLjU4YzMuMDIgMCA0LjY0LjQyIDYuMSAxLjJhOC4xOCA4LjE4IDAgMDEzLjQgMy40QzIzLjYgNi4wNyAyNCA3LjcgMjQgMTAuNzF2Mi41OGMwIDMuMDItLjQyIDQuNjQtMS4yIDYuMWE4LjE4IDguMTggMCAwMS0zLjQgMy40Yy0xLjQ3LjgtMy4xIDEuMjEtNi4xMSAxLjIxSDEwLjdjLTMuMDIgMC00LjY0LS40Mi02LjEtMS4yYTguMTggOC4xOCAwIDAxLTMuNC0zLjRDLjQgMTcuOTMgMCAxNi4zIDAgMTMuMjlWMTAuN2MwLTMuMDIuNDItNC42NCAxLjItNi4xYTguMTggOC4xOCAwIDAxMy40LTMuNEM2LjA3LjQgNy43IDAgMTAuNzEgMHpcIi8+PC9zdmc+JykgNDglIDQxJSAzNy45JSA1My4zJX19QG1lZGlhICgtLW1vYmlsZSl7LmN0e2Rpc3BsYXk6bm9uZX19LmN0X19jb250ZW50e3BhZGRpbmc6NnB4IDEwcHg7Y29sb3I6I2NkZDFlMDtmb250LXNpemU6MTJweDt0ZXh0LWFsaWduOmNlbnRlcjtsZXR0ZXItc3BhY2luZzouMDJlbTtsaW5lLWhlaWdodDoxZW19LmN0OmFmdGVye2NvbnRlbnQ6XCJcIjt3aWR0aDo4cHg7aGVpZ2h0OjhweDtwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kLWNvbG9yOiMxZDIwMmI7ei1pbmRleDotMX0uY3QtLWJvdHRvbXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDVweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoNXB4KX0uY3QtLWJvdHRvbTphZnRlcnt0b3A6LTNweDtsZWZ0OjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHJvdGF0ZSgtNDVkZWcpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpIHJvdGF0ZSgtNDVkZWcpfS5jdC0tdG9wey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTVweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTVweCl9LmN0LS10b3A6YWZ0ZXJ7dG9wOmF1dG87Ym90dG9tOi0zcHg7bGVmdDo1MCU7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKSByb3RhdGUoLTQ1ZGVnKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKSByb3RhdGUoLTQ1ZGVnKX0uY3QtLWxlZnR7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtNXB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNXB4KX0uY3QtLWxlZnQ6YWZ0ZXJ7dG9wOjUwJTtsZWZ0OmF1dG87cmlnaHQ6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUoNDEuNiUsLTUwJSkgcm90YXRlKC00NWRlZyk7dHJhbnNmb3JtOnRyYW5zbGF0ZSg0MS42JSwtNTAlKSByb3RhdGUoLTQ1ZGVnKX0uY3QtLXJpZ2h0ey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoNXB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCg1cHgpfS5jdC0tcmlnaHQ6YWZ0ZXJ7dG9wOjUwJTtsZWZ0OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlKC00MS42JSwtNTAlKSByb3RhdGUoLTQ1ZGVnKTt0cmFuc2Zvcm06dHJhbnNsYXRlKC00MS42JSwtNTAlKSByb3RhdGUoLTQ1ZGVnKX0uY3QtLXNob3due29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTpub25lO3RyYW5zZm9ybTpub25lfWA7XG4gICAgfV0pLmRlZmF1bHQ7XG4gIH0pO1xufSkoVm8pO1xudmFyIGppID0gVm8uZXhwb3J0cztcbmNvbnN0IEhpID0gLyogQF9fUFVSRV9fICovIEtlKGppKTtcbmxldCBVID0gbnVsbDtcbmZ1bmN0aW9uIEV0KCkge1xuICBVIHx8IChVID0gbmV3IEhpKCkpO1xufVxuZnVuY3Rpb24gJGkobiwgZSwgdCkge1xuICBFdCgpLCBVID09IG51bGwgfHwgVS5zaG93KG4sIGUsIHQpO1xufVxuZnVuY3Rpb24gJGUobiA9ICExKSB7XG4gIEV0KCksIFUgPT0gbnVsbCB8fCBVLmhpZGUobik7XG59XG5mdW5jdGlvbiB6ZShuLCBlLCB0KSB7XG4gIEV0KCksIFUgPT0gbnVsbCB8fCBVLm9uSG92ZXIobiwgZSwgdCk7XG59XG5mdW5jdGlvbiB6aSgpIHtcbiAgVSA9PSBudWxsIHx8IFUuZGVzdHJveSgpLCBVID0gbnVsbDtcbn1cbmNsYXNzIFVpIGV4dGVuZHMgRSB7XG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIG1vZHVsZUNvbmZpZ3VyYXRpb24gLSBNb2R1bGUgQ29uZmlndXJhdGlvblxuICAgKiBAcGFyYW0gbW9kdWxlQ29uZmlndXJhdGlvbi5jb25maWcgLSBFZGl0b3IncyBjb25maWdcbiAgICogQHBhcmFtIG1vZHVsZUNvbmZpZ3VyYXRpb24uZXZlbnRzRGlzcGF0Y2hlciAtIEVkaXRvcidzIGV2ZW50IGRpc3BhdGNoZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgY29uZmlnOiBlLCBldmVudHNEaXNwYXRjaGVyOiB0IH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWc6IGUsXG4gICAgICBldmVudHNEaXNwYXRjaGVyOiB0XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBtZXRob2RzXG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2hvdzogKGUsIHQsIG8pID0+IHRoaXMuc2hvdyhlLCB0LCBvKSxcbiAgICAgIGhpZGU6ICgpID0+IHRoaXMuaGlkZSgpLFxuICAgICAgb25Ib3ZlcjogKGUsIHQsIG8pID0+IHRoaXMub25Ib3ZlcihlLCB0LCBvKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZCBzaG93IHRvb2x0aXAgb24gZWxlbWVudCB3aXRoIHBhc3NlZCBIVE1MIGNvbnRlbnRcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgb24gd2hpY2ggdG9vbHRpcCBzaG91bGQgYmUgc2hvd25cbiAgICogQHBhcmFtIHtUb29sdGlwQ29udGVudH0gY29udGVudCAtIHRvb2x0aXAgY29udGVudFxuICAgKiBAcGFyYW0ge1Rvb2x0aXBPcHRpb25zfSBvcHRpb25zIC0gdG9vbHRpcCBvcHRpb25zXG4gICAqL1xuICBzaG93KGUsIHQsIG8pIHtcbiAgICAkaShlLCB0LCBvKTtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kIGhpZGVzIHRvb2x0aXAgb24gSFRNTCBwYWdlXG4gICAqL1xuICBoaWRlKCkge1xuICAgICRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIERlY29yYXRvciBmb3Igc2hvd2luZyBUb29sdGlwIGJ5IG1vdXNlZW50ZXIvbW91c2VsZWF2ZVxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCBvbiB3aGljaCB0b29sdGlwIHNob3VsZCBiZSBzaG93blxuICAgKiBAcGFyYW0ge1Rvb2x0aXBDb250ZW50fSBjb250ZW50IC0gdG9vbHRpcCBjb250ZW50XG4gICAqIEBwYXJhbSB7VG9vbHRpcE9wdGlvbnN9IG9wdGlvbnMgLSB0b29sdGlwIG9wdGlvbnNcbiAgICovXG4gIG9uSG92ZXIoZSwgdCwgbykge1xuICAgIHplKGUsIHQsIG8pO1xuICB9XG59XG5jbGFzcyBXaSBleHRlbmRzIEUge1xuICAvKipcbiAgICogQXZhaWxhYmxlIG1ldGhvZHMgLyBnZXR0ZXJzXG4gICAqL1xuICBnZXQgbWV0aG9kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZXM6IHRoaXMuZWRpdG9yTm9kZXNcbiAgICAgIC8qKlxuICAgICAgICogVGhlcmUgY2FuIGJlIGFkZGVkIHNvbWUgVUkgbWV0aG9kcywgbGlrZSB0b2dnbGVUaGluTW9kZSgpIGV0Y1xuICAgICAgICovXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRXhwb3J0ZWQgY2xhc3Nlc1xuICAgKi9cbiAgZ2V0IGVkaXRvck5vZGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIFRvcC1sZXZlbCBlZGl0b3IgaW5zdGFuY2Ugd3JhcHBlclxuICAgICAgICovXG4gICAgICB3cmFwcGVyOiB0aGlzLkVkaXRvci5VSS5ub2Rlcy53cmFwcGVyLFxuICAgICAgLyoqXG4gICAgICAgKiBFbGVtZW50IHRoYXQgaG9sZHMgYWxsIHRoZSBCbG9ja3NcbiAgICAgICAqL1xuICAgICAgcmVkYWN0b3I6IHRoaXMuRWRpdG9yLlVJLm5vZGVzLnJlZGFjdG9yXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gcW8obiwgZSkge1xuICBjb25zdCB0ID0ge307XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhuKS5mb3JFYWNoKChbbywgaV0pID0+IHtcbiAgICBpZiAoRChpKSkge1xuICAgICAgY29uc3QgcyA9IGUgPyBgJHtlfS4ke299YCA6IG87XG4gICAgICBPYmplY3QudmFsdWVzKGkpLmV2ZXJ5KChhKSA9PiB0ZShhKSkgPyB0W29dID0gcyA6IHRbb10gPSBxbyhpLCBzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdFtvXSA9IGk7XG4gIH0pLCB0O1xufVxuY29uc3QgSyA9IHFvKEZvKTtcbmZ1bmN0aW9uIFlpKG4sIGUpIHtcbiAgY29uc3QgdCA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmtleXMobikuZm9yRWFjaCgobykgPT4ge1xuICAgIGNvbnN0IGkgPSBlW29dO1xuICAgIGkgIT09IHZvaWQgMCA/IHRbaV0gPSBuW29dIDogdFtvXSA9IG5bb107XG4gIH0pLCB0O1xufVxuY29uc3QgWm8gPSBjbGFzcyBFZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W119IG5vZGVMaXN0IOKAlCB0aGUgbGlzdCBvZiBpdGVyYWJsZSBIVE1MLWl0ZW1zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb2N1c2VkQ3NzQ2xhc3MgLSB1c2VyLXByb3ZpZGVkIENTUy1jbGFzcyB0aGF0IHdpbGwgYmUgc2V0IGluIGZsaXBwaW5nIHByb2Nlc3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLmN1cnNvciA9IC0xLCB0aGlzLml0ZW1zID0gW10sIHRoaXMuaXRlbXMgPSBlIHx8IFtdLCB0aGlzLmZvY3VzZWRDc3NDbGFzcyA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgRm9jdXNlZCBidXR0b24gTm9kZVxuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBnZXQgY3VycmVudEl0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuY3Vyc29yID09PSAtMSA/IG51bGwgOiB0aGlzLml0ZW1zW3RoaXMuY3Vyc29yXTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBjdXJzb3IgdG8gc3BlY2lmaWVkIHBvc2l0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBjdXJzb3JQb3NpdGlvbiAtIG5ldyBjdXJzb3IgcG9zaXRpb25cbiAgICovXG4gIHNldEN1cnNvcihlKSB7XG4gICAgZSA8IHRoaXMuaXRlbXMubGVuZ3RoICYmIGUgPj0gLTEgJiYgKHRoaXMuZHJvcEN1cnNvcigpLCB0aGlzLmN1cnNvciA9IGUsIHRoaXMuaXRlbXNbdGhpcy5jdXJzb3JdLmNsYXNzTGlzdC5hZGQodGhpcy5mb2N1c2VkQ3NzQ2xhc3MpKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBpdGVtcy4gQ2FuIGJlIHVzZWQgd2hlbiBpdGVyYWJsZSBpdGVtcyBjaGFuZ2VkIGR5bmFtaWNhbGx5XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXX0gbm9kZUxpc3QgLSBub2RlcyB0byBpdGVyYXRlXG4gICAqL1xuICBzZXRJdGVtcyhlKSB7XG4gICAgdGhpcy5pdGVtcyA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgY3Vyc29yIG5leHQgdG8gdGhlIGN1cnJlbnRcbiAgICovXG4gIG5leHQoKSB7XG4gICAgdGhpcy5jdXJzb3IgPSB0aGlzLmxlYWZOb2Rlc0FuZFJldHVybkluZGV4KEVlLmRpcmVjdGlvbnMuUklHSFQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGN1cnNvciBiZWZvcmUgY3VycmVudFxuICAgKi9cbiAgcHJldmlvdXMoKSB7XG4gICAgdGhpcy5jdXJzb3IgPSB0aGlzLmxlYWZOb2Rlc0FuZFJldHVybkluZGV4KEVlLmRpcmVjdGlvbnMuTEVGVCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgY3Vyc29yIHRvIHRoZSBkZWZhdWx0IHBvc2l0aW9uIGFuZCByZW1vdmVzIENTUy1jbGFzcyBmcm9tIHByZXZpb3VzbHkgZm9jdXNlZCBpdGVtXG4gICAqL1xuICBkcm9wQ3Vyc29yKCkge1xuICAgIHRoaXMuY3Vyc29yICE9PSAtMSAmJiAodGhpcy5pdGVtc1t0aGlzLmN1cnNvcl0uY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmZvY3VzZWRDc3NDbGFzcyksIHRoaXMuY3Vyc29yID0gLTEpO1xuICB9XG4gIC8qKlxuICAgKiBMZWFmcyBub2RlcyBpbnNpZGUgdGhlIHRhcmdldCBsaXN0IGZyb20gYWN0aXZlIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiAtIGxlYWYgZGlyZWN0aW9uLiBDYW4gYmUgJ2xlZnQnIG9yICdyaWdodCdcbiAgICogQHJldHVybnMge251bWJlcn0gaW5kZXggb2YgZm9jdXNlZCBub2RlXG4gICAqL1xuICBsZWFmTm9kZXNBbmRSZXR1cm5JbmRleChlKSB7XG4gICAgaWYgKHRoaXMuaXRlbXMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yO1xuICAgIGxldCB0ID0gdGhpcy5jdXJzb3I7XG4gICAgcmV0dXJuIHQgPT09IC0xID8gdCA9IGUgPT09IEVlLmRpcmVjdGlvbnMuUklHSFQgPyAtMSA6IDAgOiB0aGlzLml0ZW1zW3RdLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5mb2N1c2VkQ3NzQ2xhc3MpLCBlID09PSBFZS5kaXJlY3Rpb25zLlJJR0hUID8gdCA9ICh0ICsgMSkgJSB0aGlzLml0ZW1zLmxlbmd0aCA6IHQgPSAodGhpcy5pdGVtcy5sZW5ndGggKyB0IC0gMSkgJSB0aGlzLml0ZW1zLmxlbmd0aCwgZC5jYW5TZXRDYXJldCh0aGlzLml0ZW1zW3RdKSAmJiBGZSgoKSA9PiBiLnNldEN1cnNvcih0aGlzLml0ZW1zW3RdKSwgNTApKCksIHRoaXMuaXRlbXNbdF0uY2xhc3NMaXN0LmFkZCh0aGlzLmZvY3VzZWRDc3NDbGFzcyksIHQ7XG4gIH1cbn07XG5aby5kaXJlY3Rpb25zID0ge1xuICBSSUdIVDogXCJyaWdodFwiLFxuICBMRUZUOiBcImxlZnRcIlxufTtcbmxldCBrZSA9IFpvO1xuY2xhc3MgY2Uge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBkaWZmZXJlbnQgY29uc3RydWN0aW5nIHNldHRpbmdzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5pdGVyYXRvciA9IG51bGwsIHRoaXMuYWN0aXZhdGVkID0gITEsIHRoaXMuZmxpcENhbGxiYWNrcyA9IFtdLCB0aGlzLm9uS2V5RG93biA9ICh0KSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0V2ZW50UmVhZHlGb3JIYW5kbGluZyh0KSlcbiAgICAgICAgc3dpdGNoIChjZS51c2VkS2V5cy5pbmNsdWRlcyh0LmtleUNvZGUpICYmIHQucHJldmVudERlZmF1bHQoKSwgdC5rZXlDb2RlKSB7XG4gICAgICAgICAgY2FzZSB5LlRBQjpcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVGFiUHJlc3ModCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIHkuTEVGVDpcbiAgICAgICAgICBjYXNlIHkuVVA6XG4gICAgICAgICAgICB0aGlzLmZsaXBMZWZ0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIHkuUklHSFQ6XG4gICAgICAgICAgY2FzZSB5LkRPV046XG4gICAgICAgICAgICB0aGlzLmZsaXBSaWdodCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSB5LkVOVEVSOlxuICAgICAgICAgICAgdGhpcy5oYW5kbGVFbnRlclByZXNzKHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzLml0ZXJhdG9yID0gbmV3IGtlKGUuaXRlbXMsIGUuZm9jdXNlZEl0ZW1DbGFzcyksIHRoaXMuYWN0aXZhdGVDYWxsYmFjayA9IGUuYWN0aXZhdGVDYWxsYmFjaywgdGhpcy5hbGxvd2VkS2V5cyA9IGUuYWxsb3dlZEtleXMgfHwgY2UudXNlZEtleXM7XG4gIH1cbiAgLyoqXG4gICAqIFRydWUgaWYgZmxpcHBlciBpcyBjdXJyZW50bHkgYWN0aXZhdGVkXG4gICAqL1xuICBnZXQgaXNBY3RpdmF0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZhdGVkO1xuICB9XG4gIC8qKlxuICAgKiBBcnJheSBvZiBrZXlzIChjb2RlcykgdGhhdCBpcyBoYW5kbGVkIGJ5IEZsaXBwZXJcbiAgICogVXNlZCB0bzpcbiAgICogIC0gcHJldmVudERlZmF1bHQgb25seSBmb3IgdGhpcyBrZXlzLCBub3QgYWxsIGtleWRvd25zIChAc2VlIGNvbnN0cnVjdG9yKVxuICAgKiAgLSB0byBza2lwIGV4dGVybmFsIGJlaGF2aW91cnMgb25seSBmb3IgdGhlc2Uga2V5cywgd2hlbiBmaWxsZXIgaXMgYWN0aXZhdGVkIChAc2VlIEJsb2NrRXZlbnRzQGFycm93UmlnaHRBbmREb3duKVxuICAgKi9cbiAgc3RhdGljIGdldCB1c2VkS2V5cygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeS5UQUIsXG4gICAgICB5LkxFRlQsXG4gICAgICB5LlJJR0hULFxuICAgICAgeS5FTlRFUixcbiAgICAgIHkuVVAsXG4gICAgICB5LkRPV05cbiAgICBdO1xuICB9XG4gIC8qKlxuICAgKiBBY3RpdmUgdGFiL2Fycm93cyBoYW5kbGluZyBieSBmbGlwcGVyXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtcyAtIFNvbWUgbW9kdWxlcyAobGlrZSwgSW5saW5lVG9vbGJhciwgQmxvY2tTZXR0aW5ncykgbWlnaHQgcmVmcmVzaCBidXR0b25zIGR5bmFtaWNhbGx5XG4gICAqIEBwYXJhbSBjdXJzb3JQb3NpdGlvbiAtIGluZGV4IG9mIHRoZSBpdGVtIHRoYXQgc2hvdWxkIGJlIGZvY3VzZWQgb25jZSBmbGlwcGVyIGlzIGFjdGl2YXRlZFxuICAgKi9cbiAgYWN0aXZhdGUoZSwgdCkge1xuICAgIHRoaXMuYWN0aXZhdGVkID0gITAsIGUgJiYgdGhpcy5pdGVyYXRvci5zZXRJdGVtcyhlKSwgdCAhPT0gdm9pZCAwICYmIHRoaXMuaXRlcmF0b3Iuc2V0Q3Vyc29yKHQpLCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLm9uS2V5RG93biwgITApO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlIHRhYi9hcnJvd3MgaGFuZGxpbmcgYnkgZmxpcHBlclxuICAgKi9cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmFjdGl2YXRlZCA9ICExLCB0aGlzLmRyb3BDdXJzb3IoKSwgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5vbktleURvd24pO1xuICB9XG4gIC8qKlxuICAgKiBGb2N1cyBmaXJzdCBpdGVtXG4gICAqL1xuICBmb2N1c0ZpcnN0KCkge1xuICAgIHRoaXMuZHJvcEN1cnNvcigpLCB0aGlzLmZsaXBSaWdodCgpO1xuICB9XG4gIC8qKlxuICAgKiBGb2N1c2VzIHByZXZpb3VzIGZsaXBwZXIgaXRlcmF0b3IgaXRlbVxuICAgKi9cbiAgZmxpcExlZnQoKSB7XG4gICAgdGhpcy5pdGVyYXRvci5wcmV2aW91cygpLCB0aGlzLmZsaXBDYWxsYmFjaygpO1xuICB9XG4gIC8qKlxuICAgKiBGb2N1c2VzIG5leHQgZmxpcHBlciBpdGVyYXRvciBpdGVtXG4gICAqL1xuICBmbGlwUmlnaHQoKSB7XG4gICAgdGhpcy5pdGVyYXRvci5uZXh0KCksIHRoaXMuZmxpcENhbGxiYWNrKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIHNvbWUgYnV0dG9uIGlzIGZvY3VzZWRcbiAgICovXG4gIGhhc0ZvY3VzKCkge1xuICAgIHJldHVybiAhIXRoaXMuaXRlcmF0b3IuY3VycmVudEl0ZW07XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyZXMgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgZXhlY3V0ZWQgb24gZWFjaCBuYXZpZ2F0aW9uIGFjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gY2IgLSBmdW5jdGlvbiB0byBleGVjdXRlXG4gICAqL1xuICBvbkZsaXAoZSkge1xuICAgIHRoaXMuZmxpcENhbGxiYWNrcy5wdXNoKGUpO1xuICB9XG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyZXMgZnVuY3Rpb24gdGhhdCBpcyBleGVjdXRlZCBvbiBlYWNoIG5hdmlnYXRpb24gYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBjYiAtIGZ1bmN0aW9uIHRvIHN0b3AgZXhlY3V0aW5nXG4gICAqL1xuICByZW1vdmVPbkZsaXAoZSkge1xuICAgIHRoaXMuZmxpcENhbGxiYWNrcyA9IHRoaXMuZmxpcENhbGxiYWNrcy5maWx0ZXIoKHQpID0+IHQgIT09IGUpO1xuICB9XG4gIC8qKlxuICAgKiBEcm9wcyBmbGlwcGVyJ3MgaXRlcmF0b3IgY3Vyc29yXG4gICAqXG4gICAqIEBzZWUgRG9tSXRlcmF0b3IjZHJvcEN1cnNvclxuICAgKi9cbiAgZHJvcEN1cnNvcigpIHtcbiAgICB0aGlzLml0ZXJhdG9yLmRyb3BDdXJzb3IoKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBmaXJlZCBiZWZvcmUgaGFuZGxpbmcgZmxpcHBlciBrZXljb2Rlc1xuICAgKiBUaGUgcmVzdWx0IG9mIHRoaXMgZnVuY3Rpb24gZGVmaW5lcyBpZiBpdCBpcyBuZWVkIHRvIGJlIGhhbmRsZWQgb3Igbm90XG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBrZXlkb3duIGtleWJvYXJkIGV2ZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNFdmVudFJlYWR5Rm9ySGFuZGxpbmcoZSkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2YXRlZCAmJiB0aGlzLmFsbG93ZWRLZXlzLmluY2x1ZGVzKGUua2V5Q29kZSk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZW4gZmxpcHBlciBpcyBhY3RpdmF0ZWQgdGFiIHByZXNzIHdpbGwgbGVhZiB0aGUgaXRlbXNcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIHRhYiBrZXlkb3duIGV2ZW50XG4gICAqL1xuICBoYW5kbGVUYWJQcmVzcyhlKSB7XG4gICAgc3dpdGNoIChlLnNoaWZ0S2V5ID8ga2UuZGlyZWN0aW9ucy5MRUZUIDoga2UuZGlyZWN0aW9ucy5SSUdIVCkge1xuICAgICAgY2FzZSBrZS5kaXJlY3Rpb25zLlJJR0hUOlxuICAgICAgICB0aGlzLmZsaXBSaWdodCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Uga2UuZGlyZWN0aW9ucy5MRUZUOlxuICAgICAgICB0aGlzLmZsaXBMZWZ0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRW50ZXIgcHJlc3Mgd2lsbCBjbGljayBjdXJyZW50IGl0ZW0gaWYgZmxpcHBlciBpcyBhY3RpdmF0ZWRcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGVudGVyIGtleWRvd24gZXZlbnRcbiAgICovXG4gIGhhbmRsZUVudGVyUHJlc3MoZSkge1xuICAgIHRoaXMuYWN0aXZhdGVkICYmICh0aGlzLml0ZXJhdG9yLmN1cnJlbnRJdGVtICYmIChlLnN0b3BQcm9wYWdhdGlvbigpLCBlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuaXRlcmF0b3IuY3VycmVudEl0ZW0uY2xpY2soKSksIEEodGhpcy5hY3RpdmF0ZUNhbGxiYWNrKSAmJiB0aGlzLmFjdGl2YXRlQ2FsbGJhY2sodGhpcy5pdGVyYXRvci5jdXJyZW50SXRlbSkpO1xuICB9XG4gIC8qKlxuICAgKiBGaXJlZCBhZnRlciBmbGlwcGluZyBpbiBhbnkgZGlyZWN0aW9uXG4gICAqL1xuICBmbGlwQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5pdGVyYXRvci5jdXJyZW50SXRlbSAmJiB0aGlzLml0ZXJhdG9yLmN1cnJlbnRJdGVtLnNjcm9sbEludG9WaWV3SWZOZWVkZWQoKSwgdGhpcy5mbGlwQ2FsbGJhY2tzLmZvckVhY2goKGUpID0+IGUoKSk7XG4gIH1cbn1cbmNvbnN0IEtpID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk05IDEyTDkgNy4xQzkgNy4wNDQ3NyA5LjA0NDc3IDcgOS4xIDdIMTAuNEMxMS41IDcgMTQgNy4xIDE0IDkuNUMxNCA5LjUgMTQgMTIgMTEgMTJNOSAxMlYxNi44QzkgMTYuOTEwNSA5LjA4OTU0IDE3IDkuMiAxN0gxMi41QzE0IDE3IDE1IDE2IDE1IDE0LjVDMTUgMTEuNzA0NiAxMSAxMiAxMSAxMk05IDEySDExXCIvPjwvc3ZnPicsIFhpID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk03IDEwTDExLjg1ODYgMTQuODU4NkMxMS45MzY3IDE0LjkzNjcgMTIuMDYzMyAxNC45MzY3IDEyLjE0MTQgMTQuODU4NkwxNyAxMFwiLz48L3N2Zz4nLCBWaSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTQuNSAxNy41TDkuNjQxNDIgMTIuNjQxNEM5LjU2MzMxIDEyLjU2MzMgOS41NjMzMSAxMi40MzY3IDkuNjQxNDIgMTIuMzU4NkwxNC41IDcuNVwiLz48L3N2Zz4nLCBxaSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNOS41ODI4NCAxNy41TDE0LjQ0MTQgMTIuNjQxNEMxNC41MTk1IDEyLjU2MzMgMTQuNTE5NSAxMi40MzY3IDE0LjQ0MTQgMTIuMzU4Nkw5LjU4Mjg0IDcuNVwiLz48L3N2Zz4nLCBaaSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNyAxNUwxMS44NTg2IDEwLjE0MTRDMTEuOTM2NyAxMC4wNjMzIDEyLjA2MzMgMTAuMDYzMyAxMi4xNDE0IDEwLjE0MTRMMTcgMTVcIi8+PC9zdmc+JywgR2kgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTggOEwxMiAxMk0xMiAxMkwxNiAxNk0xMiAxMkwxNiA4TTEyIDEyTDggMTZcIi8+PC9zdmc+JywgUWkgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCI0XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48L3N2Zz4nLCBKaSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTMuMzQgMTBDMTIuNDIyMyAxMi43MzM3IDExIDE3IDExIDE3XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNC4yMSA3SDE0LjJcIi8+PC9zdmc+JywgQ28gPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTcuNjk5OTggMTIuNkw3LjY3ODk2IDEyLjYyQzYuNTM5OTMgMTMuNzA0OCA2LjUyMDEyIDE1LjUxNTUgNy42MzUxNiAxNi42MjVWMTYuNjI1QzguNzIyOTMgMTcuNzA3MyAxMC40Nzk5IDE3LjcxMDIgMTEuNTcxMiAxNi42MzE0TDEzLjAyNjMgMTUuMTkzQzE0LjA3MDMgMTQuMTYwOSAxNC4yMTQxIDEyLjUyNSAxMy4zNjYyIDExLjMyNjZMMTMuMjIgMTEuMTJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE2LjIyIDExLjEyTDE2LjM1NjQgMTAuOTgwNUMxNy4yODk1IDEwLjAyNjUgMTcuMzQ3OCA4LjUyMDcgMTYuNDkxNCA3LjQ5NzMzVjcuNDk3MzNDMTUuNTY5MSA2LjM5NTA5IDEzLjkyNjkgNi4yNTE0MyAxMi44MjcxIDcuMTc2NzVMMTEuMzkwMSA4LjM4NTg4QzEwLjA5MzUgOS40NzY3NCA5Ljk1NzA2IDExLjQyNDEgMTEuMDg4OCAxMi42ODUyTDExLjEyIDEyLjcyXCIvPjwvc3ZnPicsIGVzID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyLjZcIiBkPVwiTTkuNDA5OTkgNy4yOTk5OUg5LjRcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjIuNlwiIGQ9XCJNMTQuNiA3LjI5OTk5SDE0LjU5XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyLjZcIiBkPVwiTTkuMzA5OTkgMTJIOS4zXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyLjZcIiBkPVwiTTE0LjYgMTJIMTQuNTlcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjIuNlwiIGQ9XCJNOS40MDk5OSAxNi43SDkuNFwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMi42XCIgZD1cIk0xNC42IDE2LjdIMTQuNTlcIi8+PC9zdmc+JywgdHMgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTEyIDdWMTJNMTIgMTdWMTJNMTcgMTJIMTJNMTIgMTJIN1wiLz48L3N2Zz4nLCBHbyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTEuNSAxNy41TDUgMTFNNSAxMVYxNS41TTUgMTFIOS41XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xMi41IDYuNUwxOSAxM00xOSAxM1Y4LjVNMTkgMTNIMTQuNVwiLz48L3N2Zz4nLCBvcyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48Y2lyY2xlIGN4PVwiMTAuNVwiIGN5PVwiMTAuNVwiIHI9XCI1LjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIvPjxsaW5lIHgxPVwiMTUuNDE0MlwiIHgyPVwiMTlcIiB5MT1cIjE1XCIgeTI9XCIxOC41ODU4XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PC9zdmc+JywgbnMgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE1Ljc3OTUgMTEuNUMxNS43Nzk1IDExLjUgMTYuMDUzIDExLjE5NjIgMTYuNTQ5NyAxMC42NzIyQzE3LjQ0NDIgOS43Mjg1NiAxNy40NzAxIDguMjQ3NSAxNi41NzgxIDcuMzAxNDVWNy4zMDE0NUMxNS42NDgyIDYuMzE1MjIgMTQuMDg3MyA2LjI5MjI3IDEzLjEyODggNy4yNTA3M0wxMS44Nzk2IDguNDk5OTlcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTguMjQ1MTcgMTIuMzg4M0M4LjI0NTE3IDEyLjM4ODMgNy45NzE3MSAxMi42OTIyIDcuNDc1MDQgMTMuMjE2MUM2LjU4MDUxIDE0LjE1OTggNi41NTQ2NyAxNS42NDA4IDcuNDQ2NjYgMTYuNTg2OVYxNi41ODY5QzguMzc2NTMgMTcuNTczMSA5LjkzNzQ0IDE3LjU5NjEgMTAuODk1OSAxNi42Mzc2TDEyLjE0NTIgMTUuMzg4M1wiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTcuNzgwMiAxNS4xMDMyTDE2LjU5NyAxNC45NDIyQzE2LjAxMDkgMTQuODYyNCAxNS40ODQxIDE1LjMwNTkgMTUuNDYyNyAxNS44OTY5TDE1LjQxOTkgMTcuMDgxOFwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNi4zOTA2NCA5LjAzMjM4TDcuNTg0MzIgOS4wNjY2OEM4LjE3NTUxIDkuMDgzNjYgOC42NTIyIDguNTg2NjUgOC42MTA1NiA3Ljk5NjY5TDguNTI3MSA2LjgxMzk3XCIvPjxsaW5lIHgxPVwiMTIuMTE0MlwiIHgyPVwiMTEuN1wiIHkxPVwiMTIuMlwiIHkyPVwiMTEuNzg1OFwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIvPjwvc3ZnPicsIGlzID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxyZWN0IHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiIHg9XCI1XCIgeT1cIjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgcng9XCI0XCIvPjxsaW5lIHgxPVwiMTJcIiB4Mj1cIjEyXCIgeTE9XCI5XCIgeTI9XCIxMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xMiAxNS4wMlYxNS4wMVwiLz48L3N2Zz4nLCBzcyA9IFwiX19cIiwgcnMgPSBcIi0tXCI7XG5mdW5jdGlvbiBuZShuKSB7XG4gIHJldHVybiAoZSwgdCkgPT4gW1tuLCBlXS5maWx0ZXIoKGkpID0+ICEhaSkuam9pbihzcyksIHRdLmZpbHRlcigoaSkgPT4gISFpKS5qb2luKHJzKTtcbn1cbmNvbnN0IHllID0gbmUoXCJjZS1oaW50XCIpLCB3ZSA9IHtcbiAgcm9vdDogeWUoKSxcbiAgYWxpZ25lZFN0YXJ0OiB5ZShudWxsLCBcImFsaWduLWxlZnRcIiksXG4gIGFsaWduZWRDZW50ZXI6IHllKG51bGwsIFwiYWxpZ24tY2VudGVyXCIpLFxuICB0aXRsZTogeWUoXCJ0aXRsZVwiKSxcbiAgZGVzY3JpcHRpb246IHllKFwiZGVzY3JpcHRpb25cIilcbn07XG5jbGFzcyBhcyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIHRoZSBoaW50IGNvbnRlbnQgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIGhpbnQgY29udGVudCBwYXJhbWV0ZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5ub2RlcyA9IHtcbiAgICAgIHJvb3Q6IGQubWFrZShcImRpdlwiLCBbd2Uucm9vdCwgZS5hbGlnbm1lbnQgPT09IFwiY2VudGVyXCIgPyB3ZS5hbGlnbmVkQ2VudGVyIDogd2UuYWxpZ25lZFN0YXJ0XSksXG4gICAgICB0aXRsZTogZC5tYWtlKFwiZGl2XCIsIHdlLnRpdGxlLCB7IHRleHRDb250ZW50OiBlLnRpdGxlIH0pXG4gICAgfSwgdGhpcy5ub2Rlcy5yb290LmFwcGVuZENoaWxkKHRoaXMubm9kZXMudGl0bGUpLCBlLmRlc2NyaXB0aW9uICE9PSB2b2lkIDAgJiYgKHRoaXMubm9kZXMuZGVzY3JpcHRpb24gPSBkLm1ha2UoXCJkaXZcIiwgd2UuZGVzY3JpcHRpb24sIHsgdGV4dENvbnRlbnQ6IGUuZGVzY3JpcHRpb24gfSksIHRoaXMubm9kZXMucm9vdC5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLmRlc2NyaXB0aW9uKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvb3QgZWxlbWVudCBvZiB0aGUgaGludCBjb250ZW50XG4gICAqL1xuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnJvb3Q7XG4gIH1cbn1cbmNsYXNzIHh0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgdGhlIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBpbnN0YW5jZSBwYXJhbWV0ZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5wYXJhbXMgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBJdGVtIG5hbWUgaWYgZXhpc3RzXG4gICAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICBpZiAodGhpcy5wYXJhbXMgIT09IHZvaWQgMCAmJiBcIm5hbWVcIiBpbiB0aGlzLnBhcmFtcylcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5uYW1lO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgaW5zdGFuY2VcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgJGUoKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gY2hpbGRyZW4gcG9wb3ZlciBpcyBvcGVuZWQgKGlmIGV4aXN0cylcbiAgICovXG4gIG9uQ2hpbGRyZW5PcGVuKCkge1xuICAgIHZhciBlO1xuICAgIHRoaXMucGFyYW1zICE9PSB2b2lkIDAgJiYgXCJjaGlsZHJlblwiIGluIHRoaXMucGFyYW1zICYmIHR5cGVvZiAoKGUgPSB0aGlzLnBhcmFtcy5jaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IGUub25PcGVuKSA9PSBcImZ1bmN0aW9uXCIgJiYgdGhpcy5wYXJhbXMuY2hpbGRyZW4ub25PcGVuKCk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGNoaWxkcmVuIHBvcG92ZXIgaXMgY2xvc2VkIChpZiBleGlzdHMpXG4gICAqL1xuICBvbkNoaWxkcmVuQ2xvc2UoKSB7XG4gICAgdmFyIGU7XG4gICAgdGhpcy5wYXJhbXMgIT09IHZvaWQgMCAmJiBcImNoaWxkcmVuXCIgaW4gdGhpcy5wYXJhbXMgJiYgdHlwZW9mICgoZSA9IHRoaXMucGFyYW1zLmNoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogZS5vbkNsb3NlKSA9PSBcImZ1bmN0aW9uXCIgJiYgdGhpcy5wYXJhbXMuY2hpbGRyZW4ub25DbG9zZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgb24gcG9wb3ZlciBpdGVtIGNsaWNrXG4gICAqL1xuICBoYW5kbGVDbGljaygpIHtcbiAgICB2YXIgZSwgdDtcbiAgICB0aGlzLnBhcmFtcyAhPT0gdm9pZCAwICYmIFwib25BY3RpdmF0ZVwiIGluIHRoaXMucGFyYW1zICYmICgodCA9IChlID0gdGhpcy5wYXJhbXMpLm9uQWN0aXZhdGUpID09IG51bGwgfHwgdC5jYWxsKGUsIHRoaXMucGFyYW1zKSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgaGludCB0byB0aGUgaXRlbSBlbGVtZW50IGlmIGhpbnQgZGF0YSBpcyBwcm92aWRlZFxuICAgKlxuICAgKiBAcGFyYW0gaXRlbUVsZW1lbnQgLSBwb3BvdmVyIGl0ZW0gcm9vdCBlbGVtZW50IHRvIGFkZCBoaW50IHRvXG4gICAqIEBwYXJhbSBoaW50RGF0YSAtIGhpbnQgZGF0YVxuICAgKi9cbiAgYWRkSGludChlLCB0KSB7XG4gICAgY29uc3QgbyA9IG5ldyBhcyh0KTtcbiAgICB6ZShlLCBvLmdldEVsZW1lbnQoKSwge1xuICAgICAgcGxhY2VtZW50OiB0LnBvc2l0aW9uLFxuICAgICAgaGlkaW5nRGVsYXk6IDEwMFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGl0ZW0gY2hpbGRyZW4gdGhhdCBhcmUgcmVwcmVzZW50ZWQgYXMgcG9wb3ZlciBpdGVtc1xuICAgKi9cbiAgZ2V0IGNoaWxkcmVuKCkge1xuICAgIHZhciBlO1xuICAgIHJldHVybiB0aGlzLnBhcmFtcyAhPT0gdm9pZCAwICYmIFwiY2hpbGRyZW5cIiBpbiB0aGlzLnBhcmFtcyAmJiAoKGUgPSB0aGlzLnBhcmFtcy5jaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IGUuaXRlbXMpICE9PSB2b2lkIDAgPyB0aGlzLnBhcmFtcy5jaGlsZHJlbi5pdGVtcyA6IFtdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgaXRlbSBoYXMgYW55IHR5cGUgb2YgY2hpbGRyZW5cbiAgICovXG4gIGdldCBoYXNDaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgaXRlbSBjaGlsZHJlbiBzaG91bGQgYmUgb3BlbiBpbnN0YW50bHkgYWZ0ZXIgcG9wb3ZlciBpcyBvcGVuZWQgYW5kIG5vdCBvbiBpdGVtIGNsaWNrL2hvdmVyXG4gICAqL1xuICBnZXQgaXNDaGlsZHJlbk9wZW4oKSB7XG4gICAgdmFyIGU7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zICE9PSB2b2lkIDAgJiYgXCJjaGlsZHJlblwiIGluIHRoaXMucGFyYW1zICYmICgoZSA9IHRoaXMucGFyYW1zLmNoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogZS5pc09wZW4pID09PSAhMDtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBpdGVtIGNoaWxkcmVuIGl0ZW1zIHNob3VsZCBiZSBuYXZpZ2F0YWJsZSB2aWEga2V5Ym9hcmRcbiAgICovXG4gIGdldCBpc0NoaWxkcmVuRmxpcHBhYmxlKCkge1xuICAgIHZhciBlO1xuICAgIHJldHVybiAhKHRoaXMucGFyYW1zID09PSB2b2lkIDAgfHwgIShcImNoaWxkcmVuXCIgaW4gdGhpcy5wYXJhbXMpIHx8ICgoZSA9IHRoaXMucGFyYW1zLmNoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogZS5pc0ZsaXBwYWJsZSkgPT09ICExKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGl0ZW0gaGFzIGNoaWxkcmVuIHRoYXQgc2hvdWxkIGJlIHNlYXJjaGFibGVcbiAgICovXG4gIGdldCBpc0NoaWxkcmVuU2VhcmNoYWJsZSgpIHtcbiAgICB2YXIgZTtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXMgIT09IHZvaWQgMCAmJiBcImNoaWxkcmVuXCIgaW4gdGhpcy5wYXJhbXMgJiYgKChlID0gdGhpcy5wYXJhbXMuY2hpbGRyZW4pID09IG51bGwgPyB2b2lkIDAgOiBlLnNlYXJjaGFibGUpID09PSAhMDtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBwb3BvdmVyIHNob3VsZCBjbG9zZSBvbmNlIGl0ZW0gaXMgYWN0aXZhdGVkXG4gICAqL1xuICBnZXQgY2xvc2VPbkFjdGl2YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmFtcyAhPT0gdm9pZCAwICYmIFwiY2xvc2VPbkFjdGl2YXRlXCIgaW4gdGhpcy5wYXJhbXMgJiYgdGhpcy5wYXJhbXMuY2xvc2VPbkFjdGl2YXRlO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIGl0ZW0gaXMgYWN0aXZlXG4gICAqL1xuICBnZXQgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zID09PSB2b2lkIDAgfHwgIShcImlzQWN0aXZlXCIgaW4gdGhpcy5wYXJhbXMpID8gITEgOiB0eXBlb2YgdGhpcy5wYXJhbXMuaXNBY3RpdmUgPT0gXCJmdW5jdGlvblwiID8gdGhpcy5wYXJhbXMuaXNBY3RpdmUoKSA6IHRoaXMucGFyYW1zLmlzQWN0aXZlID09PSAhMDtcbiAgfVxufVxuY29uc3QgWSA9IG5lKFwiY2UtcG9wb3Zlci1pdGVtXCIpLCBMID0ge1xuICBjb250YWluZXI6IFkoKSxcbiAgYWN0aXZlOiBZKG51bGwsIFwiYWN0aXZlXCIpLFxuICBkaXNhYmxlZDogWShudWxsLCBcImRpc2FibGVkXCIpLFxuICBmb2N1c2VkOiBZKG51bGwsIFwiZm9jdXNlZFwiKSxcbiAgaGlkZGVuOiBZKG51bGwsIFwiaGlkZGVuXCIpLFxuICBjb25maXJtYXRpb25TdGF0ZTogWShudWxsLCBcImNvbmZpcm1hdGlvblwiKSxcbiAgbm9Ib3ZlcjogWShudWxsLCBcIm5vLWhvdmVyXCIpLFxuICBub0ZvY3VzOiBZKG51bGwsIFwibm8tZm9jdXNcIiksXG4gIHRpdGxlOiBZKFwidGl0bGVcIiksXG4gIHNlY29uZGFyeVRpdGxlOiBZKFwic2Vjb25kYXJ5LXRpdGxlXCIpLFxuICBpY29uOiBZKFwiaWNvblwiKSxcbiAgaWNvblRvb2w6IFkoXCJpY29uXCIsIFwidG9vbFwiKSxcbiAgaWNvbkNoZXZyb25SaWdodDogWShcImljb25cIiwgXCJjaGV2cm9uLXJpZ2h0XCIpLFxuICB3b2JibGVBbmltYXRpb246IG5lKFwid29iYmxlXCIpKClcbn07XG5jbGFzcyByZSBleHRlbmRzIHh0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgcG9wb3ZlciBpdGVtIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBwb3BvdmVyIGl0ZW0gY29uc3RydWN0aW9uIHBhcmFtc1xuICAgKiBAcGFyYW0gcmVuZGVyUGFyYW1zIC0gcG9wb3ZlciBpdGVtIHJlbmRlciBwYXJhbXMuXG4gICAqIFRoZSBwYXJhbWV0ZXJzIHRoYXQgYXJlIG5vdCBzZXQgYnkgdXNlciB2aWEgcG9wb3ZlciBhcGkgYnV0IHJhdGhlciBkZXBlbmQgb24gdGVjaG5pY2FsIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSksIHRoaXMucGFyYW1zID0gZSwgdGhpcy5ub2RlcyA9IHtcbiAgICAgIHJvb3Q6IG51bGwsXG4gICAgICBpY29uOiBudWxsXG4gICAgfSwgdGhpcy5jb25maXJtYXRpb25TdGF0ZSA9IG51bGwsIHRoaXMucmVtb3ZlU3BlY2lhbEZvY3VzQmVoYXZpb3IgPSAoKSA9PiB7XG4gICAgICB2YXIgbztcbiAgICAgIChvID0gdGhpcy5ub2Rlcy5yb290KSA9PSBudWxsIHx8IG8uY2xhc3NMaXN0LnJlbW92ZShMLm5vRm9jdXMpO1xuICAgIH0sIHRoaXMucmVtb3ZlU3BlY2lhbEhvdmVyQmVoYXZpb3IgPSAoKSA9PiB7XG4gICAgICB2YXIgbztcbiAgICAgIChvID0gdGhpcy5ub2Rlcy5yb290KSA9PSBudWxsIHx8IG8uY2xhc3NMaXN0LnJlbW92ZShMLm5vSG92ZXIpO1xuICAgIH0sIHRoaXMub25FcnJvckFuaW1hdGlvbkVuZCA9ICgpID0+IHtcbiAgICAgIHZhciBvLCBpO1xuICAgICAgKG8gPSB0aGlzLm5vZGVzLmljb24pID09IG51bGwgfHwgby5jbGFzc0xpc3QucmVtb3ZlKEwud29iYmxlQW5pbWF0aW9uKSwgKGkgPSB0aGlzLm5vZGVzLmljb24pID09IG51bGwgfHwgaS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsIHRoaXMub25FcnJvckFuaW1hdGlvbkVuZCk7XG4gICAgfSwgdGhpcy5ub2Rlcy5yb290ID0gdGhpcy5tYWtlKGUsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIGl0ZW0gaXMgZGlzYWJsZWQgYW5kIGhlbmNlIG5vdCBjbGlja2FibGVcbiAgICovXG4gIGdldCBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmFtcy5pc0Rpc2FibGVkID09PSAhMDtcbiAgfVxuICAvKipcbiAgICogRXhwb3NlcyBwb3BvdmVyIGl0ZW0gdG9nZ2xlIHBhcmFtZXRlclxuICAgKi9cbiAgZ2V0IHRvZ2dsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXMudG9nZ2xlO1xuICB9XG4gIC8qKlxuICAgKiBJdGVtIHRpdGxlXG4gICAqL1xuICBnZXQgdGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zLnRpdGxlO1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIGNvbmZpcm1hdGlvbiBzdGF0ZSBpcyBlbmFibGVkIGZvciBwb3BvdmVyIGl0ZW1cbiAgICovXG4gIGdldCBpc0NvbmZpcm1hdGlvblN0YXRlRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maXJtYXRpb25TdGF0ZSAhPT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSBpZiBpdGVtIGlzIGZvY3VzZWQgaW4ga2V5Ym9hcmQgbmF2aWdhdGlvbiBwcm9jZXNzXG4gICAqL1xuICBnZXQgaXNGb2N1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnJvb3QgPT09IG51bGwgPyAhMSA6IHRoaXMubm9kZXMucm9vdC5jbGFzc0xpc3QuY29udGFpbnMoTC5mb2N1c2VkKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwb3BvdmVyIGl0ZW0gcm9vdCBlbGVtZW50XG4gICAqL1xuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnJvb3Q7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCBvbiBwb3BvdmVyIGl0ZW0gY2xpY2tcbiAgICovXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIGlmICh0aGlzLmlzQ29uZmlybWF0aW9uU3RhdGVFbmFibGVkICYmIHRoaXMuY29uZmlybWF0aW9uU3RhdGUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuYWN0aXZhdGVPckVuYWJsZUNvbmZpcm1hdGlvbk1vZGUodGhpcy5jb25maXJtYXRpb25TdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYWN0aXZhdGVPckVuYWJsZUNvbmZpcm1hdGlvbk1vZGUodGhpcy5wYXJhbXMpO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGVzIGl0ZW0gYWN0aXZlIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSBpc0FjdGl2ZSAtIHRydWUgaWYgaXRlbSBzaG91bGQgc3RyaWN0bHkgc2hvdWxkIGJlY29tZSBhY3RpdmVcbiAgICovXG4gIHRvZ2dsZUFjdGl2ZShlKSB7XG4gICAgdmFyIHQ7XG4gICAgKHQgPSB0aGlzLm5vZGVzLnJvb3QpID09IG51bGwgfHwgdC5jbGFzc0xpc3QudG9nZ2xlKEwuYWN0aXZlLCBlKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlcyBpdGVtIGhpZGRlbiBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gaXNIaWRkZW4gLSB0cnVlIGlmIGl0ZW0gc2hvdWxkIGJlIGhpZGRlblxuICAgKi9cbiAgdG9nZ2xlSGlkZGVuKGUpIHtcbiAgICB2YXIgdDtcbiAgICAodCA9IHRoaXMubm9kZXMucm9vdCkgPT0gbnVsbCB8fCB0LmNsYXNzTGlzdC50b2dnbGUoTC5oaWRkZW4sIGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgcG9wb3ZlciBpdGVtIHRvIGl0cyBvcmlnaW5hbCBzdGF0ZVxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5pc0NvbmZpcm1hdGlvblN0YXRlRW5hYmxlZCAmJiB0aGlzLmRpc2FibGVDb25maXJtYXRpb25Nb2RlKCk7XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZCBjYWxsZWQgb25jZSBpdGVtIGJlY29tZXMgZm9jdXNlZCBkdXJpbmcga2V5Ym9hcmQgbmF2aWdhdGlvblxuICAgKi9cbiAgb25Gb2N1cygpIHtcbiAgICB0aGlzLmRpc2FibGVTcGVjaWFsSG92ZXJBbmRGb2N1c0JlaGF2aW9yKCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgSFRNTCBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gcG9wb3ZlciBpdGVtIHBhcmFtc1xuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gaXRlbSBjb25zdHJ1Y3Rpb24gcGFyYW1zXG4gICAqIEBwYXJhbSByZW5kZXJQYXJhbXMgLSBwb3BvdmVyIGl0ZW0gcmVuZGVyIHBhcmFtc1xuICAgKi9cbiAgbWFrZShlLCB0KSB7XG4gICAgdmFyIHMsIHI7XG4gICAgY29uc3QgbyA9ICh0ID09IG51bGwgPyB2b2lkIDAgOiB0LndyYXBwZXJUYWcpIHx8IFwiZGl2XCIsIGkgPSBkLm1ha2UobywgTC5jb250YWluZXIsIHtcbiAgICAgIHR5cGU6IG8gPT09IFwiYnV0dG9uXCIgPyBcImJ1dHRvblwiIDogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIGUubmFtZSAmJiAoaS5kYXRhc2V0Lml0ZW1OYW1lID0gZS5uYW1lKSwgdGhpcy5ub2Rlcy5pY29uID0gZC5tYWtlKFwiZGl2XCIsIFtMLmljb24sIEwuaWNvblRvb2xdLCB7XG4gICAgICBpbm5lckhUTUw6IGUuaWNvbiB8fCBRaVxuICAgIH0pLCBpLmFwcGVuZENoaWxkKHRoaXMubm9kZXMuaWNvbiksIGUudGl0bGUgIT09IHZvaWQgMCAmJiBpLmFwcGVuZENoaWxkKGQubWFrZShcImRpdlwiLCBMLnRpdGxlLCB7XG4gICAgICBpbm5lckhUTUw6IGUudGl0bGUgfHwgXCJcIlxuICAgIH0pKSwgZS5zZWNvbmRhcnlMYWJlbCAmJiBpLmFwcGVuZENoaWxkKGQubWFrZShcImRpdlwiLCBMLnNlY29uZGFyeVRpdGxlLCB7XG4gICAgICB0ZXh0Q29udGVudDogZS5zZWNvbmRhcnlMYWJlbFxuICAgIH0pKSwgdGhpcy5oYXNDaGlsZHJlbiAmJiBpLmFwcGVuZENoaWxkKGQubWFrZShcImRpdlwiLCBbTC5pY29uLCBMLmljb25DaGV2cm9uUmlnaHRdLCB7XG4gICAgICBpbm5lckhUTUw6IHFpXG4gICAgfSkpLCB0aGlzLmlzQWN0aXZlICYmIGkuY2xhc3NMaXN0LmFkZChMLmFjdGl2ZSksIGUuaXNEaXNhYmxlZCAmJiBpLmNsYXNzTGlzdC5hZGQoTC5kaXNhYmxlZCksIGUuaGludCAhPT0gdm9pZCAwICYmICgocyA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuaGludCkgPT0gbnVsbCA/IHZvaWQgMCA6IHMuZW5hYmxlZCkgIT09ICExICYmIHRoaXMuYWRkSGludChpLCB7XG4gICAgICAuLi5lLmhpbnQsXG4gICAgICBwb3NpdGlvbjogKChyID0gdCA9PSBudWxsID8gdm9pZCAwIDogdC5oaW50KSA9PSBudWxsID8gdm9pZCAwIDogci5wb3NpdGlvbikgfHwgXCJyaWdodFwiXG4gICAgfSksIGk7XG4gIH1cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyBjb25maXJtYXRpb24gbW9kZSBmb3IgdGhlIGl0ZW0uXG4gICAqXG4gICAqIEBwYXJhbSBuZXdTdGF0ZSAtIG5ldyBwb3BvdmVyIGl0ZW0gcGFyYW1zIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWRcbiAgICovXG4gIGVuYWJsZUNvbmZpcm1hdGlvbk1vZGUoZSkge1xuICAgIGlmICh0aGlzLm5vZGVzLnJvb3QgPT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIC4uLnRoaXMucGFyYW1zLFxuICAgICAgLi4uZSxcbiAgICAgIGNvbmZpcm1hdGlvbjogXCJjb25maXJtYXRpb25cIiBpbiBlID8gZS5jb25maXJtYXRpb24gOiB2b2lkIDBcbiAgICB9LCBvID0gdGhpcy5tYWtlKHQpO1xuICAgIHRoaXMubm9kZXMucm9vdC5pbm5lckhUTUwgPSBvLmlubmVySFRNTCwgdGhpcy5ub2Rlcy5yb290LmNsYXNzTGlzdC5hZGQoTC5jb25maXJtYXRpb25TdGF0ZSksIHRoaXMuY29uZmlybWF0aW9uU3RhdGUgPSBlLCB0aGlzLmVuYWJsZVNwZWNpYWxIb3ZlckFuZEZvY3VzQmVoYXZpb3IoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBpdGVtIHRvIGl0cyBvcmlnaW5hbCBzdGF0ZVxuICAgKi9cbiAgZGlzYWJsZUNvbmZpcm1hdGlvbk1vZGUoKSB7XG4gICAgaWYgKHRoaXMubm9kZXMucm9vdCA9PT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5tYWtlKHRoaXMucGFyYW1zKTtcbiAgICB0aGlzLm5vZGVzLnJvb3QuaW5uZXJIVE1MID0gZS5pbm5lckhUTUwsIHRoaXMubm9kZXMucm9vdC5jbGFzc0xpc3QucmVtb3ZlKEwuY29uZmlybWF0aW9uU3RhdGUpLCB0aGlzLmNvbmZpcm1hdGlvblN0YXRlID0gbnVsbCwgdGhpcy5kaXNhYmxlU3BlY2lhbEhvdmVyQW5kRm9jdXNCZWhhdmlvcigpO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIHNwZWNpYWwgZm9jdXMgYW5kIGhvdmVyIGJlaGF2aW9yIGZvciBpdGVtIGluIGNvbmZpcm1hdGlvbiBzdGF0ZS5cbiAgICogVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudCBpdGVtIGZyb20gYmVpbmcgaGlnaGxpZ2h0ZWQgYXMgaG92ZXJlZC9mb2N1c2VkIGp1c3QgYWZ0ZXIgY2xpY2suXG4gICAqL1xuICBlbmFibGVTcGVjaWFsSG92ZXJBbmRGb2N1c0JlaGF2aW9yKCkge1xuICAgIHZhciBlLCB0LCBvO1xuICAgIChlID0gdGhpcy5ub2Rlcy5yb290KSA9PSBudWxsIHx8IGUuY2xhc3NMaXN0LmFkZChMLm5vSG92ZXIpLCAodCA9IHRoaXMubm9kZXMucm9vdCkgPT0gbnVsbCB8fCB0LmNsYXNzTGlzdC5hZGQoTC5ub0ZvY3VzKSwgKG8gPSB0aGlzLm5vZGVzLnJvb3QpID09IG51bGwgfHwgby5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLnJlbW92ZVNwZWNpYWxIb3ZlckJlaGF2aW9yLCB7IG9uY2U6ICEwIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEaXNhYmxlcyBzcGVjaWFsIGZvY3VzIGFuZCBob3ZlciBiZWhhdmlvclxuICAgKi9cbiAgZGlzYWJsZVNwZWNpYWxIb3ZlckFuZEZvY3VzQmVoYXZpb3IoKSB7XG4gICAgdmFyIGU7XG4gICAgdGhpcy5yZW1vdmVTcGVjaWFsRm9jdXNCZWhhdmlvcigpLCB0aGlzLnJlbW92ZVNwZWNpYWxIb3ZlckJlaGF2aW9yKCksIChlID0gdGhpcy5ub2Rlcy5yb290KSA9PSBudWxsIHx8IGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5yZW1vdmVTcGVjaWFsSG92ZXJCZWhhdmlvcik7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGl0ZW0ncyBvbkFjdGl2YXRlIGNhbGxiYWNrIGlmIHRoZSBpdGVtIGhhcyBubyBjb25maXJtYXRpb24gY29uZmlndXJlZFxuICAgKlxuICAgKiBAcGFyYW0gaXRlbSAtIGl0ZW0gdG8gYWN0aXZhdGUgb3IgYnJpbmcgdG8gY29uZmlybWF0aW9uIG1vZGVcbiAgICovXG4gIGFjdGl2YXRlT3JFbmFibGVDb25maXJtYXRpb25Nb2RlKGUpIHtcbiAgICB2YXIgdDtcbiAgICBpZiAoIShcImNvbmZpcm1hdGlvblwiIGluIGUpIHx8IGUuY29uZmlybWF0aW9uID09PSB2b2lkIDApXG4gICAgICB0cnkge1xuICAgICAgICAodCA9IGUub25BY3RpdmF0ZSkgPT0gbnVsbCB8fCB0LmNhbGwoZSwgZSksIHRoaXMuZGlzYWJsZUNvbmZpcm1hdGlvbk1vZGUoKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICB0aGlzLmFuaW1hdGVFcnJvcigpO1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIHRoaXMuZW5hYmxlQ29uZmlybWF0aW9uTW9kZShlLmNvbmZpcm1hdGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIEFuaW1hdGVzIGl0ZW0gd2hpY2ggc3ltYm9saXplcyB0aGF0IGVycm9yIG9jY3VyZWQgd2hpbGUgZXhlY3V0aW5nICdvbkFjdGl2YXRlKCknIGNhbGxiYWNrXG4gICAqL1xuICBhbmltYXRlRXJyb3IoKSB7XG4gICAgdmFyIGUsIHQsIG87XG4gICAgKGUgPSB0aGlzLm5vZGVzLmljb24pICE9IG51bGwgJiYgZS5jbGFzc0xpc3QuY29udGFpbnMoTC53b2JibGVBbmltYXRpb24pIHx8ICgodCA9IHRoaXMubm9kZXMuaWNvbikgPT0gbnVsbCB8fCB0LmNsYXNzTGlzdC5hZGQoTC53b2JibGVBbmltYXRpb24pLCAobyA9IHRoaXMubm9kZXMuaWNvbikgPT0gbnVsbCB8fCBvLmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgdGhpcy5vbkVycm9yQW5pbWF0aW9uRW5kKSk7XG4gIH1cbn1cbmNvbnN0IG50ID0gbmUoXCJjZS1wb3BvdmVyLWl0ZW0tc2VwYXJhdG9yXCIpLCBpdCA9IHtcbiAgY29udGFpbmVyOiBudCgpLFxuICBsaW5lOiBudChcImxpbmVcIiksXG4gIGhpZGRlbjogbnQobnVsbCwgXCJoaWRkZW5cIilcbn07XG5jbGFzcyBRbyBleHRlbmRzIHh0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgdGhlIGluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpLCB0aGlzLm5vZGVzID0ge1xuICAgICAgcm9vdDogZC5tYWtlKFwiZGl2XCIsIGl0LmNvbnRhaW5lciksXG4gICAgICBsaW5lOiBkLm1ha2UoXCJkaXZcIiwgaXQubGluZSlcbiAgICB9LCB0aGlzLm5vZGVzLnJvb3QuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5saW5lKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwb3BvdmVyIHNlcGFyYXRvciByb290IGVsZW1lbnRcbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMucm9vdDtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlcyBpdGVtIGhpZGRlbiBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gaXNIaWRkZW4gLSB0cnVlIGlmIGl0ZW0gc2hvdWxkIGJlIGhpZGRlblxuICAgKi9cbiAgdG9nZ2xlSGlkZGVuKGUpIHtcbiAgICB2YXIgdDtcbiAgICAodCA9IHRoaXMubm9kZXMucm9vdCkgPT0gbnVsbCB8fCB0LmNsYXNzTGlzdC50b2dnbGUoaXQuaGlkZGVuLCBlKTtcbiAgfVxufVxudmFyIEcgPSAvKiBAX19QVVJFX18gKi8gKChuKSA9PiAobi5DbG9zZWQgPSBcImNsb3NlZFwiLCBuLkNsb3NlZE9uQWN0aXZhdGUgPSBcImNsb3NlZC1vbi1hY3RpdmF0ZVwiLCBuKSkoRyB8fCB7fSk7XG5jb25zdCAkID0gbmUoXCJjZS1wb3BvdmVyXCIpLCBQID0ge1xuICBwb3BvdmVyOiAkKCksXG4gIHBvcG92ZXJDb250YWluZXI6ICQoXCJjb250YWluZXJcIiksXG4gIHBvcG92ZXJPcGVuVG9wOiAkKG51bGwsIFwib3Blbi10b3BcIiksXG4gIHBvcG92ZXJPcGVuTGVmdDogJChudWxsLCBcIm9wZW4tbGVmdFwiKSxcbiAgcG9wb3Zlck9wZW5lZDogJChudWxsLCBcIm9wZW5lZFwiKSxcbiAgc2VhcmNoOiAkKFwic2VhcmNoXCIpLFxuICBub3RoaW5nRm91bmRNZXNzYWdlOiAkKFwibm90aGluZy1mb3VuZC1tZXNzYWdlXCIpLFxuICBub3RoaW5nRm91bmRNZXNzYWdlRGlzcGxheWVkOiAkKFwibm90aGluZy1mb3VuZC1tZXNzYWdlXCIsIFwiZGlzcGxheWVkXCIpLFxuICBpdGVtczogJChcIml0ZW1zXCIpLFxuICBvdmVybGF5OiAkKFwib3ZlcmxheVwiKSxcbiAgb3ZlcmxheUhpZGRlbjogJChcIm92ZXJsYXlcIiwgXCJoaWRkZW5cIiksXG4gIHBvcG92ZXJOZXN0ZWQ6ICQobnVsbCwgXCJuZXN0ZWRcIiksXG4gIGdldFBvcG92ZXJOZXN0ZWRDbGFzczogKG4pID0+ICQobnVsbCwgYG5lc3RlZC1sZXZlbC0ke24udG9TdHJpbmcoKX1gKSxcbiAgcG9wb3ZlcklubGluZTogJChudWxsLCBcImlubGluZVwiKSxcbiAgcG9wb3ZlckhlYWRlcjogJChcImhlYWRlclwiKVxufTtcbnZhciBmZSA9IC8qIEBfX1BVUkVfXyAqLyAoKG4pID0+IChuLk5lc3RpbmdMZXZlbCA9IFwiLS1uZXN0aW5nLWxldmVsXCIsIG4uUG9wb3ZlckhlaWdodCA9IFwiLS1wb3BvdmVyLWhlaWdodFwiLCBuLklubGluZVBvcG92ZXJXaWR0aCA9IFwiLS1pbmxpbmUtcG9wb3Zlci13aWR0aFwiLCBuLlRyaWdnZXJJdGVtTGVmdCA9IFwiLS10cmlnZ2VyLWl0ZW0tbGVmdFwiLCBuLlRyaWdnZXJJdGVtVG9wID0gXCItLXRyaWdnZXItaXRlbS10b3BcIiwgbikpKGZlIHx8IHt9KTtcbmNvbnN0IFRvID0gbmUoXCJjZS1wb3BvdmVyLWl0ZW0taHRtbFwiKSwgU28gPSB7XG4gIHJvb3Q6IFRvKCksXG4gIGhpZGRlbjogVG8obnVsbCwgXCJoaWRkZW5cIilcbn07XG5jbGFzcyBTZSBleHRlbmRzIHh0IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgdGhlIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMg4oCTIGluc3RhbmNlIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHJlbmRlclBhcmFtcyDigJMgcG9wb3ZlciBpdGVtIHJlbmRlciBwYXJhbXMuXG4gICAqIFRoZSBwYXJhbWV0ZXJzIHRoYXQgYXJlIG5vdCBzZXQgYnkgdXNlciB2aWEgcG9wb3ZlciBhcGkgYnV0IHJhdGhlciBkZXBlbmQgb24gdGVjaG5pY2FsIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgdmFyIG8sIGk7XG4gICAgc3VwZXIoZSksIHRoaXMubm9kZXMgPSB7XG4gICAgICByb290OiBkLm1ha2UoXCJkaXZcIiwgU28ucm9vdClcbiAgICB9LCB0aGlzLm5vZGVzLnJvb3QuYXBwZW5kQ2hpbGQoZS5lbGVtZW50KSwgZS5uYW1lICYmICh0aGlzLm5vZGVzLnJvb3QuZGF0YXNldC5pdGVtTmFtZSA9IGUubmFtZSksIGUuaGludCAhPT0gdm9pZCAwICYmICgobyA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuaGludCkgPT0gbnVsbCA/IHZvaWQgMCA6IG8uZW5hYmxlZCkgIT09ICExICYmIHRoaXMuYWRkSGludCh0aGlzLm5vZGVzLnJvb3QsIHtcbiAgICAgIC4uLmUuaGludCxcbiAgICAgIHBvc2l0aW9uOiAoKGkgPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmhpbnQpID09IG51bGwgPyB2b2lkIDAgOiBpLnBvc2l0aW9uKSB8fCBcInJpZ2h0XCJcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwb3BvdmVyIGl0ZW0gcm9vdCBlbGVtZW50XG4gICAqL1xuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnJvb3Q7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZXMgaXRlbSBoaWRkZW4gc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIGlzSGlkZGVuIC0gdHJ1ZSBpZiBpdGVtIHNob3VsZCBiZSBoaWRkZW5cbiAgICovXG4gIHRvZ2dsZUhpZGRlbihlKSB7XG4gICAgdmFyIHQ7XG4gICAgKHQgPSB0aGlzLm5vZGVzLnJvb3QpID09IG51bGwgfHwgdC5jbGFzc0xpc3QudG9nZ2xlKFNvLmhpZGRlbiwgZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgbGlzdCBvZiBidXR0b25zIGFuZCBpbnB1dHMgaW5zaWRlIGN1c3RvbSBjb250ZW50XG4gICAqL1xuICBnZXRDb250cm9scygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5ub2Rlcy5yb290LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICBgYnV0dG9uLCAke2QuYWxsSW5wdXRzU2VsZWN0b3J9YFxuICAgICk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZSk7XG4gIH1cbn1cbmNsYXNzIEpvIGV4dGVuZHMgT2Uge1xuICAvKipcbiAgICogQ29uc3RydWN0cyB0aGUgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIHBvcG92ZXIgY29uc3RydWN0aW9uIHBhcmFtc1xuICAgKiBAcGFyYW0gaXRlbXNSZW5kZXJQYXJhbXMgLSBwb3BvdmVyIGl0ZW0gcmVuZGVyIHBhcmFtcy5cbiAgICogVGhlIHBhcmFtZXRlcnMgdGhhdCBhcmUgbm90IHNldCBieSB1c2VyIHZpYSBwb3BvdmVyIGFwaSBidXQgcmF0aGVyIGRlcGVuZCBvbiB0ZWNobmljYWwgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQgPSB7fSkge1xuICAgIHN1cGVyKCksIHRoaXMucGFyYW1zID0gZSwgdGhpcy5pdGVtc1JlbmRlclBhcmFtcyA9IHQsIHRoaXMubGlzdGVuZXJzID0gbmV3IF9lKCksIHRoaXMubWVzc2FnZXMgPSB7XG4gICAgICBub3RoaW5nRm91bmQ6IFwiTm90aGluZyBmb3VuZFwiLFxuICAgICAgc2VhcmNoOiBcIlNlYXJjaFwiXG4gICAgfSwgdGhpcy5pdGVtcyA9IHRoaXMuYnVpbGRJdGVtcyhlLml0ZW1zKSwgZS5tZXNzYWdlcyAmJiAodGhpcy5tZXNzYWdlcyA9IHtcbiAgICAgIC4uLnRoaXMubWVzc2FnZXMsXG4gICAgICAuLi5lLm1lc3NhZ2VzXG4gICAgfSksIHRoaXMubm9kZXMgPSB7fSwgdGhpcy5ub2Rlcy5wb3BvdmVyQ29udGFpbmVyID0gZC5tYWtlKFwiZGl2XCIsIFtQLnBvcG92ZXJDb250YWluZXJdKSwgdGhpcy5ub2Rlcy5ub3RoaW5nRm91bmRNZXNzYWdlID0gZC5tYWtlKFwiZGl2XCIsIFtQLm5vdGhpbmdGb3VuZE1lc3NhZ2VdLCB7XG4gICAgICB0ZXh0Q29udGVudDogdGhpcy5tZXNzYWdlcy5ub3RoaW5nRm91bmRcbiAgICB9KSwgdGhpcy5ub2Rlcy5wb3BvdmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubm9kZXMubm90aGluZ0ZvdW5kTWVzc2FnZSksIHRoaXMubm9kZXMuaXRlbXMgPSBkLm1ha2UoXCJkaXZcIiwgW1AuaXRlbXNdKSwgdGhpcy5pdGVtcy5mb3JFYWNoKChvKSA9PiB7XG4gICAgICBjb25zdCBpID0gby5nZXRFbGVtZW50KCk7XG4gICAgICBpICE9PSBudWxsICYmIHRoaXMubm9kZXMuaXRlbXMuYXBwZW5kQ2hpbGQoaSk7XG4gICAgfSksIHRoaXMubm9kZXMucG9wb3ZlckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLml0ZW1zKSwgdGhpcy5saXN0ZW5lcnMub24odGhpcy5ub2Rlcy5wb3BvdmVyQ29udGFpbmVyLCBcImNsaWNrXCIsIChvKSA9PiB0aGlzLmhhbmRsZUNsaWNrKG8pKSwgdGhpcy5ub2Rlcy5wb3BvdmVyID0gZC5tYWtlKFwiZGl2XCIsIFtcbiAgICAgIFAucG9wb3ZlcixcbiAgICAgIHRoaXMucGFyYW1zLmNsYXNzXG4gICAgXSksIHRoaXMubm9kZXMucG9wb3Zlci5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLnBvcG92ZXJDb250YWluZXIpO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0IG9mIGRlZmF1bHQgcG9wb3ZlciBpdGVtcyB0aGF0IGFyZSBzZWFyY2hhYmxlIGFuZCBtYXkgaGF2ZSBjb25maXJtYXRpb24gc3RhdGVcbiAgICovXG4gIGdldCBpdGVtc0RlZmF1bHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMuZmlsdGVyKChlKSA9PiBlIGluc3RhbmNlb2YgcmUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEhUTUwgZWxlbWVudCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwb3BvdmVyXG4gICAqL1xuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnBvcG92ZXI7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW4gcG9wb3ZlclxuICAgKi9cbiAgc2hvdygpIHtcbiAgICB0aGlzLm5vZGVzLnBvcG92ZXIuY2xhc3NMaXN0LmFkZChQLnBvcG92ZXJPcGVuZWQpLCB0aGlzLnNlYXJjaCAhPT0gdm9pZCAwICYmIHRoaXMuc2VhcmNoLmZvY3VzKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyBwb3BvdmVyXG4gICAqL1xuICBoaWRlKCkge1xuICAgIHRoaXMubm9kZXMucG9wb3Zlci5jbGFzc0xpc3QucmVtb3ZlKFAucG9wb3Zlck9wZW5lZCksIHRoaXMubm9kZXMucG9wb3Zlci5jbGFzc0xpc3QucmVtb3ZlKFAucG9wb3Zlck9wZW5Ub3ApLCB0aGlzLml0ZW1zRGVmYXVsdC5mb3JFYWNoKChlKSA9PiBlLnJlc2V0KCkpLCB0aGlzLnNlYXJjaCAhPT0gdm9pZCAwICYmIHRoaXMuc2VhcmNoLmNsZWFyKCksIHRoaXMuZW1pdChHLkNsb3NlZCk7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFycyBtZW1vcnlcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdmFyIGU7XG4gICAgdGhpcy5pdGVtcy5mb3JFYWNoKCh0KSA9PiB0LmRlc3Ryb3koKSksIHRoaXMubm9kZXMucG9wb3Zlci5yZW1vdmUoKSwgdGhpcy5saXN0ZW5lcnMucmVtb3ZlQWxsKCksIChlID0gdGhpcy5zZWFyY2gpID09IG51bGwgfHwgZS5kZXN0cm95KCk7XG4gIH1cbiAgLyoqXG4gICAqIExvb2tzIGZvciB0aGUgaXRlbSBieSBuYW1lIGFuZCBpbWl0YXRlcyBjbGljayBvbiBpdFxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIG5hbWUgb2YgdGhlIGl0ZW0gdG8gYWN0aXZhdGVcbiAgICovXG4gIGFjdGl2YXRlSXRlbUJ5TmFtZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuaXRlbXMuZmluZCgobykgPT4gby5uYW1lID09PSBlKTtcbiAgICB0aGlzLmhhbmRsZUl0ZW1DbGljayh0KTtcbiAgfVxuICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIHBvcG92ZXIgaXRlbXNcbiAgICpcbiAgICogQHBhcmFtIGl0ZW1zIC0gbGlzdCBvZiBpdGVtcyBwYXJhbXNcbiAgICovXG4gIGJ1aWxkSXRlbXMoZSkge1xuICAgIHJldHVybiBlLm1hcCgodCkgPT4ge1xuICAgICAgc3dpdGNoICh0LnR5cGUpIHtcbiAgICAgICAgY2FzZSBfLlNlcGFyYXRvcjpcbiAgICAgICAgICByZXR1cm4gbmV3IFFvKCk7XG4gICAgICAgIGNhc2UgXy5IdG1sOlxuICAgICAgICAgIHJldHVybiBuZXcgU2UodCwgdGhpcy5pdGVtc1JlbmRlclBhcmFtc1tfLkh0bWxdKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbmV3IHJlKHQsIHRoaXMuaXRlbXNSZW5kZXJQYXJhbXNbXy5EZWZhdWx0XSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBwb3BvdmVyIGl0ZW0gdGhhdCBpcyB0aGUgdGFyZ2V0IG9mIHRoZSBzcGVjaWZpZWQgZXZlbnRcbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gZXZlbnQgdG8gcmV0cmlldmUgcG9wb3ZlciBpdGVtIGZyb21cbiAgICovXG4gIGdldFRhcmdldEl0ZW0oZSkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbHRlcigodCkgPT4gdCBpbnN0YW5jZW9mIHJlIHx8IHQgaW5zdGFuY2VvZiBTZSkuZmluZCgodCkgPT4ge1xuICAgICAgY29uc3QgbyA9IHQuZ2V0RWxlbWVudCgpO1xuICAgICAgcmV0dXJuIG8gPT09IG51bGwgPyAhMSA6IGUuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMobyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgcG9wb3ZlciBpdGVtIGNsaWNrXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtIC0gaXRlbSB0byBoYW5kbGUgY2xpY2sgb2ZcbiAgICovXG4gIGhhbmRsZUl0ZW1DbGljayhlKSB7XG4gICAgaWYgKCEoXCJpc0Rpc2FibGVkXCIgaW4gZSAmJiBlLmlzRGlzYWJsZWQpKSB7XG4gICAgICBpZiAoZS5oYXNDaGlsZHJlbikge1xuICAgICAgICB0aGlzLnNob3dOZXN0ZWRJdGVtcyhlKSwgXCJoYW5kbGVDbGlja1wiIGluIGUgJiYgdHlwZW9mIGUuaGFuZGxlQ2xpY2sgPT0gXCJmdW5jdGlvblwiICYmIGUuaGFuZGxlQ2xpY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5pdGVtc0RlZmF1bHQuZmlsdGVyKCh0KSA9PiB0ICE9PSBlKS5mb3JFYWNoKCh0KSA9PiB0LnJlc2V0KCkpLCBcImhhbmRsZUNsaWNrXCIgaW4gZSAmJiB0eXBlb2YgZS5oYW5kbGVDbGljayA9PSBcImZ1bmN0aW9uXCIgJiYgZS5oYW5kbGVDbGljaygpLCB0aGlzLnRvZ2dsZUl0ZW1BY3RpdmVuZXNzSWZOZWVkZWQoZSksIGUuY2xvc2VPbkFjdGl2YXRlICYmICh0aGlzLmhpZGUoKSwgdGhpcy5lbWl0KEcuQ2xvc2VkT25BY3RpdmF0ZSkpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBjbGlja3MgaW5zaWRlIHBvcG92ZXJcbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gaXRlbSB0byBoYW5kbGUgY2xpY2sgb2ZcbiAgICovXG4gIGhhbmRsZUNsaWNrKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRUYXJnZXRJdGVtKGUpO1xuICAgIHQgIT09IHZvaWQgMCAmJiB0aGlzLmhhbmRsZUl0ZW1DbGljayh0KTtcbiAgfVxuICAvKipcbiAgICogLSBUb2dnbGVzIGl0ZW0gYWN0aXZlIHN0YXRlLCBpZiBjbGlja2VkIHBvcG92ZXIgaXRlbSBoYXMgcHJvcGVydHkgJ3RvZ2dsZScgc2V0IHRvIHRydWUuXG4gICAqXG4gICAqIC0gUGVyZm9ybXMgcmFkaW9idXR0b24tbGlrZSBiZWhhdmlvciBpZiB0aGUgaXRlbSBoYXMgcHJvcGVydHkgJ3RvZ2dsZScgc2V0IHRvIHN0cmluZyBrZXkuXG4gICAqIChBbGwgdGhlIG90aGVyIGl0ZW1zIHdpdGggdGhlIHNhbWUga2V5IGdldCBpbmFjdGl2ZSwgYW5kIHRoZSBpdGVtIGdldHMgYWN0aXZlKVxuICAgKlxuICAgKiBAcGFyYW0gY2xpY2tlZEl0ZW0gLSBwb3BvdmVyIGl0ZW0gdGhhdCB3YXMgY2xpY2tlZFxuICAgKi9cbiAgdG9nZ2xlSXRlbUFjdGl2ZW5lc3NJZk5lZWRlZChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiByZSAmJiAoZS50b2dnbGUgPT09ICEwICYmIGUudG9nZ2xlQWN0aXZlKCksIHR5cGVvZiBlLnRvZ2dsZSA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgY29uc3QgdCA9IHRoaXMuaXRlbXNEZWZhdWx0LmZpbHRlcigobykgPT4gby50b2dnbGUgPT09IGUudG9nZ2xlKTtcbiAgICAgIGlmICh0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlLnRvZ2dsZUFjdGl2ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0LmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgby50b2dnbGVBY3RpdmUobyA9PT0gZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbnZhciBVZSA9IC8qIEBfX1BVUkVfXyAqLyAoKG4pID0+IChuLlNlYXJjaCA9IFwic2VhcmNoXCIsIG4pKShVZSB8fCB7fSk7XG5jb25zdCBzdCA9IG5lKFwiY2R4LXNlYXJjaC1maWVsZFwiKSwgcnQgPSB7XG4gIHdyYXBwZXI6IHN0KCksXG4gIGljb246IHN0KFwiaWNvblwiKSxcbiAgaW5wdXQ6IHN0KFwiaW5wdXRcIilcbn07XG5jbGFzcyBscyBleHRlbmRzIE9lIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gYXZhaWxhYmxlIGNvbmZpZ1xuICAgKiBAcGFyYW0gb3B0aW9ucy5pdGVtcyAtIHNlYXJjaGFibGUgaXRlbXMgbGlzdFxuICAgKiBAcGFyYW0gb3B0aW9ucy5wbGFjZWhvbGRlciAtIGlucHV0IHBsYWNlaG9sZGVyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGl0ZW1zOiBlLCBwbGFjZWhvbGRlcjogdCB9KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5saXN0ZW5lcnMgPSBuZXcgX2UoKSwgdGhpcy5pdGVtcyA9IGUsIHRoaXMud3JhcHBlciA9IGQubWFrZShcImRpdlwiLCBydC53cmFwcGVyKTtcbiAgICBjb25zdCBvID0gZC5tYWtlKFwiZGl2XCIsIHJ0Lmljb24sIHtcbiAgICAgIGlubmVySFRNTDogb3NcbiAgICB9KTtcbiAgICB0aGlzLmlucHV0ID0gZC5tYWtlKFwiaW5wdXRcIiwgcnQuaW5wdXQsIHtcbiAgICAgIHBsYWNlaG9sZGVyOiB0LFxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIHByZXZlbnQgZm9jdXNpbmcgb24gdGhlIGlucHV0IGJ5IFRhYiBrZXlcbiAgICAgICAqIChQb3BvdmVyIGluIHRoZSBUb29sYmFyIGxheXMgYmVsb3cgdGhlIGJsb2NrcyxcbiAgICAgICAqIHNvIFRhYiBpbiB0aGUgbGFzdCBibG9jayB3aWxsIGZvY3VzIHRoaXMgaGlkZGVuIGlucHV0IGlmIHRoaXMgcHJvcGVydHkgaXMgbm90IHNldClcbiAgICAgICAqL1xuICAgICAgdGFiSW5kZXg6IC0xXG4gICAgfSksIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZChvKSwgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuaW5wdXQpLCB0aGlzLmxpc3RlbmVycy5vbih0aGlzLmlucHV0LCBcImlucHV0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuc2VhcmNoUXVlcnkgPSB0aGlzLmlucHV0LnZhbHVlLCB0aGlzLmVtaXQoVWUuU2VhcmNoLCB7XG4gICAgICAgIHF1ZXJ5OiB0aGlzLnNlYXJjaFF1ZXJ5LFxuICAgICAgICBpdGVtczogdGhpcy5mb3VuZEl0ZW1zXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBzZWFyY2ggZmllbGQgZWxlbWVudFxuICAgKi9cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGZvY3VzIHRvIHRoZSBpbnB1dFxuICAgKi9cbiAgZm9jdXMoKSB7XG4gICAgdGhpcy5pbnB1dC5mb2N1cygpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgc2VhcmNoIHF1ZXJ5IGFuZCByZXN1bHRzXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLmlucHV0LnZhbHVlID0gXCJcIiwgdGhpcy5zZWFyY2hRdWVyeSA9IFwiXCIsIHRoaXMuZW1pdChVZS5TZWFyY2gsIHtcbiAgICAgIHF1ZXJ5OiBcIlwiLFxuICAgICAgaXRlbXM6IHRoaXMuZm91bmRJdGVtc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgbWVtb3J5XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMubGlzdGVuZXJzLnJlbW92ZUFsbCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGxpc3Qgb2YgZm91bmQgaXRlbXMgZm9yIHRoZSBjdXJyZW50IHNlYXJjaCBxdWVyeVxuICAgKi9cbiAgZ2V0IGZvdW5kSXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMuZmlsdGVyKChlKSA9PiB0aGlzLmNoZWNrSXRlbShlKSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbnRhaW5zIGxvZ2ljIGZvciBjaGVja2luZyB3aGV0aGVyIHBhc3NlZCBpdGVtIGNvbmZvcm1zIHRoZSBzZWFyY2ggcXVlcnlcbiAgICpcbiAgICogQHBhcmFtIGl0ZW0gLSBpdGVtIHRvIGJlIGNoZWNrZWRcbiAgICovXG4gIGNoZWNrSXRlbShlKSB7XG4gICAgdmFyIGksIHM7XG4gICAgY29uc3QgdCA9ICgoaSA9IGUudGl0bGUpID09IG51bGwgPyB2b2lkIDAgOiBpLnRvTG93ZXJDYXNlKCkpIHx8IFwiXCIsIG8gPSAocyA9IHRoaXMuc2VhcmNoUXVlcnkpID09IG51bGwgPyB2b2lkIDAgOiBzLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG8gIT09IHZvaWQgMCA/IHQuaW5jbHVkZXMobykgOiAhMTtcbiAgfVxufVxudmFyIGNzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIHVzID0gKG4sIGUsIHQsIG8pID0+IHtcbiAgZm9yICh2YXIgaSA9IG8gPiAxID8gdm9pZCAwIDogbyA/IGRzKGUsIHQpIDogZSwgcyA9IG4ubGVuZ3RoIC0gMSwgcjsgcyA+PSAwOyBzLS0pXG4gICAgKHIgPSBuW3NdKSAmJiAoaSA9IChvID8gcihlLCB0LCBpKSA6IHIoaSkpIHx8IGkpO1xuICByZXR1cm4gbyAmJiBpICYmIGNzKGUsIHQsIGkpLCBpO1xufTtcbmNvbnN0IGVuID0gY2xhc3MgdG4gZXh0ZW5kcyBKbyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgdGhlIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBwb3BvdmVyIHBhcmFtc1xuICAgKiBAcGFyYW0gaXRlbXNSZW5kZXJQYXJhbXMg4oCTwqBwb3BvdmVyIGl0ZW0gcmVuZGVyIHBhcmFtcy5cbiAgICogVGhlIHBhcmFtZXRlcnMgdGhhdCBhcmUgbm90IHNldCBieSB1c2VyIHZpYSBwb3BvdmVyIGFwaSBidXQgcmF0aGVyIGRlcGVuZCBvbiB0ZWNobmljYWwgaW1wbGVtZW50YXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihlLCB0KSwgdGhpcy5uZXN0aW5nTGV2ZWwgPSAwLCB0aGlzLm5lc3RlZFBvcG92ZXJUcmlnZ2VySXRlbSA9IG51bGwsIHRoaXMucHJldmlvdXNseUhvdmVyZWRJdGVtID0gbnVsbCwgdGhpcy5zY29wZUVsZW1lbnQgPSBkb2N1bWVudC5ib2R5LCB0aGlzLmhpZGUgPSAoKSA9PiB7XG4gICAgICB2YXIgbztcbiAgICAgIHN1cGVyLmhpZGUoKSwgdGhpcy5kZXN0cm95TmVzdGVkUG9wb3ZlcklmRXhpc3RzKCksIChvID0gdGhpcy5mbGlwcGVyKSA9PSBudWxsIHx8IG8uZGVhY3RpdmF0ZSgpLCB0aGlzLnByZXZpb3VzbHlIb3ZlcmVkSXRlbSA9IG51bGw7XG4gICAgfSwgdGhpcy5vbkZsaXAgPSAoKSA9PiB7XG4gICAgICBjb25zdCBvID0gdGhpcy5pdGVtc0RlZmF1bHQuZmluZCgoaSkgPT4gaS5pc0ZvY3VzZWQpO1xuICAgICAgbyA9PSBudWxsIHx8IG8ub25Gb2N1cygpO1xuICAgIH0sIHRoaXMub25TZWFyY2ggPSAobykgPT4ge1xuICAgICAgdmFyIGE7XG4gICAgICBjb25zdCBpID0gby5xdWVyeSA9PT0gXCJcIiwgcyA9IG8uaXRlbXMubGVuZ3RoID09PSAwO1xuICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChsKSA9PiB7XG4gICAgICAgIGxldCBjID0gITE7XG4gICAgICAgIGwgaW5zdGFuY2VvZiByZSA/IGMgPSAhby5pdGVtcy5pbmNsdWRlcyhsKSA6IChsIGluc3RhbmNlb2YgUW8gfHwgbCBpbnN0YW5jZW9mIFNlKSAmJiAoYyA9IHMgfHwgIWkpLCBsLnRvZ2dsZUhpZGRlbihjKTtcbiAgICAgIH0pLCB0aGlzLnRvZ2dsZU5vdGhpbmdGb3VuZE1lc3NhZ2Uocyk7XG4gICAgICBjb25zdCByID0gby5xdWVyeSA9PT0gXCJcIiA/IHRoaXMuZmxpcHBhYmxlRWxlbWVudHMgOiBvLml0ZW1zLm1hcCgobCkgPT4gbC5nZXRFbGVtZW50KCkpO1xuICAgICAgKGEgPSB0aGlzLmZsaXBwZXIpICE9IG51bGwgJiYgYS5pc0FjdGl2YXRlZCAmJiAodGhpcy5mbGlwcGVyLmRlYWN0aXZhdGUoKSwgdGhpcy5mbGlwcGVyLmFjdGl2YXRlKHIpKTtcbiAgICB9LCBlLm5lc3RpbmdMZXZlbCAhPT0gdm9pZCAwICYmICh0aGlzLm5lc3RpbmdMZXZlbCA9IGUubmVzdGluZ0xldmVsKSwgdGhpcy5uZXN0aW5nTGV2ZWwgPiAwICYmIHRoaXMubm9kZXMucG9wb3Zlci5jbGFzc0xpc3QuYWRkKFAucG9wb3Zlck5lc3RlZCksIGUuc2NvcGVFbGVtZW50ICE9PSB2b2lkIDAgJiYgKHRoaXMuc2NvcGVFbGVtZW50ID0gZS5zY29wZUVsZW1lbnQpLCB0aGlzLm5vZGVzLnBvcG92ZXJDb250YWluZXIgIT09IG51bGwgJiYgdGhpcy5saXN0ZW5lcnMub24odGhpcy5ub2Rlcy5wb3BvdmVyQ29udGFpbmVyLCBcIm1vdXNlb3ZlclwiLCAobykgPT4gdGhpcy5oYW5kbGVIb3ZlcihvKSksIGUuc2VhcmNoYWJsZSAmJiB0aGlzLmFkZFNlYXJjaCgpLCBlLmZsaXBwYWJsZSAhPT0gITEgJiYgKHRoaXMuZmxpcHBlciA9IG5ldyBjZSh7XG4gICAgICBpdGVtczogdGhpcy5mbGlwcGFibGVFbGVtZW50cyxcbiAgICAgIGZvY3VzZWRJdGVtQ2xhc3M6IEwuZm9jdXNlZCxcbiAgICAgIGFsbG93ZWRLZXlzOiBbXG4gICAgICAgIHkuVEFCLFxuICAgICAgICB5LlVQLFxuICAgICAgICB5LkRPV04sXG4gICAgICAgIHkuRU5URVJcbiAgICAgIF1cbiAgICB9KSwgdGhpcy5mbGlwcGVyLm9uRmxpcCh0aGlzLm9uRmxpcCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgc29tZSBpdGVtIGluc2lkZSBwb3BvdmVyIGlzIGZvY3VzZWRcbiAgICovXG4gIGhhc0ZvY3VzKCkge1xuICAgIHJldHVybiB0aGlzLmZsaXBwZXIgPT09IHZvaWQgMCA/ICExIDogdGhpcy5mbGlwcGVyLmhhc0ZvY3VzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNjcm9sbCBwb3NpdGlvbiBpbnNpZGUgaXRlbXMgY29udGFpbmVyIG9mIHRoZSBwb3BvdmVyXG4gICAqL1xuICBnZXQgc2Nyb2xsVG9wKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLml0ZW1zID09PSBudWxsID8gMCA6IHRoaXMubm9kZXMuaXRlbXMuc2Nyb2xsVG9wO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHZpc2libGUgZWxlbWVudCBvZmZzZXQgdG9wXG4gICAqL1xuICBnZXQgb2Zmc2V0VG9wKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnBvcG92ZXJDb250YWluZXIgPT09IG51bGwgPyAwIDogdGhpcy5ub2Rlcy5wb3BvdmVyQ29udGFpbmVyLm9mZnNldFRvcDtcbiAgfVxuICAvKipcbiAgICogT3BlbiBwb3BvdmVyXG4gICAqL1xuICBzaG93KCkge1xuICAgIHZhciBlO1xuICAgIHRoaXMubm9kZXMucG9wb3Zlci5zdHlsZS5zZXRQcm9wZXJ0eShmZS5Qb3BvdmVySGVpZ2h0LCB0aGlzLnNpemUuaGVpZ2h0ICsgXCJweFwiKSwgdGhpcy5zaG91bGRPcGVuQm90dG9tIHx8IHRoaXMubm9kZXMucG9wb3Zlci5jbGFzc0xpc3QuYWRkKFAucG9wb3Zlck9wZW5Ub3ApLCB0aGlzLnNob3VsZE9wZW5SaWdodCB8fCB0aGlzLm5vZGVzLnBvcG92ZXIuY2xhc3NMaXN0LmFkZChQLnBvcG92ZXJPcGVuTGVmdCksIHN1cGVyLnNob3coKSwgKGUgPSB0aGlzLmZsaXBwZXIpID09IG51bGwgfHwgZS5hY3RpdmF0ZSh0aGlzLmZsaXBwYWJsZUVsZW1lbnRzKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIG1lbW9yeVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmhpZGUoKSwgc3VwZXIuZGVzdHJveSgpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGRpc3BsYXlpbmcgbmVzdGVkIGl0ZW1zIGZvciB0aGUgaXRlbS5cbiAgICpcbiAgICogQHBhcmFtIGl0ZW0g4oCTIGl0ZW0gdG8gc2hvdyBuZXN0ZWQgcG9wb3ZlciBmb3JcbiAgICovXG4gIHNob3dOZXN0ZWRJdGVtcyhlKSB7XG4gICAgdGhpcy5uZXN0ZWRQb3BvdmVyICE9PSBudWxsICYmIHRoaXMubmVzdGVkUG9wb3ZlciAhPT0gdm9pZCAwIHx8ICh0aGlzLm5lc3RlZFBvcG92ZXJUcmlnZ2VySXRlbSA9IGUsIHRoaXMuc2hvd05lc3RlZFBvcG92ZXJGb3JJdGVtKGUpKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBob3ZlciBldmVudHMgaW5zaWRlIHBvcG92ZXIgaXRlbXMgY29udGFpbmVyXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIGhvdmVyIGV2ZW50IGRhdGFcbiAgICovXG4gIGhhbmRsZUhvdmVyKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRUYXJnZXRJdGVtKGUpO1xuICAgIHQgIT09IHZvaWQgMCAmJiB0aGlzLnByZXZpb3VzbHlIb3ZlcmVkSXRlbSAhPT0gdCAmJiAodGhpcy5kZXN0cm95TmVzdGVkUG9wb3ZlcklmRXhpc3RzKCksIHRoaXMucHJldmlvdXNseUhvdmVyZWRJdGVtID0gdCwgdC5oYXNDaGlsZHJlbiAmJiB0aGlzLnNob3dOZXN0ZWRQb3BvdmVyRm9ySXRlbSh0KSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgQ1NTIHZhcmlhYmxlIHdpdGggcG9zaXRpb24gb2YgaXRlbSBuZWFyIHdoaWNoIG5lc3RlZCBwb3BvdmVyIHNob3VsZCBiZSBkaXNwbGF5ZWQuXG4gICAqIElzIHVzZWQgZm9yIGNvcnJlY3QgcG9zaXRpb25pbmcgb2YgdGhlIG5lc3RlZCBwb3BvdmVyXG4gICAqXG4gICAqIEBwYXJhbSBuZXN0ZWRQb3BvdmVyRWwgLSBuZXN0ZWQgcG9wb3ZlciBlbGVtZW50XG4gICAqIEBwYXJhbSBpdGVtIOKAkyBpdGVtIG5lYXIgd2hpY2ggbmVzdGVkIHBvcG92ZXIgc2hvdWxkIGJlIGRpc3BsYXllZFxuICAgKi9cbiAgc2V0VHJpZ2dlckl0ZW1Qb3NpdGlvbihlLCB0KSB7XG4gICAgY29uc3QgbyA9IHQuZ2V0RWxlbWVudCgpLCBpID0gKG8gPyBvLm9mZnNldFRvcCA6IDApIC0gdGhpcy5zY3JvbGxUb3AsIHMgPSB0aGlzLm9mZnNldFRvcCArIGk7XG4gICAgZS5zdHlsZS5zZXRQcm9wZXJ0eShmZS5UcmlnZ2VySXRlbVRvcCwgcyArIFwicHhcIik7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGV4aXN0aW5nIG5lc3RlZCBwb3BvdmVyXG4gICAqL1xuICBkZXN0cm95TmVzdGVkUG9wb3ZlcklmRXhpc3RzKCkge1xuICAgIHZhciBlLCB0O1xuICAgIHRoaXMubmVzdGVkUG9wb3ZlciA9PT0gdm9pZCAwIHx8IHRoaXMubmVzdGVkUG9wb3ZlciA9PT0gbnVsbCB8fCAodGhpcy5uZXN0ZWRQb3BvdmVyLm9mZihHLkNsb3NlZE9uQWN0aXZhdGUsIHRoaXMuaGlkZSksIHRoaXMubmVzdGVkUG9wb3Zlci5oaWRlKCksIHRoaXMubmVzdGVkUG9wb3Zlci5kZXN0cm95KCksIHRoaXMubmVzdGVkUG9wb3Zlci5nZXRFbGVtZW50KCkucmVtb3ZlKCksIHRoaXMubmVzdGVkUG9wb3ZlciA9IG51bGwsIChlID0gdGhpcy5mbGlwcGVyKSA9PSBudWxsIHx8IGUuYWN0aXZhdGUodGhpcy5mbGlwcGFibGVFbGVtZW50cyksICh0ID0gdGhpcy5uZXN0ZWRQb3BvdmVyVHJpZ2dlckl0ZW0pID09IG51bGwgfHwgdC5vbkNoaWxkcmVuQ2xvc2UoKSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGRpc3BsYXlzIG5lc3RlZCBwb3BvdmVyIGZvciBzcGVjaWZpZWQgaXRlbS5cbiAgICogSXMgdXNlZCBvbmx5IG9uIGRlc2t0b3BcbiAgICpcbiAgICogQHBhcmFtIGl0ZW0gLSBpdGVtIHRvIGRpc3BsYXkgbmVzdGVkIHBvcG92ZXIgYnlcbiAgICovXG4gIHNob3dOZXN0ZWRQb3BvdmVyRm9ySXRlbShlKSB7XG4gICAgdmFyIG87XG4gICAgdGhpcy5uZXN0ZWRQb3BvdmVyID0gbmV3IHRuKHtcbiAgICAgIHNlYXJjaGFibGU6IGUuaXNDaGlsZHJlblNlYXJjaGFibGUsXG4gICAgICBpdGVtczogZS5jaGlsZHJlbixcbiAgICAgIG5lc3RpbmdMZXZlbDogdGhpcy5uZXN0aW5nTGV2ZWwgKyAxLFxuICAgICAgZmxpcHBhYmxlOiBlLmlzQ2hpbGRyZW5GbGlwcGFibGUsXG4gICAgICBtZXNzYWdlczogdGhpcy5tZXNzYWdlc1xuICAgIH0pLCBlLm9uQ2hpbGRyZW5PcGVuKCksIHRoaXMubmVzdGVkUG9wb3Zlci5vbihHLkNsb3NlZE9uQWN0aXZhdGUsIHRoaXMuaGlkZSk7XG4gICAgY29uc3QgdCA9IHRoaXMubmVzdGVkUG9wb3Zlci5nZXRFbGVtZW50KCk7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMucG9wb3Zlci5hcHBlbmRDaGlsZCh0KSwgdGhpcy5zZXRUcmlnZ2VySXRlbVBvc2l0aW9uKHQsIGUpLCB0LnN0eWxlLnNldFByb3BlcnR5KGZlLk5lc3RpbmdMZXZlbCwgdGhpcy5uZXN0ZWRQb3BvdmVyLm5lc3RpbmdMZXZlbC50b1N0cmluZygpKSwgdGhpcy5uZXN0ZWRQb3BvdmVyLnNob3coKSwgKG8gPSB0aGlzLmZsaXBwZXIpID09IG51bGwgfHwgby5kZWFjdGl2YXRlKCksIHRoaXMubmVzdGVkUG9wb3ZlcjtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHBvcG92ZXIgc2hvdWxkIGJlIG9wZW5lZCBib3R0b20uXG4gICAqIEl0IHNob3VsZCBoYXBwZW4gd2hlbiB0aGVyZSBpcyBlbm91Z2ggc3BhY2UgYmVsb3cgb3Igbm90IGVub3VnaCBzcGFjZSBhYm92ZVxuICAgKi9cbiAgZ2V0IHNob3VsZE9wZW5Cb3R0b20oKSB7XG4gICAgaWYgKHRoaXMubm9kZXMucG9wb3ZlciA9PT0gdm9pZCAwIHx8IHRoaXMubm9kZXMucG9wb3ZlciA9PT0gbnVsbClcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBlID0gdGhpcy5ub2Rlcy5wb3BvdmVyQ29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0ID0gdGhpcy5zY29wZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG8gPSB0aGlzLnNpemUuaGVpZ2h0LCBpID0gZS50b3AgKyBvLCBzID0gZS50b3AgLSBvLCByID0gTWF0aC5taW4od2luZG93LmlubmVySGVpZ2h0LCB0LmJvdHRvbSk7XG4gICAgcmV0dXJuIHMgPCB0LnRvcCB8fCBpIDw9IHI7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBwb3BvdmVyIHNob3VsZCBiZSBvcGVuZWQgbGVmdC5cbiAgICogSXQgc2hvdWxkIGhhcHBlbiB3aGVuIHRoZXJlIGlzIGVub3VnaCBzcGFjZSBpbiB0aGUgcmlnaHQgb3Igbm90IGVub3VnaCBzcGFjZSBpbiB0aGUgbGVmdFxuICAgKi9cbiAgZ2V0IHNob3VsZE9wZW5SaWdodCgpIHtcbiAgICBpZiAodGhpcy5ub2Rlcy5wb3BvdmVyID09PSB2b2lkIDAgfHwgdGhpcy5ub2Rlcy5wb3BvdmVyID09PSBudWxsKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGUgPSB0aGlzLm5vZGVzLnBvcG92ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHQgPSB0aGlzLnNjb3BlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbyA9IHRoaXMuc2l6ZS53aWR0aCwgaSA9IGUucmlnaHQgKyBvLCBzID0gZS5sZWZ0IC0gbywgciA9IE1hdGgubWluKHdpbmRvdy5pbm5lcldpZHRoLCB0LnJpZ2h0KTtcbiAgICByZXR1cm4gcyA8IHQubGVmdCB8fCBpIDw9IHI7XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgdmFyIGk7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIHdpZHRoOiAwXG4gICAgfTtcbiAgICBpZiAodGhpcy5ub2Rlcy5wb3BvdmVyID09PSBudWxsKVxuICAgICAgcmV0dXJuIGU7XG4gICAgY29uc3QgdCA9IHRoaXMubm9kZXMucG9wb3Zlci5jbG9uZU5vZGUoITApO1xuICAgIHQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCIsIHQuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCIsIHQuc3R5bGUudG9wID0gXCItMTAwMHB4XCIsIHQuY2xhc3NMaXN0LmFkZChQLnBvcG92ZXJPcGVuZWQpLCAoaSA9IHQucXVlcnlTZWxlY3RvcihcIi5cIiArIFAucG9wb3Zlck5lc3RlZCkpID09IG51bGwgfHwgaS5yZW1vdmUoKSwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0KTtcbiAgICBjb25zdCBvID0gdC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgUC5wb3BvdmVyQ29udGFpbmVyKTtcbiAgICByZXR1cm4gZS5oZWlnaHQgPSBvLm9mZnNldEhlaWdodCwgZS53aWR0aCA9IG8ub2Zmc2V0V2lkdGgsIHQucmVtb3ZlKCksIGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgbGlzdCBvZiBlbGVtZW50cyBhdmFpbGFibGUgZm9yIGtleWJvYXJkIG5hdmlnYXRpb24uXG4gICAqL1xuICBnZXQgZmxpcHBhYmxlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMubWFwKCh0KSA9PiB7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIHJlKVxuICAgICAgICByZXR1cm4gdC5nZXRFbGVtZW50KCk7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIFNlKVxuICAgICAgICByZXR1cm4gdC5nZXRDb250cm9scygpO1xuICAgIH0pLmZsYXQoKS5maWx0ZXIoKHQpID0+IHQgIT0gbnVsbCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgc2VhcmNoIHRvIHRoZSBwb3BvdmVyXG4gICAqL1xuICBhZGRTZWFyY2goKSB7XG4gICAgdGhpcy5zZWFyY2ggPSBuZXcgbHMoe1xuICAgICAgaXRlbXM6IHRoaXMuaXRlbXNEZWZhdWx0LFxuICAgICAgcGxhY2Vob2xkZXI6IHRoaXMubWVzc2FnZXMuc2VhcmNoXG4gICAgfSksIHRoaXMuc2VhcmNoLm9uKFVlLlNlYXJjaCwgdGhpcy5vblNlYXJjaCk7XG4gICAgY29uc3QgZSA9IHRoaXMuc2VhcmNoLmdldEVsZW1lbnQoKTtcbiAgICBlLmNsYXNzTGlzdC5hZGQoUC5zZWFyY2gpLCB0aGlzLm5vZGVzLnBvcG92ZXJDb250YWluZXIuaW5zZXJ0QmVmb3JlKGUsIHRoaXMubm9kZXMucG9wb3ZlckNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlcyBub3RoaW5nIGZvdW5kIG1lc3NhZ2UgdmlzaWJpbGl0eVxuICAgKlxuICAgKiBAcGFyYW0gaXNEaXNwbGF5ZWQgLSB0cnVlIGlmIHRoZSBtZXNzYWdlIHNob3VsZCBiZSBkaXNwbGF5ZWRcbiAgICovXG4gIHRvZ2dsZU5vdGhpbmdGb3VuZE1lc3NhZ2UoZSkge1xuICAgIHRoaXMubm9kZXMubm90aGluZ0ZvdW5kTWVzc2FnZS5jbGFzc0xpc3QudG9nZ2xlKFAubm90aGluZ0ZvdW5kTWVzc2FnZURpc3BsYXllZCwgZSk7XG4gIH1cbn07XG51cyhbXG4gIG1lXG5dLCBlbi5wcm90b3R5cGUsIFwic2l6ZVwiLCAxKTtcbmxldCBCdCA9IGVuO1xuY2xhc3MgaHMgZXh0ZW5kcyBCdCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIHRoZSBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gaW5zdGFuY2UgcGFyYW1ldGVyc1xuICAgKi9cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGNvbnN0IHQgPSAhYmUoKTtcbiAgICBzdXBlcihcbiAgICAgIHtcbiAgICAgICAgLi4uZSxcbiAgICAgICAgY2xhc3M6IFAucG9wb3ZlcklubGluZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgW18uRGVmYXVsdF06IHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBXZSB1c2UgYnV0dG9uIGluc3RlYWQgb2YgZGl2IGhlcmUgdG8gZml4IGJ1ZyBhc3NvY2lhdGVkIHdpdGggZm9jdXMgbG9zcyAod2hpY2ggbGVhZHMgdG8gc2VsZWN0aW9uIGNoYW5nZSkgb24gY2xpY2sgaW4gc2FmYXJpXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAdG9kbyBmaWd1cmUgb3V0IGJldHRlciB3YXkgdG8gc29sdmUgdGhlIGlzc3VlXG4gICAgICAgICAgICovXG4gICAgICAgICAgd3JhcHBlclRhZzogXCJidXR0b25cIixcbiAgICAgICAgICBoaW50OiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJ0b3BcIixcbiAgICAgICAgICAgIGFsaWdubWVudDogXCJjZW50ZXJcIixcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtfLkh0bWxdOiB7XG4gICAgICAgICAgaGludDoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwidG9wXCIsXG4gICAgICAgICAgICBhbGlnbm1lbnQ6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICBlbmFibGVkOiB0XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKSwgdGhpcy5pdGVtcy5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAhKG8gaW5zdGFuY2VvZiByZSkgJiYgIShvIGluc3RhbmNlb2YgU2UpIHx8IG8uaGFzQ2hpbGRyZW4gJiYgby5pc0NoaWxkcmVuT3BlbiAmJiB0aGlzLnNob3dOZXN0ZWRJdGVtcyhvKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB2aXNpYmxlIGVsZW1lbnQgb2Zmc2V0IHRvcFxuICAgKi9cbiAgZ2V0IG9mZnNldExlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMucG9wb3ZlckNvbnRhaW5lciA9PT0gbnVsbCA/IDAgOiB0aGlzLm5vZGVzLnBvcG92ZXJDb250YWluZXIub2Zmc2V0TGVmdDtcbiAgfVxuICAvKipcbiAgICogT3BlbiBwb3BvdmVyXG4gICAqL1xuICBzaG93KCkge1xuICAgIHRoaXMubmVzdGluZ0xldmVsID09PSAwICYmIHRoaXMubm9kZXMucG9wb3Zlci5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgIGZlLklubGluZVBvcG92ZXJXaWR0aCxcbiAgICAgIHRoaXMuc2l6ZS53aWR0aCArIFwicHhcIlxuICAgICksIHN1cGVyLnNob3coKTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZSBob3ZlciBldmVudCBoYW5kbGluZy5cbiAgICogT3ZlcnJpZGVzIHBhcmVudCdzIGNsYXNzIGJlaGF2aW9yXG4gICAqL1xuICBoYW5kbGVIb3ZlcigpIHtcbiAgfVxuICAvKipcbiAgICogU2V0cyBDU1MgdmFyaWFibGUgd2l0aCBwb3NpdGlvbiBvZiBpdGVtIG5lYXIgd2hpY2ggbmVzdGVkIHBvcG92ZXIgc2hvdWxkIGJlIGRpc3BsYXllZC5cbiAgICogSXMgdXNlZCB0byBwb3NpdGlvbiBuZXN0ZWQgcG9wb3ZlciByaWdodCBiZWxvdyBjbGlja2VkIGl0ZW1cbiAgICpcbiAgICogQHBhcmFtIG5lc3RlZFBvcG92ZXJFbCAtIG5lc3RlZCBwb3BvdmVyIGVsZW1lbnRcbiAgICogQHBhcmFtIGl0ZW0g4oCTIGl0ZW0gbmVhciB3aGljaCBuZXN0ZWQgcG9wb3ZlciBzaG91bGQgYmUgZGlzcGxheWVkXG4gICAqL1xuICBzZXRUcmlnZ2VySXRlbVBvc2l0aW9uKGUsIHQpIHtcbiAgICBjb25zdCBvID0gdC5nZXRFbGVtZW50KCksIGkgPSBvID8gby5vZmZzZXRMZWZ0IDogMCwgcyA9IHRoaXMub2Zmc2V0TGVmdCArIGk7XG4gICAgZS5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgIGZlLlRyaWdnZXJJdGVtTGVmdCxcbiAgICAgIHMgKyBcInB4XCJcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGRpc3BsYXlpbmcgbmVzdGVkIGl0ZW1zIGZvciB0aGUgaXRlbS5cbiAgICogT3ZlcnJpZGluZyBpbiBvcmRlciB0byBhZGQgdG9nZ2xpbmcgYmVoYXZpb3VyXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtIOKAkyBpdGVtIHRvIHRvZ2dsZSBuZXN0ZWQgcG9wb3ZlciBmb3JcbiAgICovXG4gIHNob3dOZXN0ZWRJdGVtcyhlKSB7XG4gICAgaWYgKHRoaXMubmVzdGVkUG9wb3ZlclRyaWdnZXJJdGVtID09PSBlKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lOZXN0ZWRQb3BvdmVySWZFeGlzdHMoKSwgdGhpcy5uZXN0ZWRQb3BvdmVyVHJpZ2dlckl0ZW0gPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5zaG93TmVzdGVkSXRlbXMoZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGRpc3BsYXlzIG5lc3RlZCBwb3BvdmVyIGZvciBzcGVjaWZpZWQgaXRlbS5cbiAgICogSXMgdXNlZCBvbmx5IG9uIGRlc2t0b3BcbiAgICpcbiAgICogQHBhcmFtIGl0ZW0gLSBpdGVtIHRvIGRpc3BsYXkgbmVzdGVkIHBvcG92ZXIgYnlcbiAgICovXG4gIHNob3dOZXN0ZWRQb3BvdmVyRm9ySXRlbShlKSB7XG4gICAgY29uc3QgdCA9IHN1cGVyLnNob3dOZXN0ZWRQb3BvdmVyRm9ySXRlbShlKTtcbiAgICByZXR1cm4gdC5nZXRFbGVtZW50KCkuY2xhc3NMaXN0LmFkZChQLmdldFBvcG92ZXJOZXN0ZWRDbGFzcyh0Lm5lc3RpbmdMZXZlbCkpLCB0O1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkZXMgZGVmYXVsdCBpdGVtIGNsaWNrIGhhbmRsaW5nLlxuICAgKiBIZWxwcyB0byBjbG9zZSBuZXN0ZWQgcG9wb3ZlciBvbmNlIG90aGVyIGl0ZW0gaXMgY2xpY2tlZC5cbiAgICpcbiAgICogQHBhcmFtIGl0ZW0gLSBjbGlja2VkIGl0ZW1cbiAgICovXG4gIGhhbmRsZUl0ZW1DbGljayhlKSB7XG4gICAgdmFyIHQ7XG4gICAgZSAhPT0gdGhpcy5uZXN0ZWRQb3BvdmVyVHJpZ2dlckl0ZW0gJiYgKCh0ID0gdGhpcy5uZXN0ZWRQb3BvdmVyVHJpZ2dlckl0ZW0pID09IG51bGwgfHwgdC5oYW5kbGVDbGljaygpLCBzdXBlci5kZXN0cm95TmVzdGVkUG9wb3ZlcklmRXhpc3RzKCkpLCBzdXBlci5oYW5kbGVJdGVtQ2xpY2soZSk7XG4gIH1cbn1cbmNvbnN0IG9uID0gY2xhc3MgeGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNjcm9sbFBvc2l0aW9uID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogTG9ja3MgYm9keSBlbGVtZW50IHNjcm9sbFxuICAgKi9cbiAgbG9jaygpIHtcbiAgICBwdCA/IHRoaXMubG9ja0hhcmQoKSA6IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCh4ZS5DU1Muc2Nyb2xsTG9ja2VkKTtcbiAgfVxuICAvKipcbiAgICogVW5sb2NrcyBib2R5IGVsZW1lbnQgc2Nyb2xsXG4gICAqL1xuICB1bmxvY2soKSB7XG4gICAgcHQgPyB0aGlzLnVubG9ja0hhcmQoKSA6IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSh4ZS5DU1Muc2Nyb2xsTG9ja2VkKTtcbiAgfVxuICAvKipcbiAgICogTG9ja3Mgc2Nyb2xsIGluIGEgaGFyZCB3YXkgKHZpYSBzZXR0aW5nIGZpeGVkIHBvc2l0aW9uIHRvIGJvZHkgZWxlbWVudClcbiAgICovXG4gIGxvY2tIYXJkKCkge1xuICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gPSB3aW5kb3cucGFnZVlPZmZzZXQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgIFwiLS13aW5kb3ctc2Nyb2xsLW9mZnNldFwiLFxuICAgICAgYCR7dGhpcy5zY3JvbGxQb3NpdGlvbn1weGBcbiAgICApLCBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoeGUuQ1NTLnNjcm9sbExvY2tlZEhhcmQpO1xuICB9XG4gIC8qKlxuICAgKiBVbmxvY2tzIGhhcmQgc2Nyb2xsIGxvY2tcbiAgICovXG4gIHVubG9ja0hhcmQoKSB7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKHhlLkNTUy5zY3JvbGxMb2NrZWRIYXJkKSwgdGhpcy5zY3JvbGxQb3NpdGlvbiAhPT0gbnVsbCAmJiB3aW5kb3cuc2Nyb2xsVG8oMCwgdGhpcy5zY3JvbGxQb3NpdGlvbiksIHRoaXMuc2Nyb2xsUG9zaXRpb24gPSBudWxsO1xuICB9XG59O1xub24uQ1NTID0ge1xuICBzY3JvbGxMb2NrZWQ6IFwiY2Utc2Nyb2xsLWxvY2tlZFwiLFxuICBzY3JvbGxMb2NrZWRIYXJkOiBcImNlLXNjcm9sbC1sb2NrZWQtLWhhcmRcIlxufTtcbmxldCBwcyA9IG9uO1xuY29uc3QgYXQgPSBuZShcImNlLXBvcG92ZXItaGVhZGVyXCIpLCBsdCA9IHtcbiAgcm9vdDogYXQoKSxcbiAgdGV4dDogYXQoXCJ0ZXh0XCIpLFxuICBiYWNrQnV0dG9uOiBhdChcImJhY2stYnV0dG9uXCIpXG59O1xuY2xhc3MgZnMge1xuICAvKipcbiAgICogQ29uc3RydWN0cyB0aGUgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIHBvcG92ZXIgaGVhZGVyIHBhcmFtc1xuICAgKi9cbiAgY29uc3RydWN0b3IoeyB0ZXh0OiBlLCBvbkJhY2tCdXR0b25DbGljazogdCB9KSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgX2UoKSwgdGhpcy50ZXh0ID0gZSwgdGhpcy5vbkJhY2tCdXR0b25DbGljayA9IHQsIHRoaXMubm9kZXMgPSB7XG4gICAgICByb290OiBkLm1ha2UoXCJkaXZcIiwgW2x0LnJvb3RdKSxcbiAgICAgIGJhY2tCdXR0b246IGQubWFrZShcImJ1dHRvblwiLCBbbHQuYmFja0J1dHRvbl0pLFxuICAgICAgdGV4dDogZC5tYWtlKFwiZGl2XCIsIFtsdC50ZXh0XSlcbiAgICB9LCB0aGlzLm5vZGVzLmJhY2tCdXR0b24uaW5uZXJIVE1MID0gVmksIHRoaXMubm9kZXMucm9vdC5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLmJhY2tCdXR0b24pLCB0aGlzLmxpc3RlbmVycy5vbih0aGlzLm5vZGVzLmJhY2tCdXR0b24sIFwiY2xpY2tcIiwgdGhpcy5vbkJhY2tCdXR0b25DbGljayksIHRoaXMubm9kZXMudGV4dC5pbm5lclRleHQgPSB0aGlzLnRleHQsIHRoaXMubm9kZXMucm9vdC5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLnRleHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHBvcG92ZXIgaGVhZGVyIHJvb3QgaHRtbCBlbGVtZW50XG4gICAqL1xuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnJvb3Q7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBpbnN0YW5jZVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm5vZGVzLnJvb3QucmVtb3ZlKCksIHRoaXMubGlzdGVuZXJzLmRlc3Ryb3koKTtcbiAgfVxufVxuY2xhc3MgZ3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmhpc3RvcnkgPSBbXTtcbiAgfVxuICAvKipcbiAgICogUHVzaCBuZXcgcG9wb3ZlciBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gc3RhdGUgLSBuZXcgc3RhdGVcbiAgICovXG4gIHB1c2goZSkge1xuICAgIHRoaXMuaGlzdG9yeS5wdXNoKGUpO1xuICB9XG4gIC8qKlxuICAgKiBQb3AgbGFzdCBwb3BvdmVyIHN0YXRlXG4gICAqL1xuICBwb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5wb3AoKTtcbiAgfVxuICAvKipcbiAgICogVGl0bGUgcmV0cmlldmVkIGZyb20gdGhlIGN1cnJlbnQgc3RhdGVcbiAgICovXG4gIGdldCBjdXJyZW50VGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5sZW5ndGggPT09IDAgPyBcIlwiIDogdGhpcy5oaXN0b3J5W3RoaXMuaGlzdG9yeS5sZW5ndGggLSAxXS50aXRsZTtcbiAgfVxuICAvKipcbiAgICogSXRlbXMgbGlzdCByZXRyaWV2ZWQgZnJvbSB0aGUgY3VycmVudCBzdGF0ZVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRJdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy5oaXN0b3J5Lmxlbmd0aCA9PT0gMCA/IFtdIDogdGhpcy5oaXN0b3J5W3RoaXMuaGlzdG9yeS5sZW5ndGggLSAxXS5pdGVtcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBoaXN0b3J5IHRvIGluaXRpYWwgcG9wb3ZlciBzdGF0ZVxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgZm9yICg7IHRoaXMuaGlzdG9yeS5sZW5ndGggPiAxOyApXG4gICAgICB0aGlzLnBvcCgpO1xuICB9XG59XG5jbGFzcyBubiBleHRlbmRzIEpvIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCB0aGUgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIHBvcG92ZXIgcGFyYW1zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoZSwge1xuICAgICAgW18uRGVmYXVsdF06IHtcbiAgICAgICAgaGludDoge1xuICAgICAgICAgIGVuYWJsZWQ6ICExXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbXy5IdG1sXToge1xuICAgICAgICBoaW50OiB7XG4gICAgICAgICAgZW5hYmxlZDogITFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLCB0aGlzLnNjcm9sbExvY2tlciA9IG5ldyBwcygpLCB0aGlzLmhpc3RvcnkgPSBuZXcgZ3MoKSwgdGhpcy5pc0hpZGRlbiA9ICEwLCB0aGlzLm5vZGVzLm92ZXJsYXkgPSBkLm1ha2UoXCJkaXZcIiwgW1Aub3ZlcmxheSwgUC5vdmVybGF5SGlkZGVuXSksIHRoaXMubm9kZXMucG9wb3Zlci5pbnNlcnRCZWZvcmUodGhpcy5ub2Rlcy5vdmVybGF5LCB0aGlzLm5vZGVzLnBvcG92ZXIuZmlyc3RDaGlsZCksIHRoaXMubGlzdGVuZXJzLm9uKHRoaXMubm9kZXMub3ZlcmxheSwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9KSwgdGhpcy5oaXN0b3J5LnB1c2goeyBpdGVtczogZS5pdGVtcyB9KTtcbiAgfVxuICAvKipcbiAgICogT3BlbiBwb3BvdmVyXG4gICAqL1xuICBzaG93KCkge1xuICAgIHRoaXMubm9kZXMub3ZlcmxheS5jbGFzc0xpc3QucmVtb3ZlKFAub3ZlcmxheUhpZGRlbiksIHN1cGVyLnNob3coKSwgdGhpcy5zY3JvbGxMb2NrZXIubG9jaygpLCB0aGlzLmlzSGlkZGVuID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyBwb3BvdmVyXG4gICAqL1xuICBoaWRlKCkge1xuICAgIHRoaXMuaXNIaWRkZW4gfHwgKHN1cGVyLmhpZGUoKSwgdGhpcy5ub2Rlcy5vdmVybGF5LmNsYXNzTGlzdC5hZGQoUC5vdmVybGF5SGlkZGVuKSwgdGhpcy5zY3JvbGxMb2NrZXIudW5sb2NrKCksIHRoaXMuaGlzdG9yeS5yZXNldCgpLCB0aGlzLmlzSGlkZGVuID0gITApO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgbWVtb3J5XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKSwgdGhpcy5zY3JvbGxMb2NrZXIudW5sb2NrKCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgZGlzcGxheWluZyBuZXN0ZWQgaXRlbXMgZm9yIHRoZSBpdGVtXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtIOKAk8KgaXRlbSB0byBzaG93IG5lc3RlZCBwb3BvdmVyIGZvclxuICAgKi9cbiAgc2hvd05lc3RlZEl0ZW1zKGUpIHtcbiAgICB0aGlzLnVwZGF0ZUl0ZW1zQW5kSGVhZGVyKGUuY2hpbGRyZW4sIGUudGl0bGUpLCB0aGlzLmhpc3RvcnkucHVzaCh7XG4gICAgICB0aXRsZTogZS50aXRsZSxcbiAgICAgIGl0ZW1zOiBlLmNoaWxkcmVuXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgcmVuZGVyZWQgcG9wb3ZlciBpdGVtcyBhbmQgaGVhZGVyIGFuZCBkaXNwbGF5cyBuZXcgb25lc1xuICAgKlxuICAgKiBAcGFyYW0gaXRlbXMgLSBuZXcgcG9wb3ZlciBpdGVtc1xuICAgKiBAcGFyYW0gdGl0bGUgLSBuZXcgcG9wb3ZlciBoZWFkZXIgdGV4dFxuICAgKi9cbiAgdXBkYXRlSXRlbXNBbmRIZWFkZXIoZSwgdCkge1xuICAgIGlmICh0aGlzLmhlYWRlciAhPT0gbnVsbCAmJiB0aGlzLmhlYWRlciAhPT0gdm9pZCAwICYmICh0aGlzLmhlYWRlci5kZXN0cm95KCksIHRoaXMuaGVhZGVyID0gbnVsbCksIHQgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5oZWFkZXIgPSBuZXcgZnMoe1xuICAgICAgICB0ZXh0OiB0LFxuICAgICAgICBvbkJhY2tCdXR0b25DbGljazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGlzdG9yeS5wb3AoKSwgdGhpcy51cGRhdGVJdGVtc0FuZEhlYWRlcih0aGlzLmhpc3RvcnkuY3VycmVudEl0ZW1zLCB0aGlzLmhpc3RvcnkuY3VycmVudFRpdGxlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBvID0gdGhpcy5oZWFkZXIuZ2V0RWxlbWVudCgpO1xuICAgICAgbyAhPT0gbnVsbCAmJiB0aGlzLm5vZGVzLnBvcG92ZXJDb250YWluZXIuaW5zZXJ0QmVmb3JlKG8sIHRoaXMubm9kZXMucG9wb3ZlckNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgdGhpcy5pdGVtcy5mb3JFYWNoKChvKSA9PiB7XG4gICAgICB2YXIgaTtcbiAgICAgIHJldHVybiAoaSA9IG8uZ2V0RWxlbWVudCgpKSA9PSBudWxsID8gdm9pZCAwIDogaS5yZW1vdmUoKTtcbiAgICB9KSwgdGhpcy5pdGVtcyA9IHRoaXMuYnVpbGRJdGVtcyhlKSwgdGhpcy5pdGVtcy5mb3JFYWNoKChvKSA9PiB7XG4gICAgICB2YXIgcztcbiAgICAgIGNvbnN0IGkgPSBvLmdldEVsZW1lbnQoKTtcbiAgICAgIGkgIT09IG51bGwgJiYgKChzID0gdGhpcy5ub2Rlcy5pdGVtcykgPT0gbnVsbCB8fCBzLmFwcGVuZENoaWxkKGkpKTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgbXMgZXh0ZW5kcyBFIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5vcGVuZWQgPSAhMSwgdGhpcy5zZWxlY3Rpb24gPSBuZXcgYigpLCB0aGlzLnBvcG92ZXIgPSBudWxsLCB0aGlzLmNsb3NlID0gKCkgPT4ge1xuICAgICAgdGhpcy5vcGVuZWQgJiYgKHRoaXMub3BlbmVkID0gITEsIGIuaXNBdEVkaXRvciB8fCB0aGlzLnNlbGVjdGlvbi5yZXN0b3JlKCksIHRoaXMuc2VsZWN0aW9uLmNsZWFyU2F2ZWQoKSwgIXRoaXMuRWRpdG9yLkNyb3NzQmxvY2tTZWxlY3Rpb24uaXNDcm9zc0Jsb2NrU2VsZWN0aW9uU3RhcnRlZCAmJiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrICYmIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLnVuc2VsZWN0QmxvY2sodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jayksIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5lbWl0KHRoaXMuZXZlbnRzLmNsb3NlZCksIHRoaXMucG9wb3ZlciAmJiAodGhpcy5wb3BvdmVyLm9mZihHLkNsb3NlZCwgdGhpcy5vblBvcG92ZXJDbG9zZSksIHRoaXMucG9wb3Zlci5kZXN0cm95KCksIHRoaXMucG9wb3Zlci5nZXRFbGVtZW50KCkucmVtb3ZlKCksIHRoaXMucG9wb3ZlciA9IG51bGwpKTtcbiAgICB9LCB0aGlzLm9uUG9wb3ZlckNsb3NlID0gKCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIE1vZHVsZSBFdmVudHNcbiAgICovXG4gIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZW5lZDogXCJibG9jay1zZXR0aW5ncy1vcGVuZWRcIixcbiAgICAgIGNsb3NlZDogXCJibG9jay1zZXR0aW5ncy1jbG9zZWRcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEJsb2NrIFNldHRpbmdzIENTU1xuICAgKi9cbiAgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0dGluZ3M6IFwiY2Utc2V0dGluZ3NcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgaW5uZXIgcG9wb3ZlcidzIGZsaXBwZXIgaW5zdGFuY2VcbiAgICpcbiAgICogQHRvZG8gcmVtb3ZlIG9uY2UgQmxvY2tTZXR0aW5ncyBiZWNvbWVzIHN0YW5kYWxvbmUgbm9uLW1vZHVsZSBjbGFzc1xuICAgKi9cbiAgZ2V0IGZsaXBwZXIoKSB7XG4gICAgdmFyIGU7XG4gICAgaWYgKHRoaXMucG9wb3ZlciAhPT0gbnVsbClcbiAgICAgIHJldHVybiBcImZsaXBwZXJcIiBpbiB0aGlzLnBvcG92ZXIgPyAoZSA9IHRoaXMucG9wb3ZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IGUuZmxpcHBlciA6IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogUGFuZWwgd2l0aCBibG9jayBzZXR0aW5ncyB3aXRoIDIgc2VjdGlvbnM6XG4gICAqICAtIFRvb2wncyBTZXR0aW5nc1xuICAgKiAgLSBEZWZhdWx0IFNldHRpbmdzIFtNb3ZlLCBSZW1vdmUsIGV0Y11cbiAgICovXG4gIG1ha2UoKSB7XG4gICAgdGhpcy5ub2Rlcy53cmFwcGVyID0gZC5tYWtlKFwiZGl2XCIsIFt0aGlzLkNTUy5zZXR0aW5nc10pLCB0aGlzLm5vZGVzLndyYXBwZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1jeVwiLCBcImJsb2NrLXR1bmVzXCIpLCB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIub24oVGUsIHRoaXMuY2xvc2UpO1xuICB9XG4gIC8qKlxuICAgKiBEZXN0cm95cyBtb2R1bGVcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVBbGxOb2RlcygpLCB0aGlzLmxpc3RlbmVycy5kZXN0cm95KCksIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5vZmYoVGUsIHRoaXMuY2xvc2UpO1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIEJsb2NrIFNldHRpbmdzIHBhbmVcbiAgICpcbiAgICogQHBhcmFtIHRhcmdldEJsb2NrIC0gbmVhciB3aGljaCBCbG9jayB3ZSBzaG91bGQgb3BlbiBCbG9ja1NldHRpbmdzXG4gICAqL1xuICBhc3luYyBvcGVuKGUgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrKSB7XG4gICAgdmFyIHM7XG4gICAgdGhpcy5vcGVuZWQgPSAhMCwgdGhpcy5zZWxlY3Rpb24uc2F2ZSgpLCB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5zZWxlY3RCbG9jayhlKSwgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uY2xlYXJDYWNoZSgpO1xuICAgIGNvbnN0IHsgdG9vbFR1bmVzOiB0LCBjb21tb25UdW5lczogbyB9ID0gZS5nZXRUdW5lcygpO1xuICAgIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5lbWl0KHRoaXMuZXZlbnRzLm9wZW5lZCk7XG4gICAgY29uc3QgaSA9IGJlKCkgPyBubiA6IEJ0O1xuICAgIHRoaXMucG9wb3ZlciA9IG5ldyBpKHtcbiAgICAgIHNlYXJjaGFibGU6ICEwLFxuICAgICAgaXRlbXM6IGF3YWl0IHRoaXMuZ2V0VHVuZXNJdGVtcyhlLCBvLCB0KSxcbiAgICAgIHNjb3BlRWxlbWVudDogdGhpcy5FZGl0b3IuQVBJLm1ldGhvZHMudWkubm9kZXMucmVkYWN0b3IsXG4gICAgICBtZXNzYWdlczoge1xuICAgICAgICBub3RoaW5nRm91bmQ6IHoudWkoSy51aS5wb3BvdmVyLCBcIk5vdGhpbmcgZm91bmRcIiksXG4gICAgICAgIHNlYXJjaDogei51aShLLnVpLnBvcG92ZXIsIFwiRmlsdGVyXCIpXG4gICAgICB9XG4gICAgfSksIHRoaXMucG9wb3Zlci5vbihHLkNsb3NlZCwgdGhpcy5vblBvcG92ZXJDbG9zZSksIChzID0gdGhpcy5ub2Rlcy53cmFwcGVyKSA9PSBudWxsIHx8IHMuYXBwZW5kKHRoaXMucG9wb3Zlci5nZXRFbGVtZW50KCkpLCB0aGlzLnBvcG92ZXIuc2hvdygpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHJvb3QgYmxvY2sgc2V0dGluZ3MgZWxlbWVudFxuICAgKi9cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGxpc3Qgb2YgaXRlbXMgdG8gYmUgZGlzcGxheWVkIGluIGJsb2NrIHR1bmVzIG1lbnUuXG4gICAqIE1lcmdlcyB0b29sIHNwZWNpZmljIHR1bmVzLCBjb252ZXJzaW9uIG1lbnUgYW5kIGNvbW1vbiB0dW5lcyBpbiBvbmUgbGlzdCBpbiBwcmVkZWZpbmVkIG9yZGVyXG4gICAqXG4gICAqIEBwYXJhbSBjdXJyZW50QmxvY2sg4oCTICBibG9jayB3ZSBhcmUgYWJvdXQgdG8gb3BlbiBibG9jayB0dW5lcyBmb3JcbiAgICogQHBhcmFtIGNvbW1vblR1bmVzIOKAkyBjb21tb24gdHVuZXNcbiAgICogQHBhcmFtIHRvb2xUdW5lcyAtIHRvb2wgc3BlY2lmaWMgdHVuZXNcbiAgICovXG4gIGFzeW5jIGdldFR1bmVzSXRlbXMoZSwgdCwgbykge1xuICAgIGNvbnN0IGkgPSBbXTtcbiAgICBvICE9PSB2b2lkIDAgJiYgby5sZW5ndGggPiAwICYmIChpLnB1c2goLi4ubyksIGkucHVzaCh7XG4gICAgICB0eXBlOiBfLlNlcGFyYXRvclxuICAgIH0pKTtcbiAgICBjb25zdCBzID0gQXJyYXkuZnJvbSh0aGlzLkVkaXRvci5Ub29scy5ibG9ja1Rvb2xzLnZhbHVlcygpKSwgYSA9IChhd2FpdCBZbyhlLCBzKSkucmVkdWNlKChsLCBjKSA9PiAoYy50b29sYm94LmZvckVhY2goKHUpID0+IHtcbiAgICAgIGwucHVzaCh7XG4gICAgICAgIGljb246IHUuaWNvbixcbiAgICAgICAgdGl0bGU6IHoudChLLnRvb2xOYW1lcywgdS50aXRsZSksXG4gICAgICAgIG5hbWU6IGMubmFtZSxcbiAgICAgICAgY2xvc2VPbkFjdGl2YXRlOiAhMCxcbiAgICAgICAgb25BY3RpdmF0ZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBoLCBDYXJldDogcCwgVG9vbGJhcjogZyB9ID0gdGhpcy5FZGl0b3IsIGYgPSBhd2FpdCBoLmNvbnZlcnQoZSwgYy5uYW1lLCB1LmRhdGEpO1xuICAgICAgICAgIGcuY2xvc2UoKSwgcC5zZXRUb0Jsb2NrKGYsIHAucG9zaXRpb25zLkVORCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLCBsKSwgW10pO1xuICAgIHJldHVybiBhLmxlbmd0aCA+IDAgJiYgKGkucHVzaCh7XG4gICAgICBpY29uOiBHbyxcbiAgICAgIG5hbWU6IFwiY29udmVydC10b1wiLFxuICAgICAgdGl0bGU6IHoudWkoSy51aS5wb3BvdmVyLCBcIkNvbnZlcnQgdG9cIiksXG4gICAgICBjaGlsZHJlbjoge1xuICAgICAgICBzZWFyY2hhYmxlOiAhMCxcbiAgICAgICAgaXRlbXM6IGFcbiAgICAgIH1cbiAgICB9KSwgaS5wdXNoKHtcbiAgICAgIHR5cGU6IF8uU2VwYXJhdG9yXG4gICAgfSkpLCBpLnB1c2goLi4udCksIGkubWFwKChsKSA9PiB0aGlzLnJlc29sdmVUdW5lQWxpYXNlcyhsKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc29sdmVzIGFsaWFzZXMgaW4gdHVuZXMgbWVudSBpdGVtc1xuICAgKlxuICAgKiBAcGFyYW0gaXRlbSAtIGl0ZW0gd2l0aCByZXNvbHZlZCBhbGlhc2VzXG4gICAqL1xuICByZXNvbHZlVHVuZUFsaWFzZXMoZSkge1xuICAgIGlmIChlLnR5cGUgPT09IF8uU2VwYXJhdG9yIHx8IGUudHlwZSA9PT0gXy5IdG1sKVxuICAgICAgcmV0dXJuIGU7XG4gICAgY29uc3QgdCA9IFlpKGUsIHsgbGFiZWw6IFwidGl0bGVcIiB9KTtcbiAgICByZXR1cm4gZS5jb25maXJtYXRpb24gJiYgKHQuY29uZmlybWF0aW9uID0gdGhpcy5yZXNvbHZlVHVuZUFsaWFzZXMoZS5jb25maXJtYXRpb24pKSwgdDtcbiAgfVxufVxudmFyIHNuID0geyBleHBvcnRzOiB7fSB9O1xuLyohXG4gKiBMaWJyYXJ5IGZvciBoYW5kbGluZyBrZXlib2FyZCBzaG9ydGN1dHNcbiAqIEBjb3B5cmlnaHQgQ29kZVggKGh0dHBzOi8vY29kZXguc28pXG4gKiBAbGljZW5zZSBNSVRcbiAqIEBhdXRob3IgQ29kZVggKGh0dHBzOi8vY29kZXguc28pXG4gKiBAdmVyc2lvbiAxLjIuMFxuICovXG4oZnVuY3Rpb24obiwgZSkge1xuICAoZnVuY3Rpb24odCwgbykge1xuICAgIG4uZXhwb3J0cyA9IG8oKTtcbiAgfSkod2luZG93LCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIG8gPSB7fTtcbiAgICAgIGZ1bmN0aW9uIGkocykge1xuICAgICAgICBpZiAob1tzXSlcbiAgICAgICAgICByZXR1cm4gb1tzXS5leHBvcnRzO1xuICAgICAgICB2YXIgciA9IG9bc10gPSB7IGk6IHMsIGw6ICExLCBleHBvcnRzOiB7fSB9O1xuICAgICAgICByZXR1cm4gdFtzXS5jYWxsKHIuZXhwb3J0cywgciwgci5leHBvcnRzLCBpKSwgci5sID0gITAsIHIuZXhwb3J0cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBpLm0gPSB0LCBpLmMgPSBvLCBpLmQgPSBmdW5jdGlvbihzLCByLCBhKSB7XG4gICAgICAgIGkubyhzLCByKSB8fCBPYmplY3QuZGVmaW5lUHJvcGVydHkocywgciwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBhIH0pO1xuICAgICAgfSwgaS5yID0gZnVuY3Rpb24ocykge1xuICAgICAgICB0eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gICAgICB9LCBpLnQgPSBmdW5jdGlvbihzLCByKSB7XG4gICAgICAgIGlmICgxICYgciAmJiAocyA9IGkocykpLCA4ICYgciB8fCA0ICYgciAmJiB0eXBlb2YgcyA9PSBcIm9iamVjdFwiICYmIHMgJiYgcy5fX2VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB2YXIgYSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBpZiAoaS5yKGEpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogITAsIHZhbHVlOiBzIH0pLCAyICYgciAmJiB0eXBlb2YgcyAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgIGZvciAodmFyIGwgaW4gcylcbiAgICAgICAgICAgIGkuZChhLCBsLCAoZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICByZXR1cm4gc1tjXTtcbiAgICAgICAgICAgIH0pLmJpbmQobnVsbCwgbCkpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sIGkubiA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIHIgPSBzICYmIHMuX19lc01vZHVsZSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzLmRlZmF1bHQ7XG4gICAgICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGkuZChyLCBcImFcIiwgciksIHI7XG4gICAgICB9LCBpLm8gPSBmdW5jdGlvbihzLCByKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcik7XG4gICAgICB9LCBpLnAgPSBcIlwiLCBpKGkucyA9IDApO1xuICAgIH0oW2Z1bmN0aW9uKHQsIG8sIGkpIHtcbiAgICAgIGZ1bmN0aW9uIHMobCwgYykge1xuICAgICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IGMubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICB2YXIgaCA9IGNbdV07XG4gICAgICAgICAgaC5lbnVtZXJhYmxlID0gaC5lbnVtZXJhYmxlIHx8ICExLCBoLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gaCAmJiAoaC53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGwsIGgua2V5LCBoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcihsLCBjLCB1KSB7XG4gICAgICAgIHJldHVybiBjICYmIHMobC5wcm90b3R5cGUsIGMpLCB1ICYmIHMobCwgdSksIGw7XG4gICAgICB9XG4gICAgICBpLnIobyk7XG4gICAgICB2YXIgYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBsKGMpIHtcbiAgICAgICAgICB2YXIgdSA9IHRoaXM7XG4gICAgICAgICAgKGZ1bmN0aW9uKGgsIHApIHtcbiAgICAgICAgICAgIGlmICghKGggaW5zdGFuY2VvZiBwKSlcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICB9KSh0aGlzLCBsKSwgdGhpcy5jb21tYW5kcyA9IHt9LCB0aGlzLmtleXMgPSB7fSwgdGhpcy5uYW1lID0gYy5uYW1lLCB0aGlzLnBhcnNlU2hvcnRjdXROYW1lKGMubmFtZSksIHRoaXMuZWxlbWVudCA9IGMub24sIHRoaXMuY2FsbGJhY2sgPSBjLmNhbGxiYWNrLCB0aGlzLmV4ZWN1dGVTaG9ydGN1dCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIHUuZXhlY3V0ZShoKTtcbiAgICAgICAgICB9LCB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5leGVjdXRlU2hvcnRjdXQsICExKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcihsLCBudWxsLCBbeyBrZXk6IFwic3VwcG9ydGVkQ29tbWFuZHNcIiwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4geyBTSElGVDogW1wiU0hJRlRcIl0sIENNRDogW1wiQ01EXCIsIFwiQ09OVFJPTFwiLCBcIkNPTU1BTkRcIiwgXCJXSU5ET1dTXCIsIFwiQ1RSTFwiXSwgQUxUOiBbXCJBTFRcIiwgXCJPUFRJT05cIl0gfTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJrZXlDb2Rlc1wiLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB7IDA6IDQ4LCAxOiA0OSwgMjogNTAsIDM6IDUxLCA0OiA1MiwgNTogNTMsIDY6IDU0LCA3OiA1NSwgODogNTYsIDk6IDU3LCBBOiA2NSwgQjogNjYsIEM6IDY3LCBEOiA2OCwgRTogNjksIEY6IDcwLCBHOiA3MSwgSDogNzIsIEk6IDczLCBKOiA3NCwgSzogNzUsIEw6IDc2LCBNOiA3NywgTjogNzgsIE86IDc5LCBQOiA4MCwgUTogODEsIFI6IDgyLCBTOiA4MywgVDogODQsIFU6IDg1LCBWOiA4NiwgVzogODcsIFg6IDg4LCBZOiA4OSwgWjogOTAsIEJBQ0tTUEFDRTogOCwgRU5URVI6IDEzLCBFU0NBUEU6IDI3LCBMRUZUOiAzNywgVVA6IDM4LCBSSUdIVDogMzksIERPV046IDQwLCBJTlNFUlQ6IDQ1LCBERUxFVEU6IDQ2LCBcIi5cIjogMTkwIH07XG4gICAgICAgIH0gfV0pLCByKGwsIFt7IGtleTogXCJwYXJzZVNob3J0Y3V0TmFtZVwiLCB2YWx1ZTogZnVuY3Rpb24oYykge1xuICAgICAgICAgIGMgPSBjLnNwbGl0KFwiK1wiKTtcbiAgICAgICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IGMubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgIGNbdV0gPSBjW3VdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgaCA9ICExO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBsLnN1cHBvcnRlZENvbW1hbmRzKVxuICAgICAgICAgICAgICBpZiAobC5zdXBwb3J0ZWRDb21tYW5kc1twXS5pbmNsdWRlcyhjW3VdKSkge1xuICAgICAgICAgICAgICAgIGggPSB0aGlzLmNvbW1hbmRzW3BdID0gITA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGggfHwgKHRoaXMua2V5c1tjW3VdXSA9ICEwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgZyBpbiBsLnN1cHBvcnRlZENvbW1hbmRzKVxuICAgICAgICAgICAgdGhpcy5jb21tYW5kc1tnXSB8fCAodGhpcy5jb21tYW5kc1tnXSA9ICExKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJleGVjdXRlXCIsIHZhbHVlOiBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgdmFyIHUsIGggPSB7IENNRDogYy5jdHJsS2V5IHx8IGMubWV0YUtleSwgU0hJRlQ6IGMuc2hpZnRLZXksIEFMVDogYy5hbHRLZXkgfSwgcCA9ICEwO1xuICAgICAgICAgIGZvciAodSBpbiB0aGlzLmNvbW1hbmRzKVxuICAgICAgICAgICAgdGhpcy5jb21tYW5kc1t1XSAhPT0gaFt1XSAmJiAocCA9ICExKTtcbiAgICAgICAgICB2YXIgZywgZiA9ICEwO1xuICAgICAgICAgIGZvciAoZyBpbiB0aGlzLmtleXMpXG4gICAgICAgICAgICBmID0gZiAmJiBjLmtleUNvZGUgPT09IGwua2V5Q29kZXNbZ107XG4gICAgICAgICAgcCAmJiBmICYmIHRoaXMuY2FsbGJhY2soYyk7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwicmVtb3ZlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5leGVjdXRlU2hvcnRjdXQpO1xuICAgICAgICB9IH1dKSwgbDtcbiAgICAgIH0oKTtcbiAgICAgIG8uZGVmYXVsdCA9IGE7XG4gICAgfV0pLmRlZmF1bHQ7XG4gIH0pO1xufSkoc24pO1xudmFyIGJzID0gc24uZXhwb3J0cztcbmNvbnN0IHZzID0gLyogQF9fUFVSRV9fICovIEtlKGJzKTtcbmNsYXNzIGtzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yZWdpc3RlcmVkU2hvcnRjdXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgc2hvcnRjdXRcbiAgICpcbiAgICogQHBhcmFtIHNob3J0Y3V0IC0gc2hvcnRjdXQgb3B0aW9uc1xuICAgKi9cbiAgYWRkKGUpIHtcbiAgICBpZiAodGhpcy5maW5kU2hvcnRjdXQoZS5vbiwgZS5uYW1lKSlcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgU2hvcnRjdXQgJHtlLm5hbWV9IGlzIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3IgJHtlLm9ufS4gUGxlYXNlIHJlbW92ZSBpdCBiZWZvcmUgYWRkIGEgbmV3IGhhbmRsZXIuYFxuICAgICAgKTtcbiAgICBjb25zdCBvID0gbmV3IHZzKHtcbiAgICAgIG5hbWU6IGUubmFtZSxcbiAgICAgIG9uOiBlLm9uLFxuICAgICAgY2FsbGJhY2s6IGUuaGFuZGxlclxuICAgIH0pLCBpID0gdGhpcy5yZWdpc3RlcmVkU2hvcnRjdXRzLmdldChlLm9uKSB8fCBbXTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRTaG9ydGN1dHMuc2V0KGUub24sIFsuLi5pLCBvXSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBzaG9ydGN1dFxuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudCAtIEVsZW1lbnQgc2hvcnRjdXQgaXMgc2V0IGZvclxuICAgKiBAcGFyYW0gbmFtZSAtIHNob3J0Y3V0IG5hbWVcbiAgICovXG4gIHJlbW92ZShlLCB0KSB7XG4gICAgY29uc3QgbyA9IHRoaXMuZmluZFNob3J0Y3V0KGUsIHQpO1xuICAgIGlmICghbylcbiAgICAgIHJldHVybjtcbiAgICBvLnJlbW92ZSgpO1xuICAgIGNvbnN0IGkgPSB0aGlzLnJlZ2lzdGVyZWRTaG9ydGN1dHMuZ2V0KGUpO1xuICAgIHRoaXMucmVnaXN0ZXJlZFNob3J0Y3V0cy5zZXQoZSwgaS5maWx0ZXIoKHMpID0+IHMgIT09IG8pKTtcbiAgfVxuICAvKipcbiAgICogR2V0IFNob3J0Y3V0IGluc3RhbmNlIGlmIGV4aXN0XG4gICAqXG4gICAqIEBwYXJhbSBlbGVtZW50IC0gRWxlbWVudCBzaG9yY3V0IGlzIHNldCBmb3JcbiAgICogQHBhcmFtIHNob3J0Y3V0IC0gc2hvcnRjdXQgbmFtZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBpbmRleCAtIHNob3J0Y3V0IGluZGV4IGlmIGV4aXN0XG4gICAqL1xuICBmaW5kU2hvcnRjdXQoZSwgdCkge1xuICAgIHJldHVybiAodGhpcy5yZWdpc3RlcmVkU2hvcnRjdXRzLmdldChlKSB8fCBbXSkuZmluZCgoeyBuYW1lOiBpIH0pID0+IGkgPT09IHQpO1xuICB9XG59XG5jb25zdCBnZSA9IG5ldyBrcygpO1xudmFyIHlzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCB3cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIHJuID0gKG4sIGUsIHQsIG8pID0+IHtcbiAgZm9yICh2YXIgaSA9IG8gPiAxID8gdm9pZCAwIDogbyA/IHdzKGUsIHQpIDogZSwgcyA9IG4ubGVuZ3RoIC0gMSwgcjsgcyA+PSAwOyBzLS0pXG4gICAgKHIgPSBuW3NdKSAmJiAoaSA9IChvID8gcihlLCB0LCBpKSA6IHIoaSkpIHx8IGkpO1xuICByZXR1cm4gbyAmJiBpICYmIHlzKGUsIHQsIGkpLCBpO1xufSwgTGUgPSAvKiBAX19QVVJFX18gKi8gKChuKSA9PiAobi5PcGVuZWQgPSBcInRvb2xib3gtb3BlbmVkXCIsIG4uQ2xvc2VkID0gXCJ0b29sYm94LWNsb3NlZFwiLCBuLkJsb2NrQWRkZWQgPSBcInRvb2xib3gtYmxvY2stYWRkZWRcIiwgbikpKExlIHx8IHt9KTtcbmNvbnN0IEN0ID0gY2xhc3MgYW4gZXh0ZW5kcyBPZSB7XG4gIC8qKlxuICAgKiBUb29sYm94IGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gYXZhaWxhYmxlIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIG9wdGlvbnMuYXBpIC0gRWRpdG9yIEFQSSBtZXRob2RzXG4gICAqIEBwYXJhbSBvcHRpb25zLnRvb2xzIC0gVG9vbHMgYXZhaWxhYmxlIHRvIGNoZWNrIHdoZXRoZXIgc29tZSBvZiB0aGVtIHNob3VsZCBiZSBkaXNwbGF5ZWQgYXQgdGhlIFRvb2xib3ggb3Igbm90XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGFwaTogZSwgdG9vbHM6IHQsIGkxOG5MYWJlbHM6IG8gfSkge1xuICAgIHN1cGVyKCksIHRoaXMub3BlbmVkID0gITEsIHRoaXMubGlzdGVuZXJzID0gbmV3IF9lKCksIHRoaXMucG9wb3ZlciA9IG51bGwsIHRoaXMuaGFuZGxlTW9iaWxlTGF5b3V0VG9nZ2xlID0gKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95UG9wb3ZlcigpLCB0aGlzLmluaXRQb3BvdmVyKCk7XG4gICAgfSwgdGhpcy5vblBvcG92ZXJDbG9zZSA9ICgpID0+IHtcbiAgICAgIHRoaXMub3BlbmVkID0gITEsIHRoaXMuZW1pdChcbiAgICAgICAgXCJ0b29sYm94LWNsb3NlZFwiXG4gICAgICAgIC8qIENsb3NlZCAqL1xuICAgICAgKTtcbiAgICB9LCB0aGlzLmFwaSA9IGUsIHRoaXMudG9vbHMgPSB0LCB0aGlzLmkxOG5MYWJlbHMgPSBvLCB0aGlzLmVuYWJsZVNob3J0Y3V0cygpLCB0aGlzLm5vZGVzID0ge1xuICAgICAgdG9vbGJveDogZC5tYWtlKFwiZGl2XCIsIGFuLkNTUy50b29sYm94KVxuICAgIH0sIHRoaXMuaW5pdFBvcG92ZXIoKSwgdGhpcy5ub2Rlcy50b29sYm94LnNldEF0dHJpYnV0ZShcImRhdGEtY3lcIiwgXCJ0b29sYm94XCIpLCB0aGlzLmFwaS5ldmVudHMub24oVGUsIHRoaXMuaGFuZGxlTW9iaWxlTGF5b3V0VG9nZ2xlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBUcnVlIGlmIFRvb2xib3ggaXMgRW1wdHkgYW5kIG5vdGhpbmcgdG8gc2hvd1xuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xzVG9CZURpc3BsYXllZC5sZW5ndGggPT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIENTUyBzdHlsZXNcbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b29sYm94OiBcImNlLXRvb2xib3hcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcm9vdCBibG9jayBzZXR0aW5ncyBlbGVtZW50XG4gICAqL1xuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnRvb2xib3g7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgVG9vbGJveCBoYXMgdGhlIEZsaXBwZXIgYWN0aXZhdGVkIGFuZCB0aGUgRmxpcHBlciBoYXMgc2VsZWN0ZWQgYnV0dG9uXG4gICAqL1xuICBoYXNGb2N1cygpIHtcbiAgICBpZiAodGhpcy5wb3BvdmVyICE9PSBudWxsKVxuICAgICAgcmV0dXJuIFwiaGFzRm9jdXNcIiBpbiB0aGlzLnBvcG92ZXIgPyB0aGlzLnBvcG92ZXIuaGFzRm9jdXMoKSA6IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogRGVzdHJveSBNb2R1bGVcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdmFyIGU7XG4gICAgc3VwZXIuZGVzdHJveSgpLCB0aGlzLm5vZGVzICYmIHRoaXMubm9kZXMudG9vbGJveCAmJiB0aGlzLm5vZGVzLnRvb2xib3gucmVtb3ZlKCksIHRoaXMucmVtb3ZlQWxsU2hvcnRjdXRzKCksIChlID0gdGhpcy5wb3BvdmVyKSA9PSBudWxsIHx8IGUub2ZmKEcuQ2xvc2VkLCB0aGlzLm9uUG9wb3ZlckNsb3NlKSwgdGhpcy5saXN0ZW5lcnMuZGVzdHJveSgpLCB0aGlzLmFwaS5ldmVudHMub2ZmKFRlLCB0aGlzLmhhbmRsZU1vYmlsZUxheW91dFRvZ2dsZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRvb2xib3ggVG9vbCdzIGJ1dHRvbiBjbGljayBoYW5kbGVyXG4gICAqXG4gICAqIEBwYXJhbSB0b29sTmFtZSAtIHRvb2wgdHlwZSB0byBiZSBhY3RpdmF0ZWRcbiAgICogQHBhcmFtIGJsb2NrRGF0YU92ZXJyaWRlcyAtIEJsb2NrIGRhdGEgcHJlZGVmaW5lZCBieSB0aGUgYWN0aXZhdGVkIFRvb2xib3ggaXRlbVxuICAgKi9cbiAgdG9vbEJ1dHRvbkFjdGl2YXRlZChlLCB0KSB7XG4gICAgdGhpcy5pbnNlcnROZXdCbG9jayhlLCB0KTtcbiAgfVxuICAvKipcbiAgICogT3BlbiBUb29sYm94IHdpdGggVG9vbHNcbiAgICovXG4gIG9wZW4oKSB7XG4gICAgdmFyIGU7XG4gICAgdGhpcy5pc0VtcHR5IHx8ICgoZSA9IHRoaXMucG9wb3ZlcikgPT0gbnVsbCB8fCBlLnNob3coKSwgdGhpcy5vcGVuZWQgPSAhMCwgdGhpcy5lbWl0KFxuICAgICAgXCJ0b29sYm94LW9wZW5lZFwiXG4gICAgICAvKiBPcGVuZWQgKi9cbiAgICApKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2UgVG9vbGJveFxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdmFyIGU7XG4gICAgKGUgPSB0aGlzLnBvcG92ZXIpID09IG51bGwgfHwgZS5oaWRlKCksIHRoaXMub3BlbmVkID0gITEsIHRoaXMuZW1pdChcbiAgICAgIFwidG9vbGJveC1jbG9zZWRcIlxuICAgICAgLyogQ2xvc2VkICovXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2UgVG9vbGJveFxuICAgKi9cbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMub3BlbmVkID8gdGhpcy5jbG9zZSgpIDogdGhpcy5vcGVuKCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdG9vbGJveCBwb3BvdmVyIGFuZCBhcHBlbmRzIGl0IGluc2lkZSB3cmFwcGVyIGVsZW1lbnRcbiAgICovXG4gIGluaXRQb3BvdmVyKCkge1xuICAgIHZhciB0O1xuICAgIGNvbnN0IGUgPSBiZSgpID8gbm4gOiBCdDtcbiAgICB0aGlzLnBvcG92ZXIgPSBuZXcgZSh7XG4gICAgICBzY29wZUVsZW1lbnQ6IHRoaXMuYXBpLnVpLm5vZGVzLnJlZGFjdG9yLFxuICAgICAgc2VhcmNoYWJsZTogITAsXG4gICAgICBtZXNzYWdlczoge1xuICAgICAgICBub3RoaW5nRm91bmQ6IHRoaXMuaTE4bkxhYmVscy5ub3RoaW5nRm91bmQsXG4gICAgICAgIHNlYXJjaDogdGhpcy5pMThuTGFiZWxzLmZpbHRlclxuICAgICAgfSxcbiAgICAgIGl0ZW1zOiB0aGlzLnRvb2xib3hJdGVtc1RvQmVEaXNwbGF5ZWRcbiAgICB9KSwgdGhpcy5wb3BvdmVyLm9uKEcuQ2xvc2VkLCB0aGlzLm9uUG9wb3ZlckNsb3NlKSwgKHQgPSB0aGlzLm5vZGVzLnRvb2xib3gpID09IG51bGwgfHwgdC5hcHBlbmQodGhpcy5wb3BvdmVyLmdldEVsZW1lbnQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHBvcG92ZXIgaW5zdGFuY2UgYW5kIHJlbW92ZXMgaXQgZnJvbSBET01cbiAgICovXG4gIGRlc3Ryb3lQb3BvdmVyKCkge1xuICAgIHRoaXMucG9wb3ZlciAhPT0gbnVsbCAmJiAodGhpcy5wb3BvdmVyLmhpZGUoKSwgdGhpcy5wb3BvdmVyLm9mZihHLkNsb3NlZCwgdGhpcy5vblBvcG92ZXJDbG9zZSksIHRoaXMucG9wb3Zlci5kZXN0cm95KCksIHRoaXMucG9wb3ZlciA9IG51bGwpLCB0aGlzLm5vZGVzLnRvb2xib3ggIT09IG51bGwgJiYgKHRoaXMubm9kZXMudG9vbGJveC5pbm5lckhUTUwgPSBcIlwiKTtcbiAgfVxuICBnZXQgdG9vbHNUb0JlRGlzcGxheWVkKCkge1xuICAgIGNvbnN0IGUgPSBbXTtcbiAgICByZXR1cm4gdGhpcy50b29scy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0LnRvb2xib3ggJiYgZS5wdXNoKHQpO1xuICAgIH0pLCBlO1xuICB9XG4gIGdldCB0b29sYm94SXRlbXNUb0JlRGlzcGxheWVkKCkge1xuICAgIGNvbnN0IGUgPSAodCwgbywgaSA9ICEwKSA9PiAoe1xuICAgICAgaWNvbjogdC5pY29uLFxuICAgICAgdGl0bGU6IHoudChLLnRvb2xOYW1lcywgdC50aXRsZSB8fCBqZShvLm5hbWUpKSxcbiAgICAgIG5hbWU6IG8ubmFtZSxcbiAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy50b29sQnV0dG9uQWN0aXZhdGVkKG8ubmFtZSwgdC5kYXRhKTtcbiAgICAgIH0sXG4gICAgICBzZWNvbmRhcnlMYWJlbDogby5zaG9ydGN1dCAmJiBpID8gdnQoby5zaG9ydGN1dCkgOiBcIlwiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMudG9vbHNUb0JlRGlzcGxheWVkLnJlZHVjZSgodCwgbykgPT4gKEFycmF5LmlzQXJyYXkoby50b29sYm94KSA/IG8udG9vbGJveC5mb3JFYWNoKChpLCBzKSA9PiB7XG4gICAgICB0LnB1c2goZShpLCBvLCBzID09PSAwKSk7XG4gICAgfSkgOiBvLnRvb2xib3ggIT09IHZvaWQgMCAmJiB0LnB1c2goZShvLnRvb2xib3gsIG8pKSwgdCksIFtdKTtcbiAgfVxuICAvKipcbiAgICogSXRlcmF0ZSBhbGwgdG9vbHMgYW5kIGVuYWJsZSB0aGVpcnMgc2hvcnRjdXRzIGlmIHNwZWNpZmllZFxuICAgKi9cbiAgZW5hYmxlU2hvcnRjdXRzKCkge1xuICAgIHRoaXMudG9vbHNUb0JlRGlzcGxheWVkLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBlLnNob3J0Y3V0O1xuICAgICAgdCAmJiB0aGlzLmVuYWJsZVNob3J0Y3V0Rm9yVG9vbChlLm5hbWUsIHQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGUgc2hvcnRjdXQgQmxvY2sgVG9vbCBpbXBsZW1lbnRlZCBzaG9ydGN1dFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9vbE5hbWUgLSBUb29sIG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNob3J0Y3V0IC0gc2hvcnRjdXQgYWNjb3JkaW5nIHRvIHRoZSBTaG9ydGN1dERhdGEgTW9kdWxlIGZvcm1hdFxuICAgKi9cbiAgZW5hYmxlU2hvcnRjdXRGb3JUb29sKGUsIHQpIHtcbiAgICBnZS5hZGQoe1xuICAgICAgbmFtZTogdCxcbiAgICAgIG9uOiB0aGlzLmFwaS51aS5ub2Rlcy5yZWRhY3RvcixcbiAgICAgIGhhbmRsZXI6IGFzeW5jIChvKSA9PiB7XG4gICAgICAgIG8ucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuYXBpLmJsb2Nrcy5nZXRDdXJyZW50QmxvY2tJbmRleCgpLCBzID0gdGhpcy5hcGkuYmxvY2tzLmdldEJsb2NrQnlJbmRleChpKTtcbiAgICAgICAgaWYgKHMpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLmFwaS5ibG9ja3MuY29udmVydChzLmlkLCBlKTtcbiAgICAgICAgICAgIHRoaXMuYXBpLmNhcmV0LnNldFRvQmxvY2sociwgXCJlbmRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgfVxuICAgICAgICB0aGlzLmluc2VydE5ld0Jsb2NrKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBhZGRlZCBzaG9ydGN1dHNcbiAgICogRmlyZWQgd2hlbiB0aGUgUmVhZC1Pbmx5IG1vZGUgaXMgYWN0aXZhdGVkXG4gICAqL1xuICByZW1vdmVBbGxTaG9ydGN1dHMoKSB7XG4gICAgdGhpcy50b29sc1RvQmVEaXNwbGF5ZWQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgY29uc3QgdCA9IGUuc2hvcnRjdXQ7XG4gICAgICB0ICYmIGdlLnJlbW92ZSh0aGlzLmFwaS51aS5ub2Rlcy5yZWRhY3RvciwgdCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgbmV3IGJsb2NrXG4gICAqIENhbiBiZSBjYWxsZWQgd2hlbiBidXR0b24gY2xpY2tlZCBvbiBUb29sYm94IG9yIGJ5IFNob3J0Y3V0RGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9vbE5hbWUgLSBUb29sIG5hbWVcbiAgICogQHBhcmFtIGJsb2NrRGF0YU92ZXJyaWRlcyAtIHByZWRlZmluZWQgQmxvY2sgZGF0YVxuICAgKi9cbiAgYXN5bmMgaW5zZXJ0TmV3QmxvY2soZSwgdCkge1xuICAgIGNvbnN0IG8gPSB0aGlzLmFwaS5ibG9ja3MuZ2V0Q3VycmVudEJsb2NrSW5kZXgoKSwgaSA9IHRoaXMuYXBpLmJsb2Nrcy5nZXRCbG9ja0J5SW5kZXgobyk7XG4gICAgaWYgKCFpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHMgPSBpLmlzRW1wdHkgPyBvIDogbyArIDE7XG4gICAgbGV0IHI7XG4gICAgaWYgKHQpIHtcbiAgICAgIGNvbnN0IGwgPSBhd2FpdCB0aGlzLmFwaS5ibG9ja3MuY29tcG9zZUJsb2NrRGF0YShlKTtcbiAgICAgIHIgPSBPYmplY3QuYXNzaWduKGwsIHQpO1xuICAgIH1cbiAgICBjb25zdCBhID0gdGhpcy5hcGkuYmxvY2tzLmluc2VydChcbiAgICAgIGUsXG4gICAgICByLFxuICAgICAgdm9pZCAwLFxuICAgICAgcyxcbiAgICAgIHZvaWQgMCxcbiAgICAgIGkuaXNFbXB0eVxuICAgICk7XG4gICAgYS5jYWxsKGVlLkFQUEVORF9DQUxMQkFDSyksIHRoaXMuYXBpLmNhcmV0LnNldFRvQmxvY2socyksIHRoaXMuZW1pdChcInRvb2xib3gtYmxvY2stYWRkZWRcIiwge1xuICAgICAgYmxvY2s6IGFcbiAgICB9KSwgdGhpcy5hcGkudG9vbGJhci5jbG9zZSgpO1xuICB9XG59O1xucm4oW1xuICBtZVxuXSwgQ3QucHJvdG90eXBlLCBcInRvb2xzVG9CZURpc3BsYXllZFwiLCAxKTtcbnJuKFtcbiAgbWVcbl0sIEN0LnByb3RvdHlwZSwgXCJ0b29sYm94SXRlbXNUb0JlRGlzcGxheWVkXCIsIDEpO1xubGV0IEVzID0gQ3Q7XG5jb25zdCBsbiA9IFwiYmxvY2sgaG92ZXJlZFwiO1xuYXN5bmMgZnVuY3Rpb24geHMobiwgZSkge1xuICBjb25zdCB0ID0gbmF2aWdhdG9yLmtleWJvYXJkO1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIGU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIChhd2FpdCB0LmdldExheW91dE1hcCgpKS5nZXQobikgfHwgZTtcbiAgfSBjYXRjaCAobykge1xuICAgIHJldHVybiBjb25zb2xlLmVycm9yKG8pLCBlO1xuICB9XG59XG5jbGFzcyBCcyBleHRlbmRzIEUge1xuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uIC0gTW9kdWxlIENvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIG1vZHVsZUNvbmZpZ3VyYXRpb24uY29uZmlnIC0gRWRpdG9yJ3MgY29uZmlnXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uLmV2ZW50c0Rpc3BhdGNoZXIgLSBFZGl0b3IncyBldmVudCBkaXNwYXRjaGVyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGNvbmZpZzogZSwgZXZlbnRzRGlzcGF0Y2hlcjogdCB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnOiBlLFxuICAgICAgZXZlbnRzRGlzcGF0Y2hlcjogdFxuICAgIH0pLCB0aGlzLnRvb2xib3hJbnN0YW5jZSA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIENTUyBzdHlsZXNcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2xiYXI6IFwiY2UtdG9vbGJhclwiLFxuICAgICAgY29udGVudDogXCJjZS10b29sYmFyX19jb250ZW50XCIsXG4gICAgICBhY3Rpb25zOiBcImNlLXRvb2xiYXJfX2FjdGlvbnNcIixcbiAgICAgIGFjdGlvbnNPcGVuZWQ6IFwiY2UtdG9vbGJhcl9fYWN0aW9ucy0tb3BlbmVkXCIsXG4gICAgICB0b29sYmFyT3BlbmVkOiBcImNlLXRvb2xiYXItLW9wZW5lZFwiLFxuICAgICAgb3BlbmVkVG9vbGJveEhvbGRlck1vZGlmaWVyOiBcImNvZGV4LWVkaXRvci0tdG9vbGJveC1vcGVuZWRcIixcbiAgICAgIHBsdXNCdXR0b246IFwiY2UtdG9vbGJhcl9fcGx1c1wiLFxuICAgICAgcGx1c0J1dHRvblNob3J0Y3V0OiBcImNlLXRvb2xiYXJfX3BsdXMtc2hvcnRjdXRcIixcbiAgICAgIHNldHRpbmdzVG9nZ2xlcjogXCJjZS10b29sYmFyX19zZXR0aW5ncy1idG5cIixcbiAgICAgIHNldHRpbmdzVG9nZ2xlckhpZGRlbjogXCJjZS10b29sYmFyX19zZXR0aW5ncy1idG4tLWhpZGRlblwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVG9vbGJhciBvcGVuaW5nIHN0YXRlXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IG9wZW5lZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLkNTUy50b29sYmFyT3BlbmVkKTtcbiAgfVxuICAvKipcbiAgICogUHVibGljIGludGVyZmFjZSBmb3IgYWNjZXNzaW5nIHRoZSBUb29sYm94XG4gICAqL1xuICBnZXQgdG9vbGJveCgpIHtcbiAgICB2YXIgZTtcbiAgICByZXR1cm4ge1xuICAgICAgb3BlbmVkOiAoZSA9IHRoaXMudG9vbGJveEluc3RhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogZS5vcGVuZWQsXG4gICAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgKHQgPSB0aGlzLnRvb2xib3hJbnN0YW5jZSkgPT0gbnVsbCB8fCB0LmNsb3NlKCk7XG4gICAgICB9LFxuICAgICAgb3BlbjogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy50b29sYm94SW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICBTKFwidG9vbGJveC5vcGVuKCkgY2FsbGVkIGJlZm9yZSBpbml0aWFsaXphdGlvbiBpcyBmaW5pc2hlZFwiLCBcIndhcm5cIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2sgPSB0aGlzLmhvdmVyZWRCbG9jaywgdGhpcy50b29sYm94SW5zdGFuY2Uub3BlbigpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZTogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy50b29sYm94SW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICBTKFwidG9vbGJveC50b2dnbGUoKSBjYWxsZWQgYmVmb3JlIGluaXRpYWxpemF0aW9uIGlzIGZpbmlzaGVkXCIsIFwid2FyblwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b29sYm94SW5zdGFuY2UudG9nZ2xlKCk7XG4gICAgICB9LFxuICAgICAgaGFzRm9jdXM6ICgpID0+IHtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHJldHVybiAodCA9IHRoaXMudG9vbGJveEluc3RhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogdC5oYXNGb2N1cygpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEJsb2NrIGFjdGlvbnMgYXBwZWFyYW5jZSBtYW5pcHVsYXRpb25zXG4gICAqL1xuICBnZXQgYmxvY2tBY3Rpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBoaWRlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMubm9kZXMuYWN0aW9ucy5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuQ1NTLmFjdGlvbnNPcGVuZWQpO1xuICAgICAgfSxcbiAgICAgIHNob3c6ICgpID0+IHtcbiAgICAgICAgdGhpcy5ub2Rlcy5hY3Rpb25zLmNsYXNzTGlzdC5hZGQodGhpcy5DU1MuYWN0aW9uc09wZW5lZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kcyBmb3Igd29ya2luZyB3aXRoIEJsb2NrIFR1bmVzIHRvZ2dsZXJcbiAgICovXG4gIGdldCBibG9ja1R1bmVzVG9nZ2xlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGlkZTogKCkgPT4gdGhpcy5ub2Rlcy5zZXR0aW5nc1RvZ2dsZXIuY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5zZXR0aW5nc1RvZ2dsZXJIaWRkZW4pLFxuICAgICAgc2hvdzogKCkgPT4gdGhpcy5ub2Rlcy5zZXR0aW5nc1RvZ2dsZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLkNTUy5zZXR0aW5nc1RvZ2dsZXJIaWRkZW4pXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlcyByZWFkLW9ubHkgbW9kZVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYWRPbmx5RW5hYmxlZCAtIHJlYWQtb25seSBtb2RlXG4gICAqL1xuICB0b2dnbGVSZWFkT25seShlKSB7XG4gICAgZSA/ICh0aGlzLmRlc3Ryb3koKSwgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5kZXN0cm95KCksIHRoaXMuZGlzYWJsZU1vZHVsZUJpbmRpbmdzKCkpIDogd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgdGhpcy5kcmF3VUkoKSwgdGhpcy5lbmFibGVNb2R1bGVCaW5kaW5ncygpO1xuICAgIH0sIHsgdGltZW91dDogMmUzIH0pO1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlIFRvb2xiYXIgdG8gdGhlIHBhc3NlZCAob3IgY3VycmVudCkgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIGJsb2NrIC0gYmxvY2sgdG8gbW92ZSBUb29sYmFyIG5lYXIgaXRcbiAgICovXG4gIG1vdmVBbmRPcGVuKGUgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrKSB7XG4gICAgaWYgKHRoaXMudG9vbGJveEluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICBTKFwiQ2FuJ3Qgb3BlbiBUb29sYmFyIHNpbmNlIEVkaXRvciBpbml0aWFsaXphdGlvbiBpcyBub3QgZmluaXNoZWQgeWV0XCIsIFwid2FyblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMudG9vbGJveEluc3RhbmNlLm9wZW5lZCAmJiB0aGlzLnRvb2xib3hJbnN0YW5jZS5jbG9zZSgpLCB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLm9wZW5lZCAmJiB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLmNsb3NlKCksICFlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaG92ZXJlZEJsb2NrID0gZTtcbiAgICBjb25zdCB0ID0gZS5ob2xkZXIsIHsgaXNNb2JpbGU6IG8gfSA9IHRoaXMuRWRpdG9yLlVJO1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHMgPSAyMCwgciA9IGUuZmlyc3RJbnB1dCwgYSA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGwgPSByICE9PSB2b2lkIDAgPyByLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogbnVsbCwgYyA9IGwgIT09IG51bGwgPyBsLnRvcCAtIGEudG9wIDogbnVsbCwgdSA9IGMgIT09IG51bGwgPyBjID4gcyA6IHZvaWQgMDtcbiAgICBpZiAobylcbiAgICAgIGkgPSB0Lm9mZnNldFRvcCArIHQub2Zmc2V0SGVpZ2h0O1xuICAgIGVsc2UgaWYgKHIgPT09IHZvaWQgMCB8fCB1KSB7XG4gICAgICBjb25zdCBoID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZS5wbHVnaW5zQ29udGVudCkucGFkZGluZ1RvcCk7XG4gICAgICBpID0gdC5vZmZzZXRUb3AgKyBoO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoID0gbGkociksIHAgPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLm5vZGVzLnBsdXNCdXR0b24pLmhlaWdodCwgMTApLCBnID0gODtcbiAgICAgIGkgPSB0Lm9mZnNldFRvcCArIGggLSBwICsgZyArIGM7XG4gICAgfVxuICAgIHRoaXMubm9kZXMud3JhcHBlci5zdHlsZS50b3AgPSBgJHtNYXRoLmZsb29yKGkpfXB4YCwgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmJsb2Nrcy5sZW5ndGggPT09IDEgJiYgZS5pc0VtcHR5ID8gdGhpcy5ibG9ja1R1bmVzVG9nZ2xlci5oaWRlKCkgOiB0aGlzLmJsb2NrVHVuZXNUb2dnbGVyLnNob3coKSwgdGhpcy5vcGVuKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlIHRoZSBUb29sYmFyXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB2YXIgZSwgdDtcbiAgICB0aGlzLkVkaXRvci5SZWFkT25seS5pc0VuYWJsZWQgfHwgKChlID0gdGhpcy5ub2Rlcy53cmFwcGVyKSA9PSBudWxsIHx8IGUuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLkNTUy50b29sYmFyT3BlbmVkKSwgdGhpcy5ibG9ja0FjdGlvbnMuaGlkZSgpLCAodCA9IHRoaXMudG9vbGJveEluc3RhbmNlKSA9PSBudWxsIHx8IHQuY2xvc2UoKSwgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5jbG9zZSgpLCB0aGlzLnJlc2V0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldCB0aGUgVG9vbGJhciBwb3NpdGlvbiB0byBwcmV2ZW50IERPTSBoZWlnaHQgZ3Jvd3RoLCBmb3IgZXhhbXBsZSBhZnRlciBibG9ja3MgZGVsZXRpb25cbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMubm9kZXMud3JhcHBlci5zdHlsZS50b3AgPSBcInVuc2V0XCI7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW4gVG9vbGJhciB3aXRoIFBsdXMgQnV0dG9uIGFuZCBBY3Rpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aEJsb2NrQWN0aW9ucyAtIGJ5IGRlZmF1bHQsIFRvb2xiYXIgb3BlbnMgd2l0aCBCbG9jayBBY3Rpb25zLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIGZsYWcgYWxsb3dzIHRvIG9wZW4gVG9vbGJhciB3aXRob3V0IEFjdGlvbnMuXG4gICAqL1xuICBvcGVuKGUgPSAhMCkge1xuICAgIHRoaXMubm9kZXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLnRvb2xiYXJPcGVuZWQpLCBlID8gdGhpcy5ibG9ja0FjdGlvbnMuc2hvdygpIDogdGhpcy5ibG9ja0FjdGlvbnMuaGlkZSgpO1xuICB9XG4gIC8qKlxuICAgKiBEcmF3cyBUb29sYmFyIGVsZW1lbnRzXG4gICAqL1xuICBhc3luYyBtYWtlKCkge1xuICAgIHRoaXMubm9kZXMud3JhcHBlciA9IGQubWFrZShcImRpdlwiLCB0aGlzLkNTUy50b29sYmFyKSwgW1wiY29udGVudFwiLCBcImFjdGlvbnNcIl0uZm9yRWFjaCgocykgPT4ge1xuICAgICAgdGhpcy5ub2Rlc1tzXSA9IGQubWFrZShcImRpdlwiLCB0aGlzLkNTU1tzXSk7XG4gICAgfSksIGQuYXBwZW5kKHRoaXMubm9kZXMud3JhcHBlciwgdGhpcy5ub2Rlcy5jb250ZW50KSwgZC5hcHBlbmQodGhpcy5ub2Rlcy5jb250ZW50LCB0aGlzLm5vZGVzLmFjdGlvbnMpLCB0aGlzLm5vZGVzLnBsdXNCdXR0b24gPSBkLm1ha2UoXCJkaXZcIiwgdGhpcy5DU1MucGx1c0J1dHRvbiwge1xuICAgICAgaW5uZXJIVE1MOiB0c1xuICAgIH0pLCBkLmFwcGVuZCh0aGlzLm5vZGVzLmFjdGlvbnMsIHRoaXMubm9kZXMucGx1c0J1dHRvbiksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKHRoaXMubm9kZXMucGx1c0J1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICAkZSghMCksIHRoaXMucGx1c0J1dHRvbkNsaWNrZWQoKTtcbiAgICB9LCAhMSk7XG4gICAgY29uc3QgZSA9IGQubWFrZShcImRpdlwiKTtcbiAgICBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHoudWkoSy51aS50b29sYmFyLnRvb2xib3gsIFwiQWRkXCIpKSksIGUuYXBwZW5kQ2hpbGQoZC5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLnBsdXNCdXR0b25TaG9ydGN1dCwge1xuICAgICAgdGV4dENvbnRlbnQ6IFwiL1wiXG4gICAgfSkpLCB6ZSh0aGlzLm5vZGVzLnBsdXNCdXR0b24sIGUsIHtcbiAgICAgIGhpZGluZ0RlbGF5OiA0MDBcbiAgICB9KSwgdGhpcy5ub2Rlcy5zZXR0aW5nc1RvZ2dsZXIgPSBkLm1ha2UoXCJzcGFuXCIsIHRoaXMuQ1NTLnNldHRpbmdzVG9nZ2xlciwge1xuICAgICAgaW5uZXJIVE1MOiBlc1xuICAgIH0pLCBkLmFwcGVuZCh0aGlzLm5vZGVzLmFjdGlvbnMsIHRoaXMubm9kZXMuc2V0dGluZ3NUb2dnbGVyKTtcbiAgICBjb25zdCB0ID0gZC5tYWtlKFwiZGl2XCIpLCBvID0gZC50ZXh0KHoudWkoSy51aS5ibG9ja1R1bmVzLnRvZ2dsZXIsIFwiQ2xpY2sgdG8gdHVuZVwiKSksIGkgPSBhd2FpdCB4cyhcIlNsYXNoXCIsIFwiL1wiKTtcbiAgICB0LmFwcGVuZENoaWxkKG8pLCB0LmFwcGVuZENoaWxkKGQubWFrZShcImRpdlwiLCB0aGlzLkNTUy5wbHVzQnV0dG9uU2hvcnRjdXQsIHtcbiAgICAgIHRleHRDb250ZW50OiB2dChgQ01EICsgJHtpfWApXG4gICAgfSkpLCB6ZSh0aGlzLm5vZGVzLnNldHRpbmdzVG9nZ2xlciwgdCwge1xuICAgICAgaGlkaW5nRGVsYXk6IDQwMFxuICAgIH0pLCBkLmFwcGVuZCh0aGlzLm5vZGVzLmFjdGlvbnMsIHRoaXMubWFrZVRvb2xib3goKSksIGQuYXBwZW5kKHRoaXMubm9kZXMuYWN0aW9ucywgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5nZXRFbGVtZW50KCkpLCBkLmFwcGVuZCh0aGlzLkVkaXRvci5VSS5ub2Rlcy53cmFwcGVyLCB0aGlzLm5vZGVzLndyYXBwZXIpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBUb29sYm94IGluc3RhbmNlIGFuZCByZXR1cm4gaXQncyByZW5kZXJlZCBlbGVtZW50XG4gICAqL1xuICBtYWtlVG9vbGJveCgpIHtcbiAgICByZXR1cm4gdGhpcy50b29sYm94SW5zdGFuY2UgPSBuZXcgRXMoe1xuICAgICAgYXBpOiB0aGlzLkVkaXRvci5BUEkubWV0aG9kcyxcbiAgICAgIHRvb2xzOiB0aGlzLkVkaXRvci5Ub29scy5ibG9ja1Rvb2xzLFxuICAgICAgaTE4bkxhYmVsczoge1xuICAgICAgICBmaWx0ZXI6IHoudWkoSy51aS5wb3BvdmVyLCBcIkZpbHRlclwiKSxcbiAgICAgICAgbm90aGluZ0ZvdW5kOiB6LnVpKEsudWkucG9wb3ZlciwgXCJOb3RoaW5nIGZvdW5kXCIpXG4gICAgICB9XG4gICAgfSksIHRoaXMudG9vbGJveEluc3RhbmNlLm9uKExlLk9wZW5lZCwgKCkgPT4ge1xuICAgICAgdGhpcy5FZGl0b3IuVUkubm9kZXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLm9wZW5lZFRvb2xib3hIb2xkZXJNb2RpZmllcik7XG4gICAgfSksIHRoaXMudG9vbGJveEluc3RhbmNlLm9uKExlLkNsb3NlZCwgKCkgPT4ge1xuICAgICAgdGhpcy5FZGl0b3IuVUkubm9kZXMud3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuQ1NTLm9wZW5lZFRvb2xib3hIb2xkZXJNb2RpZmllcik7XG4gICAgfSksIHRoaXMudG9vbGJveEluc3RhbmNlLm9uKExlLkJsb2NrQWRkZWQsICh7IGJsb2NrOiBlIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBDYXJldDogbyB9ID0gdGhpcy5FZGl0b3IsIGkgPSB0LmdldEJsb2NrQnlJZChlLmlkKTtcbiAgICAgIGkuaW5wdXRzLmxlbmd0aCA9PT0gMCAmJiAoaSA9PT0gdC5sYXN0QmxvY2sgPyAodC5pbnNlcnRBdEVuZCgpLCBvLnNldFRvQmxvY2sodC5sYXN0QmxvY2spKSA6IG8uc2V0VG9CbG9jayh0Lm5leHRCbG9jaykpO1xuICAgIH0pLCB0aGlzLnRvb2xib3hJbnN0YW5jZS5nZXRFbGVtZW50KCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXIgZm9yIFBsdXMgQnV0dG9uXG4gICAqL1xuICBwbHVzQnV0dG9uQ2xpY2tlZCgpIHtcbiAgICB2YXIgZTtcbiAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrID0gdGhpcy5ob3ZlcmVkQmxvY2ssIChlID0gdGhpcy50b29sYm94SW5zdGFuY2UpID09IG51bGwgfHwgZS50b2dnbGUoKTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIGJpbmRpbmdzXG4gICAqL1xuICBlbmFibGVNb2R1bGVCaW5kaW5ncygpIHtcbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbih0aGlzLm5vZGVzLnNldHRpbmdzVG9nZ2xlciwgXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgIHZhciB0O1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKSwgdGhpcy5zZXR0aW5nc1RvZ2dsZXJDbGlja2VkKCksICh0ID0gdGhpcy50b29sYm94SW5zdGFuY2UpICE9IG51bGwgJiYgdC5vcGVuZWQgJiYgdGhpcy50b29sYm94SW5zdGFuY2UuY2xvc2UoKSwgJGUoITApO1xuICAgIH0sICEwKSwgYmUoKSB8fCB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIub24obG4sIChlKSA9PiB7XG4gICAgICB2YXIgdDtcbiAgICAgIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbmVkIHx8ICh0ID0gdGhpcy50b29sYm94SW5zdGFuY2UpICE9IG51bGwgJiYgdC5vcGVuZWQgfHwgdGhpcy5tb3ZlQW5kT3BlbihlLmJsb2NrKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZSBiaW5kaW5nc1xuICAgKi9cbiAgZGlzYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLmNsZWFyQWxsKCk7XG4gIH1cbiAgLyoqXG4gICAqIENsaWNrcyBvbiB0aGUgQmxvY2sgU2V0dGluZ3MgdG9nZ2xlclxuICAgKi9cbiAgc2V0dGluZ3NUb2dnbGVyQ2xpY2tlZCgpIHtcbiAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrID0gdGhpcy5ob3ZlcmVkQmxvY2ssIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbmVkID8gdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5jbG9zZSgpIDogdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuKHRoaXMuaG92ZXJlZEJsb2NrKTtcbiAgfVxuICAvKipcbiAgICogRHJhd3MgVG9vbGJhciBVSVxuICAgKlxuICAgKiBUb29sYmFyIGNvbnRhaW5zIEJsb2NrU2V0dGluZ3MgYW5kIFRvb2xib3guXG4gICAqIFRoYXQncyB3aHkgYXQgZmlyc3Qgd2UgZHJhdyBpdHMgY29tcG9uZW50cyBhbmQgdGhlbiBUb29sYmFyIGl0c2VsZlxuICAgKlxuICAgKiBTdGVwczpcbiAgICogIC0gTWFrZSBUb29sYmFyIGRlcGVuZGVudCBjb21wb25lbnRzIGxpa2UgQmxvY2tTZXR0aW5ncywgVG9vbGJveCBhbmQgc28gb25cbiAgICogIC0gTWFrZSBpdHNlbGYgYW5kIGFwcGVuZCBkZXBlbmRlbnQgbm9kZXMgdG8gaXRzZWxmXG4gICAqXG4gICAqL1xuICBkcmF3VUkoKSB7XG4gICAgdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5tYWtlKCksIHRoaXMubWFrZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBjcmVhdGVkIGFuZCBzYXZlZCBIVE1MRWxlbWVudHNcbiAgICogSXQgaXMgdXNlZCBpbiBSZWFkLU9ubHkgbW9kZVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbW92ZUFsbE5vZGVzKCksIHRoaXMudG9vbGJveEluc3RhbmNlICYmIHRoaXMudG9vbGJveEluc3RhbmNlLmRlc3Ryb3koKTtcbiAgfVxufVxudmFyIGFlID0gLyogQF9fUFVSRV9fICovICgobikgPT4gKG5bbi5CbG9jayA9IDBdID0gXCJCbG9ja1wiLCBuW24uSW5saW5lID0gMV0gPSBcIklubGluZVwiLCBuW24uVHVuZSA9IDJdID0gXCJUdW5lXCIsIG4pKShhZSB8fCB7fSksIFBlID0gLyogQF9fUFVSRV9fICovICgobikgPT4gKG4uU2hvcnRjdXQgPSBcInNob3J0Y3V0XCIsIG4uVG9vbGJveCA9IFwidG9vbGJveFwiLCBuLkVuYWJsZWRJbmxpbmVUb29scyA9IFwiaW5saW5lVG9vbGJhclwiLCBuLkVuYWJsZWRCbG9ja1R1bmVzID0gXCJ0dW5lc1wiLCBuLkNvbmZpZyA9IFwiY29uZmlnXCIsIG4pKShQZSB8fCB7fSksIGNuID0gLyogQF9fUFVSRV9fICovICgobikgPT4gKG4uU2hvcnRjdXQgPSBcInNob3J0Y3V0XCIsIG4uU2FuaXRpemVDb25maWcgPSBcInNhbml0aXplXCIsIG4pKShjbiB8fCB7fSksIHBlID0gLyogQF9fUFVSRV9fICovICgobikgPT4gKG4uSXNFbmFibGVkTGluZUJyZWFrcyA9IFwiZW5hYmxlTGluZUJyZWFrc1wiLCBuLlRvb2xib3ggPSBcInRvb2xib3hcIiwgbi5Db252ZXJzaW9uQ29uZmlnID0gXCJjb252ZXJzaW9uQ29uZmlnXCIsIG4uSXNSZWFkT25seVN1cHBvcnRlZCA9IFwiaXNSZWFkT25seVN1cHBvcnRlZFwiLCBuLlBhc3RlQ29uZmlnID0gXCJwYXN0ZUNvbmZpZ1wiLCBuKSkocGUgfHwge30pLCBXZSA9IC8qIEBfX1BVUkVfXyAqLyAoKG4pID0+IChuLklzSW5saW5lID0gXCJpc0lubGluZVwiLCBuLlRpdGxlID0gXCJ0aXRsZVwiLCBuLklzUmVhZE9ubHlTdXBwb3J0ZWQgPSBcImlzUmVhZE9ubHlTdXBwb3J0ZWRcIiwgbikpKFdlIHx8IHt9KSwgbXQgPSAvKiBAX19QVVJFX18gKi8gKChuKSA9PiAobi5Jc1R1bmUgPSBcImlzVHVuZVwiLCBuKSkobXQgfHwge30pO1xuY2xhc3MgVHQge1xuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3JPcHRpb25zfSBvcHRpb25zIC0gQ29uc3RydWN0b3Igb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIG5hbWU6IGUsXG4gICAgY29uc3RydWN0YWJsZTogdCxcbiAgICBjb25maWc6IG8sXG4gICAgYXBpOiBpLFxuICAgIGlzRGVmYXVsdDogcyxcbiAgICBpc0ludGVybmFsOiByID0gITEsXG4gICAgZGVmYXVsdFBsYWNlaG9sZGVyOiBhXG4gIH0pIHtcbiAgICB0aGlzLmFwaSA9IGksIHRoaXMubmFtZSA9IGUsIHRoaXMuY29uc3RydWN0YWJsZSA9IHQsIHRoaXMuY29uZmlnID0gbywgdGhpcy5pc0RlZmF1bHQgPSBzLCB0aGlzLmlzSW50ZXJuYWwgPSByLCB0aGlzLmRlZmF1bHRQbGFjZWhvbGRlciA9IGE7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgVG9vbCB1c2VyIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGdldCBzZXR0aW5ncygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jb25maWcuY29uZmlnIHx8IHt9O1xuICAgIHJldHVybiB0aGlzLmlzRGVmYXVsdCAmJiAhKFwicGxhY2Vob2xkZXJcIiBpbiBlKSAmJiB0aGlzLmRlZmF1bHRQbGFjZWhvbGRlciAmJiAoZS5wbGFjZWhvbGRlciA9IHRoaXMuZGVmYXVsdFBsYWNlaG9sZGVyKSwgZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbHMgVG9vbCdzIHJlc2V0IG1ldGhvZFxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgaWYgKEEodGhpcy5jb25zdHJ1Y3RhYmxlLnJlc2V0KSlcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdGFibGUucmVzZXQoKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbHMgVG9vbCdzIHByZXBhcmUgbWV0aG9kXG4gICAqL1xuICBwcmVwYXJlKCkge1xuICAgIGlmIChBKHRoaXMuY29uc3RydWN0YWJsZS5wcmVwYXJlKSlcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdGFibGUucHJlcGFyZSh7XG4gICAgICAgIHRvb2xOYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIGNvbmZpZzogdGhpcy5zZXR0aW5nc1xuICAgICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgc2hvcnRjdXQgZm9yIFRvb2wgKGludGVybmFsIG9yIHNwZWNpZmllZCBieSB1c2VyKVxuICAgKi9cbiAgZ2V0IHNob3J0Y3V0KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmNvbnN0cnVjdGFibGUuc2hvcnRjdXQ7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnNob3J0Y3V0IHx8IGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgVG9vbCdzIHNhbml0aXplciBjb25maWd1cmF0aW9uXG4gICAqL1xuICBnZXQgc2FuaXRpemVDb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0YWJsZS5zYW5pdGl6ZSB8fCB7fTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIFRvb2xzIGlzIGlubGluZVxuICAgKi9cbiAgaXNJbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gYWUuSW5saW5lO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgVG9vbHMgaXMgYmxvY2tcbiAgICovXG4gIGlzQmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gYWUuQmxvY2s7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBUb29scyBpcyB0dW5lXG4gICAqL1xuICBpc1R1bmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gYWUuVHVuZTtcbiAgfVxufVxuY2xhc3MgQ3MgZXh0ZW5kcyBFIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uIC0gTW9kdWxlIENvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIG1vZHVsZUNvbmZpZ3VyYXRpb24uY29uZmlnIC0gRWRpdG9yJ3MgY29uZmlnXG4gICAqIEBwYXJhbSBtb2R1bGVDb25maWd1cmF0aW9uLmV2ZW50c0Rpc3BhdGNoZXIgLSBFZGl0b3IncyBldmVudCBkaXNwYXRjaGVyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGNvbmZpZzogZSwgZXZlbnRzRGlzcGF0Y2hlcjogdCB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnOiBlLFxuICAgICAgZXZlbnRzRGlzcGF0Y2hlcjogdFxuICAgIH0pLCB0aGlzLkNTUyA9IHtcbiAgICAgIGlubGluZVRvb2xiYXI6IFwiY2UtaW5saW5lLXRvb2xiYXJcIlxuICAgIH0sIHRoaXMub3BlbmVkID0gITEsIHRoaXMucG9wb3ZlciA9IG51bGwsIHRoaXMudG9vbGJhclZlcnRpY2FsTWFyZ2luID0gYmUoKSA/IDIwIDogNiwgdGhpcy50b29scyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIHRoaXMubWFrZSgpO1xuICAgIH0sIHsgdGltZW91dDogMmUzIH0pO1xuICB9XG4gIC8qKlxuICAgKiAgTW92aW5nIC8gYXBwZWFyYW5jZVxuICAgKiAgfn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+flxuICAgKi9cbiAgLyoqXG4gICAqIFNob3dzIElubGluZSBUb29sYmFyIGlmIHNvbWV0aGluZyBpcyBzZWxlY3RlZFxuICAgKlxuICAgKiBAcGFyYW0gW25lZWRUb0Nsb3NlXSAtIHBhc3MgdHJ1ZSB0byBjbG9zZSB0b29sYmFyIGlmIGl0IGlzIG5vdCBhbGxvd2VkLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBdm9pZCB0byB1c2UgaXQganVzdCBmb3IgY2xvc2luZyBJVCwgYmV0dGVyIGNhbGwgLmNsb3NlKCkgY2xlYXJseS5cbiAgICovXG4gIGFzeW5jIHRyeVRvU2hvdyhlID0gITEpIHtcbiAgICBlICYmIHRoaXMuY2xvc2UoKSwgdGhpcy5hbGxvd2VkVG9TaG93KCkgJiYgKGF3YWl0IHRoaXMub3BlbigpLCB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCkpO1xuICB9XG4gIC8qKlxuICAgKiBIaWRlcyBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdmFyIGUsIHQ7XG4gICAgaWYgKHRoaXMub3BlbmVkKSB7XG4gICAgICBmb3IgKGNvbnN0IFtvLCBpXSBvZiB0aGlzLnRvb2xzKSB7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLmdldFRvb2xTaG9ydGN1dChvLm5hbWUpO1xuICAgICAgICBzICE9PSB2b2lkIDAgJiYgZ2UucmVtb3ZlKHRoaXMuRWRpdG9yLlVJLm5vZGVzLnJlZGFjdG9yLCBzKSwgQShpLmNsZWFyKSAmJiBpLmNsZWFyKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRvb2xzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5yZXNldCgpLCB0aGlzLm9wZW5lZCA9ICExLCAoZSA9IHRoaXMucG9wb3ZlcikgPT0gbnVsbCB8fCBlLmhpZGUoKSwgKHQgPSB0aGlzLnBvcG92ZXIpID09IG51bGwgfHwgdC5kZXN0cm95KCksIHRoaXMucG9wb3ZlciA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiBub2RlIGlzIGNvbnRhaW5lZCBieSBJbmxpbmUgVG9vbGJhclxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUg4oCUIG5vZGUgdG8gY2hlY2tcbiAgICovXG4gIGNvbnRhaW5zTm9kZShlKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMud3JhcHBlciA9PT0gdm9pZCAwID8gITEgOiB0aGlzLm5vZGVzLndyYXBwZXIuY29udGFpbnMoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgVUkgYW5kIGl0cyBjb21wb25lbnRzXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHZhciBlO1xuICAgIHRoaXMucmVtb3ZlQWxsTm9kZXMoKSwgKGUgPSB0aGlzLnBvcG92ZXIpID09IG51bGwgfHwgZS5kZXN0cm95KCksIHRoaXMucG9wb3ZlciA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2luZyBET01cbiAgICovXG4gIG1ha2UoKSB7XG4gICAgdGhpcy5ub2Rlcy53cmFwcGVyID0gZC5tYWtlKFwiZGl2XCIsIFtcbiAgICAgIHRoaXMuQ1NTLmlubGluZVRvb2xiYXIsXG4gICAgICAuLi50aGlzLmlzUnRsID8gW3RoaXMuRWRpdG9yLlVJLkNTUy5lZGl0b3JSdGxGaXhdIDogW11cbiAgICBdKSwgdGhpcy5ub2Rlcy53cmFwcGVyLnNldEF0dHJpYnV0ZShcImRhdGEtY3lcIiwgXCJpbmxpbmUtdG9vbGJhclwiKSwgZC5hcHBlbmQodGhpcy5FZGl0b3IuVUkubm9kZXMud3JhcHBlciwgdGhpcy5ub2Rlcy53cmFwcGVyKTtcbiAgfVxuICAvKipcbiAgICogU2hvd3MgSW5saW5lIFRvb2xiYXJcbiAgICovXG4gIGFzeW5jIG9wZW4oKSB7XG4gICAgdmFyIHQ7XG4gICAgaWYgKHRoaXMub3BlbmVkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMub3BlbmVkID0gITAsIHRoaXMucG9wb3ZlciAhPT0gbnVsbCAmJiB0aGlzLnBvcG92ZXIuZGVzdHJveSgpLCB0aGlzLmNyZWF0ZVRvb2xzSW5zdGFuY2VzKCk7XG4gICAgY29uc3QgZSA9IGF3YWl0IHRoaXMuZ2V0UG9wb3Zlckl0ZW1zKCk7XG4gICAgdGhpcy5wb3BvdmVyID0gbmV3IGhzKHtcbiAgICAgIGl0ZW1zOiBlLFxuICAgICAgc2NvcGVFbGVtZW50OiB0aGlzLkVkaXRvci5BUEkubWV0aG9kcy51aS5ub2Rlcy5yZWRhY3RvcixcbiAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgIG5vdGhpbmdGb3VuZDogei51aShLLnVpLnBvcG92ZXIsIFwiTm90aGluZyBmb3VuZFwiKSxcbiAgICAgICAgc2VhcmNoOiB6LnVpKEsudWkucG9wb3ZlciwgXCJGaWx0ZXJcIilcbiAgICAgIH1cbiAgICB9KSwgdGhpcy5tb3ZlKHRoaXMucG9wb3Zlci5zaXplLndpZHRoKSwgKHQgPSB0aGlzLm5vZGVzLndyYXBwZXIpID09IG51bGwgfHwgdC5hcHBlbmQodGhpcy5wb3BvdmVyLmdldEVsZW1lbnQoKSksIHRoaXMucG9wb3Zlci5zaG93KCk7XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgVG9vbGJhciB0byB0aGUgc2VsZWN0ZWQgdGV4dFxuICAgKlxuICAgKiBAcGFyYW0gcG9wb3ZlcldpZHRoIC0gd2lkdGggb2YgdGhlIHRvb2xiYXIgcG9wb3ZlclxuICAgKi9cbiAgbW92ZShlKSB7XG4gICAgY29uc3QgdCA9IGIucmVjdCwgbyA9IHRoaXMuRWRpdG9yLlVJLm5vZGVzLndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGkgPSB7XG4gICAgICB4OiB0LnggLSBvLngsXG4gICAgICB5OiB0LnkgKyB0LmhlaWdodCAtIC8vICsgd2luZG93LnNjcm9sbFlcbiAgICAgIG8udG9wICsgdGhpcy50b29sYmFyVmVydGljYWxNYXJnaW5cbiAgICB9O1xuICAgIGkueCArIGUgKyBvLnggPiB0aGlzLkVkaXRvci5VSS5jb250ZW50UmVjdC5yaWdodCAmJiAoaS54ID0gdGhpcy5FZGl0b3IuVUkuY29udGVudFJlY3QucmlnaHQgLSBlIC0gby54KSwgdGhpcy5ub2Rlcy53cmFwcGVyLnN0eWxlLmxlZnQgPSBNYXRoLmZsb29yKGkueCkgKyBcInB4XCIsIHRoaXMubm9kZXMud3JhcHBlci5zdHlsZS50b3AgPSBNYXRoLmZsb29yKGkueSkgKyBcInB4XCI7XG4gIH1cbiAgLyoqXG4gICAqIENsZWFyIG9yaWVudGF0aW9uIGNsYXNzZXMgYW5kIHJlc2V0IHBvc2l0aW9uXG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLm5vZGVzLndyYXBwZXIuc3R5bGUubGVmdCA9IFwiMFwiLCB0aGlzLm5vZGVzLndyYXBwZXIuc3R5bGUudG9wID0gXCIwXCI7XG4gIH1cbiAgLyoqXG4gICAqIE5lZWQgdG8gc2hvdyBJbmxpbmUgVG9vbGJhciBvciBub3RcbiAgICovXG4gIGFsbG93ZWRUb1Nob3coKSB7XG4gICAgY29uc3QgZSA9IFtcIklNR1wiLCBcIklOUFVUXCJdLCB0ID0gYi5nZXQoKSwgbyA9IGIudGV4dDtcbiAgICBpZiAoIXQgfHwgIXQuYW5jaG9yTm9kZSB8fCB0LmlzQ29sbGFwc2VkIHx8IG8ubGVuZ3RoIDwgMSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBpID0gZC5pc0VsZW1lbnQodC5hbmNob3JOb2RlKSA/IHQuYW5jaG9yTm9kZSA6IHQuYW5jaG9yTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIGlmIChpID09PSBudWxsIHx8IHQgIT09IG51bGwgJiYgZS5pbmNsdWRlcyhpLnRhZ05hbWUpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHMgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2sodC5hbmNob3JOb2RlKTtcbiAgICByZXR1cm4gIXMgfHwgdGhpcy5nZXRUb29scygpLnNvbWUoKGMpID0+IHMudG9vbC5pbmxpbmVUb29scy5oYXMoYy5uYW1lKSkgPT09ICExID8gITEgOiBpLmNsb3Nlc3QoXCJbY29udGVudGVkaXRhYmxlXVwiKSAhPT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogIFdvcmtpbmcgd2l0aCBUb29sc1xuICAgKiAgfn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+flxuICAgKi9cbiAgLyoqXG4gICAqIFJldHVybnMgdG9vbHMgdGhhdCBhcmUgYXZhaWxhYmxlIGZvciBjdXJyZW50IGJsb2NrXG4gICAqXG4gICAqIFVzZWQgdG8gY2hlY2sgaWYgSW5saW5lIFRvb2xiYXIgY291bGQgYmUgc2hvd25cbiAgICogYW5kIHRvIHJlbmRlciB0b29scyBpbiB0aGUgSW5saW5lIFRvb2xiYXJcbiAgICovXG4gIGdldFRvb2xzKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrO1xuICAgIHJldHVybiBlID8gQXJyYXkuZnJvbShlLnRvb2wuaW5saW5lVG9vbHMudmFsdWVzKCkpLmZpbHRlcigobykgPT4gISh0aGlzLkVkaXRvci5SZWFkT25seS5pc0VuYWJsZWQgJiYgby5pc1JlYWRPbmx5U3VwcG9ydGVkICE9PSAhMCkpIDogW107XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgdG9vbHMgaW5zdGFuY2VzIGFuZCBzYXZlcyB0aGVtIHRvIHRoaXMudG9vbHNcbiAgICovXG4gIGNyZWF0ZVRvb2xzSW5zdGFuY2VzKCkge1xuICAgIHRoaXMudG9vbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLmdldFRvb2xzKCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgbyA9IHQuY3JlYXRlKCk7XG4gICAgICB0aGlzLnRvb2xzLnNldCh0LCBvKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBQb3BvdmVyIEl0ZW1zIGZvciB0b29scyBzZWdyZWdhdGVkIGJ5IHRoZWlyIGFwcGVhcmFuY2UgdHlwZTogcmVndWxhciBpdGVtcyBhbmQgY3VzdG9tIGh0bWwgZWxlbWVudHMuXG4gICAqL1xuICBhc3luYyBnZXRQb3BvdmVySXRlbXMoKSB7XG4gICAgY29uc3QgZSA9IFtdO1xuICAgIGxldCB0ID0gMDtcbiAgICBmb3IgKGNvbnN0IFtvLCBpXSBvZiB0aGlzLnRvb2xzKSB7XG4gICAgICBjb25zdCBzID0gYXdhaXQgaS5yZW5kZXIoKSwgciA9IHRoaXMuZ2V0VG9vbFNob3J0Y3V0KG8ubmFtZSk7XG4gICAgICBpZiAociAhPT0gdm9pZCAwKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlU2hvcnRjdXRzKG8ubmFtZSwgcik7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICB9XG4gICAgICBjb25zdCBhID0gciAhPT0gdm9pZCAwID8gdnQocikgOiB2b2lkIDAsIGwgPSB6LnQoXG4gICAgICAgIEsudG9vbE5hbWVzLFxuICAgICAgICBvLnRpdGxlIHx8IGplKG8ubmFtZSlcbiAgICAgICk7XG4gICAgICBbc10uZmxhdCgpLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgdmFyIGgsIHA7XG4gICAgICAgIGNvbnN0IHUgPSB7XG4gICAgICAgICAgbmFtZTogby5uYW1lLFxuICAgICAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudG9vbENsaWNrZWQoaSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBoaW50OiB7XG4gICAgICAgICAgICB0aXRsZTogbCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBhXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZC5pc0VsZW1lbnQoYykpIHtcbiAgICAgICAgICBjb25zdCBnID0ge1xuICAgICAgICAgICAgLi4udSxcbiAgICAgICAgICAgIGVsZW1lbnQ6IGMsXG4gICAgICAgICAgICB0eXBlOiBfLkh0bWxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChBKGkucmVuZGVyQWN0aW9ucykpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBpLnJlbmRlckFjdGlvbnMoKTtcbiAgICAgICAgICAgIGcuY2hpbGRyZW4gPSB7XG4gICAgICAgICAgICAgIGlzT3BlbjogKGggPSBpLmNoZWNrU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBoLmNhbGwoaSwgYi5nZXQoKSksXG4gICAgICAgICAgICAgIC8qKiBEaXNhYmxlIGtleWJvYXJkIG5hdmlnYXRpb24gaW4gYWN0aW9ucywgYXMgaXQgbWlnaHQgY29uZmxpY3Qgd2l0aCBlbnRlciBwcmVzcyBoYW5kbGluZyAqL1xuICAgICAgICAgICAgICBpc0ZsaXBwYWJsZTogITEsXG4gICAgICAgICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXy5IdG1sLFxuICAgICAgICAgICAgICAgICAgZWxlbWVudDogZlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIChwID0gaS5jaGVja1N0YXRlKSA9PSBudWxsIHx8IHAuY2FsbChpLCBiLmdldCgpKTtcbiAgICAgICAgICBlLnB1c2goZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYy50eXBlID09PSBfLkh0bWwpXG4gICAgICAgICAgZS5wdXNoKHtcbiAgICAgICAgICAgIC4uLnUsXG4gICAgICAgICAgICAuLi5jLFxuICAgICAgICAgICAgdHlwZTogXy5IdG1sXG4gICAgICAgICAgfSk7XG4gICAgICAgIGVsc2UgaWYgKGMudHlwZSA9PT0gXy5TZXBhcmF0b3IpXG4gICAgICAgICAgZS5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IF8uU2VwYXJhdG9yXG4gICAgICAgICAgfSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGcgPSB7XG4gICAgICAgICAgICAuLi51LFxuICAgICAgICAgICAgLi4uYyxcbiAgICAgICAgICAgIHR5cGU6IF8uRGVmYXVsdFxuICAgICAgICAgIH07XG4gICAgICAgICAgXCJjaGlsZHJlblwiIGluIGcgJiYgdCAhPT0gMCAmJiBlLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXy5TZXBhcmF0b3JcbiAgICAgICAgICB9KSwgZS5wdXNoKGcpLCBcImNoaWxkcmVuXCIgaW4gZyAmJiB0IDwgdGhpcy50b29scy5zaXplIC0gMSAmJiBlLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXy5TZXBhcmF0b3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksIHQrKztcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBzaG9ydGN1dCBuYW1lIGZvciB0b29sXG4gICAqXG4gICAqIEBwYXJhbSB0b29sTmFtZSDigJQgVG9vbCBuYW1lXG4gICAqL1xuICBnZXRUb29sU2hvcnRjdXQoZSkge1xuICAgIGNvbnN0IHsgVG9vbHM6IHQgfSA9IHRoaXMuRWRpdG9yLCBvID0gdC5pbmxpbmVUb29scy5nZXQoZSksIGkgPSB0LmludGVybmFsLmlubGluZVRvb2xzO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGkua2V5cygpKS5pbmNsdWRlcyhlKSA/IHRoaXMuaW5saW5lVG9vbHNbZV1bY24uU2hvcnRjdXRdIDogbyA9PSBudWxsID8gdm9pZCAwIDogby5zaG9ydGN1dDtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIFRvb2wgc2hvcnRjdXQgd2l0aCBFZGl0b3IgU2hvcnRjdXRzIE1vZHVsZVxuICAgKlxuICAgKiBAcGFyYW0gdG9vbE5hbWUgLSB0b29sIG5hbWVcbiAgICogQHBhcmFtIHNob3J0Y3V0IC0gc2hvcnRjdXQgYWNjb3JkaW5nIHRvIHRoZSBTaG9ydGN1dERhdGEgTW9kdWxlIGZvcm1hdFxuICAgKi9cbiAgZW5hYmxlU2hvcnRjdXRzKGUsIHQpIHtcbiAgICBnZS5hZGQoe1xuICAgICAgbmFtZTogdCxcbiAgICAgIGhhbmRsZXI6IChvKSA9PiB7XG4gICAgICAgIHZhciBzO1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRCbG9jazogaSB9ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyO1xuICAgICAgICBpICYmIGkudG9vbC5lbmFibGVkSW5saW5lVG9vbHMgJiYgKG8ucHJldmVudERlZmF1bHQoKSwgKHMgPSB0aGlzLnBvcG92ZXIpID09IG51bGwgfHwgcy5hY3RpdmF0ZUl0ZW1CeU5hbWUoZSkpO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogV2UgbmVlZCB0byBiaW5kIHNob3J0Y3V0IHRvIHRoZSBkb2N1bWVudCB0byBtYWtlIGl0IHdvcmsgaW4gcmVhZC1vbmx5IG1vZGVcbiAgICAgICAqL1xuICAgICAgb246IGRvY3VtZW50XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIElubGluZSBUb29sIGJ1dHRvbiBjbGlja3NcbiAgICpcbiAgICogQHBhcmFtIHRvb2wgLSBUb29sJ3MgaW5zdGFuY2VcbiAgICovXG4gIHRvb2xDbGlja2VkKGUpIHtcbiAgICB2YXIgbztcbiAgICBjb25zdCB0ID0gYi5yYW5nZTtcbiAgICAobyA9IGUuc3Vycm91bmQpID09IG51bGwgfHwgby5jYWxsKGUsIHQpLCB0aGlzLmNoZWNrVG9vbHNTdGF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBUb29sc2Agc3RhdGUgYnkgc2VsZWN0aW9uXG4gICAqL1xuICBjaGVja1Rvb2xzU3RhdGUoKSB7XG4gICAgdmFyIGU7XG4gICAgKGUgPSB0aGlzLnRvb2xzKSA9PSBudWxsIHx8IGUuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdmFyIG87XG4gICAgICAobyA9IHQuY2hlY2tTdGF0ZSkgPT0gbnVsbCB8fCBvLmNhbGwodCwgYi5nZXQoKSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmxpbmUgdG9vbHMgdG9vbHNcbiAgICogVG9vbHMgdGhhdCBoYXMgaXNJbmxpbmUgaXMgdHJ1ZVxuICAgKi9cbiAgZ2V0IGlubGluZVRvb2xzKCkge1xuICAgIGNvbnN0IGUgPSB7fTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLkVkaXRvci5Ub29scy5pbmxpbmVUb29scy5lbnRyaWVzKCkpLmZvckVhY2goKFt0LCBvXSkgPT4ge1xuICAgICAgZVt0XSA9IG8uY3JlYXRlKCk7XG4gICAgfSksIGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGRuKCkge1xuICBjb25zdCBuID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICBpZiAobiA9PT0gbnVsbClcbiAgICByZXR1cm4gW251bGwsIDBdO1xuICBsZXQgZSA9IG4uZm9jdXNOb2RlLCB0ID0gbi5mb2N1c09mZnNldDtcbiAgcmV0dXJuIGUgPT09IG51bGwgPyBbbnVsbCwgMF0gOiAoZS5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREUgJiYgZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDAgJiYgKGUuY2hpbGROb2Rlc1t0XSA/IChlID0gZS5jaGlsZE5vZGVzW3RdLCB0ID0gMCkgOiAoZSA9IGUuY2hpbGROb2Rlc1t0IC0gMV0sIHQgPSBlLnRleHRDb250ZW50Lmxlbmd0aCkpLCBbZSwgdF0pO1xufVxuZnVuY3Rpb24gdW4obiwgZSwgdCwgbykge1xuICBjb25zdCBpID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgbyA9PT0gXCJsZWZ0XCIgPyAoaS5zZXRTdGFydChuLCAwKSwgaS5zZXRFbmQoZSwgdCkpIDogKGkuc2V0U3RhcnQoZSwgdCksIGkuc2V0RW5kKG4sIG4uY2hpbGROb2Rlcy5sZW5ndGgpKTtcbiAgY29uc3QgcyA9IGkuY2xvbmVDb250ZW50cygpLCByID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgci5hcHBlbmRDaGlsZChzKTtcbiAgY29uc3QgYSA9IHIudGV4dENvbnRlbnQgfHwgXCJcIjtcbiAgcmV0dXJuIGFpKGEpO1xufVxuZnVuY3Rpb24gTmUobikge1xuICBjb25zdCBlID0gZC5nZXREZWVwZXN0Tm9kZShuKTtcbiAgaWYgKGUgPT09IG51bGwgfHwgZC5pc0VtcHR5KG4pKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKGQuaXNOYXRpdmVJbnB1dChlKSlcbiAgICByZXR1cm4gZS5zZWxlY3Rpb25FbmQgPT09IDA7XG4gIGlmIChkLmlzRW1wdHkobikpXG4gICAgcmV0dXJuICEwO1xuICBjb25zdCBbdCwgb10gPSBkbigpO1xuICByZXR1cm4gdCA9PT0gbnVsbCA/ICExIDogdW4obiwgdCwgbywgXCJsZWZ0XCIpO1xufVxuZnVuY3Rpb24gUmUobikge1xuICBjb25zdCBlID0gZC5nZXREZWVwZXN0Tm9kZShuLCAhMCk7XG4gIGlmIChlID09PSBudWxsKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKGQuaXNOYXRpdmVJbnB1dChlKSlcbiAgICByZXR1cm4gZS5zZWxlY3Rpb25FbmQgPT09IGUudmFsdWUubGVuZ3RoO1xuICBjb25zdCBbdCwgb10gPSBkbigpO1xuICByZXR1cm4gdCA9PT0gbnVsbCA/ICExIDogdW4obiwgdCwgbywgXCJyaWdodFwiKTtcbn1cbnZhciBobiA9IHt9LCBTdCA9IHt9LCBYZSA9IHt9LCBkZSA9IHt9LCBJdCA9IHt9LCBPdCA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE90LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5PdC5hbGxJbnB1dHNTZWxlY3RvciA9IFRzO1xuZnVuY3Rpb24gVHMoKSB7XG4gIHZhciBuID0gW1widGV4dFwiLCBcInBhc3N3b3JkXCIsIFwiZW1haWxcIiwgXCJudW1iZXJcIiwgXCJzZWFyY2hcIiwgXCJ0ZWxcIiwgXCJ1cmxcIl07XG4gIHJldHVybiBcIltjb250ZW50ZWRpdGFibGU9dHJ1ZV0sIHRleHRhcmVhLCBpbnB1dDpub3QoW3R5cGVdKSwgXCIgKyBuLm1hcChmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuICdpbnB1dFt0eXBlPVwiJy5jb25jYXQoZSwgJ1wiXScpO1xuICB9KS5qb2luKFwiLCBcIik7XG59XG4oZnVuY3Rpb24obikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBuLmFsbElucHV0c1NlbGVjdG9yID0gdm9pZCAwO1xuICB2YXIgZSA9IE90O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJhbGxJbnB1dHNTZWxlY3RvclwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmFsbElucHV0c1NlbGVjdG9yO1xuICB9IH0pO1xufSkoSXQpO1xudmFyIHVlID0ge30sIF90ID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX3QsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbl90LmlzTmF0aXZlSW5wdXQgPSBTcztcbmZ1bmN0aW9uIFNzKG4pIHtcbiAgdmFyIGUgPSBbXG4gICAgXCJJTlBVVFwiLFxuICAgIFwiVEVYVEFSRUFcIlxuICBdO1xuICByZXR1cm4gbiAmJiBuLnRhZ05hbWUgPyBlLmluY2x1ZGVzKG4udGFnTmFtZSkgOiAhMTtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uaXNOYXRpdmVJbnB1dCA9IHZvaWQgMDtcbiAgdmFyIGUgPSBfdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiaXNOYXRpdmVJbnB1dFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmlzTmF0aXZlSW5wdXQ7XG4gIH0gfSk7XG59KSh1ZSk7XG52YXIgcG4gPSB7fSwgTXQgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuTXQuYXBwZW5kID0gSXM7XG5mdW5jdGlvbiBJcyhuLCBlKSB7XG4gIEFycmF5LmlzQXJyYXkoZSkgPyBlLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgIG4uYXBwZW5kQ2hpbGQodCk7XG4gIH0pIDogbi5hcHBlbmRDaGlsZChlKTtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uYXBwZW5kID0gdm9pZCAwO1xuICB2YXIgZSA9IE10O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJhcHBlbmRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5hcHBlbmQ7XG4gIH0gfSk7XG59KShwbik7XG52YXIgQXQgPSB7fSwgTHQgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuTHQuYmxvY2tFbGVtZW50cyA9IE9zO1xuZnVuY3Rpb24gT3MoKSB7XG4gIHJldHVybiBbXG4gICAgXCJhZGRyZXNzXCIsXG4gICAgXCJhcnRpY2xlXCIsXG4gICAgXCJhc2lkZVwiLFxuICAgIFwiYmxvY2txdW90ZVwiLFxuICAgIFwiY2FudmFzXCIsXG4gICAgXCJkaXZcIixcbiAgICBcImRsXCIsXG4gICAgXCJkdFwiLFxuICAgIFwiZmllbGRzZXRcIixcbiAgICBcImZpZ2NhcHRpb25cIixcbiAgICBcImZpZ3VyZVwiLFxuICAgIFwiZm9vdGVyXCIsXG4gICAgXCJmb3JtXCIsXG4gICAgXCJoMVwiLFxuICAgIFwiaDJcIixcbiAgICBcImgzXCIsXG4gICAgXCJoNFwiLFxuICAgIFwiaDVcIixcbiAgICBcImg2XCIsXG4gICAgXCJoZWFkZXJcIixcbiAgICBcImhncm91cFwiLFxuICAgIFwiaHJcIixcbiAgICBcImxpXCIsXG4gICAgXCJtYWluXCIsXG4gICAgXCJuYXZcIixcbiAgICBcIm5vc2NyaXB0XCIsXG4gICAgXCJvbFwiLFxuICAgIFwib3V0cHV0XCIsXG4gICAgXCJwXCIsXG4gICAgXCJwcmVcIixcbiAgICBcInJ1YnlcIixcbiAgICBcInNlY3Rpb25cIixcbiAgICBcInRhYmxlXCIsXG4gICAgXCJ0Ym9keVwiLFxuICAgIFwidGhlYWRcIixcbiAgICBcInRyXCIsXG4gICAgXCJ0Zm9vdFwiLFxuICAgIFwidWxcIixcbiAgICBcInZpZGVvXCJcbiAgXTtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uYmxvY2tFbGVtZW50cyA9IHZvaWQgMDtcbiAgdmFyIGUgPSBMdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiYmxvY2tFbGVtZW50c1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmJsb2NrRWxlbWVudHM7XG4gIH0gfSk7XG59KShBdCk7XG52YXIgZm4gPSB7fSwgUHQgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuUHQuY2FsY3VsYXRlQmFzZWxpbmUgPSBfcztcbmZ1bmN0aW9uIF9zKG4pIHtcbiAgdmFyIGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShuKSwgdCA9IHBhcnNlRmxvYXQoZS5mb250U2l6ZSksIG8gPSBwYXJzZUZsb2F0KGUubGluZUhlaWdodCkgfHwgdCAqIDEuMiwgaSA9IHBhcnNlRmxvYXQoZS5wYWRkaW5nVG9wKSwgcyA9IHBhcnNlRmxvYXQoZS5ib3JkZXJUb3BXaWR0aCksIHIgPSBwYXJzZUZsb2F0KGUubWFyZ2luVG9wKSwgYSA9IHQgKiAwLjgsIGwgPSAobyAtIHQpIC8gMiwgYyA9IHIgKyBzICsgaSArIGwgKyBhO1xuICByZXR1cm4gYztcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uY2FsY3VsYXRlQmFzZWxpbmUgPSB2b2lkIDA7XG4gIHZhciBlID0gUHQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImNhbGN1bGF0ZUJhc2VsaW5lXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuY2FsY3VsYXRlQmFzZWxpbmU7XG4gIH0gfSk7XG59KShmbik7XG52YXIgZ24gPSB7fSwgTnQgPSB7fSwgUnQgPSB7fSwgRHQgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuRHQuaXNDb250ZW50RWRpdGFibGUgPSBNcztcbmZ1bmN0aW9uIE1zKG4pIHtcbiAgcmV0dXJuIG4uY29udGVudEVkaXRhYmxlID09PSBcInRydWVcIjtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uaXNDb250ZW50RWRpdGFibGUgPSB2b2lkIDA7XG4gIHZhciBlID0gRHQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImlzQ29udGVudEVkaXRhYmxlXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuaXNDb250ZW50RWRpdGFibGU7XG4gIH0gfSk7XG59KShSdCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTnQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbk50LmNhblNldENhcmV0ID0gUHM7XG52YXIgQXMgPSB1ZSwgTHMgPSBSdDtcbmZ1bmN0aW9uIFBzKG4pIHtcbiAgdmFyIGUgPSAhMDtcbiAgaWYgKCgwLCBBcy5pc05hdGl2ZUlucHV0KShuKSlcbiAgICBzd2l0Y2ggKG4udHlwZSkge1xuICAgICAgY2FzZSBcImZpbGVcIjpcbiAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxuICAgICAgY2FzZSBcInJhZGlvXCI6XG4gICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICBjYXNlIFwic3VibWl0XCI6XG4gICAgICBjYXNlIFwiYnV0dG9uXCI6XG4gICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgIGNhc2UgXCJyZXNldFwiOlxuICAgICAgICBlID0gITE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgZWxzZVxuICAgIGUgPSAoMCwgTHMuaXNDb250ZW50RWRpdGFibGUpKG4pO1xuICByZXR1cm4gZTtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uY2FuU2V0Q2FyZXQgPSB2b2lkIDA7XG4gIHZhciBlID0gTnQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImNhblNldENhcmV0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuY2FuU2V0Q2FyZXQ7XG4gIH0gfSk7XG59KShnbik7XG52YXIgVmUgPSB7fSwgRnQgPSB7fTtcbmZ1bmN0aW9uIE5zKG4sIGUsIHQpIHtcbiAgY29uc3QgbyA9IHQudmFsdWUgIT09IHZvaWQgMCA/IFwidmFsdWVcIiA6IFwiZ2V0XCIsIGkgPSB0W29dLCBzID0gYCMke2V9Q2FjaGVgO1xuICBpZiAodFtvXSA9IGZ1bmN0aW9uKC4uLnIpIHtcbiAgICByZXR1cm4gdGhpc1tzXSA9PT0gdm9pZCAwICYmICh0aGlzW3NdID0gaS5hcHBseSh0aGlzLCByKSksIHRoaXNbc107XG4gIH0sIG8gPT09IFwiZ2V0XCIgJiYgdC5zZXQpIHtcbiAgICBjb25zdCByID0gdC5zZXQ7XG4gICAgdC5zZXQgPSBmdW5jdGlvbihhKSB7XG4gICAgICBkZWxldGUgbltzXSwgci5hcHBseSh0aGlzLCBhKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gbW4oKSB7XG4gIGNvbnN0IG4gPSB7XG4gICAgd2luOiAhMSxcbiAgICBtYWM6ICExLFxuICAgIHgxMTogITEsXG4gICAgbGludXg6ICExXG4gIH0sIGUgPSBPYmplY3Qua2V5cyhuKS5maW5kKCh0KSA9PiB3aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb24udG9Mb3dlckNhc2UoKS5pbmRleE9mKHQpICE9PSAtMSk7XG4gIHJldHVybiBlICE9PSB2b2lkIDAgJiYgKG5bZV0gPSAhMCksIG47XG59XG5mdW5jdGlvbiBqdChuKSB7XG4gIHJldHVybiBuICE9IG51bGwgJiYgbiAhPT0gXCJcIiAmJiAodHlwZW9mIG4gIT0gXCJvYmplY3RcIiB8fCBPYmplY3Qua2V5cyhuKS5sZW5ndGggPiAwKTtcbn1cbmZ1bmN0aW9uIFJzKG4pIHtcbiAgcmV0dXJuICFqdChuKTtcbn1cbmNvbnN0IERzID0gKCkgPT4gdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5uYXZpZ2F0b3IgIT09IG51bGwgJiYganQod2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSkgJiYgKC9pUChhZHxob25lfG9kKS8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSB8fCB3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtID09PSBcIk1hY0ludGVsXCIgJiYgd2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDEpO1xuZnVuY3Rpb24gRnMobikge1xuICBjb25zdCBlID0gbW4oKTtcbiAgcmV0dXJuIG4gPSBuLnJlcGxhY2UoL3NoaWZ0L2dpLCBcIuKHp1wiKS5yZXBsYWNlKC9iYWNrc3BhY2UvZ2ksIFwi4oyrXCIpLnJlcGxhY2UoL2VudGVyL2dpLCBcIuKPjlwiKS5yZXBsYWNlKC91cC9naSwgXCLihpFcIikucmVwbGFjZSgvbGVmdC9naSwgXCLihpJcIikucmVwbGFjZSgvZG93bi9naSwgXCLihpNcIikucmVwbGFjZSgvcmlnaHQvZ2ksIFwi4oaQXCIpLnJlcGxhY2UoL2VzY2FwZS9naSwgXCLijotcIikucmVwbGFjZSgvaW5zZXJ0L2dpLCBcIkluc1wiKS5yZXBsYWNlKC9kZWxldGUvZ2ksIFwi4pChXCIpLnJlcGxhY2UoL1xcKy9naSwgXCIrXCIpLCBlLm1hYyA/IG4gPSBuLnJlcGxhY2UoL2N0cmx8Y21kL2dpLCBcIuKMmFwiKS5yZXBsYWNlKC9hbHQvZ2ksIFwi4oylXCIpIDogbiA9IG4ucmVwbGFjZSgvY21kL2dpLCBcIkN0cmxcIikucmVwbGFjZSgvd2luZG93cy9naSwgXCJXSU5cIiksIG47XG59XG5mdW5jdGlvbiBqcyhuKSB7XG4gIHJldHVybiBuWzBdLnRvVXBwZXJDYXNlKCkgKyBuLnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gSHMobikge1xuICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgZS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIiwgZS5zdHlsZS5sZWZ0ID0gXCItOTk5cHhcIiwgZS5zdHlsZS5ib3R0b20gPSBcIi05OTlweFwiLCBlLmlubmVySFRNTCA9IG4sIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZSk7XG4gIGNvbnN0IHQgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIG8gPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBpZiAoby5zZWxlY3ROb2RlKGUpLCB0ID09PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb3B5IHRleHQgdG8gY2xpcGJvYXJkXCIpO1xuICB0LnJlbW92ZUFsbFJhbmdlcygpLCB0LmFkZFJhbmdlKG8pLCBkb2N1bWVudC5leGVjQ29tbWFuZChcImNvcHlcIiksIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZSk7XG59XG5mdW5jdGlvbiAkcyhuLCBlLCB0KSB7XG4gIGxldCBvO1xuICByZXR1cm4gKC4uLmkpID0+IHtcbiAgICBjb25zdCBzID0gdGhpcywgciA9ICgpID0+IHtcbiAgICAgIG8gPSB2b2lkIDAsIHQgIT09ICEwICYmIG4uYXBwbHkocywgaSk7XG4gICAgfSwgYSA9IHQgPT09ICEwICYmIG8gIT09IHZvaWQgMDtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KG8pLCBvID0gd2luZG93LnNldFRpbWVvdXQociwgZSksIGEgJiYgbi5hcHBseShzLCBpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG9lKG4pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuKS5tYXRjaCgvXFxzKFthLXpBLVpdKykvKVsxXS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24genMobikge1xuICByZXR1cm4gb2UobikgPT09IFwiYm9vbGVhblwiO1xufVxuZnVuY3Rpb24gYm4obikge1xuICByZXR1cm4gb2UobikgPT09IFwiZnVuY3Rpb25cIiB8fCBvZShuKSA9PT0gXCJhc3luY2Z1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBVcyhuKSB7XG4gIHJldHVybiBibihuKSAmJiAvXlxccypjbGFzc1xccysvLnRlc3Qobi50b1N0cmluZygpKTtcbn1cbmZ1bmN0aW9uIFdzKG4pIHtcbiAgcmV0dXJuIG9lKG4pID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gRGUobikge1xuICByZXR1cm4gb2UobikgPT09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBZcyhuKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUobikgPT09IG47XG59XG5mdW5jdGlvbiBLcyhuKSB7XG4gIHJldHVybiBvZShuKSA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIFhzKG4pIHtcbiAgcmV0dXJuIG9lKG4pID09PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gYnQobiwgLi4uZSkge1xuICBpZiAoIWUubGVuZ3RoKVxuICAgIHJldHVybiBuO1xuICBjb25zdCB0ID0gZS5zaGlmdCgpO1xuICBpZiAoRGUobikgJiYgRGUodCkpXG4gICAgZm9yIChjb25zdCBvIGluIHQpXG4gICAgICBEZSh0W29dKSA/IChuW29dID09PSB2b2lkIDAgJiYgT2JqZWN0LmFzc2lnbihuLCB7IFtvXToge30gfSksIGJ0KG5bb10sIHRbb10pKSA6IE9iamVjdC5hc3NpZ24obiwgeyBbb106IHRbb10gfSk7XG4gIHJldHVybiBidChuLCAuLi5lKTtcbn1cbmZ1bmN0aW9uIFZzKG4sIGUsIHQpIHtcbiAgY29uc3QgbyA9IGDCqyR7ZX3CuyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHVzZSB0aGUgwqske3R9wrsgaW5zdGVhZC5gO1xuICBuICYmIGNvbnNvbGUud2FybihvKTtcbn1cbmZ1bmN0aW9uIHFzKG4pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFVSTChuKS5ocmVmO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gbi5zdWJzdHJpbmcoMCwgMikgPT09IFwiLy9cIiA/IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIG4gOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgbjtcbn1cbmZ1bmN0aW9uIFpzKG4pIHtcbiAgcmV0dXJuIG4gPiA0NyAmJiBuIDwgNTggfHwgbiA9PT0gMzIgfHwgbiA9PT0gMTMgfHwgbiA9PT0gMjI5IHx8IG4gPiA2NCAmJiBuIDwgOTEgfHwgbiA+IDk1ICYmIG4gPCAxMTIgfHwgbiA+IDE4NSAmJiBuIDwgMTkzIHx8IG4gPiAyMTggJiYgbiA8IDIyMztcbn1cbmNvbnN0IEdzID0ge1xuICBCQUNLU1BBQ0U6IDgsXG4gIFRBQjogOSxcbiAgRU5URVI6IDEzLFxuICBTSElGVDogMTYsXG4gIENUUkw6IDE3LFxuICBBTFQ6IDE4LFxuICBFU0M6IDI3LFxuICBTUEFDRTogMzIsXG4gIExFRlQ6IDM3LFxuICBVUDogMzgsXG4gIERPV046IDQwLFxuICBSSUdIVDogMzksXG4gIERFTEVURTogNDYsXG4gIE1FVEE6IDkxLFxuICBTTEFTSDogMTkxXG59LCBRcyA9IHtcbiAgTEVGVDogMCxcbiAgV0hFRUw6IDEsXG4gIFJJR0hUOiAyLFxuICBCQUNLV0FSRDogMyxcbiAgRk9SV0FSRDogNFxufTtcbmxldCBKcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb21wbGV0ZWQgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIG5ldyBwcm9taXNlIHRvIHF1ZXVlXG4gICAqIEBwYXJhbSBvcGVyYXRpb24gLSBwcm9taXNlIHNob3VsZCBiZSBhZGRlZCB0byBxdWV1ZVxuICAgKi9cbiAgYWRkKGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHQsIG8pID0+IHtcbiAgICAgIHRoaXMuY29tcGxldGVkID0gdGhpcy5jb21wbGV0ZWQudGhlbihlKS50aGVuKHQpLmNhdGNoKG8pO1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gZXIobiwgZSwgdCA9IHZvaWQgMCkge1xuICBsZXQgbywgaSwgcywgciA9IG51bGwsIGEgPSAwO1xuICB0IHx8ICh0ID0ge30pO1xuICBjb25zdCBsID0gZnVuY3Rpb24oKSB7XG4gICAgYSA9IHQubGVhZGluZyA9PT0gITEgPyAwIDogRGF0ZS5ub3coKSwgciA9IG51bGwsIHMgPSBuLmFwcGx5KG8sIGkpLCByID09PSBudWxsICYmIChvID0gaSA9IG51bGwpO1xuICB9O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgYyA9IERhdGUubm93KCk7XG4gICAgIWEgJiYgdC5sZWFkaW5nID09PSAhMSAmJiAoYSA9IGMpO1xuICAgIGNvbnN0IHUgPSBlIC0gKGMgLSBhKTtcbiAgICByZXR1cm4gbyA9IHRoaXMsIGkgPSBhcmd1bWVudHMsIHUgPD0gMCB8fCB1ID4gZSA/IChyICYmIChjbGVhclRpbWVvdXQociksIHIgPSBudWxsKSwgYSA9IGMsIHMgPSBuLmFwcGx5KG8sIGkpLCByID09PSBudWxsICYmIChvID0gaSA9IG51bGwpKSA6ICFyICYmIHQudHJhaWxpbmcgIT09ICExICYmIChyID0gc2V0VGltZW91dChsLCB1KSksIHM7XG4gIH07XG59XG5jb25zdCB0ciA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFByb21pc2VRdWV1ZTogSnMsXG4gIGJlYXV0aWZ5U2hvcnRjdXQ6IEZzLFxuICBjYWNoZWFibGU6IE5zLFxuICBjYXBpdGFsaXplOiBqcyxcbiAgY29weVRleHRUb0NsaXBib2FyZDogSHMsXG4gIGRlYm91bmNlOiAkcyxcbiAgZGVlcE1lcmdlOiBidCxcbiAgZGVwcmVjYXRpb25Bc3NlcnQ6IFZzLFxuICBnZXRVc2VyT1M6IG1uLFxuICBnZXRWYWxpZFVybDogcXMsXG4gIGlzQm9vbGVhbjogenMsXG4gIGlzQ2xhc3M6IFVzLFxuICBpc0VtcHR5OiBScyxcbiAgaXNGdW5jdGlvbjogYm4sXG4gIGlzSW9zRGV2aWNlOiBEcyxcbiAgaXNOdW1iZXI6IFdzLFxuICBpc09iamVjdDogRGUsXG4gIGlzUHJpbnRhYmxlS2V5OiBacyxcbiAgaXNQcm9taXNlOiBZcyxcbiAgaXNTdHJpbmc6IEtzLFxuICBpc1VuZGVmaW5lZDogWHMsXG4gIGtleUNvZGVzOiBHcyxcbiAgbW91c2VCdXR0b25zOiBRcyxcbiAgbm90RW1wdHk6IGp0LFxuICB0aHJvdHRsZTogZXIsXG4gIHR5cGVPZjogb2Vcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIEh0ID0gLyogQF9fUFVSRV9fICovIFhuKHRyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuRnQuY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHMgPSBpcjtcbnZhciBvciA9IEh0LCBuciA9IEF0O1xuZnVuY3Rpb24gaXIobikge1xuICB2YXIgZTtcbiAgKDAsIG9yLmlzU3RyaW5nKShuKSA/IChlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgZS5pbm5lckhUTUwgPSBuKSA6IGUgPSBuO1xuICB2YXIgdCA9IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gISgwLCBuci5ibG9ja0VsZW1lbnRzKSgpLmluY2x1ZGVzKG8udGFnTmFtZS50b0xvd2VyQ2FzZSgpKSAmJiBBcnJheS5mcm9tKG8uY2hpbGRyZW4pLmV2ZXJ5KHQpO1xuICB9O1xuICByZXR1cm4gQXJyYXkuZnJvbShlLmNoaWxkcmVuKS5ldmVyeSh0KTtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHMgPSB2b2lkIDA7XG4gIHZhciBlID0gRnQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHM7XG4gIH0gfSk7XG59KShWZSk7XG52YXIgdm4gPSB7fSwgJHQgPSB7fSwgcWUgPSB7fSwgenQgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh6dCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuenQubWFrZSA9IHNyO1xuZnVuY3Rpb24gc3IobiwgZSwgdCkge1xuICB2YXIgbztcbiAgZSA9PT0gdm9pZCAwICYmIChlID0gbnVsbCksIHQgPT09IHZvaWQgMCAmJiAodCA9IHt9KTtcbiAgdmFyIGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG4pO1xuICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgIHZhciBzID0gZS5maWx0ZXIoZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIGEgIT09IHZvaWQgMDtcbiAgICB9KTtcbiAgICAobyA9IGkuY2xhc3NMaXN0KS5hZGQuYXBwbHkobywgcyk7XG4gIH0gZWxzZVxuICAgIGUgIT09IG51bGwgJiYgaS5jbGFzc0xpc3QuYWRkKGUpO1xuICBmb3IgKHZhciByIGluIHQpXG4gICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIHIpICYmIChpW3JdID0gdFtyXSk7XG4gIHJldHVybiBpO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5tYWtlID0gdm9pZCAwO1xuICB2YXIgZSA9IHp0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJtYWtlXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUubWFrZTtcbiAgfSB9KTtcbn0pKHFlKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuJHQuZnJhZ21lbnRUb1N0cmluZyA9IGFyO1xudmFyIHJyID0gcWU7XG5mdW5jdGlvbiBhcihuKSB7XG4gIHZhciBlID0gKDAsIHJyLm1ha2UpKFwiZGl2XCIpO1xuICByZXR1cm4gZS5hcHBlbmRDaGlsZChuKSwgZS5pbm5lckhUTUw7XG59XG4oZnVuY3Rpb24obikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBuLmZyYWdtZW50VG9TdHJpbmcgPSB2b2lkIDA7XG4gIHZhciBlID0gJHQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImZyYWdtZW50VG9TdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5mcmFnbWVudFRvU3RyaW5nO1xuICB9IH0pO1xufSkodm4pO1xudmFyIGtuID0ge30sIFV0ID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcblV0LmdldENvbnRlbnRMZW5ndGggPSBjcjtcbnZhciBsciA9IHVlO1xuZnVuY3Rpb24gY3Iobikge1xuICB2YXIgZSwgdDtcbiAgcmV0dXJuICgwLCBsci5pc05hdGl2ZUlucHV0KShuKSA/IG4udmFsdWUubGVuZ3RoIDogbi5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgPyBuLmxlbmd0aCA6ICh0ID0gKGUgPSBuLnRleHRDb250ZW50KSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLmxlbmd0aCkgIT09IG51bGwgJiYgdCAhPT0gdm9pZCAwID8gdCA6IDA7XG59XG4oZnVuY3Rpb24obikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBuLmdldENvbnRlbnRMZW5ndGggPSB2b2lkIDA7XG4gIHZhciBlID0gVXQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImdldENvbnRlbnRMZW5ndGhcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5nZXRDb250ZW50TGVuZ3RoO1xuICB9IH0pO1xufSkoa24pO1xudmFyIFd0ID0ge30sIFl0ID0ge30sIElvID0gQ2UgJiYgQ2UuX19zcHJlYWRBcnJheSB8fCBmdW5jdGlvbihuLCBlLCB0KSB7XG4gIGlmICh0IHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgZm9yICh2YXIgbyA9IDAsIGkgPSBlLmxlbmd0aCwgczsgbyA8IGk7IG8rKylcbiAgICAgIChzIHx8ICEobyBpbiBlKSkgJiYgKHMgfHwgKHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLCAwLCBvKSksIHNbb10gPSBlW29dKTtcbiAgcmV0dXJuIG4uY29uY2F0KHMgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZSkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShZdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuWXQuZ2V0RGVlcGVzdEJsb2NrRWxlbWVudHMgPSB5bjtcbnZhciBkciA9IFZlO1xuZnVuY3Rpb24geW4obikge1xuICByZXR1cm4gKDAsIGRyLmNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzKShuKSA/IFtuXSA6IEFycmF5LmZyb20obi5jaGlsZHJlbikucmVkdWNlKGZ1bmN0aW9uKGUsIHQpIHtcbiAgICByZXR1cm4gSW8oSW8oW10sIGUsICEwKSwgeW4odCksICEwKTtcbiAgfSwgW10pO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5nZXREZWVwZXN0QmxvY2tFbGVtZW50cyA9IHZvaWQgMDtcbiAgdmFyIGUgPSBZdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiZ2V0RGVlcGVzdEJsb2NrRWxlbWVudHNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5nZXREZWVwZXN0QmxvY2tFbGVtZW50cztcbiAgfSB9KTtcbn0pKFd0KTtcbnZhciB3biA9IHt9LCBLdCA9IHt9LCBaZSA9IHt9LCBYdCA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5YdC5pc0xpbmVCcmVha1RhZyA9IHVyO1xuZnVuY3Rpb24gdXIobikge1xuICByZXR1cm4gW1xuICAgIFwiQlJcIixcbiAgICBcIldCUlwiXG4gIF0uaW5jbHVkZXMobi50YWdOYW1lKTtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uaXNMaW5lQnJlYWtUYWcgPSB2b2lkIDA7XG4gIHZhciBlID0gWHQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImlzTGluZUJyZWFrVGFnXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuaXNMaW5lQnJlYWtUYWc7XG4gIH0gfSk7XG59KShaZSk7XG52YXIgR2UgPSB7fSwgVnQgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuVnQuaXNTaW5nbGVUYWcgPSBocjtcbmZ1bmN0aW9uIGhyKG4pIHtcbiAgcmV0dXJuIFtcbiAgICBcIkFSRUFcIixcbiAgICBcIkJBU0VcIixcbiAgICBcIkJSXCIsXG4gICAgXCJDT0xcIixcbiAgICBcIkNPTU1BTkRcIixcbiAgICBcIkVNQkVEXCIsXG4gICAgXCJIUlwiLFxuICAgIFwiSU1HXCIsXG4gICAgXCJJTlBVVFwiLFxuICAgIFwiS0VZR0VOXCIsXG4gICAgXCJMSU5LXCIsXG4gICAgXCJNRVRBXCIsXG4gICAgXCJQQVJBTVwiLFxuICAgIFwiU09VUkNFXCIsXG4gICAgXCJUUkFDS1wiLFxuICAgIFwiV0JSXCJcbiAgXS5pbmNsdWRlcyhuLnRhZ05hbWUpO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5pc1NpbmdsZVRhZyA9IHZvaWQgMDtcbiAgdmFyIGUgPSBWdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiaXNTaW5nbGVUYWdcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5pc1NpbmdsZVRhZztcbiAgfSB9KTtcbn0pKEdlKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShLdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuS3QuZ2V0RGVlcGVzdE5vZGUgPSBFbjtcbnZhciBwciA9IHVlLCBmciA9IFplLCBnciA9IEdlO1xuZnVuY3Rpb24gRW4obiwgZSkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSAhMSk7XG4gIHZhciB0ID0gZSA/IFwibGFzdENoaWxkXCIgOiBcImZpcnN0Q2hpbGRcIiwgbyA9IGUgPyBcInByZXZpb3VzU2libGluZ1wiIDogXCJuZXh0U2libGluZ1wiO1xuICBpZiAobi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgblt0XSkge1xuICAgIHZhciBpID0gblt0XTtcbiAgICBpZiAoKDAsIGdyLmlzU2luZ2xlVGFnKShpKSAmJiAhKDAsIHByLmlzTmF0aXZlSW5wdXQpKGkpICYmICEoMCwgZnIuaXNMaW5lQnJlYWtUYWcpKGkpKVxuICAgICAgaWYgKGlbb10pXG4gICAgICAgIGkgPSBpW29dO1xuICAgICAgZWxzZSBpZiAoaS5wYXJlbnROb2RlICE9PSBudWxsICYmIGkucGFyZW50Tm9kZVtvXSlcbiAgICAgICAgaSA9IGkucGFyZW50Tm9kZVtvXTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGkucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gRW4oaSwgZSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG4oZnVuY3Rpb24obikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBuLmdldERlZXBlc3ROb2RlID0gdm9pZCAwO1xuICB2YXIgZSA9IEt0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJnZXREZWVwZXN0Tm9kZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmdldERlZXBlc3ROb2RlO1xuICB9IH0pO1xufSkod24pO1xudmFyIHhuID0ge30sIHF0ID0ge30sIE1lID0gQ2UgJiYgQ2UuX19zcHJlYWRBcnJheSB8fCBmdW5jdGlvbihuLCBlLCB0KSB7XG4gIGlmICh0IHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgZm9yICh2YXIgbyA9IDAsIGkgPSBlLmxlbmd0aCwgczsgbyA8IGk7IG8rKylcbiAgICAgIChzIHx8ICEobyBpbiBlKSkgJiYgKHMgfHwgKHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLCAwLCBvKSksIHNbb10gPSBlW29dKTtcbiAgcmV0dXJuIG4uY29uY2F0KHMgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZSkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShxdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xucXQuZmluZEFsbElucHV0cyA9IHlyO1xudmFyIG1yID0gVmUsIGJyID0gV3QsIHZyID0gSXQsIGtyID0gdWU7XG5mdW5jdGlvbiB5cihuKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKG4ucXVlcnlTZWxlY3RvckFsbCgoMCwgdnIuYWxsSW5wdXRzU2VsZWN0b3IpKCkpKS5yZWR1Y2UoZnVuY3Rpb24oZSwgdCkge1xuICAgIHJldHVybiAoMCwga3IuaXNOYXRpdmVJbnB1dCkodCkgfHwgKDAsIG1yLmNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzKSh0KSA/IE1lKE1lKFtdLCBlLCAhMCksIFt0XSwgITEpIDogTWUoTWUoW10sIGUsICEwKSwgKDAsIGJyLmdldERlZXBlc3RCbG9ja0VsZW1lbnRzKSh0KSwgITApO1xuICB9LCBbXSk7XG59XG4oZnVuY3Rpb24obikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBuLmZpbmRBbGxJbnB1dHMgPSB2b2lkIDA7XG4gIHZhciBlID0gcXQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImZpbmRBbGxJbnB1dHNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5maW5kQWxsSW5wdXRzO1xuICB9IH0pO1xufSkoeG4pO1xudmFyIEJuID0ge30sIFp0ID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoWnQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcblp0LmlzQ29sbGFwc2VkV2hpdGVzcGFjZXMgPSB3cjtcbmZ1bmN0aW9uIHdyKG4pIHtcbiAgcmV0dXJuICEvW15cXHRcXG5cXHIgXS8udGVzdChuKTtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uaXNDb2xsYXBzZWRXaGl0ZXNwYWNlcyA9IHZvaWQgMDtcbiAgdmFyIGUgPSBadDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiaXNDb2xsYXBzZWRXaGl0ZXNwYWNlc1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmlzQ29sbGFwc2VkV2hpdGVzcGFjZXM7XG4gIH0gfSk7XG59KShCbik7XG52YXIgR3QgPSB7fSwgUXQgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuUXQuaXNFbGVtZW50ID0geHI7XG52YXIgRXIgPSBIdDtcbmZ1bmN0aW9uIHhyKG4pIHtcbiAgcmV0dXJuICgwLCBFci5pc051bWJlcikobikgPyAhMSA6ICEhbiAmJiAhIW4ubm9kZVR5cGUgJiYgbi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG59XG4oZnVuY3Rpb24obikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBuLmlzRWxlbWVudCA9IHZvaWQgMDtcbiAgdmFyIGUgPSBRdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiaXNFbGVtZW50XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuaXNFbGVtZW50O1xuICB9IH0pO1xufSkoR3QpO1xudmFyIENuID0ge30sIEp0ID0ge30sIGVvID0ge30sIHRvID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkodG8sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnRvLmlzTGVhZiA9IEJyO1xuZnVuY3Rpb24gQnIobikge1xuICByZXR1cm4gbiA9PT0gbnVsbCA/ICExIDogbi5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMDtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uaXNMZWFmID0gdm9pZCAwO1xuICB2YXIgZSA9IHRvO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJpc0xlYWZcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5pc0xlYWY7XG4gIH0gfSk7XG59KShlbyk7XG52YXIgb28gPSB7fSwgbm8gPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShubywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xubm8uaXNOb2RlRW1wdHkgPSBPcjtcbnZhciBDciA9IFplLCBUciA9IEd0LCBTciA9IHVlLCBJciA9IEdlO1xuZnVuY3Rpb24gT3IobiwgZSkge1xuICB2YXIgdCA9IFwiXCI7XG4gIHJldHVybiAoMCwgSXIuaXNTaW5nbGVUYWcpKG4pICYmICEoMCwgQ3IuaXNMaW5lQnJlYWtUYWcpKG4pID8gITEgOiAoKDAsIFRyLmlzRWxlbWVudCkobikgJiYgKDAsIFNyLmlzTmF0aXZlSW5wdXQpKG4pID8gdCA9IG4udmFsdWUgOiBuLnRleHRDb250ZW50ICE9PSBudWxsICYmICh0ID0gbi50ZXh0Q29udGVudC5yZXBsYWNlKFwi4oCLXCIsIFwiXCIpKSwgZSAhPT0gdm9pZCAwICYmICh0ID0gdC5yZXBsYWNlKG5ldyBSZWdFeHAoZSwgXCJnXCIpLCBcIlwiKSksIHQudHJpbSgpLmxlbmd0aCA9PT0gMCk7XG59XG4oZnVuY3Rpb24obikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBuLmlzTm9kZUVtcHR5ID0gdm9pZCAwO1xuICB2YXIgZSA9IG5vO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJpc05vZGVFbXB0eVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmlzTm9kZUVtcHR5O1xuICB9IH0pO1xufSkob28pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEp0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5KdC5pc0VtcHR5ID0gQXI7XG52YXIgX3IgPSBlbywgTXIgPSBvbztcbmZ1bmN0aW9uIEFyKG4sIGUpIHtcbiAgbi5ub3JtYWxpemUoKTtcbiAgZm9yICh2YXIgdCA9IFtuXTsgdC5sZW5ndGggPiAwOyApIHtcbiAgICB2YXIgbyA9IHQuc2hpZnQoKTtcbiAgICBpZiAobykge1xuICAgICAgaWYgKG4gPSBvLCAoMCwgX3IuaXNMZWFmKShuKSAmJiAhKDAsIE1yLmlzTm9kZUVtcHR5KShuLCBlKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgdC5wdXNoLmFwcGx5KHQsIEFycmF5LmZyb20obi5jaGlsZE5vZGVzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAhMDtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uaXNFbXB0eSA9IHZvaWQgMDtcbiAgdmFyIGUgPSBKdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiaXNFbXB0eVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmlzRW1wdHk7XG4gIH0gfSk7XG59KShDbik7XG52YXIgVG4gPSB7fSwgaW8gPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuaW8uaXNGcmFnbWVudCA9IFByO1xudmFyIExyID0gSHQ7XG5mdW5jdGlvbiBQcihuKSB7XG4gIHJldHVybiAoMCwgTHIuaXNOdW1iZXIpKG4pID8gITEgOiAhIW4gJiYgISFuLm5vZGVUeXBlICYmIG4ubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERTtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uaXNGcmFnbWVudCA9IHZvaWQgMDtcbiAgdmFyIGUgPSBpbztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiaXNGcmFnbWVudFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmlzRnJhZ21lbnQ7XG4gIH0gfSk7XG59KShUbik7XG52YXIgU24gPSB7fSwgc28gPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzbywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuc28uaXNIVE1MU3RyaW5nID0gUnI7XG52YXIgTnIgPSBxZTtcbmZ1bmN0aW9uIFJyKG4pIHtcbiAgdmFyIGUgPSAoMCwgTnIubWFrZSkoXCJkaXZcIik7XG4gIHJldHVybiBlLmlubmVySFRNTCA9IG4sIGUuY2hpbGRFbGVtZW50Q291bnQgPiAwO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5pc0hUTUxTdHJpbmcgPSB2b2lkIDA7XG4gIHZhciBlID0gc287XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImlzSFRNTFN0cmluZ1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmlzSFRNTFN0cmluZztcbiAgfSB9KTtcbn0pKFNuKTtcbnZhciBJbiA9IHt9LCBybyA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHJvLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5yby5vZmZzZXQgPSBEcjtcbmZ1bmN0aW9uIERyKG4pIHtcbiAgdmFyIGUgPSBuLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0ID0gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LCBvID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsIGkgPSBlLnRvcCArIG8sIHMgPSBlLmxlZnQgKyB0O1xuICByZXR1cm4ge1xuICAgIHRvcDogaSxcbiAgICBsZWZ0OiBzLFxuICAgIGJvdHRvbTogaSArIGUuaGVpZ2h0LFxuICAgIHJpZ2h0OiBzICsgZS53aWR0aFxuICB9O1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5vZmZzZXQgPSB2b2lkIDA7XG4gIHZhciBlID0gcm87XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIm9mZnNldFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLm9mZnNldDtcbiAgfSB9KTtcbn0pKEluKTtcbnZhciBPbiA9IHt9LCBhbyA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGFvLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5hby5wcmVwZW5kID0gRnI7XG5mdW5jdGlvbiBGcihuLCBlKSB7XG4gIEFycmF5LmlzQXJyYXkoZSkgPyAoZSA9IGUucmV2ZXJzZSgpLCBlLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBuLnByZXBlbmQodCk7XG4gIH0pKSA6IG4ucHJlcGVuZChlKTtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4ucHJlcGVuZCA9IHZvaWQgMDtcbiAgdmFyIGUgPSBhbztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwicHJlcGVuZFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLnByZXBlbmQ7XG4gIH0gfSk7XG59KShPbik7XG4oZnVuY3Rpb24obikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBuLnByZXBlbmQgPSBuLm9mZnNldCA9IG4ubWFrZSA9IG4uaXNMaW5lQnJlYWtUYWcgPSBuLmlzU2luZ2xlVGFnID0gbi5pc05vZGVFbXB0eSA9IG4uaXNMZWFmID0gbi5pc0hUTUxTdHJpbmcgPSBuLmlzRnJhZ21lbnQgPSBuLmlzRW1wdHkgPSBuLmlzRWxlbWVudCA9IG4uaXNDb250ZW50RWRpdGFibGUgPSBuLmlzQ29sbGFwc2VkV2hpdGVzcGFjZXMgPSBuLmZpbmRBbGxJbnB1dHMgPSBuLmlzTmF0aXZlSW5wdXQgPSBuLmFsbElucHV0c1NlbGVjdG9yID0gbi5nZXREZWVwZXN0Tm9kZSA9IG4uZ2V0RGVlcGVzdEJsb2NrRWxlbWVudHMgPSBuLmdldENvbnRlbnRMZW5ndGggPSBuLmZyYWdtZW50VG9TdHJpbmcgPSBuLmNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzID0gbi5jYW5TZXRDYXJldCA9IG4uY2FsY3VsYXRlQmFzZWxpbmUgPSBuLmJsb2NrRWxlbWVudHMgPSBuLmFwcGVuZCA9IHZvaWQgMDtcbiAgdmFyIGUgPSBJdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiYWxsSW5wdXRzU2VsZWN0b3JcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5hbGxJbnB1dHNTZWxlY3RvcjtcbiAgfSB9KTtcbiAgdmFyIHQgPSB1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiaXNOYXRpdmVJbnB1dFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmlzTmF0aXZlSW5wdXQ7XG4gIH0gfSk7XG4gIHZhciBvID0gcG47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImFwcGVuZFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBvLmFwcGVuZDtcbiAgfSB9KTtcbiAgdmFyIGkgPSBBdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiYmxvY2tFbGVtZW50c1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpLmJsb2NrRWxlbWVudHM7XG4gIH0gfSk7XG4gIHZhciBzID0gZm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImNhbGN1bGF0ZUJhc2VsaW5lXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHMuY2FsY3VsYXRlQmFzZWxpbmU7XG4gIH0gfSk7XG4gIHZhciByID0gZ247XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImNhblNldENhcmV0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHIuY2FuU2V0Q2FyZXQ7XG4gIH0gfSk7XG4gIHZhciBhID0gVmU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGEuY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHM7XG4gIH0gfSk7XG4gIHZhciBsID0gdm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImZyYWdtZW50VG9TdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbC5mcmFnbWVudFRvU3RyaW5nO1xuICB9IH0pO1xuICB2YXIgYyA9IGtuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJnZXRDb250ZW50TGVuZ3RoXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGMuZ2V0Q29udGVudExlbmd0aDtcbiAgfSB9KTtcbiAgdmFyIHUgPSBXdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiZ2V0RGVlcGVzdEJsb2NrRWxlbWVudHNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdS5nZXREZWVwZXN0QmxvY2tFbGVtZW50cztcbiAgfSB9KTtcbiAgdmFyIGggPSB3bjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiZ2V0RGVlcGVzdE5vZGVcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaC5nZXREZWVwZXN0Tm9kZTtcbiAgfSB9KTtcbiAgdmFyIHAgPSB4bjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiZmluZEFsbElucHV0c1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwLmZpbmRBbGxJbnB1dHM7XG4gIH0gfSk7XG4gIHZhciBnID0gQm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImlzQ29sbGFwc2VkV2hpdGVzcGFjZXNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZy5pc0NvbGxhcHNlZFdoaXRlc3BhY2VzO1xuICB9IH0pO1xuICB2YXIgZiA9IFJ0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJpc0NvbnRlbnRFZGl0YWJsZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmLmlzQ29udGVudEVkaXRhYmxlO1xuICB9IH0pO1xuICB2YXIgdiA9IEd0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJpc0VsZW1lbnRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdi5pc0VsZW1lbnQ7XG4gIH0gfSk7XG4gIHZhciBPID0gQ247XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImlzRW1wdHlcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTy5pc0VtcHR5O1xuICB9IH0pO1xuICB2YXIgVCA9IFRuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJpc0ZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFQuaXNGcmFnbWVudDtcbiAgfSB9KTtcbiAgdmFyIE0gPSBTbjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiaXNIVE1MU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE0uaXNIVE1MU3RyaW5nO1xuICB9IH0pO1xuICB2YXIgcSA9IGVvO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJpc0xlYWZcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcS5pc0xlYWY7XG4gIH0gfSk7XG4gIHZhciBGID0gb287XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImlzTm9kZUVtcHR5XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEYuaXNOb2RlRW1wdHk7XG4gIH0gfSk7XG4gIHZhciBIID0gWmU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImlzTGluZUJyZWFrVGFnXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEguaXNMaW5lQnJlYWtUYWc7XG4gIH0gfSk7XG4gIHZhciBRID0gR2U7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImlzU2luZ2xlVGFnXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFEuaXNTaW5nbGVUYWc7XG4gIH0gfSk7XG4gIHZhciBpZSA9IHFlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJtYWtlXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGllLm1ha2U7XG4gIH0gfSk7XG4gIHZhciBrID0gSW47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIm9mZnNldFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBrLm9mZnNldDtcbiAgfSB9KTtcbiAgdmFyIG0gPSBPbjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwicHJlcGVuZFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBtLnByZXBlbmQ7XG4gIH0gfSk7XG59KShkZSk7XG52YXIgUWUgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShRZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuUWUuZ2V0Q29udGVudGVkaXRhYmxlU2xpY2UgPSBIcjtcbnZhciBqciA9IGRlO1xuZnVuY3Rpb24gSHIobiwgZSwgdCwgbywgaSkge1xuICB2YXIgcztcbiAgaSA9PT0gdm9pZCAwICYmIChpID0gITEpO1xuICB2YXIgciA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGlmIChvID09PSBcImxlZnRcIiA/IChyLnNldFN0YXJ0KG4sIDApLCByLnNldEVuZChlLCB0KSkgOiAoci5zZXRTdGFydChlLCB0KSwgci5zZXRFbmQobiwgbi5jaGlsZE5vZGVzLmxlbmd0aCkpLCBpID09PSAhMCkge1xuICAgIHZhciBhID0gci5leHRyYWN0Q29udGVudHMoKTtcbiAgICByZXR1cm4gKDAsIGpyLmZyYWdtZW50VG9TdHJpbmcpKGEpO1xuICB9XG4gIHZhciBsID0gci5jbG9uZUNvbnRlbnRzKCksIGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBjLmFwcGVuZENoaWxkKGwpO1xuICB2YXIgdSA9IChzID0gYy50ZXh0Q29udGVudCkgIT09IG51bGwgJiYgcyAhPT0gdm9pZCAwID8gcyA6IFwiXCI7XG4gIHJldHVybiB1O1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFhlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5YZS5jaGVja0NvbnRlbnRlZGl0YWJsZVNsaWNlRm9yRW1wdGluZXNzID0gVXI7XG52YXIgJHIgPSBkZSwgenIgPSBRZTtcbmZ1bmN0aW9uIFVyKG4sIGUsIHQsIG8pIHtcbiAgdmFyIGkgPSAoMCwgenIuZ2V0Q29udGVudGVkaXRhYmxlU2xpY2UpKG4sIGUsIHQsIG8pO1xuICByZXR1cm4gKDAsICRyLmlzQ29sbGFwc2VkV2hpdGVzcGFjZXMpKGkpO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5jaGVja0NvbnRlbnRlZGl0YWJsZVNsaWNlRm9yRW1wdGluZXNzID0gdm9pZCAwO1xuICB2YXIgZSA9IFhlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJjaGVja0NvbnRlbnRlZGl0YWJsZVNsaWNlRm9yRW1wdGluZXNzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuY2hlY2tDb250ZW50ZWRpdGFibGVTbGljZUZvckVtcHRpbmVzcztcbiAgfSB9KTtcbn0pKFN0KTtcbnZhciBfbiA9IHt9O1xuKGZ1bmN0aW9uKG4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgbi5nZXRDb250ZW50ZWRpdGFibGVTbGljZSA9IHZvaWQgMDtcbiAgdmFyIGUgPSBRZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiZ2V0Q29udGVudGVkaXRhYmxlU2xpY2VcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5nZXRDb250ZW50ZWRpdGFibGVTbGljZTtcbiAgfSB9KTtcbn0pKF9uKTtcbnZhciBNbiA9IHt9LCBsbyA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGxvLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5sby5mb2N1cyA9IFlyO1xudmFyIFdyID0gZGU7XG5mdW5jdGlvbiBZcihuLCBlKSB7XG4gIHZhciB0LCBvO1xuICBpZiAoZSA9PT0gdm9pZCAwICYmIChlID0gITApLCAoMCwgV3IuaXNOYXRpdmVJbnB1dCkobikpIHtcbiAgICBuLmZvY3VzKCk7XG4gICAgdmFyIGkgPSBlID8gMCA6IG4udmFsdWUubGVuZ3RoO1xuICAgIG4uc2V0U2VsZWN0aW9uUmFuZ2UoaSwgaSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHMgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLCByID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghcilcbiAgICAgIHJldHVybjtcbiAgICB2YXIgYSA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBnID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gICAgICBwLmFwcGVuZENoaWxkKGcpLCBzLnNldFN0YXJ0KGcsIDApLCBzLnNldEVuZChnLCAwKTtcbiAgICB9LCBsID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHAgIT0gbnVsbDtcbiAgICB9LCBjID0gbi5jaGlsZE5vZGVzLCB1ID0gZSA/IGNbMF0gOiBjW2MubGVuZ3RoIC0gMV07XG4gICAgaWYgKGwodSkpIHtcbiAgICAgIGZvciAoOyBsKHUpICYmIHUubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFOyApXG4gICAgICAgIHUgPSBlID8gdS5maXJzdENoaWxkIDogdS5sYXN0Q2hpbGQ7XG4gICAgICBpZiAobCh1KSAmJiB1Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICB2YXIgaCA9IChvID0gKHQgPSB1LnRleHRDb250ZW50KSA9PT0gbnVsbCB8fCB0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0Lmxlbmd0aCkgIT09IG51bGwgJiYgbyAhPT0gdm9pZCAwID8gbyA6IDAsIGkgPSBlID8gMCA6IGg7XG4gICAgICAgIHMuc2V0U3RhcnQodSwgaSksIHMuc2V0RW5kKHUsIGkpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGEobik7XG4gICAgfSBlbHNlXG4gICAgICBhKG4pO1xuICAgIHIucmVtb3ZlQWxsUmFuZ2VzKCksIHIuYWRkUmFuZ2Uocyk7XG4gIH1cbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uZm9jdXMgPSB2b2lkIDA7XG4gIHZhciBlID0gbG87XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImZvY3VzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuZm9jdXM7XG4gIH0gfSk7XG59KShNbik7XG52YXIgY28gPSB7fSwgSmUgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShKZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuSmUuZ2V0Q2FyZXROb2RlQW5kT2Zmc2V0ID0gS3I7XG5mdW5jdGlvbiBLcigpIHtcbiAgdmFyIG4gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIGlmIChuID09PSBudWxsKVxuICAgIHJldHVybiBbbnVsbCwgMF07XG4gIHZhciBlID0gbi5mb2N1c05vZGUsIHQgPSBuLmZvY3VzT2Zmc2V0O1xuICByZXR1cm4gZSA9PT0gbnVsbCA/IFtudWxsLCAwXSA6IChlLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSAmJiBlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCAmJiAoZS5jaGlsZE5vZGVzW3RdICE9PSB2b2lkIDAgPyAoZSA9IGUuY2hpbGROb2Rlc1t0XSwgdCA9IDApIDogKGUgPSBlLmNoaWxkTm9kZXNbdCAtIDFdLCBlLnRleHRDb250ZW50ICE9PSBudWxsICYmICh0ID0gZS50ZXh0Q29udGVudC5sZW5ndGgpKSksIFtlLCB0XSk7XG59XG4oZnVuY3Rpb24obikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBuLmdldENhcmV0Tm9kZUFuZE9mZnNldCA9IHZvaWQgMDtcbiAgdmFyIGUgPSBKZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiZ2V0Q2FyZXROb2RlQW5kT2Zmc2V0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuZ2V0Q2FyZXROb2RlQW5kT2Zmc2V0O1xuICB9IH0pO1xufSkoY28pO1xudmFyIEFuID0ge30sIGV0ID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmV0LmdldFJhbmdlID0gWHI7XG5mdW5jdGlvbiBYcigpIHtcbiAgdmFyIG4gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHJldHVybiBuICYmIG4ucmFuZ2VDb3VudCA/IG4uZ2V0UmFuZ2VBdCgwKSA6IG51bGw7XG59XG4oZnVuY3Rpb24obikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBuLmdldFJhbmdlID0gdm9pZCAwO1xuICB2YXIgZSA9IGV0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJnZXRSYW5nZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmdldFJhbmdlO1xuICB9IH0pO1xufSkoQW4pO1xudmFyIExuID0ge30sIHVvID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkodW8sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnVvLmlzQ2FyZXRBdEVuZE9mSW5wdXQgPSBacjtcbnZhciBPbyA9IGRlLCBWciA9IGNvLCBxciA9IFN0O1xuZnVuY3Rpb24gWnIobikge1xuICB2YXIgZSA9ICgwLCBPby5nZXREZWVwZXN0Tm9kZSkobiwgITApO1xuICBpZiAoZSA9PT0gbnVsbClcbiAgICByZXR1cm4gITA7XG4gIGlmICgoMCwgT28uaXNOYXRpdmVJbnB1dCkoZSkpXG4gICAgcmV0dXJuIGUuc2VsZWN0aW9uRW5kID09PSBlLnZhbHVlLmxlbmd0aDtcbiAgdmFyIHQgPSAoMCwgVnIuZ2V0Q2FyZXROb2RlQW5kT2Zmc2V0KSgpLCBvID0gdFswXSwgaSA9IHRbMV07XG4gIHJldHVybiBvID09PSBudWxsID8gITEgOiAoMCwgcXIuY2hlY2tDb250ZW50ZWRpdGFibGVTbGljZUZvckVtcHRpbmVzcykobiwgbywgaSwgXCJyaWdodFwiKTtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uaXNDYXJldEF0RW5kT2ZJbnB1dCA9IHZvaWQgMDtcbiAgdmFyIGUgPSB1bztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiaXNDYXJldEF0RW5kT2ZJbnB1dFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLmlzQ2FyZXRBdEVuZE9mSW5wdXQ7XG4gIH0gfSk7XG59KShMbik7XG52YXIgUG4gPSB7fSwgaG8gPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShobywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuaG8uaXNDYXJldEF0U3RhcnRPZklucHV0ID0gSnI7XG52YXIgQWUgPSBkZSwgR3IgPSBKZSwgUXIgPSBYZTtcbmZ1bmN0aW9uIEpyKG4pIHtcbiAgdmFyIGUgPSAoMCwgQWUuZ2V0RGVlcGVzdE5vZGUpKG4pO1xuICBpZiAoZSA9PT0gbnVsbCB8fCAoMCwgQWUuaXNFbXB0eSkobikpXG4gICAgcmV0dXJuICEwO1xuICBpZiAoKDAsIEFlLmlzTmF0aXZlSW5wdXQpKGUpKVxuICAgIHJldHVybiBlLnNlbGVjdGlvbkVuZCA9PT0gMDtcbiAgaWYgKCgwLCBBZS5pc0VtcHR5KShuKSlcbiAgICByZXR1cm4gITA7XG4gIHZhciB0ID0gKDAsIEdyLmdldENhcmV0Tm9kZUFuZE9mZnNldCkoKSwgbyA9IHRbMF0sIGkgPSB0WzFdO1xuICByZXR1cm4gbyA9PT0gbnVsbCA/ICExIDogKDAsIFFyLmNoZWNrQ29udGVudGVkaXRhYmxlU2xpY2VGb3JFbXB0aW5lc3MpKG4sIG8sIGksIFwibGVmdFwiKTtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uaXNDYXJldEF0U3RhcnRPZklucHV0ID0gdm9pZCAwO1xuICB2YXIgZSA9IGhvO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJpc0NhcmV0QXRTdGFydE9mSW5wdXRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZS5pc0NhcmV0QXRTdGFydE9mSW5wdXQ7XG4gIH0gfSk7XG59KShQbik7XG52YXIgTm4gPSB7fSwgcG8gPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwbywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xucG8uc2F2ZSA9IG9hO1xudmFyIGVhID0gZGUsIHRhID0gZXQ7XG5mdW5jdGlvbiBvYSgpIHtcbiAgdmFyIG4gPSAoMCwgdGEuZ2V0UmFuZ2UpKCksIGUgPSAoMCwgZWEubWFrZSkoXCJzcGFuXCIpO1xuICBpZiAoZS5pZCA9IFwiY3Vyc29yXCIsIGUuaGlkZGVuID0gITAsICEhbilcbiAgICByZXR1cm4gbi5pbnNlcnROb2RlKGUpLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgbyAmJiAobi5zZXRTdGFydEFmdGVyKGUpLCBuLnNldEVuZEFmdGVyKGUpLCBvLnJlbW92ZUFsbFJhbmdlcygpLCBvLmFkZFJhbmdlKG4pLCBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBlLnJlbW92ZSgpO1xuICAgICAgfSwgMTUwKSk7XG4gICAgfTtcbn1cbihmdW5jdGlvbihuKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIG4uc2F2ZSA9IHZvaWQgMDtcbiAgdmFyIGUgPSBwbztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwic2F2ZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlLnNhdmU7XG4gIH0gfSk7XG59KShObik7XG4oZnVuY3Rpb24obikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBuLnNhdmUgPSBuLmlzQ2FyZXRBdFN0YXJ0T2ZJbnB1dCA9IG4uaXNDYXJldEF0RW5kT2ZJbnB1dCA9IG4uZ2V0UmFuZ2UgPSBuLmdldENhcmV0Tm9kZUFuZE9mZnNldCA9IG4uZm9jdXMgPSBuLmdldENvbnRlbnRlZGl0YWJsZVNsaWNlID0gbi5jaGVja0NvbnRlbnRlZGl0YWJsZVNsaWNlRm9yRW1wdGluZXNzID0gdm9pZCAwO1xuICB2YXIgZSA9IFN0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJjaGVja0NvbnRlbnRlZGl0YWJsZVNsaWNlRm9yRW1wdGluZXNzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGUuY2hlY2tDb250ZW50ZWRpdGFibGVTbGljZUZvckVtcHRpbmVzcztcbiAgfSB9KTtcbiAgdmFyIHQgPSBfbjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiZ2V0Q29udGVudGVkaXRhYmxlU2xpY2VcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5nZXRDb250ZW50ZWRpdGFibGVTbGljZTtcbiAgfSB9KTtcbiAgdmFyIG8gPSBNbjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiZm9jdXNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gby5mb2N1cztcbiAgfSB9KTtcbiAgdmFyIGkgPSBjbztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiZ2V0Q2FyZXROb2RlQW5kT2Zmc2V0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGkuZ2V0Q2FyZXROb2RlQW5kT2Zmc2V0O1xuICB9IH0pO1xuICB2YXIgcyA9IEFuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJnZXRSYW5nZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzLmdldFJhbmdlO1xuICB9IH0pO1xuICB2YXIgciA9IExuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJpc0NhcmV0QXRFbmRPZklucHV0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHIuaXNDYXJldEF0RW5kT2ZJbnB1dDtcbiAgfSB9KTtcbiAgdmFyIGEgPSBQbjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiaXNDYXJldEF0U3RhcnRPZklucHV0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGEuaXNDYXJldEF0U3RhcnRPZklucHV0O1xuICB9IH0pO1xuICB2YXIgbCA9IE5uO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJzYXZlXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGwuc2F2ZTtcbiAgfSB9KTtcbn0pKGhuKTtcbmNsYXNzIG5hIGV4dGVuZHMgRSB7XG4gIC8qKlxuICAgKiBBbGwga2V5ZG93bnMgb24gQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWRvd25cbiAgICovXG4gIGtleWRvd24oZSkge1xuICAgIHN3aXRjaCAodGhpcy5iZWZvcmVLZXlkb3duUHJvY2Vzc2luZyhlKSwgZS5rZXlDb2RlKSB7XG4gICAgICBjYXNlIHkuQkFDS1NQQUNFOlxuICAgICAgICB0aGlzLmJhY2tzcGFjZShlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHkuREVMRVRFOlxuICAgICAgICB0aGlzLmRlbGV0ZShlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHkuRU5URVI6XG4gICAgICAgIHRoaXMuZW50ZXIoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB5LkRPV046XG4gICAgICBjYXNlIHkuUklHSFQ6XG4gICAgICAgIHRoaXMuYXJyb3dSaWdodEFuZERvd24oZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB5LlVQOlxuICAgICAgY2FzZSB5LkxFRlQ6XG4gICAgICAgIHRoaXMuYXJyb3dMZWZ0QW5kVXAoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB5LlRBQjpcbiAgICAgICAgdGhpcy50YWJQcmVzc2VkKGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZS5rZXkgPT09IFwiL1wiICYmICFlLmN0cmxLZXkgJiYgIWUubWV0YUtleSAmJiB0aGlzLnNsYXNoUHJlc3NlZChlKSwgZS5jb2RlID09PSBcIlNsYXNoXCIgJiYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpICYmIChlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuY29tbWFuZFNsYXNoUHJlc3NlZCgpKTtcbiAgfVxuICAvKipcbiAgICogRmlyZXMgb24ga2V5ZG93biBiZWZvcmUgZXZlbnQgcHJvY2Vzc2luZ1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5ZG93blxuICAgKi9cbiAgYmVmb3JlS2V5ZG93blByb2Nlc3NpbmcoZSkge1xuICAgIHRoaXMubmVlZFRvb2xiYXJDbG9zaW5nKGUpICYmIFBvKGUua2V5Q29kZSkgJiYgKHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKSwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLmFsdEtleSB8fCBlLnNoaWZ0S2V5IHx8IHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKGUpKTtcbiAgfVxuICAvKipcbiAgICogS2V5IHVwIG9uIEJsb2NrOlxuICAgKiAtIHNob3dzIElubGluZSBUb29sYmFyIGlmIHNvbWV0aGluZyBzZWxlY3RlZFxuICAgKiAtIHNob3dzIGNvbnZlcnNpb24gdG9vbGJhciB3aXRoIDg1JSBvZiBibG9jayBzZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleXVwIGV2ZW50XG4gICAqL1xuICBrZXl1cChlKSB7XG4gICAgZS5zaGlmdEtleSB8fCB0aGlzLkVkaXRvci5VSS5jaGVja0VtcHRpbmVzcygpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgZHJvcCB0YXJnZXQgc3R5bGVzXG4gICAqXG4gICAqIEBwYXJhbSB7RHJhZ0V2ZW50fSBldmVudCAtIGRyYWcgb3ZlciBldmVudFxuICAgKi9cbiAgZHJhZ092ZXIoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUNoaWxkTm9kZShlLnRhcmdldCk7XG4gICAgdC5kcm9wVGFyZ2V0ID0gITA7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBkcm9wIHRhcmdldCBzdHlsZVxuICAgKlxuICAgKiBAcGFyYW0ge0RyYWdFdmVudH0gZXZlbnQgLSBkcmFnIGxlYXZlIGV2ZW50XG4gICAqL1xuICBkcmFnTGVhdmUoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUNoaWxkTm9kZShlLnRhcmdldCk7XG4gICAgdC5kcm9wVGFyZ2V0ID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIENvcHlpbmcgc2VsZWN0ZWQgYmxvY2tzXG4gICAqIEJlZm9yZSBwdXR0aW5nIHRvIHRoZSBjbGlwYm9hcmQgd2Ugc2FuaXRpemUgYWxsIGJsb2NrcyBhbmQgdGhlbiBjb3B5IHRvIHRoZSBjbGlwYm9hcmRcbiAgICpcbiAgICogQHBhcmFtIHtDbGlwYm9hcmRFdmVudH0gZXZlbnQgLSBjbGlwYm9hcmQgZXZlbnRcbiAgICovXG4gIGhhbmRsZUNvbW1hbmRDKGUpIHtcbiAgICBjb25zdCB7IEJsb2NrU2VsZWN0aW9uOiB0IH0gPSB0aGlzLkVkaXRvcjtcbiAgICB0LmFueUJsb2NrU2VsZWN0ZWQgJiYgdC5jb3B5U2VsZWN0ZWRCbG9ja3MoZSk7XG4gIH1cbiAgLyoqXG4gICAqIENvcHkgYW5kIERlbGV0ZSBzZWxlY3RlZCBCbG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtDbGlwYm9hcmRFdmVudH0gZXZlbnQgLSBjbGlwYm9hcmQgZXZlbnRcbiAgICovXG4gIGhhbmRsZUNvbW1hbmRYKGUpIHtcbiAgICBjb25zdCB7IEJsb2NrU2VsZWN0aW9uOiB0LCBCbG9ja01hbmFnZXI6IG8sIENhcmV0OiBpIH0gPSB0aGlzLkVkaXRvcjtcbiAgICB0LmFueUJsb2NrU2VsZWN0ZWQgJiYgdC5jb3B5U2VsZWN0ZWRCbG9ja3MoZSkudGhlbigoKSA9PiB7XG4gICAgICBjb25zdCBzID0gby5yZW1vdmVTZWxlY3RlZEJsb2NrcygpLCByID0gby5pbnNlcnREZWZhdWx0QmxvY2tBdEluZGV4KHMsICEwKTtcbiAgICAgIGkuc2V0VG9CbG9jayhyLCBpLnBvc2l0aW9ucy5TVEFSVCksIHQuY2xlYXJTZWxlY3Rpb24oZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFRhYiBwcmVzc2VkIGluc2lkZSBhIEJsb2NrLlxuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5ZG93blxuICAgKi9cbiAgdGFiUHJlc3NlZChlKSB7XG4gICAgY29uc3QgeyBJbmxpbmVUb29sYmFyOiB0LCBDYXJldDogbyB9ID0gdGhpcy5FZGl0b3I7XG4gICAgaWYgKHQub3BlbmVkKVxuICAgICAgcmV0dXJuO1xuICAgIChlLnNoaWZ0S2V5ID8gby5uYXZpZ2F0ZVByZXZpb3VzKCEwKSA6IG8ubmF2aWdhdGVOZXh0KCEwKSkgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIC8qKlxuICAgKiAnLycgKyAnY29tbWFuZCcga2V5ZG93biBpbnNpZGUgYSBCbG9ja1xuICAgKi9cbiAgY29tbWFuZFNsYXNoUHJlc3NlZCgpIHtcbiAgICB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5zZWxlY3RlZEJsb2Nrcy5sZW5ndGggPiAxIHx8IHRoaXMuYWN0aXZhdGVCbG9ja1NldHRpbmdzKCk7XG4gIH1cbiAgLyoqXG4gICAqICcvJyBrZXlkb3duIGluc2lkZSBhIEJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIGtleWRvd25cbiAgICovXG4gIHNsYXNoUHJlc3NlZChlKSB7XG4gICAgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jay5pc0VtcHR5ICYmIChlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuRWRpdG9yLkNhcmV0Lmluc2VydENvbnRlbnRBdENhcmV0UG9zaXRpb24oXCIvXCIpLCB0aGlzLmFjdGl2YXRlVG9vbGJveCgpKTtcbiAgfVxuICAvKipcbiAgICogRU5URVIgcHJlc3NlZCBvbiBibG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5ZG93blxuICAgKi9cbiAgZW50ZXIoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBVSTogbyB9ID0gdGhpcy5FZGl0b3IsIGkgPSB0LmN1cnJlbnRCbG9jaztcbiAgICBpZiAoaSA9PT0gdm9pZCAwIHx8IGkudG9vbC5pc0xpbmVCcmVha3NFbmFibGVkIHx8IG8uc29tZVRvb2xiYXJPcGVuZWQgJiYgby5zb21lRmxpcHBlckJ1dHRvbkZvY3VzZWQgfHwgZS5zaGlmdEtleSAmJiAhcHQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHMgPSBpO1xuICAgIGkuY3VycmVudElucHV0ICE9PSB2b2lkIDAgJiYgTmUoaS5jdXJyZW50SW5wdXQpICYmICFpLmhhc01lZGlhID8gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmluc2VydERlZmF1bHRCbG9ja0F0SW5kZXgodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9ja0luZGV4KSA6IGkuY3VycmVudElucHV0ICYmIFJlKGkuY3VycmVudElucHV0KSA/IHMgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuaW5zZXJ0RGVmYXVsdEJsb2NrQXRJbmRleCh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrSW5kZXggKyAxKSA6IHMgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuc3BsaXQoKSwgdGhpcy5FZGl0b3IuQ2FyZXQuc2V0VG9CbG9jayhzKSwgdGhpcy5FZGl0b3IuVG9vbGJhci5tb3ZlQW5kT3BlbihzKSwgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgYmFja3NwYWNlIGtleWRvd24gb24gQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWRvd25cbiAgICovXG4gIGJhY2tzcGFjZShlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIENhcmV0OiBvIH0gPSB0aGlzLkVkaXRvciwgeyBjdXJyZW50QmxvY2s6IGksIHByZXZpb3VzQmxvY2s6IHMgfSA9IHQ7XG4gICAgaWYgKGkgPT09IHZvaWQgMCB8fCAhYi5pc0NvbGxhcHNlZCB8fCAhaS5jdXJyZW50SW5wdXQgfHwgIU5lKGkuY3VycmVudElucHV0KSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCksICEoaS5jdXJyZW50SW5wdXQgPT09IGkuZmlyc3RJbnB1dCkpIHtcbiAgICAgIG8ubmF2aWdhdGVQcmV2aW91cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocyA9PT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBpZiAocy5pc0VtcHR5KSB7XG4gICAgICB0LnJlbW92ZUJsb2NrKHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaS5pc0VtcHR5KSB7XG4gICAgICB0LnJlbW92ZUJsb2NrKGkpO1xuICAgICAgY29uc3QgbCA9IHQuY3VycmVudEJsb2NrO1xuICAgICAgby5zZXRUb0Jsb2NrKGwsIG8ucG9zaXRpb25zLkVORCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHhvKHMsIGkpID8gdGhpcy5tZXJnZUJsb2NrcyhzLCBpKSA6IG8uc2V0VG9CbG9jayhzLCBvLnBvc2l0aW9ucy5FTkQpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGRlbGV0ZSBrZXlkb3duIG9uIEJsb2NrXG4gICAqIFJlbW92ZXMgY2hhciBhZnRlciB0aGUgY2FyZXQuXG4gICAqIElmIGNhcmV0IGlzIGF0IHRoZSBlbmQgb2YgdGhlIGJsb2NrLCBtZXJnZSBuZXh0IGJsb2NrIHdpdGggY3VycmVudFxuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5ZG93blxuICAgKi9cbiAgZGVsZXRlKGUpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCwgQ2FyZXQ6IG8gfSA9IHRoaXMuRWRpdG9yLCB7IGN1cnJlbnRCbG9jazogaSwgbmV4dEJsb2NrOiBzIH0gPSB0O1xuICAgIGlmICghYi5pc0NvbGxhcHNlZCB8fCAhUmUoaS5jdXJyZW50SW5wdXQpKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKSwgIShpLmN1cnJlbnRJbnB1dCA9PT0gaS5sYXN0SW5wdXQpKSB7XG4gICAgICBvLm5hdmlnYXRlTmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocyA9PT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBpZiAocy5pc0VtcHR5KSB7XG4gICAgICB0LnJlbW92ZUJsb2NrKHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaS5pc0VtcHR5KSB7XG4gICAgICB0LnJlbW92ZUJsb2NrKGkpLCBvLnNldFRvQmxvY2socywgby5wb3NpdGlvbnMuU1RBUlQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB4byhpLCBzKSA/IHRoaXMubWVyZ2VCbG9ja3MoaSwgcykgOiBvLnNldFRvQmxvY2socywgby5wb3NpdGlvbnMuU1RBUlQpO1xuICB9XG4gIC8qKlxuICAgKiBNZXJnZSBwYXNzZWQgQmxvY2tzXG4gICAqXG4gICAqIEBwYXJhbSB0YXJnZXRCbG9jayAtIHRvIHdoaWNoIEJsb2NrIHdlIHdhbnQgdG8gbWVyZ2VcbiAgICogQHBhcmFtIGJsb2NrVG9NZXJnZSAtIHdoYXQgQmxvY2sgd2Ugd2FudCB0byBtZXJnZVxuICAgKi9cbiAgbWVyZ2VCbG9ja3MoZSwgdCkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBvLCBUb29sYmFyOiBpIH0gPSB0aGlzLkVkaXRvcjtcbiAgICBlLmxhc3RJbnB1dCAhPT0gdm9pZCAwICYmIChobi5mb2N1cyhlLmxhc3RJbnB1dCwgITEpLCBvLm1lcmdlQmxvY2tzKGUsIHQpLnRoZW4oKCkgPT4ge1xuICAgICAgaS5jbG9zZSgpO1xuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIHJpZ2h0IGFuZCBkb3duIGtleWJvYXJkIGtleXNcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWJvYXJkIGV2ZW50XG4gICAqL1xuICBhcnJvd1JpZ2h0QW5kRG93bihlKSB7XG4gICAgY29uc3QgdCA9IGNlLnVzZWRLZXlzLmluY2x1ZGVzKGUua2V5Q29kZSkgJiYgKCFlLnNoaWZ0S2V5IHx8IGUua2V5Q29kZSA9PT0geS5UQUIpO1xuICAgIGlmICh0aGlzLkVkaXRvci5VSS5zb21lVG9vbGJhck9wZW5lZCAmJiB0KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKTtcbiAgICBjb25zdCB7IGN1cnJlbnRCbG9jazogbyB9ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLCBzID0gKChvID09IG51bGwgPyB2b2lkIDAgOiBvLmN1cnJlbnRJbnB1dCkgIT09IHZvaWQgMCA/IFJlKG8uY3VycmVudElucHV0KSA6IHZvaWQgMCkgfHwgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uYW55QmxvY2tTZWxlY3RlZDtcbiAgICBpZiAoZS5zaGlmdEtleSAmJiBlLmtleUNvZGUgPT09IHkuRE9XTiAmJiBzKSB7XG4gICAgICB0aGlzLkVkaXRvci5Dcm9zc0Jsb2NrU2VsZWN0aW9uLnRvZ2dsZUJsb2NrU2VsZWN0ZWRTdGF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZS5rZXlDb2RlID09PSB5LkRPV04gfHwgZS5rZXlDb2RlID09PSB5LlJJR0hUICYmICF0aGlzLmlzUnRsID8gdGhpcy5FZGl0b3IuQ2FyZXQubmF2aWdhdGVOZXh0KCkgOiB0aGlzLkVkaXRvci5DYXJldC5uYXZpZ2F0ZVByZXZpb3VzKCkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgRmUoKCkgPT4ge1xuICAgICAgdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jayAmJiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrLnVwZGF0ZUN1cnJlbnRJbnB1dCgpO1xuICAgIH0sIDIwKSgpLCB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5jbGVhclNlbGVjdGlvbihlKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGxlZnQgYW5kIHVwIGtleWJvYXJkIGtleXNcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWJvYXJkIGV2ZW50XG4gICAqL1xuICBhcnJvd0xlZnRBbmRVcChlKSB7XG4gICAgaWYgKHRoaXMuRWRpdG9yLlVJLnNvbWVUb29sYmFyT3BlbmVkKSB7XG4gICAgICBpZiAoY2UudXNlZEtleXMuaW5jbHVkZXMoZS5rZXlDb2RlKSAmJiAoIWUuc2hpZnRLZXkgfHwgZS5rZXlDb2RlID09PSB5LlRBQikpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuRWRpdG9yLlVJLmNsb3NlQWxsVG9vbGJhcnMoKTtcbiAgICB9XG4gICAgdGhpcy5FZGl0b3IuVG9vbGJhci5jbG9zZSgpO1xuICAgIGNvbnN0IHsgY3VycmVudEJsb2NrOiB0IH0gPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIsIGkgPSAoKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuY3VycmVudElucHV0KSAhPT0gdm9pZCAwID8gTmUodC5jdXJyZW50SW5wdXQpIDogdm9pZCAwKSB8fCB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5hbnlCbG9ja1NlbGVjdGVkO1xuICAgIGlmIChlLnNoaWZ0S2V5ICYmIGUua2V5Q29kZSA9PT0geS5VUCAmJiBpKSB7XG4gICAgICB0aGlzLkVkaXRvci5Dcm9zc0Jsb2NrU2VsZWN0aW9uLnRvZ2dsZUJsb2NrU2VsZWN0ZWRTdGF0ZSghMSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLmtleUNvZGUgPT09IHkuVVAgfHwgZS5rZXlDb2RlID09PSB5LkxFRlQgJiYgIXRoaXMuaXNSdGwgPyB0aGlzLkVkaXRvci5DYXJldC5uYXZpZ2F0ZVByZXZpb3VzKCkgOiB0aGlzLkVkaXRvci5DYXJldC5uYXZpZ2F0ZU5leHQoKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBGZSgoKSA9PiB7XG4gICAgICB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY3VycmVudEJsb2NrICYmIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2sudXBkYXRlQ3VycmVudElucHV0KCk7XG4gICAgfSwgMjApKCksIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKGUpO1xuICB9XG4gIC8qKlxuICAgKiBDYXNlcyB3aGVuIHdlIG5lZWQgdG8gY2xvc2UgVG9vbGJhclxuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5Ym9hcmQgZXZlbnRcbiAgICovXG4gIG5lZWRUb29sYmFyQ2xvc2luZyhlKSB7XG4gICAgY29uc3QgdCA9IGUua2V5Q29kZSA9PT0geS5FTlRFUiAmJiB0aGlzLkVkaXRvci5Ub29sYmFyLnRvb2xib3gub3BlbmVkLCBvID0gZS5rZXlDb2RlID09PSB5LkVOVEVSICYmIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mub3BlbmVkLCBpID0gZS5rZXlDb2RlID09PSB5LkVOVEVSICYmIHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIub3BlbmVkLCBzID0gZS5rZXlDb2RlID09PSB5LlRBQjtcbiAgICByZXR1cm4gIShlLnNoaWZ0S2V5IHx8IHMgfHwgdCB8fCBvIHx8IGkpO1xuICB9XG4gIC8qKlxuICAgKiBJZiBUb29sYm94IGlzIG5vdCBvcGVuLCB0aGVuIGp1c3Qgb3BlbiBpdCBhbmQgc2hvdyBwbHVzIGJ1dHRvblxuICAgKi9cbiAgYWN0aXZhdGVUb29sYm94KCkge1xuICAgIHRoaXMuRWRpdG9yLlRvb2xiYXIub3BlbmVkIHx8IHRoaXMuRWRpdG9yLlRvb2xiYXIubW92ZUFuZE9wZW4oKSwgdGhpcy5FZGl0b3IuVG9vbGJhci50b29sYm94Lm9wZW4oKTtcbiAgfVxuICAvKipcbiAgICogT3BlbiBUb29sYmFyIGFuZCBzaG93IEJsb2NrU2V0dGluZ3MgYmVmb3JlIGZsaXBwaW5nIFRvb2xzXG4gICAqL1xuICBhY3RpdmF0ZUJsb2NrU2V0dGluZ3MoKSB7XG4gICAgdGhpcy5FZGl0b3IuVG9vbGJhci5vcGVuZWQgfHwgdGhpcy5FZGl0b3IuVG9vbGJhci5tb3ZlQW5kT3BlbigpLCB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLm9wZW5lZCB8fCB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLm9wZW4oKTtcbiAgfVxufVxuY2xhc3MgY3Qge1xuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHdvcmtpbmdBcmVhIOKAlCBlZGl0b3JgcyB3b3JraW5nIG5vZGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLmJsb2NrcyA9IFtdLCB0aGlzLndvcmtpbmdBcmVhID0gZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGxlbmd0aCBvZiBCbG9jayBpbnN0YW5jZXMgYXJyYXlcbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tzLmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogR2V0IEJsb2NrIGluc3RhbmNlcyBhcnJheVxuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2tbXX1cbiAgICovXG4gIGdldCBhcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3M7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBibG9ja3MgaHRtbCBlbGVtZW50cyBhcnJheVxuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnRbXX1cbiAgICovXG4gIGdldCBub2RlcygpIHtcbiAgICByZXR1cm4gTm8odGhpcy53b3JraW5nQXJlYS5jaGlsZHJlbik7XG4gIH1cbiAgLyoqXG4gICAqIFByb3h5IHRyYXAgdG8gaW1wbGVtZW50IGFycmF5LWxpa2Ugc2V0dGVyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGJsb2Nrc1swXSA9IG5ldyBCbG9jayguLi4pXG4gICAqIEBwYXJhbSB7QmxvY2tzfSBpbnN0YW5jZSDigJQgQmxvY2tzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IHByb3BlcnR5IOKAlCBibG9jayBpbmRleCBvciBhbnkgQmxvY2tzIGNsYXNzIHByb3BlcnR5IGtleSB0byBzZXRcbiAgICogQHBhcmFtIHtCbG9ja30gdmFsdWUg4oCUIHZhbHVlIHRvIHNldFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBzZXQoZSwgdCwgbykge1xuICAgIHJldHVybiBpc05hTihOdW1iZXIodCkpID8gKFJlZmxlY3Quc2V0KGUsIHQsIG8pLCAhMCkgOiAoZS5pbnNlcnQoK3QsIG8pLCAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFByb3h5IHRyYXAgdG8gaW1wbGVtZW50IGFycmF5LWxpa2UgZ2V0dGVyXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvY2tzfSBpbnN0YW5jZSDigJQgQmxvY2tzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IHByb3BlcnR5IOKAlCBCbG9ja3MgY2xhc3MgcHJvcGVydHkga2V5XG4gICAqIEByZXR1cm5zIHtCbG9ja3wqfVxuICAgKi9cbiAgc3RhdGljIGdldChlLCB0KSB7XG4gICAgcmV0dXJuIGlzTmFOKE51bWJlcih0KSkgPyBSZWZsZWN0LmdldChlLCB0KSA6IGUuZ2V0KCt0KTtcbiAgfVxuICAvKipcbiAgICogUHVzaCBuZXcgQmxvY2sgdG8gdGhlIGJsb2NrcyBhcnJheSBhbmQgYXBwZW5kIGl0IHRvIHdvcmtpbmcgYXJlYVxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrfSBibG9jayAtIEJsb2NrIHRvIGFkZFxuICAgKi9cbiAgcHVzaChlKSB7XG4gICAgdGhpcy5ibG9ja3MucHVzaChlKSwgdGhpcy5pbnNlcnRUb0RPTShlKTtcbiAgfVxuICAvKipcbiAgICogU3dhcHMgYmxvY2tzIHdpdGggaW5kZXhlcyBmaXJzdCBhbmQgc2Vjb25kXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmaXJzdCAtIGZpcnN0IGJsb2NrIGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWNvbmQgLSBzZWNvbmQgYmxvY2sgaW5kZXhcbiAgICogQGRlcHJlY2F0ZWQg4oCUIHVzZSAnbW92ZScgaW5zdGVhZFxuICAgKi9cbiAgc3dhcChlLCB0KSB7XG4gICAgY29uc3QgbyA9IHRoaXMuYmxvY2tzW3RdO1xuICAgIGQuc3dhcCh0aGlzLmJsb2Nrc1tlXS5ob2xkZXIsIG8uaG9sZGVyKSwgdGhpcy5ibG9ja3NbdF0gPSB0aGlzLmJsb2Nrc1tlXSwgdGhpcy5ibG9ja3NbZV0gPSBvO1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlIGEgYmxvY2sgZnJvbSBvbmUgdG8gYW5vdGhlciBpbmRleFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCAtIG5ldyBpbmRleCBvZiB0aGUgYmxvY2tcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCAtIGJsb2NrIHRvIG1vdmVcbiAgICovXG4gIG1vdmUoZSwgdCkge1xuICAgIGNvbnN0IG8gPSB0aGlzLmJsb2Nrcy5zcGxpY2UodCwgMSlbMF0sIGkgPSBlIC0gMSwgcyA9IE1hdGgubWF4KDAsIGkpLCByID0gdGhpcy5ibG9ja3Nbc107XG4gICAgZSA+IDAgPyB0aGlzLmluc2VydFRvRE9NKG8sIFwiYWZ0ZXJlbmRcIiwgcikgOiB0aGlzLmluc2VydFRvRE9NKG8sIFwiYmVmb3JlYmVnaW5cIiwgciksIHRoaXMuYmxvY2tzLnNwbGljZShlLCAwLCBvKTtcbiAgICBjb25zdCBhID0gdGhpcy5jb21wb3NlQmxvY2tFdmVudChcIm1vdmVcIiwge1xuICAgICAgZnJvbUluZGV4OiB0LFxuICAgICAgdG9JbmRleDogZVxuICAgIH0pO1xuICAgIG8uY2FsbChlZS5NT1ZFRCwgYSk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBuZXcgQmxvY2sgYXQgcGFzc2VkIGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCDigJQgaW5kZXggdG8gaW5zZXJ0IEJsb2NrXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrIOKAlCBCbG9jayB0byBpbnNlcnRcbiAgICogQHBhcmFtIHtib29sZWFufSByZXBsYWNlIOKAlCBpdCB0cnVlLCByZXBsYWNlIGJsb2NrIG9uIGdpdmVuIGluZGV4XG4gICAqL1xuICBpbnNlcnQoZSwgdCwgbyA9ICExKSB7XG4gICAgaWYgKCF0aGlzLmxlbmd0aCkge1xuICAgICAgdGhpcy5wdXNoKHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlID4gdGhpcy5sZW5ndGggJiYgKGUgPSB0aGlzLmxlbmd0aCksIG8gJiYgKHRoaXMuYmxvY2tzW2VdLmhvbGRlci5yZW1vdmUoKSwgdGhpcy5ibG9ja3NbZV0uY2FsbChlZS5SRU1PVkVEKSk7XG4gICAgY29uc3QgaSA9IG8gPyAxIDogMDtcbiAgICBpZiAodGhpcy5ibG9ja3Muc3BsaWNlKGUsIGksIHQpLCBlID4gMCkge1xuICAgICAgY29uc3QgcyA9IHRoaXMuYmxvY2tzW2UgLSAxXTtcbiAgICAgIHRoaXMuaW5zZXJ0VG9ET00odCwgXCJhZnRlcmVuZFwiLCBzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcyA9IHRoaXMuYmxvY2tzW2UgKyAxXTtcbiAgICAgIHMgPyB0aGlzLmluc2VydFRvRE9NKHQsIFwiYmVmb3JlYmVnaW5cIiwgcykgOiB0aGlzLmluc2VydFRvRE9NKHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVwbGFjZXMgYmxvY2sgdW5kZXIgcGFzc2VkIGluZGV4IHdpdGggcGFzc2VkIGJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSBpbmRleCAtIGluZGV4IG9mIGV4aXN0ZWQgYmxvY2tcbiAgICogQHBhcmFtIGJsb2NrIC0gbmV3IGJsb2NrXG4gICAqL1xuICByZXBsYWNlKGUsIHQpIHtcbiAgICBpZiAodGhpcy5ibG9ja3NbZV0gPT09IHZvaWQgMClcbiAgICAgIHRocm93IEVycm9yKFwiSW5jb3JyZWN0IGluZGV4XCIpO1xuICAgIHRoaXMuYmxvY2tzW2VdLmhvbGRlci5yZXBsYWNlV2l0aCh0LmhvbGRlciksIHRoaXMuYmxvY2tzW2VdID0gdDtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyBzZXZlcmFsIGJsb2NrcyBhdCBvbmNlXG4gICAqXG4gICAqIEBwYXJhbSBibG9ja3MgLSBibG9ja3MgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSBpbmRleCAtIGluZGV4IHRvIGluc2VydCBibG9ja3MgYXRcbiAgICovXG4gIGluc2VydE1hbnkoZSwgdCkge1xuICAgIGNvbnN0IG8gPSBuZXcgRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGZvciAoY29uc3QgaSBvZiBlKVxuICAgICAgby5hcHBlbmRDaGlsZChpLmhvbGRlcik7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHQgPiAwKSB7XG4gICAgICAgIGNvbnN0IGkgPSBNYXRoLm1pbih0IC0gMSwgdGhpcy5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5ibG9ja3NbaV0uaG9sZGVyLmFmdGVyKG8pO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHQgPT09IDAgJiYgdGhpcy53b3JraW5nQXJlYS5wcmVwZW5kKG8pO1xuICAgICAgdGhpcy5ibG9ja3Muc3BsaWNlKHQsIDAsIC4uLmUpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5ibG9ja3MucHVzaCguLi5lKSwgdGhpcy53b3JraW5nQXJlYS5hcHBlbmRDaGlsZChvKTtcbiAgICBlLmZvckVhY2goKGkpID0+IGkuY2FsbChlZS5SRU5ERVJFRCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2YgQmxvY2sgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmUoZSkge1xuICAgIGlzTmFOKGUpICYmIChlID0gdGhpcy5sZW5ndGggLSAxKSwgdGhpcy5ibG9ja3NbZV0uaG9sZGVyLnJlbW92ZSgpLCB0aGlzLmJsb2Nrc1tlXS5jYWxsKGVlLlJFTU9WRUQpLCB0aGlzLmJsb2Nrcy5zcGxpY2UoZSwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgYmxvY2tzXG4gICAqL1xuICByZW1vdmVBbGwoKSB7XG4gICAgdGhpcy53b3JraW5nQXJlYS5pbm5lckhUTUwgPSBcIlwiLCB0aGlzLmJsb2Nrcy5mb3JFYWNoKChlKSA9PiBlLmNhbGwoZWUuUkVNT1ZFRCkpLCB0aGlzLmJsb2Nrcy5sZW5ndGggPSAwO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgQmxvY2sgYWZ0ZXIgcGFzc2VkIHRhcmdldFxuICAgKlxuICAgKiBAdG9kbyBkZWNpZGUgaWYgdGhpcyBtZXRob2QgaXMgbmVjZXNzYXJ5XG4gICAqIEBwYXJhbSB7QmxvY2t9IHRhcmdldEJsb2NrIOKAlCB0YXJnZXQgYWZ0ZXIgd2hpY2ggQmxvY2sgc2hvdWxkIGJlIGluc2VydGVkXG4gICAqIEBwYXJhbSB7QmxvY2t9IG5ld0Jsb2NrIOKAlCBCbG9jayB0byBpbnNlcnRcbiAgICovXG4gIGluc2VydEFmdGVyKGUsIHQpIHtcbiAgICBjb25zdCBvID0gdGhpcy5ibG9ja3MuaW5kZXhPZihlKTtcbiAgICB0aGlzLmluc2VydChvICsgMSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBCbG9jayBieSBpbmRleFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXgg4oCUIEJsb2NrIGluZGV4XG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIGdldChlKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tzW2VdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gaW5kZXggb2YgcGFzc2VkIEJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrIC0gQmxvY2sgdG8gZmluZFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgaW5kZXhPZihlKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tzLmluZGV4T2YoZSk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBuZXcgQmxvY2sgaW50byBET01cbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2sgLSBCbG9jayB0byBpbnNlcnRcbiAgICogQHBhcmFtIHtJbnNlcnRQb3NpdGlvbn0gcG9zaXRpb24g4oCUIGluc2VydCBwb3NpdGlvbiAoaWYgc2V0LCB3aWxsIHVzZSBpbnNlcnRBZGphY2VudEVsZW1lbnQpXG4gICAqIEBwYXJhbSB7QmxvY2t9IHRhcmdldCDigJQgQmxvY2sgcmVsYXRlZCB0byBwb3NpdGlvblxuICAgKi9cbiAgaW5zZXJ0VG9ET00oZSwgdCwgbykge1xuICAgIHQgPyBvLmhvbGRlci5pbnNlcnRBZGphY2VudEVsZW1lbnQodCwgZS5ob2xkZXIpIDogdGhpcy53b3JraW5nQXJlYS5hcHBlbmRDaGlsZChlLmhvbGRlciksIGUuY2FsbChlZS5SRU5ERVJFRCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbXBvc2VzIEJsb2NrIGV2ZW50IHdpdGggcGFzc2VkIHR5cGUgYW5kIGRldGFpbHNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBldmVudCB0eXBlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkZXRhaWwgLSBldmVudCBkZXRhaWxcbiAgICovXG4gIGNvbXBvc2VCbG9ja0V2ZW50KGUsIHQpIHtcbiAgICByZXR1cm4gbmV3IEN1c3RvbUV2ZW50KGUsIHtcbiAgICAgIGRldGFpbDogdFxuICAgIH0pO1xuICB9XG59XG5jb25zdCBfbyA9IFwiYmxvY2stcmVtb3ZlZFwiLCBNbyA9IFwiYmxvY2stYWRkZWRcIiwgaWEgPSBcImJsb2NrLW1vdmVkXCIsIEFvID0gXCJibG9jay1jaGFuZ2VkXCI7XG5jbGFzcyBzYSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29tcGxldGVkID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBuZXcgcHJvbWlzZSB0byBxdWV1ZVxuICAgKlxuICAgKiBAcGFyYW0gb3BlcmF0aW9uIC0gcHJvbWlzZSBzaG91bGQgYmUgYWRkZWQgdG8gcXVldWVcbiAgICovXG4gIGFkZChlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCh0LCBvKSA9PiB7XG4gICAgICB0aGlzLmNvbXBsZXRlZCA9IHRoaXMuY29tcGxldGVkLnRoZW4oZSkudGhlbih0KS5jYXRjaChvKTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgcmEgZXh0ZW5kcyBFIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5fY3VycmVudEJsb2NrSW5kZXggPSAtMSwgdGhpcy5fYmxvY2tzID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBjdXJyZW50IEJsb2NrIGluZGV4XG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgY3VycmVudEJsb2NrSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRCbG9ja0luZGV4O1xuICB9XG4gIC8qKlxuICAgKiBTZXQgY3VycmVudCBCbG9jayBpbmRleCBhbmQgZmlyZSBCbG9jayBsaWZlY3ljbGUgY2FsbGJhY2tzXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdJbmRleCAtIGluZGV4IG9mIEJsb2NrIHRvIHNldCBhcyBjdXJyZW50XG4gICAqL1xuICBzZXQgY3VycmVudEJsb2NrSW5kZXgoZSkge1xuICAgIHRoaXMuX2N1cnJlbnRCbG9ja0luZGV4ID0gZTtcbiAgfVxuICAvKipcbiAgICogcmV0dXJucyBmaXJzdCBCbG9ja1xuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2t9XG4gICAqL1xuICBnZXQgZmlyc3RCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzWzBdO1xuICB9XG4gIC8qKlxuICAgKiByZXR1cm5zIGxhc3QgQmxvY2tcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgZ2V0IGxhc3RCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzW3RoaXMuX2Jsb2Nrcy5sZW5ndGggLSAxXTtcbiAgfVxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgQmxvY2sgaW5zdGFuY2VcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzW3RoaXMuY3VycmVudEJsb2NrSW5kZXhdO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgcGFzc2VkIEJsb2NrIGFzIGEgY3VycmVudFxuICAgKlxuICAgKiBAcGFyYW0gYmxvY2sgLSBibG9jayB0byBzZXQgYXMgYSBjdXJyZW50XG4gICAqL1xuICBzZXQgY3VycmVudEJsb2NrKGUpIHtcbiAgICB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID0gdGhpcy5nZXRCbG9ja0luZGV4KGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIG5leHQgQmxvY2sgaW5zdGFuY2VcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrfG51bGx9XG4gICAqL1xuICBnZXQgbmV4dEJsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID09PSB0aGlzLl9ibG9ja3MubGVuZ3RoIC0gMSA/IG51bGwgOiB0aGlzLl9ibG9ja3NbdGhpcy5jdXJyZW50QmxvY2tJbmRleCArIDFdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gZmlyc3QgQmxvY2sgd2l0aCBpbnB1dHMgYWZ0ZXIgY3VycmVudCBCbG9ja1xuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2sgfCB1bmRlZmluZWR9XG4gICAqL1xuICBnZXQgbmV4dENvbnRlbnRmdWxCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3Muc2xpY2UodGhpcy5jdXJyZW50QmxvY2tJbmRleCArIDEpLmZpbmQoKHQpID0+ICEhdC5pbnB1dHMubGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGZpcnN0IEJsb2NrIHdpdGggaW5wdXRzIGJlZm9yZSBjdXJyZW50IEJsb2NrXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9jayB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGdldCBwcmV2aW91c0NvbnRlbnRmdWxCbG9jaygpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3Muc2xpY2UoMCwgdGhpcy5jdXJyZW50QmxvY2tJbmRleCkucmV2ZXJzZSgpLmZpbmQoKHQpID0+ICEhdC5pbnB1dHMubGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwcmV2aW91cyBCbG9jayBpbnN0YW5jZVxuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2t8bnVsbH1cbiAgICovXG4gIGdldCBwcmV2aW91c0Jsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID09PSAwID8gbnVsbCA6IHRoaXMuX2Jsb2Nrc1t0aGlzLmN1cnJlbnRCbG9ja0luZGV4IC0gMV07XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhcnJheSBvZiBCbG9jayBpbnN0YW5jZXNcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrW119IHtAbGluayBCbG9ja3MjYXJyYXl9XG4gICAqL1xuICBnZXQgYmxvY2tzKCkge1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3MuYXJyYXk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGVhY2ggQmxvY2sgaXMgZW1wdHlcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNFZGl0b3JFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3MuZXZlcnkoKGUpID0+IGUuaXNFbXB0eSk7XG4gIH1cbiAgLyoqXG4gICAqIFNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgRWRpdG9yLlVJIHByZXBhcmF0aW9uXG4gICAqIERlZmluZSB0aGlzLl9ibG9ja3MgcHJvcGVydHlcbiAgICovXG4gIHByZXBhcmUoKSB7XG4gICAgY29uc3QgZSA9IG5ldyBjdCh0aGlzLkVkaXRvci5VSS5ub2Rlcy5yZWRhY3Rvcik7XG4gICAgdGhpcy5fYmxvY2tzID0gbmV3IFByb3h5KGUsIHtcbiAgICAgIHNldDogY3Quc2V0LFxuICAgICAgZ2V0OiBjdC5nZXRcbiAgICB9KSwgdGhpcy5saXN0ZW5lcnMub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiY29weVwiLFxuICAgICAgKHQpID0+IHRoaXMuRWRpdG9yLkJsb2NrRXZlbnRzLmhhbmRsZUNvbW1hbmRDKHQpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlIHJlYWQtb25seSBzdGF0ZVxuICAgKlxuICAgKiBJZiByZWFkT25seSBpcyB0cnVlOlxuICAgKiAgLSBVbmJpbmQgZXZlbnQgaGFuZGxlcnMgZnJvbSBjcmVhdGVkIEJsb2Nrc1xuICAgKlxuICAgKiBpZiByZWFkT25seSBpcyBmYWxzZTpcbiAgICogIC0gQmluZCBldmVudCBoYW5kbGVycyB0byBhbGwgZXhpc3RpbmcgQmxvY2tzXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVhZE9ubHlFbmFibGVkIC0gXCJyZWFkIG9ubHlcIiBzdGF0ZVxuICAgKi9cbiAgdG9nZ2xlUmVhZE9ubHkoZSkge1xuICAgIGUgPyB0aGlzLmRpc2FibGVNb2R1bGVCaW5kaW5ncygpIDogdGhpcy5lbmFibGVNb2R1bGVCaW5kaW5ncygpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIEJsb2NrIGluc3RhbmNlIGJ5IHRvb2wgbmFtZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGJsb2NrIGNyZWF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbCAtIHRvb2xzIHBhc3NlZCBpbiBlZGl0b3IgY29uZmlnIHtAbGluayBFZGl0b3JDb25maWcjdG9vbHN9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZF0gLSB1bmlxdWUgaWQgZm9yIHRoaXMgYmxvY2tcbiAgICogQHBhcmFtIHtCbG9ja1Rvb2xEYXRhfSBbb3B0aW9ucy5kYXRhXSAtIGNvbnN0cnVjdG9yIHBhcmFtc1xuICAgKiBAcmV0dXJucyB7QmxvY2t9XG4gICAqL1xuICBjb21wb3NlQmxvY2soe1xuICAgIHRvb2w6IGUsXG4gICAgZGF0YTogdCA9IHt9LFxuICAgIGlkOiBvID0gdm9pZCAwLFxuICAgIHR1bmVzOiBpID0ge31cbiAgfSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLkVkaXRvci5SZWFkT25seS5pc0VuYWJsZWQsIHIgPSB0aGlzLkVkaXRvci5Ub29scy5ibG9ja1Rvb2xzLmdldChlKSwgYSA9IG5ldyBSKHtcbiAgICAgIGlkOiBvLFxuICAgICAgZGF0YTogdCxcbiAgICAgIHRvb2w6IHIsXG4gICAgICBhcGk6IHRoaXMuRWRpdG9yLkFQSSxcbiAgICAgIHJlYWRPbmx5OiBzLFxuICAgICAgdHVuZXNEYXRhOiBpXG4gICAgfSwgdGhpcy5ldmVudHNEaXNwYXRjaGVyKTtcbiAgICByZXR1cm4gcyB8fCB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICB0aGlzLmJpbmRCbG9ja0V2ZW50cyhhKTtcbiAgICB9LCB7IHRpbWVvdXQ6IDJlMyB9KSwgYTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IG5ldyBibG9jayBpbnRvIF9ibG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBpbnNlcnQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaWRdIC0gYmxvY2sncyB1bmlxdWUgaWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRvb2xdIC0gcGx1Z2luIG5hbWUsIGJ5IGRlZmF1bHQgbWV0aG9kIGluc2VydHMgdGhlIGRlZmF1bHQgYmxvY2sgdHlwZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuZGF0YV0gLSBwbHVnaW4gZGF0YVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaW5kZXhdIC0gaW5kZXggd2hlcmUgdG8gaW5zZXJ0IG5ldyBCbG9ja1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm5lZWRUb0ZvY3VzXSAtIGZsYWcgc2hvd3MgaWYgbmVlZGVkIHRvIHVwZGF0ZSBjdXJyZW50IEJsb2NrIGluZGV4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVwbGFjZV0gLSBmbGFnIHNob3dzIGlmIGJsb2NrIGJ5IHBhc3NlZCBpbmRleCBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCBpbnNlcnRlZCBvbmVcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgaW5zZXJ0KHtcbiAgICBpZDogZSA9IHZvaWQgMCxcbiAgICB0b29sOiB0ID0gdGhpcy5jb25maWcuZGVmYXVsdEJsb2NrLFxuICAgIGRhdGE6IG8gPSB7fSxcbiAgICBpbmRleDogaSxcbiAgICBuZWVkVG9Gb2N1czogcyA9ICEwLFxuICAgIHJlcGxhY2U6IHIgPSAhMSxcbiAgICB0dW5lczogYSA9IHt9XG4gIH0gPSB7fSkge1xuICAgIGxldCBsID0gaTtcbiAgICBsID09PSB2b2lkIDAgJiYgKGwgPSB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ICsgKHIgPyAwIDogMSkpO1xuICAgIGNvbnN0IGMgPSB0aGlzLmNvbXBvc2VCbG9jayh7XG4gICAgICBpZDogZSxcbiAgICAgIHRvb2w6IHQsXG4gICAgICBkYXRhOiBvLFxuICAgICAgdHVuZXM6IGFcbiAgICB9KTtcbiAgICByZXR1cm4gciAmJiB0aGlzLmJsb2NrRGlkTXV0YXRlZChfbywgdGhpcy5nZXRCbG9ja0J5SW5kZXgobCksIHtcbiAgICAgIGluZGV4OiBsXG4gICAgfSksIHRoaXMuX2Jsb2Nrcy5pbnNlcnQobCwgYywgciksIHRoaXMuYmxvY2tEaWRNdXRhdGVkKE1vLCBjLCB7XG4gICAgICBpbmRleDogbFxuICAgIH0pLCBzID8gdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IGwgOiBsIDw9IHRoaXMuY3VycmVudEJsb2NrSW5kZXggJiYgdGhpcy5jdXJyZW50QmxvY2tJbmRleCsrLCBjO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIHNldmVyYWwgYmxvY2tzIGF0IG9uY2VcbiAgICpcbiAgICogQHBhcmFtIGJsb2NrcyAtIGJsb2NrcyB0byBpbnNlcnRcbiAgICogQHBhcmFtIGluZGV4IC0gaW5kZXggd2hlcmUgdG8gaW5zZXJ0XG4gICAqL1xuICBpbnNlcnRNYW55KGUsIHQgPSAwKSB7XG4gICAgdGhpcy5fYmxvY2tzLmluc2VydE1hbnkoZSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBCbG9jayBkYXRhLlxuICAgKlxuICAgKiBDdXJyZW50bHkgd2UgZG9uJ3QgaGF2ZSBhbiAndXBkYXRlJyBtZXRob2QgaW4gdGhlIFRvb2xzIEFQSSwgc28gd2UganVzdCBjcmVhdGUgYSBuZXcgYmxvY2sgd2l0aCB0aGUgc2FtZSBpZCBhbmQgdHlwZVxuICAgKiBTaG91bGQgbm90IHRyaWdnZXIgJ2Jsb2NrLXJlbW92ZWQnIG9yICdibG9jay1hZGRlZCcgZXZlbnRzLlxuICAgKlxuICAgKiBJZiBuZWl0aGVyIGRhdGEgbm9yIHR1bmVzIGlzIHByb3ZpZGVkLCByZXR1cm4gdGhlIHByb3ZpZGVkIGJsb2NrIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBibG9jayAtIGJsb2NrIHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gZGF0YSAtIChvcHRpb25hbCkgbmV3IGRhdGFcbiAgICogQHBhcmFtIHR1bmVzIC0gKG9wdGlvbmFsKSB0dW5lIGRhdGFcbiAgICovXG4gIGFzeW5jIHVwZGF0ZShlLCB0LCBvKSB7XG4gICAgaWYgKCF0ICYmICFvKVxuICAgICAgcmV0dXJuIGU7XG4gICAgY29uc3QgaSA9IGF3YWl0IGUuZGF0YSwgcyA9IHRoaXMuY29tcG9zZUJsb2NrKHtcbiAgICAgIGlkOiBlLmlkLFxuICAgICAgdG9vbDogZS5uYW1lLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgaSwgdCA/PyB7fSksXG4gICAgICB0dW5lczogbyA/PyBlLnR1bmVzXG4gICAgfSksIHIgPSB0aGlzLmdldEJsb2NrSW5kZXgoZSk7XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2Nrcy5yZXBsYWNlKHIsIHMpLCB0aGlzLmJsb2NrRGlkTXV0YXRlZChBbywgcywge1xuICAgICAgaW5kZXg6IHJcbiAgICB9KSwgcztcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZSBwYXNzZWQgQmxvY2sgd2l0aCB0aGUgbmV3IG9uZSB3aXRoIHNwZWNpZmllZCBUb29sIGFuZCBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSBibG9jayAtIGJsb2NrIHRvIHJlcGxhY2VcbiAgICogQHBhcmFtIG5ld1Rvb2wgLSBuZXcgVG9vbCBuYW1lXG4gICAqIEBwYXJhbSBkYXRhIC0gbmV3IFRvb2wgZGF0YVxuICAgKi9cbiAgcmVwbGFjZShlLCB0LCBvKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0QmxvY2tJbmRleChlKTtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoe1xuICAgICAgdG9vbDogdCxcbiAgICAgIGRhdGE6IG8sXG4gICAgICBpbmRleDogaSxcbiAgICAgIHJlcGxhY2U6ICEwXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBwYXN0ZWQgY29udGVudC4gQ2FsbCBvblBhc3RlIGNhbGxiYWNrIGFmdGVyIGluc2VydC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvb2xOYW1lIC0gbmFtZSBvZiBUb29sIHRvIGluc2VydFxuICAgKiBAcGFyYW0ge1Bhc3RlRXZlbnR9IHBhc3RlRXZlbnQgLSBwYXN0ZWQgZGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcGxhY2UgLSBzaG91bGQgcmVwbGFjZSBjdXJyZW50IGJsb2NrXG4gICAqL1xuICBwYXN0ZShlLCB0LCBvID0gITEpIHtcbiAgICBjb25zdCBpID0gdGhpcy5pbnNlcnQoe1xuICAgICAgdG9vbDogZSxcbiAgICAgIHJlcGxhY2U6IG9cbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpLmNhbGwoZWUuT05fUEFTVEUsIHQpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAocykge1xuICAgICAgUyhgJHtlfTogb25QYXN0ZSBjYWxsYmFjayBjYWxsIGlzIGZhaWxlZGAsIFwiZXJyb3JcIiwgcyk7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgbmV3IGRlZmF1bHQgYmxvY2sgYXQgcGFzc2VkIGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGluZGV4IHdoZXJlIEJsb2NrIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5lZWRUb0ZvY3VzIC0gaWYgdHJ1ZSwgdXBkYXRlcyBjdXJyZW50IEJsb2NrIGluZGV4XG4gICAqXG4gICAqIFRPRE86IFJlbW92ZSBtZXRob2QgYW5kIHVzZSBpbnNlcnQoKSB3aXRoIGluZGV4IGluc3RlYWQgKD8pXG4gICAqIEByZXR1cm5zIHtCbG9ja30gaW5zZXJ0ZWQgQmxvY2tcbiAgICovXG4gIGluc2VydERlZmF1bHRCbG9ja0F0SW5kZXgoZSwgdCA9ICExKSB7XG4gICAgY29uc3QgbyA9IHRoaXMuY29tcG9zZUJsb2NrKHsgdG9vbDogdGhpcy5jb25maWcuZGVmYXVsdEJsb2NrIH0pO1xuICAgIHJldHVybiB0aGlzLl9ibG9ja3NbZV0gPSBvLCB0aGlzLmJsb2NrRGlkTXV0YXRlZChNbywgbywge1xuICAgICAgaW5kZXg6IGVcbiAgICB9KSwgdCA/IHRoaXMuY3VycmVudEJsb2NrSW5kZXggPSBlIDogZSA8PSB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ICYmIHRoaXMuY3VycmVudEJsb2NrSW5kZXgrKywgbztcbiAgfVxuICAvKipcbiAgICogQWx3YXlzIGluc2VydHMgYXQgdGhlIGVuZFxuICAgKlxuICAgKiBAcmV0dXJucyB7QmxvY2t9XG4gICAqL1xuICBpbnNlcnRBdEVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IHRoaXMuYmxvY2tzLmxlbmd0aCAtIDEsIHRoaXMuaW5zZXJ0KCk7XG4gIH1cbiAgLyoqXG4gICAqIE1lcmdlIHR3byBibG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gdGFyZ2V0QmxvY2sgLSBwcmV2aW91cyBibG9jayB3aWxsIGJlIGFwcGVuZCB0byB0aGlzIGJsb2NrXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrVG9NZXJnZSAtIGJsb2NrIHRoYXQgd2lsbCBiZSBtZXJnZWQgd2l0aCB0YXJnZXQgYmxvY2tcbiAgICogQHJldHVybnMge1Byb21pc2V9IC0gdGhlIHNlcXVlbmNlIHRoYXQgY2FuIGJlIGNvbnRpbnVlZFxuICAgKi9cbiAgYXN5bmMgbWVyZ2VCbG9ja3MoZSwgdCkge1xuICAgIGxldCBvO1xuICAgIGlmIChlLm5hbWUgPT09IHQubmFtZSAmJiBlLm1lcmdlYWJsZSkge1xuICAgICAgY29uc3QgaSA9IGF3YWl0IHQuZGF0YTtcbiAgICAgIGlmIChWKGkpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb3VsZCBub3QgbWVyZ2UgQmxvY2suIEZhaWxlZCB0byBleHRyYWN0IG9yaWdpbmFsIEJsb2NrIGRhdGEuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBbc10gPSB5dChbaV0sIGUudG9vbC5zYW5pdGl6ZUNvbmZpZyk7XG4gICAgICBvID0gcztcbiAgICB9IGVsc2UgaWYgKGUubWVyZ2VhYmxlICYmIEhlKHQsIFwiZXhwb3J0XCIpICYmIEhlKGUsIFwiaW1wb3J0XCIpKSB7XG4gICAgICBjb25zdCBpID0gYXdhaXQgdC5leHBvcnREYXRhQXNTdHJpbmcoKSwgcyA9IFooaSwgZS50b29sLnNhbml0aXplQ29uZmlnKTtcbiAgICAgIG8gPSBCbyhzLCBlLnRvb2wuY29udmVyc2lvbkNvbmZpZyk7XG4gICAgfVxuICAgIG8gIT09IHZvaWQgMCAmJiAoYXdhaXQgZS5tZXJnZVdpdGgobyksIHRoaXMucmVtb3ZlQmxvY2sodCksIHRoaXMuY3VycmVudEJsb2NrSW5kZXggPSB0aGlzLl9ibG9ja3MuaW5kZXhPZihlKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBwYXNzZWQgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIGJsb2NrIC0gQmxvY2sgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSBhZGRMYXN0QmxvY2sgLSBpZiB0cnVlLCBhZGRzIG5ldyBkZWZhdWx0IGJsb2NrIGF0IHRoZSBlbmQuIEB0b2RvIHJlbW92ZSB0aGlzIGxvZ2ljIGFuZCB1c2UgZXZlbnQtYnVzIGluc3RlYWRcbiAgICovXG4gIHJlbW92ZUJsb2NrKGUsIHQgPSAhMCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgobykgPT4ge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2Jsb2Nrcy5pbmRleE9mKGUpO1xuICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlSW5kZXgoaSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGZpbmQgYSBCbG9jayB0byByZW1vdmVcIik7XG4gICAgICBlLmRlc3Ryb3koKSwgdGhpcy5fYmxvY2tzLnJlbW92ZShpKSwgdGhpcy5ibG9ja0RpZE11dGF0ZWQoX28sIGUsIHtcbiAgICAgICAgaW5kZXg6IGlcbiAgICAgIH0pLCB0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID49IGkgJiYgdGhpcy5jdXJyZW50QmxvY2tJbmRleC0tLCB0aGlzLmJsb2Nrcy5sZW5ndGggPyBpID09PSAwICYmICh0aGlzLmN1cnJlbnRCbG9ja0luZGV4ID0gMCkgOiAodGhpcy51bnNldEN1cnJlbnRCbG9jaygpLCB0ICYmIHRoaXMuaW5zZXJ0KCkpLCBvKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBvbmx5IHNlbGVjdGVkIEJsb2Nrc1xuICAgKiBhbmQgcmV0dXJucyBmaXJzdCBCbG9jayBpbmRleCB3aGVyZSBzdGFydGVkIHJlbW92aW5nLi4uXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgKi9cbiAgcmVtb3ZlU2VsZWN0ZWRCbG9ja3MoKSB7XG4gICAgbGV0IGU7XG4gICAgZm9yIChsZXQgdCA9IHRoaXMuYmxvY2tzLmxlbmd0aCAtIDE7IHQgPj0gMDsgdC0tKVxuICAgICAgdGhpcy5ibG9ja3NbdF0uc2VsZWN0ZWQgJiYgKHRoaXMucmVtb3ZlQmxvY2sodGhpcy5ibG9ja3NbdF0pLCBlID0gdCk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVudGlvbiFcbiAgICogQWZ0ZXIgcmVtb3ZpbmcgaW5zZXJ0IHRoZSBuZXcgZGVmYXVsdCB0eXBlZCBCbG9jayBhbmQgZm9jdXMgb24gaXRcbiAgICogUmVtb3ZlcyBhbGwgYmxvY2tzXG4gICAqL1xuICByZW1vdmVBbGxCbG9ja3MoKSB7XG4gICAgZm9yIChsZXQgZSA9IHRoaXMuYmxvY2tzLmxlbmd0aCAtIDE7IGUgPj0gMDsgZS0tKVxuICAgICAgdGhpcy5fYmxvY2tzLnJlbW92ZShlKTtcbiAgICB0aGlzLnVuc2V0Q3VycmVudEJsb2NrKCksIHRoaXMuaW5zZXJ0KCksIHRoaXMuY3VycmVudEJsb2NrLmZpcnN0SW5wdXQuZm9jdXMoKTtcbiAgfVxuICAvKipcbiAgICogU3BsaXQgY3VycmVudCBCbG9ja1xuICAgKiAxLiBFeHRyYWN0IGNvbnRlbnQgZnJvbSBDYXJldCBwb3NpdGlvbiB0byB0aGUgQmxvY2tgcyBlbmRcbiAgICogMi4gSW5zZXJ0IGEgbmV3IEJsb2NrIGJlbG93IGN1cnJlbnQgb25lIHdpdGggZXh0cmFjdGVkIGNvbnRlbnRcbiAgICpcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgc3BsaXQoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuRWRpdG9yLkNhcmV0LmV4dHJhY3RGcmFnbWVudEZyb21DYXJldFBvc2l0aW9uKCksIHQgPSBkLm1ha2UoXCJkaXZcIik7XG4gICAgdC5hcHBlbmRDaGlsZChlKTtcbiAgICBjb25zdCBvID0ge1xuICAgICAgdGV4dDogZC5pc0VtcHR5KHQpID8gXCJcIiA6IHQuaW5uZXJIVE1MXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoeyBkYXRhOiBvIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEJsb2NrIGJ5IHBhc3NlZCBpbmRleFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCB0byBnZXQuIC0xIHRvIGdldCBsYXN0XG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIGdldEJsb2NrQnlJbmRleChlKSB7XG4gICAgcmV0dXJuIGUgPT09IC0xICYmIChlID0gdGhpcy5fYmxvY2tzLmxlbmd0aCAtIDEpLCB0aGlzLl9ibG9ja3NbZV07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaW5kZXggZm9yIHBhc3NlZCBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0gYmxvY2sgLSBibG9jayB0byBmaW5kIGluZGV4XG4gICAqL1xuICBnZXRCbG9ja0luZGV4KGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzLmluZGV4T2YoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEJsb2NrIGJ5IHBhc3NlZCBpZFxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBpZCBvZiBibG9jayB0byBnZXRcbiAgICogQHJldHVybnMge0Jsb2NrfVxuICAgKi9cbiAgZ2V0QmxvY2tCeUlkKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tzLmFycmF5LmZpbmQoKHQpID0+IHQuaWQgPT09IGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgQmxvY2sgaW5zdGFuY2UgYnkgaHRtbCBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWxlbWVudCAtIGh0bWwgZWxlbWVudCB0byBnZXQgQmxvY2sgYnlcbiAgICovXG4gIGdldEJsb2NrKGUpIHtcbiAgICBkLmlzRWxlbWVudChlKSB8fCAoZSA9IGUucGFyZW50Tm9kZSk7XG4gICAgY29uc3QgdCA9IHRoaXMuX2Jsb2Nrcy5ub2RlcywgbyA9IGUuY2xvc2VzdChgLiR7Ui5DU1Mud3JhcHBlcn1gKSwgaSA9IHQuaW5kZXhPZihvKTtcbiAgICBpZiAoaSA+PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuX2Jsb2Nrc1tpXTtcbiAgfVxuICAvKipcbiAgICogMSkgRmluZCBmaXJzdC1sZXZlbCBCbG9jayBmcm9tIHBhc3NlZCBjaGlsZCBOb2RlXG4gICAqIDIpIE1hcmsgaXQgYXMgY3VycmVudFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IGNoaWxkTm9kZSAtIGxvb2sgYWhlYWQgZnJvbSB0aGlzIG5vZGUuXG4gICAqIEByZXR1cm5zIHtCbG9jayB8IHVuZGVmaW5lZH0gY2FuIHJldHVybiB1bmRlZmluZWQgaW4gY2FzZSB3aGVuIHRoZSBwYXNzZWQgY2hpbGQgbm90ZSBpcyBub3QgYSBwYXJ0IG9mIHRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuICAgKi9cbiAgc2V0Q3VycmVudEJsb2NrQnlDaGlsZE5vZGUoZSkge1xuICAgIGQuaXNFbGVtZW50KGUpIHx8IChlID0gZS5wYXJlbnROb2RlKTtcbiAgICBjb25zdCB0ID0gZS5jbG9zZXN0KGAuJHtSLkNTUy53cmFwcGVyfWApO1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvID0gdC5jbG9zZXN0KGAuJHt0aGlzLkVkaXRvci5VSS5DU1MuZWRpdG9yV3JhcHBlcn1gKTtcbiAgICBpZiAobyAhPSBudWxsICYmIG8uaXNFcXVhbE5vZGUodGhpcy5FZGl0b3IuVUkubm9kZXMud3JhcHBlcikpXG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IHRoaXMuX2Jsb2Nrcy5ub2Rlcy5pbmRleE9mKHQpLCB0aGlzLmN1cnJlbnRCbG9jay51cGRhdGVDdXJyZW50SW5wdXQoKSwgdGhpcy5jdXJyZW50QmxvY2s7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBibG9jayB3aGljaCBjb250ZW50cyBwYXNzZWQgbm9kZVxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IGNoaWxkTm9kZSAtIG5vZGUgdG8gZ2V0IEJsb2NrIGJ5XG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG4gIGdldEJsb2NrQnlDaGlsZE5vZGUoZSkge1xuICAgIGlmICghZSB8fCAhKGUgaW5zdGFuY2VvZiBOb2RlKSlcbiAgICAgIHJldHVybjtcbiAgICBkLmlzRWxlbWVudChlKSB8fCAoZSA9IGUucGFyZW50Tm9kZSk7XG4gICAgY29uc3QgdCA9IGUuY2xvc2VzdChgLiR7Ui5DU1Mud3JhcHBlcn1gKTtcbiAgICByZXR1cm4gdGhpcy5ibG9ja3MuZmluZCgobykgPT4gby5ob2xkZXIgPT09IHQpO1xuICB9XG4gIC8qKlxuICAgKiBTd2FwIEJsb2NrcyBQb3NpdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IC0gaW5kZXggb2YgZmlyc3QgYmxvY2tcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggLSBpbmRleCBvZiBzZWNvbmQgYmxvY2tcbiAgICogQGRlcHJlY2F0ZWQg4oCUIHVzZSAnbW92ZScgaW5zdGVhZFxuICAgKi9cbiAgc3dhcChlLCB0KSB7XG4gICAgdGhpcy5fYmxvY2tzLnN3YXAoZSwgdCksIHRoaXMuY3VycmVudEJsb2NrSW5kZXggPSB0O1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlIGEgYmxvY2sgdG8gYSBuZXcgaW5kZXhcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggLSBpbmRleCB3aGVyZSB0byBtb3ZlIEJsb2NrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggLSBpbmRleCBvZiBCbG9jayB0byBtb3ZlXG4gICAqL1xuICBtb3ZlKGUsIHQgPSB0aGlzLmN1cnJlbnRCbG9ja0luZGV4KSB7XG4gICAgaWYgKGlzTmFOKGUpIHx8IGlzTmFOKHQpKSB7XG4gICAgICBTKFwiV2FybmluZyBkdXJpbmcgJ21vdmUnIGNhbGw6IGluY29ycmVjdCBpbmRpY2VzIHByb3ZpZGVkLlwiLCBcIndhcm5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy52YWxpZGF0ZUluZGV4KGUpIHx8ICF0aGlzLnZhbGlkYXRlSW5kZXgodCkpIHtcbiAgICAgIFMoXCJXYXJuaW5nIGR1cmluZyAnbW92ZScgY2FsbDogaW5kaWNlcyBjYW5ub3QgYmUgbG93ZXIgdGhhbiAwIG9yIGdyZWF0ZXIgdGhhbiB0aGUgYW1vdW50IG9mIGJsb2Nrcy5cIiwgXCJ3YXJuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9ibG9ja3MubW92ZShlLCB0KSwgdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IGUsIHRoaXMuYmxvY2tEaWRNdXRhdGVkKGlhLCB0aGlzLmN1cnJlbnRCbG9jaywge1xuICAgICAgZnJvbUluZGV4OiB0LFxuICAgICAgdG9JbmRleDogZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBwYXNzZWQgQmxvY2sgdG8gdGhlIG5ldyBUb29sXG4gICAqIFVzZXMgQ29udmVyc2lvbiBDb25maWdcbiAgICpcbiAgICogQHBhcmFtIGJsb2NrVG9Db252ZXJ0IC0gQmxvY2sgdGhhdCBzaG91bGQgYmUgY29udmVydGVkXG4gICAqIEBwYXJhbSB0YXJnZXRUb29sTmFtZSAtIG5hbWUgb2YgdGhlIFRvb2wgdG8gY29udmVydCB0b1xuICAgKiBAcGFyYW0gYmxvY2tEYXRhT3ZlcnJpZGVzIC0gb3B0aW9uYWwgbmV3IEJsb2NrIGRhdGEgb3ZlcnJpZGVzXG4gICAqL1xuICBhc3luYyBjb252ZXJ0KGUsIHQsIG8pIHtcbiAgICBpZiAoIWF3YWl0IGUuc2F2ZSgpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbnZlcnQgQmxvY2suIEZhaWxlZCB0byBleHRyYWN0IG9yaWdpbmFsIEJsb2NrIGRhdGEuXCIpO1xuICAgIGNvbnN0IHMgPSB0aGlzLkVkaXRvci5Ub29scy5ibG9ja1Rvb2xzLmdldCh0KTtcbiAgICBpZiAoIXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBjb252ZXJ0IEJsb2NrLiBUb29sIMKrJHt0fcK7IG5vdCBmb3VuZC5gKTtcbiAgICBjb25zdCByID0gYXdhaXQgZS5leHBvcnREYXRhQXNTdHJpbmcoKSwgYSA9IFooXG4gICAgICByLFxuICAgICAgcy5zYW5pdGl6ZUNvbmZpZ1xuICAgICk7XG4gICAgbGV0IGwgPSBCbyhhLCBzLmNvbnZlcnNpb25Db25maWcsIHMuc2V0dGluZ3MpO1xuICAgIHJldHVybiBvICYmIChsID0gT2JqZWN0LmFzc2lnbihsLCBvKSksIHRoaXMucmVwbGFjZShlLCBzLm5hbWUsIGwpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGN1cnJlbnQgQmxvY2sgSW5kZXggLTEgd2hpY2ggbWVhbnMgdW5rbm93blxuICAgKiBhbmQgY2xlYXIgaGlnaGxpZ2h0c1xuICAgKi9cbiAgdW5zZXRDdXJyZW50QmxvY2soKSB7XG4gICAgdGhpcy5jdXJyZW50QmxvY2tJbmRleCA9IC0xO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgRWRpdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbmVlZFRvQWRkRGVmYXVsdEJsb2NrIC0gMSkgaW4gaW50ZXJuYWwgY2FsbHMgKGZvciBleGFtcGxlLCBpbiBhcGkuYmxvY2tzLnJlbmRlcilcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZSBkb24ndCBuZWVkIHRvIGFkZCBhbiBlbXB0eSBkZWZhdWx0IGJsb2NrXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIpIGluIGFwaS5ibG9ja3MuY2xlYXIgd2Ugc2hvdWxkIGFkZCBlbXB0eSBibG9ja1xuICAgKi9cbiAgYXN5bmMgY2xlYXIoZSA9ICExKSB7XG4gICAgY29uc3QgdCA9IG5ldyBzYSgpO1xuICAgIHRoaXMuYmxvY2tzLmZvckVhY2goKG8pID0+IHtcbiAgICAgIHQuYWRkKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZW1vdmVCbG9jayhvLCAhMSk7XG4gICAgICB9KTtcbiAgICB9KSwgYXdhaXQgdC5jb21wbGV0ZWQsIHRoaXMudW5zZXRDdXJyZW50QmxvY2soKSwgZSAmJiB0aGlzLmluc2VydCgpLCB0aGlzLkVkaXRvci5VSS5jaGVja0VtcHRpbmVzcygpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgYWxsIHRoZSBibG9jayB0b29scycgcmVzb3VyY2VzXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gZWRpdG9yIGlzIGRlc3Ryb3llZFxuICAgKi9cbiAgYXN5bmMgZGVzdHJveSgpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmJsb2Nrcy5tYXAoKGUpID0+IGUuZGVzdHJveSgpKSk7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmQgQmxvY2sgZXZlbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrIC0gQmxvY2sgdG8gd2hpY2ggZXZlbnQgc2hvdWxkIGJlIGJvdW5kXG4gICAqL1xuICBiaW5kQmxvY2tFdmVudHMoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tFdmVudHM6IHQgfSA9IHRoaXMuRWRpdG9yO1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKGUuaG9sZGVyLCBcImtleWRvd25cIiwgKG8pID0+IHtcbiAgICAgIHQua2V5ZG93bihvKTtcbiAgICB9KSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24oZS5ob2xkZXIsIFwia2V5dXBcIiwgKG8pID0+IHtcbiAgICAgIHQua2V5dXAobyk7XG4gICAgfSksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKGUuaG9sZGVyLCBcImRyYWdvdmVyXCIsIChvKSA9PiB7XG4gICAgICB0LmRyYWdPdmVyKG8pO1xuICAgIH0pLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbihlLmhvbGRlciwgXCJkcmFnbGVhdmVcIiwgKG8pID0+IHtcbiAgICAgIHQuZHJhZ0xlYXZlKG8pO1xuICAgIH0pLCBlLm9uKFwiZGlkTXV0YXRlZFwiLCAobykgPT4gdGhpcy5ibG9ja0RpZE11dGF0ZWQoQW8sIG8sIHtcbiAgICAgIGluZGV4OiB0aGlzLmdldEJsb2NrSW5kZXgobylcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGUgbXV0YWJsZSBoYW5kbGVycyBhbmQgYmluZGluZ3NcbiAgICovXG4gIGRpc2FibGVNb2R1bGVCaW5kaW5ncygpIHtcbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5jbGVhckFsbCgpO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIGFsbCBtb2R1bGUgaGFuZGxlcnMgYW5kIGJpbmRpbmdzIGZvciBhbGwgQmxvY2tzXG4gICAqL1xuICBlbmFibGVNb2R1bGVCaW5kaW5ncygpIHtcbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJjdXRcIixcbiAgICAgIChlKSA9PiB0aGlzLkVkaXRvci5CbG9ja0V2ZW50cy5oYW5kbGVDb21tYW5kWChlKVxuICAgICksIHRoaXMuYmxvY2tzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIHRoaXMuYmluZEJsb2NrRXZlbnRzKGUpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgZ2l2ZW4gaW5kZXggaXMgbm90IGxvd2VyIHRoYW4gMCBvciBoaWdoZXIgdGhhbiB0aGUgYW1vdW50IG9mIGJsb2Nrc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBpbmRleCBvZiBibG9ja3MgYXJyYXkgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICB2YWxpZGF0ZUluZGV4KGUpIHtcbiAgICByZXR1cm4gIShlIDwgMCB8fCBlID49IHRoaXMuX2Jsb2Nrcy5sZW5ndGgpO1xuICB9XG4gIC8qKlxuICAgKiBCbG9jayBtdXRhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gbXV0YXRpb25UeXBlIC0gd2hhdCBoYXBwZW5lZCB3aXRoIGJsb2NrXG4gICAqIEBwYXJhbSBibG9jayAtIG11dGF0ZWQgYmxvY2tcbiAgICogQHBhcmFtIGRldGFpbERhdGEgLSBhZGRpdGlvbmFsIGRhdGEgdG8gcGFzcyB3aXRoIGNoYW5nZSBldmVudFxuICAgKi9cbiAgYmxvY2tEaWRNdXRhdGVkKGUsIHQsIG8pIHtcbiAgICBjb25zdCBpID0gbmV3IEN1c3RvbUV2ZW50KGUsIHtcbiAgICAgIGRldGFpbDoge1xuICAgICAgICB0YXJnZXQ6IG5ldyBKKHQpLFxuICAgICAgICAuLi5vXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5lbWl0KCRvLCB7XG4gICAgICBldmVudDogaVxuICAgIH0pLCB0O1xuICB9XG59XG5jbGFzcyBhYSBleHRlbmRzIEUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLmFueUJsb2NrU2VsZWN0ZWRDYWNoZSA9IG51bGwsIHRoaXMubmVlZFRvU2VsZWN0QWxsID0gITEsIHRoaXMubmF0aXZlSW5wdXRTZWxlY3RlZCA9ICExLCB0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbiA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBTYW5pdGl6ZXIgQ29uZmlnXG4gICAqXG4gICAqIEByZXR1cm5zIHtTYW5pdGl6ZXJDb25maWd9XG4gICAqL1xuICBnZXQgc2FuaXRpemVyQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwOiB7fSxcbiAgICAgIGgxOiB7fSxcbiAgICAgIGgyOiB7fSxcbiAgICAgIGgzOiB7fSxcbiAgICAgIGg0OiB7fSxcbiAgICAgIGg1OiB7fSxcbiAgICAgIGg2OiB7fSxcbiAgICAgIG9sOiB7fSxcbiAgICAgIHVsOiB7fSxcbiAgICAgIGxpOiB7fSxcbiAgICAgIGJyOiAhMCxcbiAgICAgIGltZzoge1xuICAgICAgICBzcmM6ICEwLFxuICAgICAgICB3aWR0aDogITAsXG4gICAgICAgIGhlaWdodDogITBcbiAgICAgIH0sXG4gICAgICBhOiB7XG4gICAgICAgIGhyZWY6ICEwXG4gICAgICB9LFxuICAgICAgYjoge30sXG4gICAgICBpOiB7fSxcbiAgICAgIHU6IHt9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRmxhZyB0aGF0IGlkZW50aWZpZXMgYWxsIEJsb2NrcyBzZWxlY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgYWxsQmxvY2tzU2VsZWN0ZWQoKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGUgfSA9IHRoaXMuRWRpdG9yO1xuICAgIHJldHVybiBlLmJsb2Nrcy5ldmVyeSgodCkgPT4gdC5zZWxlY3RlZCA9PT0gITApO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgc2VsZWN0ZWQgYWxsIGJsb2Nrc1xuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXRlIC0gc3RhdGUgdG8gc2V0XG4gICAqL1xuICBzZXQgYWxsQmxvY2tzU2VsZWN0ZWQoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0IH0gPSB0aGlzLkVkaXRvcjtcbiAgICB0LmJsb2Nrcy5mb3JFYWNoKChvKSA9PiB7XG4gICAgICBvLnNlbGVjdGVkID0gZTtcbiAgICB9KSwgdGhpcy5jbGVhckNhY2hlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZsYWcgdGhhdCBpZGVudGlmaWVzIGFueSBCbG9jayBzZWxlY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgYW55QmxvY2tTZWxlY3RlZCgpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogZSB9ID0gdGhpcy5FZGl0b3I7XG4gICAgcmV0dXJuIHRoaXMuYW55QmxvY2tTZWxlY3RlZENhY2hlID09PSBudWxsICYmICh0aGlzLmFueUJsb2NrU2VsZWN0ZWRDYWNoZSA9IGUuYmxvY2tzLnNvbWUoKHQpID0+IHQuc2VsZWN0ZWQgPT09ICEwKSksIHRoaXMuYW55QmxvY2tTZWxlY3RlZENhY2hlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gc2VsZWN0ZWQgQmxvY2tzIGFycmF5XG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja1tdfVxuICAgKi9cbiAgZ2V0IHNlbGVjdGVkQmxvY2tzKCkge1xuICAgIHJldHVybiB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuYmxvY2tzLmZpbHRlcigoZSkgPT4gZS5zZWxlY3RlZCk7XG4gIH1cbiAgLyoqXG4gICAqIE1vZHVsZSBQcmVwYXJhdGlvblxuICAgKiBSZWdpc3RlcnMgU2hvcnRjdXRzIENNRCtBIGFuZCBDTUQrQ1xuICAgKiB0byBzZWxlY3QgYWxsIGFuZCBjb3B5IHRoZW1cbiAgICovXG4gIHByZXBhcmUoKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgYigpLCBnZS5hZGQoe1xuICAgICAgbmFtZTogXCJDTUQrQVwiLFxuICAgICAgaGFuZGxlcjogKGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIFJlYWRPbmx5OiBvIH0gPSB0aGlzLkVkaXRvcjtcbiAgICAgICAgaWYgKG8uaXNFbmFibGVkKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLnNlbGVjdEFsbEJsb2NrcygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0LmN1cnJlbnRCbG9jayAmJiB0aGlzLmhhbmRsZUNvbW1hbmRBKGUpO1xuICAgICAgfSxcbiAgICAgIG9uOiB0aGlzLkVkaXRvci5VSS5ub2Rlcy5yZWRhY3RvclxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGUgcmVhZC1vbmx5IHN0YXRlXG4gICAqXG4gICAqICAtIFJlbW92ZSBhbGwgcmFuZ2VzXG4gICAqICAtIFVuc2VsZWN0IGFsbCBCbG9ja3NcbiAgICovXG4gIHRvZ2dsZVJlYWRPbmx5KCkge1xuICAgIGIuZ2V0KCkucmVtb3ZlQWxsUmFuZ2VzKCksIHRoaXMuYWxsQmxvY2tzU2VsZWN0ZWQgPSAhMTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHNlbGVjdGlvbiBvZiBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcj99IGluZGV4IC0gQmxvY2sgaW5kZXggYWNjb3JkaW5nIHRvIHRoZSBCbG9ja01hbmFnZXIncyBpbmRleGVzXG4gICAqL1xuICB1blNlbGVjdEJsb2NrQnlJbmRleChlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQgfSA9IHRoaXMuRWRpdG9yO1xuICAgIGxldCBvO1xuICAgIGlzTmFOKGUpID8gbyA9IHQuY3VycmVudEJsb2NrIDogbyA9IHQuZ2V0QmxvY2tCeUluZGV4KGUpLCBvLnNlbGVjdGVkID0gITEsIHRoaXMuY2xlYXJDYWNoZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhciBzZWxlY3Rpb24gZnJvbSBCbG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gcmVhc29uIC0gZXZlbnQgY2F1c2VkIGNsZWFyIG9mIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc3RvcmVTZWxlY3Rpb24gLSBpZiB0cnVlLCByZXN0b3JlIHNhdmVkIHNlbGVjdGlvblxuICAgKi9cbiAgY2xlYXJTZWxlY3Rpb24oZSwgdCA9ICExKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IG8sIENhcmV0OiBpLCBSZWN0YW5nbGVTZWxlY3Rpb246IHMgfSA9IHRoaXMuRWRpdG9yO1xuICAgIHRoaXMubmVlZFRvU2VsZWN0QWxsID0gITEsIHRoaXMubmF0aXZlSW5wdXRTZWxlY3RlZCA9ICExLCB0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbiA9ICExO1xuICAgIGNvbnN0IHIgPSBlICYmIGUgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50LCBhID0gciAmJiBQbyhlLmtleUNvZGUpO1xuICAgIGlmICh0aGlzLmFueUJsb2NrU2VsZWN0ZWQgJiYgciAmJiBhICYmICFiLmlzU2VsZWN0aW9uRXhpc3RzKSB7XG4gICAgICBjb25zdCBsID0gby5yZW1vdmVTZWxlY3RlZEJsb2NrcygpO1xuICAgICAgby5pbnNlcnREZWZhdWx0QmxvY2tBdEluZGV4KGwsICEwKSwgaS5zZXRUb0Jsb2NrKG8uY3VycmVudEJsb2NrKSwgRmUoKCkgPT4ge1xuICAgICAgICBjb25zdCBjID0gZS5rZXk7XG4gICAgICAgIGkuaW5zZXJ0Q29udGVudEF0Q2FyZXRQb3NpdGlvbihjLmxlbmd0aCA+IDEgPyBcIlwiIDogYyk7XG4gICAgICB9LCAyMCkoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuRWRpdG9yLkNyb3NzQmxvY2tTZWxlY3Rpb24uY2xlYXIoZSksICF0aGlzLmFueUJsb2NrU2VsZWN0ZWQgfHwgcy5pc1JlY3RBY3RpdmF0ZWQoKSkge1xuICAgICAgdGhpcy5FZGl0b3IuUmVjdGFuZ2xlU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHQgJiYgdGhpcy5zZWxlY3Rpb24ucmVzdG9yZSgpLCB0aGlzLmFsbEJsb2Nrc1NlbGVjdGVkID0gITE7XG4gIH1cbiAgLyoqXG4gICAqIFJlZHVjZSBlYWNoIEJsb2NrIGFuZCBjb3B5IGl0cyBjb250ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7Q2xpcGJvYXJkRXZlbnR9IGUgLSBjb3B5L2N1dCBldmVudFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGNvcHlTZWxlY3RlZEJsb2NrcyhlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHQgPSBkLm1ha2UoXCJkaXZcIik7XG4gICAgdGhpcy5zZWxlY3RlZEJsb2Nrcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBjb25zdCByID0gWihzLmhvbGRlci5pbm5lckhUTUwsIHRoaXMuc2FuaXRpemVyQ29uZmlnKSwgYSA9IGQubWFrZShcInBcIik7XG4gICAgICBhLmlubmVySFRNTCA9IHIsIHQuYXBwZW5kQ2hpbGQoYSk7XG4gICAgfSk7XG4gICAgY29uc3QgbyA9IEFycmF5LmZyb20odC5jaGlsZE5vZGVzKS5tYXAoKHMpID0+IHMudGV4dENvbnRlbnQpLmpvaW4oYFxuXG5gKSwgaSA9IHQuaW5uZXJIVE1MO1xuICAgIHJldHVybiBlLmNsaXBib2FyZERhdGEuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgbyksIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwidGV4dC9odG1sXCIsIGkpLCBQcm9taXNlLmFsbCh0aGlzLnNlbGVjdGVkQmxvY2tzLm1hcCgocykgPT4gcy5zYXZlKCkpKS50aGVuKChzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBlLmNsaXBib2FyZERhdGEuc2V0RGF0YSh0aGlzLkVkaXRvci5QYXN0ZS5NSU1FX1RZUEUsIEpTT04uc3RyaW5naWZ5KHMpKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3QgQmxvY2sgYnkgaXRzIGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyP30gaW5kZXggLSBCbG9jayBpbmRleCBhY2NvcmRpbmcgdG8gdGhlIEJsb2NrTWFuYWdlcidzIGluZGV4ZXNcbiAgICovXG4gIHNlbGVjdEJsb2NrQnlJbmRleChlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQgfSA9IHRoaXMuRWRpdG9yLCBvID0gdC5nZXRCbG9ja0J5SW5kZXgoZSk7XG4gICAgbyAhPT0gdm9pZCAwICYmIHRoaXMuc2VsZWN0QmxvY2sobyk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbGVjdCBwYXNzZWQgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2sgLSBCbG9jayB0byBzZWxlY3RcbiAgICovXG4gIHNlbGVjdEJsb2NrKGUpIHtcbiAgICB0aGlzLnNlbGVjdGlvbi5zYXZlKCksIGIuZ2V0KCkucmVtb3ZlQWxsUmFuZ2VzKCksIGUuc2VsZWN0ZWQgPSAhMCwgdGhpcy5jbGVhckNhY2hlKCksIHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIHNlbGVjdGlvbiBmcm9tIHBhc3NlZCBCbG9ja1xuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrfSBibG9jayAtIEJsb2NrIHRvIHVuc2VsZWN0XG4gICAqL1xuICB1bnNlbGVjdEJsb2NrKGUpIHtcbiAgICBlLnNlbGVjdGVkID0gITEsIHRoaXMuY2xlYXJDYWNoZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhciBhbnlCbG9ja1NlbGVjdGVkIGNhY2hlXG4gICAqL1xuICBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMuYW55QmxvY2tTZWxlY3RlZENhY2hlID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogTW9kdWxlIGRlc3RydWN0aW9uXG4gICAqIERlLXJlZ2lzdGVycyBTaG9ydGN1dCBDTUQrQVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBnZS5yZW1vdmUodGhpcy5FZGl0b3IuVUkubm9kZXMucmVkYWN0b3IsIFwiQ01EK0FcIik7XG4gIH1cbiAgLyoqXG4gICAqIEZpcnN0IENNRCtBIHNlbGVjdHMgYWxsIGlucHV0IGNvbnRlbnQgYnkgbmF0aXZlIGJlaGF2aW91cixcbiAgICogbmV4dCBDTUQrQSBrZXlwcmVzcyBzZWxlY3RzIGFsbCBibG9ja3NcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWJvYXJkIGV2ZW50XG4gICAqL1xuICBoYW5kbGVDb21tYW5kQShlKSB7XG4gICAgaWYgKHRoaXMuRWRpdG9yLlJlY3RhbmdsZVNlbGVjdGlvbi5jbGVhclNlbGVjdGlvbigpLCBkLmlzTmF0aXZlSW5wdXQoZS50YXJnZXQpICYmICF0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbikge1xuICAgICAgdGhpcy5yZWFkeVRvQmxvY2tTZWxlY3Rpb24gPSAhMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdCA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9jayhlLnRhcmdldCksIG8gPSB0LmlucHV0cztcbiAgICBpZiAoby5sZW5ndGggPiAxICYmICF0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbikge1xuICAgICAgdGhpcy5yZWFkeVRvQmxvY2tTZWxlY3Rpb24gPSAhMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG8ubGVuZ3RoID09PSAxICYmICF0aGlzLm5lZWRUb1NlbGVjdEFsbCkge1xuICAgICAgdGhpcy5uZWVkVG9TZWxlY3RBbGwgPSAhMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5uZWVkVG9TZWxlY3RBbGwgPyAoZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLnNlbGVjdEFsbEJsb2NrcygpLCB0aGlzLm5lZWRUb1NlbGVjdEFsbCA9ICExLCB0aGlzLnJlYWR5VG9CbG9ja1NlbGVjdGlvbiA9ICExKSA6IHRoaXMucmVhZHlUb0Jsb2NrU2VsZWN0aW9uICYmIChlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuc2VsZWN0QmxvY2sodCksIHRoaXMubmVlZFRvU2VsZWN0QWxsID0gITApO1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3QgQWxsIEJsb2Nrc1xuICAgKiBFYWNoIEJsb2NrIGhhcyBzZWxlY3RlZCBzZXR0ZXIgdGhhdCBtYWtlcyBCbG9jayBjb3B5YWJsZVxuICAgKi9cbiAgc2VsZWN0QWxsQmxvY2tzKCkge1xuICAgIHRoaXMuc2VsZWN0aW9uLnNhdmUoKSwgYi5nZXQoKS5yZW1vdmVBbGxSYW5nZXMoKSwgdGhpcy5hbGxCbG9ja3NTZWxlY3RlZCA9ICEwLCB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCk7XG4gIH1cbn1cbmNsYXNzIFllIGV4dGVuZHMgRSB7XG4gIC8qKlxuICAgKiBBbGxvd2VkIGNhcmV0IHBvc2l0aW9ucyBpbiBpbnB1dFxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEByZXR1cm5zIHt7U1RBUlQ6IHN0cmluZywgRU5EOiBzdHJpbmcsIERFRkFVTFQ6IHN0cmluZ319XG4gICAqL1xuICBnZXQgcG9zaXRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBTVEFSVDogXCJzdGFydFwiLFxuICAgICAgRU5EOiBcImVuZFwiLFxuICAgICAgREVGQVVMVDogXCJkZWZhdWx0XCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFbGVtZW50cyBzdHlsZXMgdGhhdCBjYW4gYmUgdXNlZnVsIGZvciBDYXJldCBNb2R1bGVcbiAgICovXG4gIHN0YXRpYyBnZXQgQ1NTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzaGFkb3dDYXJldDogXCJjZHgtc2hhZG93LWNhcmV0XCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgZ2V0cyBCbG9jayBpbnN0YW5jZSBhbmQgcHV0cyBjYXJldCB0byB0aGUgdGV4dCBub2RlIHdpdGggb2Zmc2V0XG4gICAqIFRoZXJlIHR3byB3YXlzIHRoYXQgbWV0aG9kIGFwcGxpZXMgY2FyZXQgcG9zaXRpb246XG4gICAqICAgLSBmaXJzdCBmb3VuZCB0ZXh0IG5vZGU6IHNldHMgYXQgdGhlIGJlZ2lubmluZywgYnV0IHlvdSBjYW4gcGFzcyBhbiBvZmZzZXRcbiAgICogICAtIGxhc3QgZm91bmQgdGV4dCBub2RlOiBzZXRzIGF0IHRoZSBlbmQgb2YgdGhlIG5vZGUuIEFsc28sIHlvdSBjYW4gY3VzdG9taXplIHRoZSBiZWhhdmlvdXJcbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gYmxvY2sgLSBCbG9jayBjbGFzc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb24gLSBwb3NpdGlvbiB3aGVyZSB0byBzZXQgY2FyZXQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGRlZmF1bHQgLSBsZWF2ZSBkZWZhdWx0IGJlaGF2aW91ciBhbmQgYXBwbHkgb2Zmc2V0IGlmIGl0J3MgcGFzc2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBjYXJldCBvZmZzZXQgcmVnYXJkaW5nIHRvIHRoZSB0ZXh0IG5vZGVcbiAgICovXG4gIHNldFRvQmxvY2soZSwgdCA9IHRoaXMucG9zaXRpb25zLkRFRkFVTFQsIG8gPSAwKSB7XG4gICAgdmFyIGM7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IGksIEJsb2NrU2VsZWN0aW9uOiBzIH0gPSB0aGlzLkVkaXRvcjtcbiAgICBpZiAocy5jbGVhclNlbGVjdGlvbigpLCAhZS5mb2N1c2FibGUpIHtcbiAgICAgIChjID0gd2luZG93LmdldFNlbGVjdGlvbigpKSA9PSBudWxsIHx8IGMucmVtb3ZlQWxsUmFuZ2VzKCksIHMuc2VsZWN0QmxvY2soZSksIGkuY3VycmVudEJsb2NrID0gZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHI7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICBjYXNlIHRoaXMucG9zaXRpb25zLlNUQVJUOlxuICAgICAgICByID0gZS5maXJzdElucHV0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdGhpcy5wb3NpdGlvbnMuRU5EOlxuICAgICAgICByID0gZS5sYXN0SW5wdXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgciA9IGUuY3VycmVudElucHV0O1xuICAgIH1cbiAgICBpZiAoIXIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYSA9IGQuZ2V0RGVlcGVzdE5vZGUociwgdCA9PT0gdGhpcy5wb3NpdGlvbnMuRU5EKSwgbCA9IGQuZ2V0Q29udGVudExlbmd0aChhKTtcbiAgICBzd2l0Y2ggKCEwKSB7XG4gICAgICBjYXNlIHQgPT09IHRoaXMucG9zaXRpb25zLlNUQVJUOlxuICAgICAgICBvID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHQgPT09IHRoaXMucG9zaXRpb25zLkVORDpcbiAgICAgIGNhc2UgbyA+IGw6XG4gICAgICAgIG8gPSBsO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5zZXQoYSwgbyksIGkuc2V0Q3VycmVudEJsb2NrQnlDaGlsZE5vZGUoZS5ob2xkZXIpLCBpLmN1cnJlbnRCbG9jay5jdXJyZW50SW5wdXQgPSByO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgY2FyZXQgdG8gdGhlIGN1cnJlbnQgaW5wdXQgb2YgY3VycmVudCBCbG9jay5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaW5wdXQgLSBpbnB1dCB3aGVyZSBjYXJldCBzaG91bGQgYmUgc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbiAtIHBvc2l0aW9uIG9mIHRoZSBjYXJldC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgZGVmYXVsdCAtIGxlYXZlIGRlZmF1bHQgYmVoYXZpb3VyIGFuZCBhcHBseSBvZmZzZXQgaWYgaXQncyBwYXNzZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIGNhcmV0IG9mZnNldCByZWdhcmRpbmcgdG8gdGhlIHRleHQgbm9kZVxuICAgKi9cbiAgc2V0VG9JbnB1dChlLCB0ID0gdGhpcy5wb3NpdGlvbnMuREVGQVVMVCwgbyA9IDApIHtcbiAgICBjb25zdCB7IGN1cnJlbnRCbG9jazogaSB9ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLCBzID0gZC5nZXREZWVwZXN0Tm9kZShlKTtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIGNhc2UgdGhpcy5wb3NpdGlvbnMuU1RBUlQ6XG4gICAgICAgIHRoaXMuc2V0KHMsIDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdGhpcy5wb3NpdGlvbnMuRU5EOlxuICAgICAgICB0aGlzLnNldChzLCBkLmdldENvbnRlbnRMZW5ndGgocykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG8gJiYgdGhpcy5zZXQocywgbyk7XG4gICAgfVxuICAgIGkuY3VycmVudElucHV0ID0gZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBEb2N1bWVudCBSYW5nZSBhbmQgc2V0cyBjYXJldCB0byB0aGUgZWxlbWVudCB3aXRoIG9mZnNldFxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBvZmZzZXRcbiAgICovXG4gIHNldChlLCB0ID0gMCkge1xuICAgIGNvbnN0IHsgdG9wOiBpLCBib3R0b206IHMgfSA9IGIuc2V0Q3Vyc29yKGUsIHQpLCB7IGlubmVySGVpZ2h0OiByIH0gPSB3aW5kb3c7XG4gICAgaSA8IDAgPyB3aW5kb3cuc2Nyb2xsQnkoMCwgaSAtIDMwKSA6IHMgPiByICYmIHdpbmRvdy5zY3JvbGxCeSgwLCBzIC0gciArIDMwKTtcbiAgfVxuICAvKipcbiAgICogU2V0IENhcmV0IHRvIHRoZSBsYXN0IEJsb2NrXG4gICAqIElmIGxhc3QgYmxvY2sgaXMgbm90IGVtcHR5LCBhcHBlbmQgYW5vdGhlciBlbXB0eSBibG9ja1xuICAgKi9cbiAgc2V0VG9UaGVMYXN0QmxvY2soKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5sYXN0QmxvY2s7XG4gICAgaWYgKGUpXG4gICAgICBpZiAoZS50b29sLmlzRGVmYXVsdCAmJiBlLmlzRW1wdHkpXG4gICAgICAgIHRoaXMuc2V0VG9CbG9jayhlKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmluc2VydEF0RW5kKCk7XG4gICAgICAgIHRoaXMuc2V0VG9CbG9jayh0KTtcbiAgICAgIH1cbiAgfVxuICAvKipcbiAgICogRXh0cmFjdCBjb250ZW50IGZyYWdtZW50IG9mIGN1cnJlbnQgQmxvY2sgZnJvbSBDYXJldCBwb3NpdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBCbG9ja1xuICAgKi9cbiAgZXh0cmFjdEZyYWdtZW50RnJvbUNhcmV0UG9zaXRpb24oKSB7XG4gICAgY29uc3QgZSA9IGIuZ2V0KCk7XG4gICAgaWYgKGUucmFuZ2VDb3VudCkge1xuICAgICAgY29uc3QgdCA9IGUuZ2V0UmFuZ2VBdCgwKSwgbyA9IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5jdXJyZW50QmxvY2suY3VycmVudElucHV0O1xuICAgICAgaWYgKHQuZGVsZXRlQ29udGVudHMoKSwgbylcbiAgICAgICAgaWYgKGQuaXNOYXRpdmVJbnB1dChvKSkge1xuICAgICAgICAgIGNvbnN0IGkgPSBvLCBzID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCByID0gaS52YWx1ZS5zdWJzdHJpbmcoMCwgaS5zZWxlY3Rpb25TdGFydCksIGEgPSBpLnZhbHVlLnN1YnN0cmluZyhpLnNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICByZXR1cm4gcy50ZXh0Q29udGVudCA9IGEsIGkudmFsdWUgPSByLCBzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGkgPSB0LmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICByZXR1cm4gaS5zZWxlY3ROb2RlQ29udGVudHMobyksIGkuc2V0U3RhcnQodC5lbmRDb250YWluZXIsIHQuZW5kT2Zmc2V0KSwgaS5leHRyYWN0Q29udGVudHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0J3MgY2FyZXQgdG8gdGhlIG5leHQgQmxvY2sgb3IgVG9vbGBzIGlucHV0XG4gICAqIEJlZm9yZSBtb3ZpbmcgY2FyZXQsIHdlIHNob3VsZCBjaGVjayBpZiBjYXJldCBwb3NpdGlvbiBpcyBhdCB0aGUgZW5kIG9mIFBsdWdpbnMgbm9kZVxuICAgKiBVc2luZyB7QGxpbmsgRG9tI2dldERlZXBlc3ROb2RlfSB0byBnZXQgYSBsYXN0IG5vZGUgYW5kIG1hdGNoIHdpdGggY3VycmVudCBzZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZSAtIHBhc3MgdHJ1ZSB0byBza2lwIGNoZWNrIGZvciBjYXJldCBwb3NpdGlvblxuICAgKi9cbiAgbmF2aWdhdGVOZXh0KGUgPSAhMSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0IH0gPSB0aGlzLkVkaXRvciwgeyBjdXJyZW50QmxvY2s6IG8sIG5leHRCbG9jazogaSB9ID0gdDtcbiAgICBpZiAobyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHsgbmV4dElucHV0OiBzLCBjdXJyZW50SW5wdXQ6IHIgfSA9IG8sIGEgPSByICE9PSB2b2lkIDAgPyBSZShyKSA6IHZvaWQgMDtcbiAgICBsZXQgbCA9IGk7XG4gICAgY29uc3QgYyA9IGUgfHwgYSB8fCAhby5mb2N1c2FibGU7XG4gICAgaWYgKHMgJiYgYylcbiAgICAgIHJldHVybiB0aGlzLnNldFRvSW5wdXQocywgdGhpcy5wb3NpdGlvbnMuU1RBUlQpLCAhMDtcbiAgICBpZiAobCA9PT0gbnVsbCkge1xuICAgICAgaWYgKG8udG9vbC5pc0RlZmF1bHQgfHwgIWMpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGwgPSB0Lmluc2VydEF0RW5kKCk7XG4gICAgfVxuICAgIHJldHVybiBjID8gKHRoaXMuc2V0VG9CbG9jayhsLCB0aGlzLnBvc2l0aW9ucy5TVEFSVCksICEwKSA6ICExO1xuICB9XG4gIC8qKlxuICAgKiBTZXQncyBjYXJldCB0byB0aGUgcHJldmlvdXMgVG9vbGBzIGlucHV0IG9yIEJsb2NrXG4gICAqIEJlZm9yZSBtb3ZpbmcgY2FyZXQsIHdlIHNob3VsZCBjaGVjayBpZiBjYXJldCBwb3NpdGlvbiBpcyBzdGFydCBvZiB0aGUgUGx1Z2lucyBub2RlXG4gICAqIFVzaW5nIHtAbGluayBEb20jZ2V0RGVlcGVzdE5vZGV9IHRvIGdldCBhIGxhc3Qgbm9kZSBhbmQgbWF0Y2ggd2l0aCBjdXJyZW50IHNlbGVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIC0gcGFzcyB0cnVlIHRvIHNraXAgY2hlY2sgZm9yIGNhcmV0IHBvc2l0aW9uXG4gICAqL1xuICBuYXZpZ2F0ZVByZXZpb3VzKGUgPSAhMSkge1xuICAgIGNvbnN0IHsgY3VycmVudEJsb2NrOiB0LCBwcmV2aW91c0Jsb2NrOiBvIH0gPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXI7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHsgcHJldmlvdXNJbnB1dDogaSwgY3VycmVudElucHV0OiBzIH0gPSB0LCByID0gcyAhPT0gdm9pZCAwID8gTmUocykgOiB2b2lkIDAsIGEgPSBlIHx8IHIgfHwgIXQuZm9jdXNhYmxlO1xuICAgIHJldHVybiBpICYmIGEgPyAodGhpcy5zZXRUb0lucHV0KGksIHRoaXMucG9zaXRpb25zLkVORCksICEwKSA6IG8gIT09IG51bGwgJiYgYSA/ICh0aGlzLnNldFRvQmxvY2sobywgdGhpcy5wb3NpdGlvbnMuRU5EKSwgITApIDogITE7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgc2hhZG93IGVsZW1lbnQgYWZ0ZXIgcGFzc2VkIGVsZW1lbnQgd2hlcmUgY2FyZXQgY2FuIGJlIHBsYWNlZFxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IGFmdGVyIHdoaWNoIHNoYWRvdyBjYXJldCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICovXG4gIGNyZWF0ZVNoYWRvdyhlKSB7XG4gICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIHQuY2xhc3NMaXN0LmFkZChZZS5DU1Muc2hhZG93Q2FyZXQpLCBlLmluc2VydEFkamFjZW50RWxlbWVudChcImJlZm9yZWVuZFwiLCB0KTtcbiAgfVxuICAvKipcbiAgICogUmVzdG9yZXMgY2FyZXQgcG9zaXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgd2hlcmUgY2FyZXQgc2hvdWxkIGJlIHJlc3RvcmVkXG4gICAqL1xuICByZXN0b3JlQ2FyZXQoZSkge1xuICAgIGNvbnN0IHQgPSBlLnF1ZXJ5U2VsZWN0b3IoYC4ke1llLkNTUy5zaGFkb3dDYXJldH1gKTtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm47XG4gICAgbmV3IGIoKS5leHBhbmRUb1RhZyh0KTtcbiAgICBjb25zdCBpID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBpLnNlbGVjdE5vZGUodCksIGkuZXh0cmFjdENvbnRlbnRzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgcGFzc2VkIGNvbnRlbnQgYXQgY2FyZXQgcG9zaXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgLSBjb250ZW50IHRvIGluc2VydFxuICAgKi9cbiAgaW5zZXJ0Q29udGVudEF0Q2FyZXRQb3NpdGlvbihlKSB7XG4gICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGkgPSBiLmdldCgpLCBzID0gYi5yYW5nZTtcbiAgICBvLmlubmVySFRNTCA9IGUsIEFycmF5LmZyb20oby5jaGlsZE5vZGVzKS5mb3JFYWNoKChjKSA9PiB0LmFwcGVuZENoaWxkKGMpKSwgdC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCAmJiB0LmFwcGVuZENoaWxkKG5ldyBUZXh0KCkpO1xuICAgIGNvbnN0IHIgPSB0Lmxhc3RDaGlsZDtcbiAgICBzLmRlbGV0ZUNvbnRlbnRzKCksIHMuaW5zZXJ0Tm9kZSh0KTtcbiAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSwgbCA9IHIubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gciA6IHIuZmlyc3RDaGlsZDtcbiAgICBsICE9PSBudWxsICYmIGwudGV4dENvbnRlbnQgIT09IG51bGwgJiYgYS5zZXRTdGFydChsLCBsLnRleHRDb250ZW50Lmxlbmd0aCksIGkucmVtb3ZlQWxsUmFuZ2VzKCksIGkuYWRkUmFuZ2UoYSk7XG4gIH1cbn1cbmNsYXNzIGxhIGV4dGVuZHMgRSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMub25Nb3VzZVVwID0gKCkgPT4ge1xuICAgICAgdGhpcy5saXN0ZW5lcnMub2ZmKGRvY3VtZW50LCBcIm1vdXNlb3ZlclwiLCB0aGlzLm9uTW91c2VPdmVyKSwgdGhpcy5saXN0ZW5lcnMub2ZmKGRvY3VtZW50LCBcIm1vdXNldXBcIiwgdGhpcy5vbk1vdXNlVXApO1xuICAgIH0sIHRoaXMub25Nb3VzZU92ZXIgPSAoZSkgPT4ge1xuICAgICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIEJsb2NrU2VsZWN0aW9uOiBvIH0gPSB0aGlzLkVkaXRvcjtcbiAgICAgIGlmIChlLnJlbGF0ZWRUYXJnZXQgPT09IG51bGwgJiYgZS50YXJnZXQgPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGkgPSB0LmdldEJsb2NrQnlDaGlsZE5vZGUoZS5yZWxhdGVkVGFyZ2V0KSB8fCB0aGlzLmxhc3RTZWxlY3RlZEJsb2NrLCBzID0gdC5nZXRCbG9ja0J5Q2hpbGROb2RlKGUudGFyZ2V0KTtcbiAgICAgIGlmICghKCFpIHx8ICFzKSAmJiBzICE9PSBpKSB7XG4gICAgICAgIGlmIChpID09PSB0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jaykge1xuICAgICAgICAgIGIuZ2V0KCkucmVtb3ZlQWxsUmFuZ2VzKCksIGkuc2VsZWN0ZWQgPSAhMCwgcy5zZWxlY3RlZCA9ICEwLCBvLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMgPT09IHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrKSB7XG4gICAgICAgICAgaS5zZWxlY3RlZCA9ICExLCBzLnNlbGVjdGVkID0gITEsIG8uY2xlYXJDYWNoZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCksIHRoaXMudG9nZ2xlQmxvY2tzU2VsZWN0ZWRTdGF0ZShpLCBzKSwgdGhpcy5sYXN0U2VsZWN0ZWRCbG9jayA9IHM7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTW9kdWxlIHByZXBhcmF0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgcHJlcGFyZSgpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5vbihkb2N1bWVudCwgXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgIHRoaXMuZW5hYmxlQ3Jvc3NCbG9ja1NlbGVjdGlvbihlKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB1cCBsaXN0ZW5lcnNcbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIG1vdXNlIGRvd24gZXZlbnRcbiAgICovXG4gIHdhdGNoU2VsZWN0aW9uKGUpIHtcbiAgICBpZiAoZS5idXR0b24gIT09IHFuLkxFRlQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQgfSA9IHRoaXMuRWRpdG9yO1xuICAgIHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrID0gdC5nZXRCbG9jayhlLnRhcmdldCksIHRoaXMubGFzdFNlbGVjdGVkQmxvY2sgPSB0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jaywgdGhpcy5saXN0ZW5lcnMub24oZG9jdW1lbnQsIFwibW91c2VvdmVyXCIsIHRoaXMub25Nb3VzZU92ZXIpLCB0aGlzLmxpc3RlbmVycy5vbihkb2N1bWVudCwgXCJtb3VzZXVwXCIsIHRoaXMub25Nb3VzZVVwKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaXMgY3Jvc3MgYmxvY2sgc2VsZWN0aW9uIHN0YXJ0ZWQ6XG4gICAqIHRoZXJlIHNob3VsZCBiZSBhdCBsZWFzdCAyIHNlbGVjdGVkIGJsb2Nrc1xuICAgKi9cbiAgZ2V0IGlzQ3Jvc3NCbG9ja1NlbGVjdGlvblN0YXJ0ZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5maXJzdFNlbGVjdGVkQmxvY2sgJiYgISF0aGlzLmxhc3RTZWxlY3RlZEJsb2NrICYmIHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrICE9PSB0aGlzLmxhc3RTZWxlY3RlZEJsb2NrO1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2Ugc2VsZWN0aW9uIHN0YXRlIG9mIHRoZSBuZXh0IEJsb2NrXG4gICAqIFVzZWQgZm9yIENCUyB2aWEgU2hpZnQgKyBhcnJvdyBrZXlzXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbmV4dCAtIGlmIHRydWUsIHRvZ2dsZSBuZXh0IGJsb2NrLiBQcmV2aW91cyBvdGhlcndpc2VcbiAgICovXG4gIHRvZ2dsZUJsb2NrU2VsZWN0ZWRTdGF0ZShlID0gITApIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCwgQmxvY2tTZWxlY3Rpb246IG8gfSA9IHRoaXMuRWRpdG9yO1xuICAgIHRoaXMubGFzdFNlbGVjdGVkQmxvY2sgfHwgKHRoaXMubGFzdFNlbGVjdGVkQmxvY2sgPSB0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jayA9IHQuY3VycmVudEJsb2NrKSwgdGhpcy5maXJzdFNlbGVjdGVkQmxvY2sgPT09IHRoaXMubGFzdFNlbGVjdGVkQmxvY2sgJiYgKHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrLnNlbGVjdGVkID0gITAsIG8uY2xlYXJDYWNoZSgpLCBiLmdldCgpLnJlbW92ZUFsbFJhbmdlcygpKTtcbiAgICBjb25zdCBpID0gdC5ibG9ja3MuaW5kZXhPZih0aGlzLmxhc3RTZWxlY3RlZEJsb2NrKSArIChlID8gMSA6IC0xKSwgcyA9IHQuYmxvY2tzW2ldO1xuICAgIHMgJiYgKHRoaXMubGFzdFNlbGVjdGVkQmxvY2suc2VsZWN0ZWQgIT09IHMuc2VsZWN0ZWQgPyAocy5zZWxlY3RlZCA9ICEwLCBvLmNsZWFyQ2FjaGUoKSkgOiAodGhpcy5sYXN0U2VsZWN0ZWRCbG9jay5zZWxlY3RlZCA9ICExLCBvLmNsZWFyQ2FjaGUoKSksIHRoaXMubGFzdFNlbGVjdGVkQmxvY2sgPSBzLCB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCksIHMuaG9sZGVyLnNjcm9sbEludG9WaWV3KHtcbiAgICAgIGJsb2NrOiBcIm5lYXJlc3RcIlxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXIgc2F2ZWQgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gcmVhc29uIC0gZXZlbnQgY2F1c2VkIGNsZWFyIG9mIHNlbGVjdGlvblxuICAgKi9cbiAgY2xlYXIoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBCbG9ja1NlbGVjdGlvbjogbywgQ2FyZXQ6IGkgfSA9IHRoaXMuRWRpdG9yLCBzID0gdC5ibG9ja3MuaW5kZXhPZih0aGlzLmZpcnN0U2VsZWN0ZWRCbG9jayksIHIgPSB0LmJsb2Nrcy5pbmRleE9mKHRoaXMubGFzdFNlbGVjdGVkQmxvY2spO1xuICAgIGlmIChvLmFueUJsb2NrU2VsZWN0ZWQgJiYgcyA+IC0xICYmIHIgPiAtMSAmJiBlICYmIGUgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50KVxuICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSB5LkRPV046XG4gICAgICAgIGNhc2UgeS5SSUdIVDpcbiAgICAgICAgICBpLnNldFRvQmxvY2sodC5ibG9ja3NbTWF0aC5tYXgocywgcildLCBpLnBvc2l0aW9ucy5FTkQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHkuVVA6XG4gICAgICAgIGNhc2UgeS5MRUZUOlxuICAgICAgICAgIGkuc2V0VG9CbG9jayh0LmJsb2Nrc1tNYXRoLm1pbihzLCByKV0sIGkucG9zaXRpb25zLlNUQVJUKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpLnNldFRvQmxvY2sodC5ibG9ja3NbTWF0aC5tYXgocywgcildLCBpLnBvc2l0aW9ucy5FTkQpO1xuICAgICAgfVxuICAgIHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrID0gdGhpcy5sYXN0U2VsZWN0ZWRCbG9jayA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgQ3Jvc3MgQmxvY2sgU2VsZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBtb3VzZSBkb3duIGV2ZW50XG4gICAqL1xuICBlbmFibGVDcm9zc0Jsb2NrU2VsZWN0aW9uKGUpIHtcbiAgICBjb25zdCB7IFVJOiB0IH0gPSB0aGlzLkVkaXRvcjtcbiAgICBiLmlzQ29sbGFwc2VkIHx8IHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKGUpLCB0Lm5vZGVzLnJlZGFjdG9yLmNvbnRhaW5zKGUudGFyZ2V0KSA/IHRoaXMud2F0Y2hTZWxlY3Rpb24oZSkgOiB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5jbGVhclNlbGVjdGlvbihlKTtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlIGJsb2NrcyBzZWxlY3Rpb24gc3RhdGUgYmV0d2VlbiBwYXNzZWQgdHdvIGJsb2Nrcy5cbiAgICpcbiAgICogQHBhcmFtIHtCbG9ja30gZmlyc3RCbG9jayAtIGZpcnN0IGJsb2NrIGluIHJhbmdlXG4gICAqIEBwYXJhbSB7QmxvY2t9IGxhc3RCbG9jayAtIGxhc3QgYmxvY2sgaW4gcmFuZ2VcbiAgICovXG4gIHRvZ2dsZUJsb2Nrc1NlbGVjdGVkU3RhdGUoZSwgdCkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBvLCBCbG9ja1NlbGVjdGlvbjogaSB9ID0gdGhpcy5FZGl0b3IsIHMgPSBvLmJsb2Nrcy5pbmRleE9mKGUpLCByID0gby5ibG9ja3MuaW5kZXhPZih0KSwgYSA9IGUuc2VsZWN0ZWQgIT09IHQuc2VsZWN0ZWQ7XG4gICAgZm9yIChsZXQgbCA9IE1hdGgubWluKHMsIHIpOyBsIDw9IE1hdGgubWF4KHMsIHIpOyBsKyspIHtcbiAgICAgIGNvbnN0IGMgPSBvLmJsb2Nrc1tsXTtcbiAgICAgIGMgIT09IHRoaXMuZmlyc3RTZWxlY3RlZEJsb2NrICYmIGMgIT09IChhID8gZSA6IHQpICYmIChvLmJsb2Nrc1tsXS5zZWxlY3RlZCA9ICFvLmJsb2Nrc1tsXS5zZWxlY3RlZCwgaS5jbGVhckNhY2hlKCkpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgY2EgZXh0ZW5kcyBFIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5pc1N0YXJ0ZWRBdEVkaXRvciA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGUgcmVhZC1vbmx5IHN0YXRlXG4gICAqXG4gICAqIGlmIHN0YXRlIGlzIHRydWU6XG4gICAqICAtIGRpc2FibGUgYWxsIGRyYWctbi1kcm9wIGV2ZW50IGhhbmRsZXJzXG4gICAqXG4gICAqIGlmIHN0YXRlIGlzIGZhbHNlOlxuICAgKiAgLSByZXN0b3JlIGRyYWctbi1kcm9wIGV2ZW50IGhhbmRsZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVhZE9ubHlFbmFibGVkIC0gXCJyZWFkIG9ubHlcIiBzdGF0ZVxuICAgKi9cbiAgdG9nZ2xlUmVhZE9ubHkoZSkge1xuICAgIGUgPyB0aGlzLmRpc2FibGVNb2R1bGVCaW5kaW5ncygpIDogdGhpcy5lbmFibGVNb2R1bGVCaW5kaW5ncygpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgZHJhZyBldmVudHMgbGlzdGVuZXJzIHRvIGVkaXRvciB6b25lXG4gICAqL1xuICBlbmFibGVNb2R1bGVCaW5kaW5ncygpIHtcbiAgICBjb25zdCB7IFVJOiBlIH0gPSB0aGlzLkVkaXRvcjtcbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbihlLm5vZGVzLmhvbGRlciwgXCJkcm9wXCIsIGFzeW5jICh0KSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLnByb2Nlc3NEcm9wKHQpO1xuICAgIH0sICEwKSwgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24oZS5ub2Rlcy5ob2xkZXIsIFwiZHJhZ3N0YXJ0XCIsICgpID0+IHtcbiAgICAgIHRoaXMucHJvY2Vzc0RyYWdTdGFydCgpO1xuICAgIH0pLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbihlLm5vZGVzLmhvbGRlciwgXCJkcmFnb3ZlclwiLCAodCkgPT4ge1xuICAgICAgdGhpcy5wcm9jZXNzRHJhZ092ZXIodCk7XG4gICAgfSwgITApO1xuICB9XG4gIC8qKlxuICAgKiBVbmJpbmQgZHJhZy1uLWRyb3AgZXZlbnQgaGFuZGxlcnNcbiAgICovXG4gIGRpc2FibGVNb2R1bGVCaW5kaW5ncygpIHtcbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5jbGVhckFsbCgpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgZHJvcCBldmVudFxuICAgKlxuICAgKiBAcGFyYW0ge0RyYWdFdmVudH0gZHJvcEV2ZW50IC0gZHJvcCBldmVudFxuICAgKi9cbiAgYXN5bmMgcHJvY2Vzc0Ryb3AoZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIEJsb2NrTWFuYWdlcjogdCxcbiAgICAgIFBhc3RlOiBvLFxuICAgICAgQ2FyZXQ6IGlcbiAgICB9ID0gdGhpcy5FZGl0b3I7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpLCB0LmJsb2Nrcy5mb3JFYWNoKChyKSA9PiB7XG4gICAgICByLmRyb3BUYXJnZXQgPSAhMTtcbiAgICB9KSwgYi5pc0F0RWRpdG9yICYmICFiLmlzQ29sbGFwc2VkICYmIHRoaXMuaXNTdGFydGVkQXRFZGl0b3IgJiYgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJkZWxldGVcIiksIHRoaXMuaXNTdGFydGVkQXRFZGl0b3IgPSAhMTtcbiAgICBjb25zdCBzID0gdC5zZXRDdXJyZW50QmxvY2tCeUNoaWxkTm9kZShlLnRhcmdldCk7XG4gICAgaWYgKHMpXG4gICAgICB0aGlzLkVkaXRvci5DYXJldC5zZXRUb0Jsb2NrKHMsIGkucG9zaXRpb25zLkVORCk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCByID0gdC5zZXRDdXJyZW50QmxvY2tCeUNoaWxkTm9kZSh0Lmxhc3RCbG9jay5ob2xkZXIpO1xuICAgICAgdGhpcy5FZGl0b3IuQ2FyZXQuc2V0VG9CbG9jayhyLCBpLnBvc2l0aW9ucy5FTkQpO1xuICAgIH1cbiAgICBhd2FpdCBvLnByb2Nlc3NEYXRhVHJhbnNmZXIoZS5kYXRhVHJhbnNmZXIsICEwKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGRyYWcgc3RhcnQgZXZlbnRcbiAgICovXG4gIHByb2Nlc3NEcmFnU3RhcnQoKSB7XG4gICAgYi5pc0F0RWRpdG9yICYmICFiLmlzQ29sbGFwc2VkICYmICh0aGlzLmlzU3RhcnRlZEF0RWRpdG9yID0gITApLCB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLmNsb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7RHJhZ0V2ZW50fSBkcmFnRXZlbnQgLSBkcmFnIGV2ZW50XG4gICAqL1xuICBwcm9jZXNzRHJhZ092ZXIoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxufVxuY29uc3QgZGEgPSAxODAsIHVhID0gNDAwO1xuY2xhc3MgaGEgZXh0ZW5kcyBFIHtcbiAgLyoqXG4gICAqIFByZXBhcmUgdGhlIG1vZHVsZVxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIG9wdGlvbnMgdXNlZCBieSB0aGUgbW9kaWZpY2F0aW9uIG9ic2VydmVyIG1vZHVsZVxuICAgKiBAcGFyYW0gb3B0aW9ucy5jb25maWcgLSBFZGl0b3IgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICogQHBhcmFtIG9wdGlvbnMuZXZlbnRzRGlzcGF0Y2hlciAtIGNvbW1vbiBFZGl0b3IgZXZlbnQgYnVzXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGNvbmZpZzogZSwgZXZlbnRzRGlzcGF0Y2hlcjogdCB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnOiBlLFxuICAgICAgZXZlbnRzRGlzcGF0Y2hlcjogdFxuICAgIH0pLCB0aGlzLmRpc2FibGVkID0gITEsIHRoaXMuYmF0Y2hpbmdUaW1lb3V0ID0gbnVsbCwgdGhpcy5iYXRjaGluZ09uQ2hhbmdlUXVldWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLmJhdGNoVGltZSA9IHVhLCB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobykgPT4ge1xuICAgICAgdGhpcy5yZWRhY3RvckNoYW5nZWQobyk7XG4gICAgfSksIHRoaXMuZXZlbnRzRGlzcGF0Y2hlci5vbigkbywgKG8pID0+IHtcbiAgICAgIHRoaXMucGFydGljdWxhckJsb2NrQ2hhbmdlZChvLmV2ZW50KTtcbiAgICB9KSwgdGhpcy5ldmVudHNEaXNwYXRjaGVyLm9uKHpvLCAoKSA9PiB7XG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB9KSwgdGhpcy5ldmVudHNEaXNwYXRjaGVyLm9uKFVvLCAoKSA9PiB7XG4gICAgICB0aGlzLmVuYWJsZSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9uQ2hhbmdlIGV2ZW50XG4gICAqL1xuICBlbmFibGUoKSB7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoXG4gICAgICB0aGlzLkVkaXRvci5VSS5ub2Rlcy5yZWRhY3RvcixcbiAgICAgIHtcbiAgICAgICAgY2hpbGRMaXN0OiAhMCxcbiAgICAgICAgc3VidHJlZTogITAsXG4gICAgICAgIGNoYXJhY3RlckRhdGE6ICEwLFxuICAgICAgICBhdHRyaWJ1dGVzOiAhMFxuICAgICAgfVxuICAgICksIHRoaXMuZGlzYWJsZWQgPSAhMTtcbiAgfVxuICAvKipcbiAgICogRGlzYWJsZXMgb25DaGFuZ2UgZXZlbnRcbiAgICovXG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKSwgdGhpcy5kaXNhYmxlZCA9ICEwO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIG9uQ2hhbmdlIGV2ZW50IHBhc3NlZCB0byBFZGl0b3IuanMgY29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBzb21lIG9mIG91ciBjdXN0b20gY2hhbmdlIGV2ZW50c1xuICAgKi9cbiAgcGFydGljdWxhckJsb2NrQ2hhbmdlZChlKSB7XG4gICAgdGhpcy5kaXNhYmxlZCB8fCAhQSh0aGlzLmNvbmZpZy5vbkNoYW5nZSkgfHwgKHRoaXMuYmF0Y2hpbmdPbkNoYW5nZVF1ZXVlLnNldChgYmxvY2s6JHtlLmRldGFpbC50YXJnZXQuaWR9OmV2ZW50OiR7ZS50eXBlfWAsIGUpLCB0aGlzLmJhdGNoaW5nVGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy5iYXRjaGluZ1RpbWVvdXQpLCB0aGlzLmJhdGNoaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbGV0IHQ7XG4gICAgICB0aGlzLmJhdGNoaW5nT25DaGFuZ2VRdWV1ZS5zaXplID09PSAxID8gdCA9IHRoaXMuYmF0Y2hpbmdPbkNoYW5nZVF1ZXVlLnZhbHVlcygpLm5leHQoKS52YWx1ZSA6IHQgPSBBcnJheS5mcm9tKHRoaXMuYmF0Y2hpbmdPbkNoYW5nZVF1ZXVlLnZhbHVlcygpKSwgdGhpcy5jb25maWcub25DaGFuZ2UgJiYgdGhpcy5jb25maWcub25DaGFuZ2UodGhpcy5FZGl0b3IuQVBJLm1ldGhvZHMsIHQpLCB0aGlzLmJhdGNoaW5nT25DaGFuZ2VRdWV1ZS5jbGVhcigpO1xuICAgIH0sIHRoaXMuYmF0Y2hUaW1lKSk7XG4gIH1cbiAgLyoqXG4gICAqIEZpcmVkIG9uIGV2ZXJ5IGJsb2NrcyB3cmFwcGVyIGRvbSBjaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIG11dGF0aW9ucyAtIG11dGF0aW9ucyBoYXBwZW5lZFxuICAgKi9cbiAgcmVkYWN0b3JDaGFuZ2VkKGUpIHtcbiAgICB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIuZW1pdChmdCwge1xuICAgICAgbXV0YXRpb25zOiBlXG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IFJuID0gY2xhc3MgRG4gZXh0ZW5kcyBFIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5NSU1FX1RZUEUgPSBcImFwcGxpY2F0aW9uL3gtZWRpdG9yLWpzXCIsIHRoaXMudG9vbHNUYWdzID0ge30sIHRoaXMudGFnc0J5VG9vbCA9IHt9LCB0aGlzLnRvb2xzUGF0dGVybnMgPSBbXSwgdGhpcy50b29sc0ZpbGVzID0ge30sIHRoaXMuZXhjZXB0aW9uTGlzdCA9IFtdLCB0aGlzLnByb2Nlc3NUb29sID0gKGUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHQgPSBlLmNyZWF0ZSh7fSwge30sICExKTtcbiAgICAgICAgaWYgKGUucGFzdGVDb25maWcgPT09ICExKSB7XG4gICAgICAgICAgdGhpcy5leGNlcHRpb25MaXN0LnB1c2goZS5uYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBKHQub25QYXN0ZSkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmdldFRhZ3NDb25maWcoZSksIHRoaXMuZ2V0RmlsZXNDb25maWcoZSksIHRoaXMuZ2V0UGF0dGVybnNDb25maWcoZSk7XG4gICAgICB9IGNhdGNoICh0KSB7XG4gICAgICAgIFMoXG4gICAgICAgICAgYFBhc3RlIGhhbmRsaW5nIGZvciDCqyR7ZS5uYW1lfcK7IFRvb2wgaGFzbid0IGJlZW4gc2V0IHVwIGJlY2F1c2Ugb2YgdGhlIGVycm9yYCxcbiAgICAgICAgICBcIndhcm5cIixcbiAgICAgICAgICB0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5oYW5kbGVQYXN0ZUV2ZW50ID0gYXN5bmMgKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBUb29sYmFyOiBvIH0gPSB0aGlzLkVkaXRvciwgaSA9IHQuc2V0Q3VycmVudEJsb2NrQnlDaGlsZE5vZGUoZS50YXJnZXQpO1xuICAgICAgIWkgfHwgdGhpcy5pc05hdGl2ZUJlaGF2aW91cihlLnRhcmdldCkgJiYgIWUuY2xpcGJvYXJkRGF0YS50eXBlcy5pbmNsdWRlcyhcIkZpbGVzXCIpIHx8IGkgJiYgdGhpcy5leGNlcHRpb25MaXN0LmluY2x1ZGVzKGkubmFtZSkgfHwgKGUucHJldmVudERlZmF1bHQoKSwgdGhpcy5wcm9jZXNzRGF0YVRyYW5zZmVyKGUuY2xpcGJvYXJkRGF0YSksIG8uY2xvc2UoKSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2V0IG9uUGFzdGUgY2FsbGJhY2sgYW5kIGNvbGxlY3QgdG9vbHNgIHBhc3RlIGNvbmZpZ3VyYXRpb25zXG4gICAqL1xuICBhc3luYyBwcmVwYXJlKCkge1xuICAgIHRoaXMucHJvY2Vzc1Rvb2xzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCByZWFkLW9ubHkgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByZWFkT25seUVuYWJsZWQgLSByZWFkIG9ubHkgZmxhZyB2YWx1ZVxuICAgKi9cbiAgdG9nZ2xlUmVhZE9ubHkoZSkge1xuICAgIGUgPyB0aGlzLnVuc2V0Q2FsbGJhY2soKSA6IHRoaXMuc2V0Q2FsbGJhY2soKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIHBhc3RlZCBvciBkcm9wcGVkIGRhdGEgdHJhbnNmZXIgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7RGF0YVRyYW5zZmVyfSBkYXRhVHJhbnNmZXIgLSBwYXN0ZWQgb3IgZHJvcHBlZCBkYXRhIHRyYW5zZmVyIG9iamVjdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRHJhZ05Ecm9wIC0gdHJ1ZSBpZiBkYXRhIHRyYW5zZmVyIGNvbWVzIGZyb20gZHJhZyduJ2Ryb3AgZXZlbnRzXG4gICAqL1xuICBhc3luYyBwcm9jZXNzRGF0YVRyYW5zZmVyKGUsIHQgPSAhMSkge1xuICAgIGNvbnN0IHsgVG9vbHM6IG8gfSA9IHRoaXMuRWRpdG9yLCBpID0gZS50eXBlcztcbiAgICBpZiAoKGkuaW5jbHVkZXMgPyBpLmluY2x1ZGVzKFwiRmlsZXNcIikgOiBpLmNvbnRhaW5zKFwiRmlsZXNcIikpICYmICFWKHRoaXMudG9vbHNGaWxlcykpIHtcbiAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0ZpbGVzKGUuZmlsZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByID0gZS5nZXREYXRhKHRoaXMuTUlNRV9UWVBFKSwgYSA9IGUuZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XG4gICAgbGV0IGwgPSBlLmdldERhdGEoXCJ0ZXh0L2h0bWxcIik7XG4gICAgaWYgKHIpXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmluc2VydEVkaXRvckpTRGF0YShKU09OLnBhcnNlKHIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgdCAmJiBhLnRyaW0oKSAmJiBsLnRyaW0oKSAmJiAobCA9IFwiPHA+XCIgKyAobC50cmltKCkgPyBsIDogYSkgKyBcIjwvcD5cIik7XG4gICAgY29uc3QgYyA9IE9iamVjdC5rZXlzKHRoaXMudG9vbHNUYWdzKS5yZWR1Y2UoKHAsIGcpID0+IChwW2cudG9Mb3dlckNhc2UoKV0gPSB0aGlzLnRvb2xzVGFnc1tnXS5zYW5pdGl6YXRpb25Db25maWcgPz8ge30sIHApLCB7fSksIHUgPSBPYmplY3QuYXNzaWduKHt9LCBjLCBvLmdldEFsbElubGluZVRvb2xzU2FuaXRpemVDb25maWcoKSwgeyBicjoge30gfSksIGggPSBaKGwsIHUpO1xuICAgICFoLnRyaW0oKSB8fCBoLnRyaW0oKSA9PT0gYSB8fCAhZC5pc0hUTUxTdHJpbmcoaCkgPyBhd2FpdCB0aGlzLnByb2Nlc3NUZXh0KGEpIDogYXdhaXQgdGhpcy5wcm9jZXNzVGV4dChoLCAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgcGFzdGVkIHRleHQgYW5kIGRpdmlkZSB0aGVtIGludG8gQmxvY2tzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gdGV4dCB0byBwcm9jZXNzLiBDYW4gYmUgSFRNTCBvciBwbGFpbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc0hUTUwgLSBpZiBwYXNzZWQgc3RyaW5nIGlzIEhUTUwsIHRoaXMgcGFyYW1ldGVyIHNob3VsZCBiZSB0cnVlXG4gICAqL1xuICBhc3luYyBwcm9jZXNzVGV4dChlLCB0ID0gITEpIHtcbiAgICBjb25zdCB7IENhcmV0OiBvLCBCbG9ja01hbmFnZXI6IGkgfSA9IHRoaXMuRWRpdG9yLCBzID0gdCA/IHRoaXMucHJvY2Vzc0hUTUwoZSkgOiB0aGlzLnByb2Nlc3NQbGFpbihlKTtcbiAgICBpZiAoIXMubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgc1swXS5pc0Jsb2NrID8gdGhpcy5wcm9jZXNzU2luZ2xlQmxvY2socy5wb3AoKSkgOiB0aGlzLnByb2Nlc3NJbmxpbmVQYXN0ZShzLnBvcCgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYSA9IGkuY3VycmVudEJsb2NrICYmIGkuY3VycmVudEJsb2NrLnRvb2wuaXNEZWZhdWx0ICYmIGkuY3VycmVudEJsb2NrLmlzRW1wdHk7XG4gICAgcy5tYXAoXG4gICAgICBhc3luYyAobCwgYykgPT4gdGhpcy5pbnNlcnRCbG9jayhsLCBjID09PSAwICYmIGEpXG4gICAgKSwgaS5jdXJyZW50QmxvY2sgJiYgby5zZXRUb0Jsb2NrKGkuY3VycmVudEJsb2NrLCBvLnBvc2l0aW9ucy5FTkQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgb25QYXN0ZSBjYWxsYmFjayBoYW5kbGVyXG4gICAqL1xuICBzZXRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5vbih0aGlzLkVkaXRvci5VSS5ub2Rlcy5ob2xkZXIsIFwicGFzdGVcIiwgdGhpcy5oYW5kbGVQYXN0ZUV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogVW5zZXQgb25QYXN0ZSBjYWxsYmFjayBoYW5kbGVyXG4gICAqL1xuICB1bnNldENhbGxiYWNrKCkge1xuICAgIHRoaXMubGlzdGVuZXJzLm9mZih0aGlzLkVkaXRvci5VSS5ub2Rlcy5ob2xkZXIsIFwicGFzdGVcIiwgdGhpcy5oYW5kbGVQYXN0ZUV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFuZCBwcm9jZXNzIHRvb2xgcyBwYXN0ZSBjb25maWdzXG4gICAqL1xuICBwcm9jZXNzVG9vbHMoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuRWRpdG9yLlRvb2xzLmJsb2NrVG9vbHM7XG4gICAgQXJyYXkuZnJvbShlLnZhbHVlcygpKS5mb3JFYWNoKHRoaXMucHJvY2Vzc1Rvb2wpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGFncyBuYW1lIGxpc3QgZnJvbSBlaXRoZXIgdGFnIG5hbWUgb3Igc2FuaXRpemF0aW9uIGNvbmZpZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBvYmplY3R9IHRhZ09yU2FuaXRpemVDb25maWcgLSB0YWcgbmFtZSBvciBzYW5pdGl6ZSBjb25maWcgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nW119IGFycmF5IG9mIHRhZ3MuXG4gICAqL1xuICBjb2xsZWN0VGFnTmFtZXMoZSkge1xuICAgIHJldHVybiB0ZShlKSA/IFtlXSA6IEQoZSkgPyBPYmplY3Qua2V5cyhlKSA6IFtdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGFncyB0byBzdWJzdGl0dXRlIGJ5IFRvb2xcbiAgICpcbiAgICogQHBhcmFtIHRvb2wgLSBCbG9ja1Rvb2wgb2JqZWN0XG4gICAqL1xuICBnZXRUYWdzQ29uZmlnKGUpIHtcbiAgICBpZiAoZS5wYXN0ZUNvbmZpZyA9PT0gITEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGUucGFzdGVDb25maWcudGFncyB8fCBbXSwgbyA9IFtdO1xuICAgIHQuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgY29uc3QgcyA9IHRoaXMuY29sbGVjdFRhZ05hbWVzKGkpO1xuICAgICAgby5wdXNoKC4uLnMpLCBzLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnRvb2xzVGFncywgcikpIHtcbiAgICAgICAgICBTKFxuICAgICAgICAgICAgYFBhc3RlIGhhbmRsZXIgZm9yIMKrJHtlLm5hbWV9wrsgVG9vbCBvbiDCqyR7cn3CuyB0YWcgaXMgc2tpcHBlZCBiZWNhdXNlIGl0IGlzIGFscmVhZHkgdXNlZCBieSDCqyR7dGhpcy50b29sc1RhZ3Nbcl0udG9vbC5uYW1lfcK7IFRvb2wuYCxcbiAgICAgICAgICAgIFwid2FyblwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYSA9IEQoaSkgPyBpW3JdIDogbnVsbDtcbiAgICAgICAgdGhpcy50b29sc1RhZ3Nbci50b1VwcGVyQ2FzZSgpXSA9IHtcbiAgICAgICAgICB0b29sOiBlLFxuICAgICAgICAgIHNhbml0aXphdGlvbkNvbmZpZzogYVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSksIHRoaXMudGFnc0J5VG9vbFtlLm5hbWVdID0gby5tYXAoKGkpID0+IGkudG9VcHBlckNhc2UoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBmaWxlc2AgdHlwZXMgYW5kIGV4dGVuc2lvbnMgdG8gc3Vic3RpdHV0ZSBieSBUb29sXG4gICAqXG4gICAqIEBwYXJhbSB0b29sIC0gQmxvY2tUb29sIG9iamVjdFxuICAgKi9cbiAgZ2V0RmlsZXNDb25maWcoZSkge1xuICAgIGlmIChlLnBhc3RlQ29uZmlnID09PSAhMSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGZpbGVzOiB0ID0ge30gfSA9IGUucGFzdGVDb25maWc7XG4gICAgbGV0IHsgZXh0ZW5zaW9uczogbywgbWltZVR5cGVzOiBpIH0gPSB0O1xuICAgICFvICYmICFpIHx8IChvICYmICFBcnJheS5pc0FycmF5KG8pICYmIChTKGDCq2V4dGVuc2lvbnPCuyBwcm9wZXJ0eSBvZiB0aGUgb25Ecm9wIGNvbmZpZyBmb3Igwqske2UubmFtZX3CuyBUb29sIHNob3VsZCBiZSBhbiBhcnJheWApLCBvID0gW10pLCBpICYmICFBcnJheS5pc0FycmF5KGkpICYmIChTKGDCq21pbWVUeXBlc8K7IHByb3BlcnR5IG9mIHRoZSBvbkRyb3AgY29uZmlnIGZvciDCqyR7ZS5uYW1lfcK7IFRvb2wgc2hvdWxkIGJlIGFuIGFycmF5YCksIGkgPSBbXSksIGkgJiYgKGkgPSBpLmZpbHRlcigocykgPT4gZWkocykgPyAhMCA6IChTKGBNSU1FIHR5cGUgdmFsdWUgwqske3N9wrsgZm9yIHRoZSDCqyR7ZS5uYW1lfcK7IFRvb2wgaXMgbm90IGEgdmFsaWQgTUlNRSB0eXBlYCwgXCJ3YXJuXCIpLCAhMSkpKSwgdGhpcy50b29sc0ZpbGVzW2UubmFtZV0gPSB7XG4gICAgICBleHRlbnNpb25zOiBvIHx8IFtdLFxuICAgICAgbWltZVR5cGVzOiBpIHx8IFtdXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBSZWdFeHAgcGF0dGVybnMgdG8gc3Vic3RpdHV0ZSBieSBUb29sXG4gICAqXG4gICAqIEBwYXJhbSB0b29sIC0gQmxvY2tUb29sIG9iamVjdFxuICAgKi9cbiAgZ2V0UGF0dGVybnNDb25maWcoZSkge1xuICAgIGUucGFzdGVDb25maWcgPT09ICExIHx8ICFlLnBhc3RlQ29uZmlnLnBhdHRlcm5zIHx8IFYoZS5wYXN0ZUNvbmZpZy5wYXR0ZXJucykgfHwgT2JqZWN0LmVudHJpZXMoZS5wYXN0ZUNvbmZpZy5wYXR0ZXJucykuZm9yRWFjaCgoW3QsIG9dKSA9PiB7XG4gICAgICBvIGluc3RhbmNlb2YgUmVnRXhwIHx8IFMoXG4gICAgICAgIGBQYXR0ZXJuICR7b30gZm9yIMKrJHtlLm5hbWV9wrsgVG9vbCBpcyBza2lwcGVkIGJlY2F1c2UgaXQgc2hvdWxkIGJlIGEgUmVnZXhwIGluc3RhbmNlLmAsXG4gICAgICAgIFwid2FyblwiXG4gICAgICApLCB0aGlzLnRvb2xzUGF0dGVybnMucHVzaCh7XG4gICAgICAgIGtleTogdCxcbiAgICAgICAgcGF0dGVybjogbyxcbiAgICAgICAgdG9vbDogZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGJyb3dzZXIgYmVoYXZpb3Igc3VpdHMgYmV0dGVyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnQgLSBlbGVtZW50IHdoZXJlIGNvbnRlbnQgaGFzIGJlZW4gcGFzdGVkXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNOYXRpdmVCZWhhdmlvdXIoZSkge1xuICAgIHJldHVybiBkLmlzTmF0aXZlSW5wdXQoZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBmaWxlcyBmcm9tIGRhdGEgdHJhbnNmZXIgb2JqZWN0IGFuZCBpbnNlcnQgcmVsYXRlZCBUb29sc1xuICAgKlxuICAgKiBAcGFyYW0ge0ZpbGVMaXN0fSBpdGVtcyAtIHBhc3RlZCBvciBkcm9wcGVkIGl0ZW1zXG4gICAqL1xuICBhc3luYyBwcm9jZXNzRmlsZXMoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0IH0gPSB0aGlzLkVkaXRvcjtcbiAgICBsZXQgbztcbiAgICBvID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBBcnJheS5mcm9tKGUpLm1hcCgocikgPT4gdGhpcy5wcm9jZXNzRmlsZShyKSlcbiAgICApLCBvID0gby5maWx0ZXIoKHIpID0+ICEhcik7XG4gICAgY29uc3QgcyA9IHQuY3VycmVudEJsb2NrLnRvb2wuaXNEZWZhdWx0ICYmIHQuY3VycmVudEJsb2NrLmlzRW1wdHk7XG4gICAgby5mb3JFYWNoKFxuICAgICAgKHIsIGEpID0+IHtcbiAgICAgICAgdC5wYXN0ZShyLnR5cGUsIHIuZXZlbnQsIGEgPT09IDAgJiYgcyk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZm9ybWF0aW9uIGFib3V0IGZpbGUgYW5kIGZpbmQgVG9vbCB0byBoYW5kbGUgaXRcbiAgICpcbiAgICogQHBhcmFtIHtGaWxlfSBmaWxlIC0gZmlsZSB0byBwcm9jZXNzXG4gICAqL1xuICBhc3luYyBwcm9jZXNzRmlsZShlKSB7XG4gICAgY29uc3QgdCA9IEpuKGUpLCBvID0gT2JqZWN0LmVudHJpZXModGhpcy50b29sc0ZpbGVzKS5maW5kKChbciwgeyBtaW1lVHlwZXM6IGEsIGV4dGVuc2lvbnM6IGwgfV0pID0+IHtcbiAgICAgIGNvbnN0IFtjLCB1XSA9IGUudHlwZS5zcGxpdChcIi9cIiksIGggPSBsLmZpbmQoKGcpID0+IGcudG9Mb3dlckNhc2UoKSA9PT0gdC50b0xvd2VyQ2FzZSgpKSwgcCA9IGEuZmluZCgoZykgPT4ge1xuICAgICAgICBjb25zdCBbZiwgdl0gPSBnLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgcmV0dXJuIGYgPT09IGMgJiYgKHYgPT09IHUgfHwgdiA9PT0gXCIqXCIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gISFoIHx8ICEhcDtcbiAgICB9KTtcbiAgICBpZiAoIW8pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW2ldID0gbztcbiAgICByZXR1cm4ge1xuICAgICAgZXZlbnQ6IHRoaXMuY29tcG9zZVBhc3RlRXZlbnQoXCJmaWxlXCIsIHtcbiAgICAgICAgZmlsZTogZVxuICAgICAgfSksXG4gICAgICB0eXBlOiBpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU3BsaXQgSFRNTCBzdHJpbmcgdG8gYmxvY2tzIGFuZCByZXR1cm4gaXQgYXMgYXJyYXkgb2YgQmxvY2sgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5uZXJIVE1MIC0gaHRtbCBzdHJpbmcgdG8gcHJvY2Vzc1xuICAgKiBAcmV0dXJucyB7UGFzdGVEYXRhW119XG4gICAqL1xuICBwcm9jZXNzSFRNTChlKSB7XG4gICAgY29uc3QgeyBUb29sczogdCB9ID0gdGhpcy5FZGl0b3IsIG8gPSBkLm1ha2UoXCJESVZcIik7XG4gICAgcmV0dXJuIG8uaW5uZXJIVE1MID0gZSwgdGhpcy5nZXROb2RlcyhvKS5tYXAoKHMpID0+IHtcbiAgICAgIGxldCByLCBhID0gdC5kZWZhdWx0VG9vbCwgbCA9ICExO1xuICAgICAgc3dpdGNoIChzLm5vZGVUeXBlKSB7XG4gICAgICAgIGNhc2UgTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuICAgICAgICAgIHIgPSBkLm1ha2UoXCJkaXZcIiksIHIuYXBwZW5kQ2hpbGQocyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTm9kZS5FTEVNRU5UX05PREU6XG4gICAgICAgICAgciA9IHMsIGwgPSAhMCwgdGhpcy50b29sc1RhZ3Nbci50YWdOYW1lXSAmJiAoYSA9IHRoaXMudG9vbHNUYWdzW3IudGFnTmFtZV0udG9vbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRhZ3M6IGMgfSA9IGEucGFzdGVDb25maWcgfHwgeyB0YWdzOiBbXSB9LCB1ID0gYy5yZWR1Y2UoKGcsIGYpID0+ICh0aGlzLmNvbGxlY3RUYWdOYW1lcyhmKS5mb3JFYWNoKChPKSA9PiB7XG4gICAgICAgIGNvbnN0IFQgPSBEKGYpID8gZltPXSA6IG51bGw7XG4gICAgICAgIGdbTy50b0xvd2VyQ2FzZSgpXSA9IFQgfHwge307XG4gICAgICB9KSwgZyksIHt9KSwgaCA9IE9iamVjdC5hc3NpZ24oe30sIHUsIGEuYmFzZVNhbml0aXplQ29uZmlnKTtcbiAgICAgIGlmIChyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0YWJsZVwiKSB7XG4gICAgICAgIGNvbnN0IGcgPSBaKHIub3V0ZXJIVE1MLCBoKTtcbiAgICAgICAgciA9IGQubWFrZShcImRpdlwiLCB2b2lkIDAsIHtcbiAgICAgICAgICBpbm5lckhUTUw6IGdcbiAgICAgICAgfSkuZmlyc3RDaGlsZDtcbiAgICAgIH0gZWxzZVxuICAgICAgICByLmlubmVySFRNTCA9IFooci5pbm5lckhUTUwsIGgpO1xuICAgICAgY29uc3QgcCA9IHRoaXMuY29tcG9zZVBhc3RlRXZlbnQoXCJ0YWdcIiwge1xuICAgICAgICBkYXRhOiByXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQ6IHIsXG4gICAgICAgIGlzQmxvY2s6IGwsXG4gICAgICAgIHRvb2w6IGEubmFtZSxcbiAgICAgICAgZXZlbnQ6IHBcbiAgICAgIH07XG4gICAgfSkuZmlsdGVyKChzKSA9PiB7XG4gICAgICBjb25zdCByID0gZC5pc0VtcHR5KHMuY29udGVudCksIGEgPSBkLmlzU2luZ2xlVGFnKHMuY29udGVudCk7XG4gICAgICByZXR1cm4gIXIgfHwgYTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BsaXQgcGxhaW4gdGV4dCBieSBuZXcgbGluZSBzeW1ib2xzIGFuZCByZXR1cm4gaXQgYXMgYXJyYXkgb2YgQmxvY2sgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGxhaW4gLSBzdHJpbmcgdG8gcHJvY2Vzc1xuICAgKiBAcmV0dXJucyB7UGFzdGVEYXRhW119XG4gICAqL1xuICBwcm9jZXNzUGxhaW4oZSkge1xuICAgIGNvbnN0IHsgZGVmYXVsdEJsb2NrOiB0IH0gPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgbyA9IHQ7XG4gICAgcmV0dXJuIGUuc3BsaXQoL1xccj9cXG4vKS5maWx0ZXIoKGkpID0+IGkudHJpbSgpKS5tYXAoKGkpID0+IHtcbiAgICAgIGNvbnN0IHMgPSBkLm1ha2UoXCJkaXZcIik7XG4gICAgICBzLnRleHRDb250ZW50ID0gaTtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLmNvbXBvc2VQYXN0ZUV2ZW50KFwidGFnXCIsIHtcbiAgICAgICAgZGF0YTogc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50OiBzLFxuICAgICAgICB0b29sOiBvLFxuICAgICAgICBpc0Jsb2NrOiAhMSxcbiAgICAgICAgZXZlbnQ6IHJcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgcGFzdGUgb2Ygc2luZ2xlIEJsb2NrIHRvb2wgY29udGVudFxuICAgKlxuICAgKiBAcGFyYW0ge1Bhc3RlRGF0YX0gZGF0YVRvSW5zZXJ0IC0gZGF0YSBvZiBCbG9jayB0byBpbnNlcnRcbiAgICovXG4gIGFzeW5jIHByb2Nlc3NTaW5nbGVCbG9jayhlKSB7XG4gICAgY29uc3QgeyBDYXJldDogdCwgQmxvY2tNYW5hZ2VyOiBvIH0gPSB0aGlzLkVkaXRvciwgeyBjdXJyZW50QmxvY2s6IGkgfSA9IG87XG4gICAgaWYgKCFpIHx8IGUudG9vbCAhPT0gaS5uYW1lIHx8ICFkLmNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzKGUuY29udGVudC5pbm5lckhUTUwpKSB7XG4gICAgICB0aGlzLmluc2VydEJsb2NrKGUsIChpID09IG51bGwgPyB2b2lkIDAgOiBpLnRvb2wuaXNEZWZhdWx0KSAmJiBpLmlzRW1wdHkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0Lmluc2VydENvbnRlbnRBdENhcmV0UG9zaXRpb24oZS5jb250ZW50LmlubmVySFRNTCk7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3MgcGFzdGUgdG8gc2luZ2xlIEJsb2NrOlxuICAgKiAxLiBGaW5kIHBhdHRlcm5zYCBtYXRjaGVzXG4gICAqIDIuIEluc2VydCBuZXcgYmxvY2sgaWYgaXQgaXMgbm90IHRoZSBzYW1lIHR5cGUgYXMgY3VycmVudCBvbmVcbiAgICogMy4gSnVzdCBpbnNlcnQgdGV4dCBpZiB0aGVyZSBpcyBubyBzdWJzdGl0dXRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7UGFzdGVEYXRhfSBkYXRhVG9JbnNlcnQgLSBkYXRhIG9mIEJsb2NrIHRvIGluc2VydFxuICAgKi9cbiAgYXN5bmMgcHJvY2Vzc0lubGluZVBhc3RlKGUpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCwgQ2FyZXQ6IG8gfSA9IHRoaXMuRWRpdG9yLCB7IGNvbnRlbnQ6IGkgfSA9IGU7XG4gICAgaWYgKHQuY3VycmVudEJsb2NrICYmIHQuY3VycmVudEJsb2NrLnRvb2wuaXNEZWZhdWx0ICYmIGkudGV4dENvbnRlbnQubGVuZ3RoIDwgRG4uUEFUVEVSTl9QUk9DRVNTSU5HX01BWF9MRU5HVEgpIHtcbiAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLnByb2Nlc3NQYXR0ZXJuKGkudGV4dENvbnRlbnQpO1xuICAgICAgaWYgKHIpIHtcbiAgICAgICAgY29uc3QgYSA9IHQuY3VycmVudEJsb2NrICYmIHQuY3VycmVudEJsb2NrLnRvb2wuaXNEZWZhdWx0ICYmIHQuY3VycmVudEJsb2NrLmlzRW1wdHksIGwgPSB0LnBhc3RlKHIudG9vbCwgci5ldmVudCwgYSk7XG4gICAgICAgIG8uc2V0VG9CbG9jayhsLCBvLnBvc2l0aW9ucy5FTkQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0LmN1cnJlbnRCbG9jayAmJiB0LmN1cnJlbnRCbG9jay5jdXJyZW50SW5wdXQpIHtcbiAgICAgIGNvbnN0IHIgPSB0LmN1cnJlbnRCbG9jay50b29sLmJhc2VTYW5pdGl6ZUNvbmZpZztcbiAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKFxuICAgICAgICBcImluc2VydEhUTUxcIixcbiAgICAgICAgITEsXG4gICAgICAgIFooaS5pbm5lckhUTUwsIHIpXG4gICAgICApO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5pbnNlcnRCbG9jayhlKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHBhdHRlcm5zYCBtYXRjaGVzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCB0byBwcm9jZXNzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHtldmVudDogUGFzdGVFdmVudCwgdG9vbDogc3RyaW5nfT59XG4gICAqL1xuICBhc3luYyBwcm9jZXNzUGF0dGVybihlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMudG9vbHNQYXR0ZXJucy5maW5kKChpKSA9PiB7XG4gICAgICBjb25zdCBzID0gaS5wYXR0ZXJuLmV4ZWMoZSk7XG4gICAgICByZXR1cm4gcyA/IGUgPT09IHMuc2hpZnQoKSA6ICExO1xuICAgIH0pO1xuICAgIHJldHVybiB0ID8ge1xuICAgICAgZXZlbnQ6IHRoaXMuY29tcG9zZVBhc3RlRXZlbnQoXCJwYXR0ZXJuXCIsIHtcbiAgICAgICAga2V5OiB0LmtleSxcbiAgICAgICAgZGF0YTogZVxuICAgICAgfSksXG4gICAgICB0b29sOiB0LnRvb2wubmFtZVxuICAgIH0gOiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydCBwYXN0ZWQgQmxvY2sgY29udGVudCB0byBFZGl0b3JcbiAgICpcbiAgICogQHBhcmFtIHtQYXN0ZURhdGF9IGRhdGEgLSBkYXRhIHRvIGluc2VydFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhblJlcGxhY2VDdXJyZW50QmxvY2sgLSBpZiB0cnVlIGFuZCBpcyBjdXJyZW50IEJsb2NrIGlzIGVtcHR5LCB3aWxsIHJlcGxhY2UgY3VycmVudCBCbG9ja1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGluc2VydEJsb2NrKGUsIHQgPSAhMSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiBvLCBDYXJldDogaSB9ID0gdGhpcy5FZGl0b3IsIHsgY3VycmVudEJsb2NrOiBzIH0gPSBvO1xuICAgIGxldCByO1xuICAgIGlmICh0ICYmIHMgJiYgcy5pc0VtcHR5KSB7XG4gICAgICByID0gby5wYXN0ZShlLnRvb2wsIGUuZXZlbnQsICEwKSwgaS5zZXRUb0Jsb2NrKHIsIGkucG9zaXRpb25zLkVORCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHIgPSBvLnBhc3RlKGUudG9vbCwgZS5ldmVudCksIGkuc2V0VG9CbG9jayhyLCBpLnBvc2l0aW9ucy5FTkQpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgZGF0YSBwYXNzZWQgYXMgYXBwbGljYXRpb24veC1lZGl0b3ItanMgSlNPTlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBibG9ja3Mg4oCUIEJsb2NrcycgZGF0YSB0byBpbnNlcnRcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBpbnNlcnRFZGl0b3JKU0RhdGEoZSkge1xuICAgIGNvbnN0IHsgQmxvY2tNYW5hZ2VyOiB0LCBDYXJldDogbywgVG9vbHM6IGkgfSA9IHRoaXMuRWRpdG9yO1xuICAgIHl0KFxuICAgICAgZSxcbiAgICAgIChyKSA9PiBpLmJsb2NrVG9vbHMuZ2V0KHIpLnNhbml0aXplQ29uZmlnXG4gICAgKS5mb3JFYWNoKCh7IHRvb2w6IHIsIGRhdGE6IGEgfSwgbCkgPT4ge1xuICAgICAgbGV0IGMgPSAhMTtcbiAgICAgIGwgPT09IDAgJiYgKGMgPSB0LmN1cnJlbnRCbG9jayAmJiB0LmN1cnJlbnRCbG9jay50b29sLmlzRGVmYXVsdCAmJiB0LmN1cnJlbnRCbG9jay5pc0VtcHR5KTtcbiAgICAgIGNvbnN0IHUgPSB0Lmluc2VydCh7XG4gICAgICAgIHRvb2w6IHIsXG4gICAgICAgIGRhdGE6IGEsXG4gICAgICAgIHJlcGxhY2U6IGNcbiAgICAgIH0pO1xuICAgICAgby5zZXRUb0Jsb2NrKHUsIG8ucG9zaXRpb25zLkVORCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIG5vZGVzIGZyb20gRWxlbWVudCBub2RlXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIGN1cnJlbnQgbm9kZVxuICAgKiBAcGFyYW0ge05vZGVbXX0gbm9kZXMgLSBwcm9jZXNzZWQgbm9kZXNcbiAgICogQHBhcmFtIHtOb2RlfSBkZXN0Tm9kZSAtIGRlc3RpbmF0aW9uIG5vZGVcbiAgICovXG4gIHByb2Nlc3NFbGVtZW50Tm9kZShlLCB0LCBvKSB7XG4gICAgY29uc3QgaSA9IE9iamVjdC5rZXlzKHRoaXMudG9vbHNUYWdzKSwgcyA9IGUsIHsgdG9vbDogciB9ID0gdGhpcy50b29sc1RhZ3Nbcy50YWdOYW1lXSB8fCB7fSwgYSA9IHRoaXMudGFnc0J5VG9vbFtyID09IG51bGwgPyB2b2lkIDAgOiByLm5hbWVdIHx8IFtdLCBsID0gaS5pbmNsdWRlcyhzLnRhZ05hbWUpLCBjID0gZC5ibG9ja0VsZW1lbnRzLmluY2x1ZGVzKHMudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSwgdSA9IEFycmF5LmZyb20ocy5jaGlsZHJlbikuc29tZShcbiAgICAgICh7IHRhZ05hbWU6IHAgfSkgPT4gaS5pbmNsdWRlcyhwKSAmJiAhYS5pbmNsdWRlcyhwKVxuICAgICksIGggPSBBcnJheS5mcm9tKHMuY2hpbGRyZW4pLnNvbWUoXG4gICAgICAoeyB0YWdOYW1lOiBwIH0pID0+IGQuYmxvY2tFbGVtZW50cy5pbmNsdWRlcyhwLnRvTG93ZXJDYXNlKCkpXG4gICAgKTtcbiAgICBpZiAoIWMgJiYgIWwgJiYgIXUpXG4gICAgICByZXR1cm4gby5hcHBlbmRDaGlsZChzKSwgWy4uLnQsIG9dO1xuICAgIGlmIChsICYmICF1IHx8IGMgJiYgIWggJiYgIXUpXG4gICAgICByZXR1cm4gWy4uLnQsIG8sIHNdO1xuICB9XG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBkaXZpZGUgSFRNTCBzdHJpbmcgdG8gdHdvIHR5cGVzIG9mIG5vZGVzOlxuICAgKiAxLiBCbG9jayBlbGVtZW50XG4gICAqIDIuIERvY3VtZW50IEZyYWdtZW50cyBjb250YWluZWQgdGV4dCBhbmQgbWFya3VwIHRhZ3MgbGlrZSBhLCBiLCBpIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB3cmFwcGVyIC0gd3JhcHBlciBvZiBwYXN0ZXIgSFRNTCBjb250ZW50XG4gICAqIEByZXR1cm5zIHtOb2RlW119XG4gICAqL1xuICBnZXROb2RlcyhlKSB7XG4gICAgY29uc3QgdCA9IEFycmF5LmZyb20oZS5jaGlsZE5vZGVzKTtcbiAgICBsZXQgbztcbiAgICBjb25zdCBpID0gKHMsIHIpID0+IHtcbiAgICAgIGlmIChkLmlzRW1wdHkocikgJiYgIWQuaXNTaW5nbGVUYWcocikpXG4gICAgICAgIHJldHVybiBzO1xuICAgICAgY29uc3QgYSA9IHNbcy5sZW5ndGggLSAxXTtcbiAgICAgIGxldCBsID0gbmV3IERvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIHN3aXRjaCAoYSAmJiBkLmlzRnJhZ21lbnQoYSkgJiYgKGwgPSBzLnBvcCgpKSwgci5ub2RlVHlwZSkge1xuICAgICAgICBjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOlxuICAgICAgICAgIGlmIChvID0gdGhpcy5wcm9jZXNzRWxlbWVudE5vZGUociwgcywgbCksIG8pXG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBOb2RlLlRFWFRfTk9ERTpcbiAgICAgICAgICByZXR1cm4gbC5hcHBlbmRDaGlsZChyKSwgWy4uLnMsIGxdO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBbLi4ucywgbF07XG4gICAgICB9XG4gICAgICByZXR1cm4gWy4uLnMsIC4uLkFycmF5LmZyb20oci5jaGlsZE5vZGVzKS5yZWR1Y2UoaSwgW10pXTtcbiAgICB9O1xuICAgIHJldHVybiB0LnJlZHVjZShpLCBbXSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbXBvc2UgcGFzdGUgZXZlbnQgd2l0aCBwYXNzZWQgdHlwZSBhbmQgZGV0YWlsXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0ge1Bhc3RlRXZlbnREZXRhaWx9IGRldGFpbCAtIGV2ZW50IGRldGFpbFxuICAgKi9cbiAgY29tcG9zZVBhc3RlRXZlbnQoZSwgdCkge1xuICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQoZSwge1xuICAgICAgZGV0YWlsOiB0XG4gICAgfSk7XG4gIH1cbn07XG5Sbi5QQVRURVJOX1BST0NFU1NJTkdfTUFYX0xFTkdUSCA9IDQ1MDtcbmxldCBwYSA9IFJuO1xuY2xhc3MgZmEgZXh0ZW5kcyBFIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy50b29sc0RvbnRTdXBwb3J0UmVhZE9ubHkgPSBbXSwgdGhpcy5yZWFkT25seUVuYWJsZWQgPSAhMTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBzdGF0ZSBvZiByZWFkIG9ubHkgbW9kZVxuICAgKi9cbiAgZ2V0IGlzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkT25seUVuYWJsZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBpbml0aWFsIHN0YXRlXG4gICAqL1xuICBhc3luYyBwcmVwYXJlKCkge1xuICAgIGNvbnN0IHsgVG9vbHM6IGUgfSA9IHRoaXMuRWRpdG9yLCB7IGJsb2NrVG9vbHM6IHQgfSA9IGUsIG8gPSBbXTtcbiAgICBBcnJheS5mcm9tKHQuZW50cmllcygpKS5mb3JFYWNoKChbaSwgc10pID0+IHtcbiAgICAgIHMuaXNSZWFkT25seVN1cHBvcnRlZCB8fCBvLnB1c2goaSk7XG4gICAgfSksIHRoaXMudG9vbHNEb250U3VwcG9ydFJlYWRPbmx5ID0gbywgdGhpcy5jb25maWcucmVhZE9ubHkgJiYgby5sZW5ndGggPiAwICYmIHRoaXMudGhyb3dDcml0aWNhbEVycm9yKCksIHRoaXMudG9nZ2xlKHRoaXMuY29uZmlnLnJlYWRPbmx5LCAhMCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCByZWFkLW9ubHkgbW9kZSBvciB0b2dnbGUgY3VycmVudCBzdGF0ZVxuICAgKiBDYWxsIGFsbCBNb2R1bGVzIGB0b2dnbGVSZWFkT25seWAgbWV0aG9kIGFuZCByZS1yZW5kZXIgRWRpdG9yXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSAtIChvcHRpb25hbCkgcmVhZC1vbmx5IHN0YXRlIG9yIHRvZ2dsZVxuICAgKiBAcGFyYW0gaXNJbml0aWFsIC0gKG9wdGlvbmFsKSB0cnVlIHdoZW4gZWRpdG9yIGlzIGluaXRpYWxpemluZ1xuICAgKi9cbiAgYXN5bmMgdG9nZ2xlKGUgPSAhdGhpcy5yZWFkT25seUVuYWJsZWQsIHQgPSAhMSkge1xuICAgIGUgJiYgdGhpcy50b29sc0RvbnRTdXBwb3J0UmVhZE9ubHkubGVuZ3RoID4gMCAmJiB0aGlzLnRocm93Q3JpdGljYWxFcnJvcigpO1xuICAgIGNvbnN0IG8gPSB0aGlzLnJlYWRPbmx5RW5hYmxlZDtcbiAgICB0aGlzLnJlYWRPbmx5RW5hYmxlZCA9IGU7XG4gICAgZm9yIChjb25zdCBzIGluIHRoaXMuRWRpdG9yKVxuICAgICAgdGhpcy5FZGl0b3Jbc10udG9nZ2xlUmVhZE9ubHkgJiYgdGhpcy5FZGl0b3Jbc10udG9nZ2xlUmVhZE9ubHkoZSk7XG4gICAgaWYgKG8gPT09IGUpXG4gICAgICByZXR1cm4gdGhpcy5yZWFkT25seUVuYWJsZWQ7XG4gICAgaWYgKHQpXG4gICAgICByZXR1cm4gdGhpcy5yZWFkT25seUVuYWJsZWQ7XG4gICAgdGhpcy5FZGl0b3IuTW9kaWZpY2F0aW9uc09ic2VydmVyLmRpc2FibGUoKTtcbiAgICBjb25zdCBpID0gYXdhaXQgdGhpcy5FZGl0b3IuU2F2ZXIuc2F2ZSgpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuY2xlYXIoKSwgYXdhaXQgdGhpcy5FZGl0b3IuUmVuZGVyZXIucmVuZGVyKGkuYmxvY2tzKSwgdGhpcy5FZGl0b3IuTW9kaWZpY2F0aW9uc09ic2VydmVyLmVuYWJsZSgpLCB0aGlzLnJlYWRPbmx5RW5hYmxlZDtcbiAgfVxuICAvKipcbiAgICogVGhyb3dzIGFuIGVycm9yIGFib3V0IHRvb2xzIHdoaWNoIGRvbid0IHN1cHBvcnQgcmVhZC1vbmx5IG1vZGVcbiAgICovXG4gIHRocm93Q3JpdGljYWxFcnJvcigpIHtcbiAgICB0aHJvdyBuZXcgSG8oXG4gICAgICBgVG8gZW5hYmxlIHJlYWQtb25seSBtb2RlIGFsbCBjb25uZWN0ZWQgdG9vbHMgc2hvdWxkIHN1cHBvcnQgaXQuIFRvb2xzICR7dGhpcy50b29sc0RvbnRTdXBwb3J0UmVhZE9ubHkuam9pbihcIiwgXCIpfSBkb24ndCBzdXBwb3J0IHJlYWQtb25seSBtb2RlLmBcbiAgICApO1xuICB9XG59XG5jbGFzcyBCZSBleHRlbmRzIEUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLmlzUmVjdFNlbGVjdGlvbkFjdGl2YXRlZCA9ICExLCB0aGlzLlNDUk9MTF9TUEVFRCA9IDMsIHRoaXMuSEVJR0hUX09GX1NDUk9MTF9aT05FID0gNDAsIHRoaXMuQk9UVE9NX1NDUk9MTF9aT05FID0gMSwgdGhpcy5UT1BfU0NST0xMX1pPTkUgPSAyLCB0aGlzLk1BSU5fTU9VU0VfQlVUVE9OID0gMCwgdGhpcy5tb3VzZWRvd24gPSAhMSwgdGhpcy5pc1Njcm9sbGluZyA9ICExLCB0aGlzLmluU2Nyb2xsWm9uZSA9IG51bGwsIHRoaXMuc3RhcnRYID0gMCwgdGhpcy5zdGFydFkgPSAwLCB0aGlzLm1vdXNlWCA9IDAsIHRoaXMubW91c2VZID0gMCwgdGhpcy5zdGFja09mU2VsZWN0ZWQgPSBbXSwgdGhpcy5saXN0ZW5lcklkcyA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBDU1MgY2xhc3NlcyBmb3IgdGhlIEJsb2NrXG4gICAqXG4gICAqIEByZXR1cm5zIHt7d3JhcHBlcjogc3RyaW5nLCBjb250ZW50OiBzdHJpbmd9fVxuICAgKi9cbiAgc3RhdGljIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG92ZXJsYXk6IFwiY29kZXgtZWRpdG9yLW92ZXJsYXlcIixcbiAgICAgIG92ZXJsYXlDb250YWluZXI6IFwiY29kZXgtZWRpdG9yLW92ZXJsYXlfX2NvbnRhaW5lclwiLFxuICAgICAgcmVjdDogXCJjb2RleC1lZGl0b3Itb3ZlcmxheV9fcmVjdGFuZ2xlXCIsXG4gICAgICB0b3BTY3JvbGxab25lOiBcImNvZGV4LWVkaXRvci1vdmVybGF5X19zY3JvbGwtem9uZS0tdG9wXCIsXG4gICAgICBib3R0b21TY3JvbGxab25lOiBcImNvZGV4LWVkaXRvci1vdmVybGF5X19zY3JvbGwtem9uZS0tYm90dG9tXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNb2R1bGUgUHJlcGFyYXRpb25cbiAgICogQ3JlYXRpbmcgcmVjdCBhbmQgaGFuZyBoYW5kbGVyc1xuICAgKi9cbiAgcHJlcGFyZSgpIHtcbiAgICB0aGlzLmVuYWJsZU1vZHVsZUJpbmRpbmdzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXQgcmVjdCBwYXJhbXNcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhZ2VYIC0gWCBjb29yZCBvZiBtb3VzZVxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFnZVkgLSBZIGNvb3JkIG9mIG1vdXNlXG4gICAqL1xuICBzdGFydFNlbGVjdGlvbihlLCB0KSB7XG4gICAgY29uc3QgbyA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZSAtIHdpbmRvdy5wYWdlWE9mZnNldCwgdCAtIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgby5jbG9zZXN0KGAuJHt0aGlzLkVkaXRvci5Ub29sYmFyLkNTUy50b29sYmFyfWApIHx8ICh0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi5hbGxCbG9ja3NTZWxlY3RlZCA9ICExLCB0aGlzLmNsZWFyU2VsZWN0aW9uKCksIHRoaXMuc3RhY2tPZlNlbGVjdGVkID0gW10pO1xuICAgIGNvbnN0IHMgPSBbXG4gICAgICBgLiR7Ui5DU1MuY29udGVudH1gLFxuICAgICAgYC4ke3RoaXMuRWRpdG9yLlRvb2xiYXIuQ1NTLnRvb2xiYXJ9YCxcbiAgICAgIGAuJHt0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLkNTUy5pbmxpbmVUb29sYmFyfWBcbiAgICBdLCByID0gby5jbG9zZXN0KFwiLlwiICsgdGhpcy5FZGl0b3IuVUkuQ1NTLmVkaXRvcldyYXBwZXIpLCBhID0gcy5zb21lKChsKSA9PiAhIW8uY2xvc2VzdChsKSk7XG4gICAgIXIgfHwgYSB8fCAodGhpcy5tb3VzZWRvd24gPSAhMCwgdGhpcy5zdGFydFggPSBlLCB0aGlzLnN0YXJ0WSA9IHQpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhciBhbGwgcGFyYW1zIHRvIGVuZCBzZWxlY3Rpb25cbiAgICovXG4gIGVuZFNlbGVjdGlvbigpIHtcbiAgICB0aGlzLm1vdXNlZG93biA9ICExLCB0aGlzLnN0YXJ0WCA9IDAsIHRoaXMuc3RhcnRZID0gMCwgdGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgfVxuICAvKipcbiAgICogaXMgUmVjdFNlbGVjdGlvbiBBY3RpdmF0ZWRcbiAgICovXG4gIGlzUmVjdEFjdGl2YXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1JlY3RTZWxlY3Rpb25BY3RpdmF0ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIE1hcmsgdGhhdCBzZWxlY3Rpb24gaXMgZW5kXG4gICAqL1xuICBjbGVhclNlbGVjdGlvbigpIHtcbiAgICB0aGlzLmlzUmVjdFNlbGVjdGlvbkFjdGl2YXRlZCA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIE1vZHVsZSBuZWNlc3NhcnkgZXZlbnQgaGFuZGxlcnNcbiAgICovXG4gIGVuYWJsZU1vZHVsZUJpbmRpbmdzKCkge1xuICAgIGNvbnN0IHsgY29udGFpbmVyOiBlIH0gPSB0aGlzLmdlbkhUTUwoKTtcbiAgICB0aGlzLmxpc3RlbmVycy5vbihlLCBcIm1vdXNlZG93blwiLCAodCkgPT4ge1xuICAgICAgdGhpcy5wcm9jZXNzTW91c2VEb3duKHQpO1xuICAgIH0sICExKSwgdGhpcy5saXN0ZW5lcnMub24oZG9jdW1lbnQuYm9keSwgXCJtb3VzZW1vdmVcIiwgZHQoKHQpID0+IHtcbiAgICAgIHRoaXMucHJvY2Vzc01vdXNlTW92ZSh0KTtcbiAgICB9LCAxMCksIHtcbiAgICAgIHBhc3NpdmU6ICEwXG4gICAgfSksIHRoaXMubGlzdGVuZXJzLm9uKGRvY3VtZW50LmJvZHksIFwibW91c2VsZWF2ZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnByb2Nlc3NNb3VzZUxlYXZlKCk7XG4gICAgfSksIHRoaXMubGlzdGVuZXJzLm9uKHdpbmRvdywgXCJzY3JvbGxcIiwgZHQoKHQpID0+IHtcbiAgICAgIHRoaXMucHJvY2Vzc1Njcm9sbCh0KTtcbiAgICB9LCAxMCksIHtcbiAgICAgIHBhc3NpdmU6ICEwXG4gICAgfSksIHRoaXMubGlzdGVuZXJzLm9uKGRvY3VtZW50LmJvZHksIFwibW91c2V1cFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnByb2Nlc3NNb3VzZVVwKCk7XG4gICAgfSwgITEpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgZG93biBldmVudHNcbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gbW91c2UgZXZlbnQgcGF5bG9hZFxuICAgKi9cbiAgcHJvY2Vzc01vdXNlRG93bihlKSB7XG4gICAgaWYgKGUuYnV0dG9uICE9PSB0aGlzLk1BSU5fTU9VU0VfQlVUVE9OKVxuICAgICAgcmV0dXJuO1xuICAgIGUudGFyZ2V0LmNsb3Nlc3QoZC5hbGxJbnB1dHNTZWxlY3RvcikgIT09IG51bGwgfHwgdGhpcy5zdGFydFNlbGVjdGlvbihlLnBhZ2VYLCBlLnBhZ2VZKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIG1vdmUgZXZlbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VFdmVudCAtIG1vdXNlIGV2ZW50IHBheWxvYWRcbiAgICovXG4gIHByb2Nlc3NNb3VzZU1vdmUoZSkge1xuICAgIHRoaXMuY2hhbmdpbmdSZWN0YW5nbGUoZSksIHRoaXMuc2Nyb2xsQnlab25lcyhlLmNsaWVudFkpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgbGVhdmVcbiAgICovXG4gIHByb2Nlc3NNb3VzZUxlYXZlKCkge1xuICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKSwgdGhpcy5lbmRTZWxlY3Rpb24oKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gbW91c2UgZXZlbnQgcGF5bG9hZFxuICAgKi9cbiAgcHJvY2Vzc1Njcm9sbChlKSB7XG4gICAgdGhpcy5jaGFuZ2luZ1JlY3RhbmdsZShlKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIHVwXG4gICAqL1xuICBwcm9jZXNzTW91c2VVcCgpIHtcbiAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCksIHRoaXMuZW5kU2VsZWN0aW9uKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNjcm9sbCBJZiBtb3VzZSBpbiBzY3JvbGwgem9uZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50WSAtIFkgY29vcmQgb2YgbW91c2VcbiAgICovXG4gIHNjcm9sbEJ5Wm9uZXMoZSkge1xuICAgIGlmICh0aGlzLmluU2Nyb2xsWm9uZSA9IG51bGwsIGUgPD0gdGhpcy5IRUlHSFRfT0ZfU0NST0xMX1pPTkUgJiYgKHRoaXMuaW5TY3JvbGxab25lID0gdGhpcy5UT1BfU0NST0xMX1pPTkUpLCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IC0gZSA8PSB0aGlzLkhFSUdIVF9PRl9TQ1JPTExfWk9ORSAmJiAodGhpcy5pblNjcm9sbFpvbmUgPSB0aGlzLkJPVFRPTV9TQ1JPTExfWk9ORSksICF0aGlzLmluU2Nyb2xsWm9uZSkge1xuICAgICAgdGhpcy5pc1Njcm9sbGluZyA9ICExO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzU2Nyb2xsaW5nIHx8ICh0aGlzLnNjcm9sbFZlcnRpY2FsKHRoaXMuaW5TY3JvbGxab25lID09PSB0aGlzLlRPUF9TQ1JPTExfWk9ORSA/IC10aGlzLlNDUk9MTF9TUEVFRCA6IHRoaXMuU0NST0xMX1NQRUVEKSwgdGhpcy5pc1Njcm9sbGluZyA9ICEwKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIHJlcXVpcmVkIEhUTUwgZWxlbWVudHNcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdDxzdHJpbmcsIEVsZW1lbnQ+fVxuICAgKi9cbiAgZ2VuSFRNTCgpIHtcbiAgICBjb25zdCB7IFVJOiBlIH0gPSB0aGlzLkVkaXRvciwgdCA9IGUubm9kZXMuaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBlLkNTUy5lZGl0b3JXcmFwcGVyKSwgbyA9IGQubWFrZShcImRpdlwiLCBCZS5DU1Mub3ZlcmxheSwge30pLCBpID0gZC5tYWtlKFwiZGl2XCIsIEJlLkNTUy5vdmVybGF5Q29udGFpbmVyLCB7fSksIHMgPSBkLm1ha2UoXCJkaXZcIiwgQmUuQ1NTLnJlY3QsIHt9KTtcbiAgICByZXR1cm4gaS5hcHBlbmRDaGlsZChzKSwgby5hcHBlbmRDaGlsZChpKSwgdC5hcHBlbmRDaGlsZChvKSwgdGhpcy5vdmVybGF5UmVjdGFuZ2xlID0gcywge1xuICAgICAgY29udGFpbmVyOiB0LFxuICAgICAgb3ZlcmxheTogb1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyBzY3JvbGxpbmcgaWYgYmxvY2tTZWxlY3Rpb24gaXMgYWN0aXZlIGFuZCBtb3VzZSBpcyBpbiBzY3JvbGwgem9uZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3BlZWQgLSBzcGVlZCBvZiBzY3JvbGxpbmdcbiAgICovXG4gIHNjcm9sbFZlcnRpY2FsKGUpIHtcbiAgICBpZiAoISh0aGlzLmluU2Nyb2xsWm9uZSAmJiB0aGlzLm1vdXNlZG93bikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICB3aW5kb3cuc2Nyb2xsQnkoMCwgZSksIHRoaXMubW91c2VZICs9IHdpbmRvdy5wYWdlWU9mZnNldCAtIHQsIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zY3JvbGxWZXJ0aWNhbChlKTtcbiAgICB9LCAwKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgY2hhbmdlIGluIHRoZSByZWN0YW5nbGUgYW5kIGl0cyBlZmZlY3RcbiAgICpcbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIG1vdXNlIGV2ZW50XG4gICAqL1xuICBjaGFuZ2luZ1JlY3RhbmdsZShlKSB7XG4gICAgaWYgKCF0aGlzLm1vdXNlZG93bilcbiAgICAgIHJldHVybjtcbiAgICBlLnBhZ2VZICE9PSB2b2lkIDAgJiYgKHRoaXMubW91c2VYID0gZS5wYWdlWCwgdGhpcy5tb3VzZVkgPSBlLnBhZ2VZKTtcbiAgICBjb25zdCB7IHJpZ2h0UG9zOiB0LCBsZWZ0UG9zOiBvLCBpbmRleDogaSB9ID0gdGhpcy5nZW5JbmZvRm9yTW91c2VTZWxlY3Rpb24oKSwgcyA9IHRoaXMuc3RhcnRYID4gdCAmJiB0aGlzLm1vdXNlWCA+IHQsIHIgPSB0aGlzLnN0YXJ0WCA8IG8gJiYgdGhpcy5tb3VzZVggPCBvO1xuICAgIHRoaXMucmVjdENyb3NzZXNCbG9ja3MgPSAhKHMgfHwgciksIHRoaXMuaXNSZWN0U2VsZWN0aW9uQWN0aXZhdGVkIHx8ICh0aGlzLnJlY3RDcm9zc2VzQmxvY2tzID0gITEsIHRoaXMuaXNSZWN0U2VsZWN0aW9uQWN0aXZhdGVkID0gITAsIHRoaXMuc2hyaW5rUmVjdGFuZ2xlVG9Qb2ludCgpLCB0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIiksIHRoaXMudXBkYXRlUmVjdGFuZ2xlU2l6ZSgpLCB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCksIGkgIT09IHZvaWQgMCAmJiAodGhpcy50cnlTZWxlY3ROZXh0QmxvY2soaSksIHRoaXMuaW52ZXJzZVNlbGVjdGlvbigpLCBiLmdldCgpLnJlbW92ZUFsbFJhbmdlcygpKTtcbiAgfVxuICAvKipcbiAgICogU2hyaW5rIHJlY3QgdG8gc2luZ3VsYXIgcG9pbnRcbiAgICovXG4gIHNocmlua1JlY3RhbmdsZVRvUG9pbnQoKSB7XG4gICAgdGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLmxlZnQgPSBgJHt0aGlzLnN0YXJ0WCAtIHdpbmRvdy5wYWdlWE9mZnNldH1weGAsIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS50b3AgPSBgJHt0aGlzLnN0YXJ0WSAtIHdpbmRvdy5wYWdlWU9mZnNldH1weGAsIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS5ib3R0b20gPSBgY2FsYygxMDAlIC0gJHt0aGlzLnN0YXJ0WSAtIHdpbmRvdy5wYWdlWU9mZnNldH1weGAsIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS5yaWdodCA9IGBjYWxjKDEwMCUgLSAke3RoaXMuc3RhcnRYIC0gd2luZG93LnBhZ2VYT2Zmc2V0fXB4YDtcbiAgfVxuICAvKipcbiAgICogU2VsZWN0IG9yIHVuc2VsZWN0IGFsbCBvZiBibG9ja3MgaW4gYXJyYXkgaWYgcmVjdCBpcyBvdXQgb3IgaW4gc2VsZWN0YWJsZSBhcmVhXG4gICAqL1xuICBpbnZlcnNlU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUluZGV4KHRoaXMuc3RhY2tPZlNlbGVjdGVkWzBdKS5zZWxlY3RlZDtcbiAgICBpZiAodGhpcy5yZWN0Q3Jvc3Nlc0Jsb2NrcyAmJiAhdClcbiAgICAgIGZvciAoY29uc3QgbyBvZiB0aGlzLnN0YWNrT2ZTZWxlY3RlZClcbiAgICAgICAgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uc2VsZWN0QmxvY2tCeUluZGV4KG8pO1xuICAgIGlmICghdGhpcy5yZWN0Q3Jvc3Nlc0Jsb2NrcyAmJiB0KVxuICAgICAgZm9yIChjb25zdCBvIG9mIHRoaXMuc3RhY2tPZlNlbGVjdGVkKVxuICAgICAgICB0aGlzLkVkaXRvci5CbG9ja1NlbGVjdGlvbi51blNlbGVjdEJsb2NrQnlJbmRleChvKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBzaXplIG9mIHJlY3RhbmdsZVxuICAgKi9cbiAgdXBkYXRlUmVjdGFuZ2xlU2l6ZSgpIHtcbiAgICB0aGlzLm1vdXNlWSA+PSB0aGlzLnN0YXJ0WSA/ICh0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUudG9wID0gYCR7dGhpcy5zdGFydFkgLSB3aW5kb3cucGFnZVlPZmZzZXR9cHhgLCB0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUuYm90dG9tID0gYGNhbGMoMTAwJSAtICR7dGhpcy5tb3VzZVkgLSB3aW5kb3cucGFnZVlPZmZzZXR9cHhgKSA6ICh0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUuYm90dG9tID0gYGNhbGMoMTAwJSAtICR7dGhpcy5zdGFydFkgLSB3aW5kb3cucGFnZVlPZmZzZXR9cHhgLCB0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUudG9wID0gYCR7dGhpcy5tb3VzZVkgLSB3aW5kb3cucGFnZVlPZmZzZXR9cHhgKSwgdGhpcy5tb3VzZVggPj0gdGhpcy5zdGFydFggPyAodGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLmxlZnQgPSBgJHt0aGlzLnN0YXJ0WCAtIHdpbmRvdy5wYWdlWE9mZnNldH1weGAsIHRoaXMub3ZlcmxheVJlY3RhbmdsZS5zdHlsZS5yaWdodCA9IGBjYWxjKDEwMCUgLSAke3RoaXMubW91c2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0fXB4YCkgOiAodGhpcy5vdmVybGF5UmVjdGFuZ2xlLnN0eWxlLnJpZ2h0ID0gYGNhbGMoMTAwJSAtICR7dGhpcy5zdGFydFggLSB3aW5kb3cucGFnZVhPZmZzZXR9cHhgLCB0aGlzLm92ZXJsYXlSZWN0YW5nbGUuc3R5bGUubGVmdCA9IGAke3RoaXMubW91c2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0fXB4YCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbGxlY3RzIGluZm9ybWF0aW9uIG5lZWRlZCB0byBkZXRlcm1pbmUgdGhlIGJlaGF2aW9yIG9mIHRoZSByZWN0YW5nbGVcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH0gaW5kZXggLSBpbmRleCBuZXh0IEJsb2NrLCBsZWZ0UG9zIC0gc3RhcnQgb2YgbGVmdCBib3JkZXIgb2YgQmxvY2ssIHJpZ2h0UG9zIC0gcmlnaHQgYm9yZGVyXG4gICAqL1xuICBnZW5JbmZvRm9yTW91c2VTZWxlY3Rpb24oKSB7XG4gICAgY29uc3QgdCA9IGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGggLyAyLCBvID0gdGhpcy5tb3VzZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQsIGkgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHQsIG8pLCBzID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmdldEJsb2NrQnlDaGlsZE5vZGUoaSk7XG4gICAgbGV0IHI7XG4gICAgcyAhPT0gdm9pZCAwICYmIChyID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmJsb2Nrcy5maW5kSW5kZXgoKGgpID0+IGguaG9sZGVyID09PSBzLmhvbGRlcikpO1xuICAgIGNvbnN0IGEgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIubGFzdEJsb2NrLmhvbGRlci5xdWVyeVNlbGVjdG9yKFwiLlwiICsgUi5DU1MuY29udGVudCksIGwgPSBOdW1iZXIucGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoYSkud2lkdGgsIDEwKSAvIDIsIGMgPSB0IC0gbCwgdSA9IHQgKyBsO1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleDogcixcbiAgICAgIGxlZnRQb3M6IGMsXG4gICAgICByaWdodFBvczogdVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNlbGVjdCBibG9jayB3aXRoIGluZGV4IGluZGV4XG4gICAqXG4gICAqIEBwYXJhbSBpbmRleCAtIGluZGV4IG9mIGJsb2NrIGluIHJlZGFjdG9yXG4gICAqL1xuICBhZGRCbG9ja0luU2VsZWN0aW9uKGUpIHtcbiAgICB0aGlzLnJlY3RDcm9zc2VzQmxvY2tzICYmIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLnNlbGVjdEJsb2NrQnlJbmRleChlKSwgdGhpcy5zdGFja09mU2VsZWN0ZWQucHVzaChlKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIGJsb2NrIHRvIHRoZSBzZWxlY3Rpb24gYW5kIGRldGVybWluZXMgd2hpY2ggYmxvY2tzIHNob3VsZCBiZSBzZWxlY3RlZFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5kZXggLSBpbmRleCBvZiBuZXcgYmxvY2sgaW4gdGhlIHJlYWN0b3JcbiAgICovXG4gIHRyeVNlbGVjdE5leHRCbG9jayhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc3RhY2tPZlNlbGVjdGVkW3RoaXMuc3RhY2tPZlNlbGVjdGVkLmxlbmd0aCAtIDFdID09PSBlLCBvID0gdGhpcy5zdGFja09mU2VsZWN0ZWQubGVuZ3RoLCBpID0gMSwgcyA9IC0xLCByID0gMDtcbiAgICBpZiAodClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhID0gdGhpcy5zdGFja09mU2VsZWN0ZWRbbyAtIDFdIC0gdGhpcy5zdGFja09mU2VsZWN0ZWRbbyAtIDJdID4gMDtcbiAgICBsZXQgbCA9IHI7XG4gICAgbyA+IDEgJiYgKGwgPSBhID8gaSA6IHMpO1xuICAgIGNvbnN0IGMgPSBlID4gdGhpcy5zdGFja09mU2VsZWN0ZWRbbyAtIDFdICYmIGwgPT09IGksIHUgPSBlIDwgdGhpcy5zdGFja09mU2VsZWN0ZWRbbyAtIDFdICYmIGwgPT09IHMsIHAgPSAhKGMgfHwgdSB8fCBsID09PSByKTtcbiAgICBpZiAoIXAgJiYgKGUgPiB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0gfHwgdGhpcy5zdGFja09mU2VsZWN0ZWRbbyAtIDFdID09PSB2b2lkIDApKSB7XG4gICAgICBsZXQgdiA9IHRoaXMuc3RhY2tPZlNlbGVjdGVkW28gLSAxXSArIDEgfHwgZTtcbiAgICAgIGZvciAodjsgdiA8PSBlOyB2KyspXG4gICAgICAgIHRoaXMuYWRkQmxvY2tJblNlbGVjdGlvbih2KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwICYmIGUgPCB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0pIHtcbiAgICAgIGZvciAobGV0IHYgPSB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0gLSAxOyB2ID49IGU7IHYtLSlcbiAgICAgICAgdGhpcy5hZGRCbG9ja0luU2VsZWN0aW9uKHYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXApXG4gICAgICByZXR1cm47XG4gICAgbGV0IGcgPSBvIC0gMSwgZjtcbiAgICBmb3IgKGUgPiB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtvIC0gMV0gPyBmID0gKCkgPT4gZSA+IHRoaXMuc3RhY2tPZlNlbGVjdGVkW2ddIDogZiA9ICgpID0+IGUgPCB0aGlzLnN0YWNrT2ZTZWxlY3RlZFtnXTsgZigpOyApXG4gICAgICB0aGlzLnJlY3RDcm9zc2VzQmxvY2tzICYmIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLnVuU2VsZWN0QmxvY2tCeUluZGV4KHRoaXMuc3RhY2tPZlNlbGVjdGVkW2ddKSwgdGhpcy5zdGFja09mU2VsZWN0ZWQucG9wKCksIGctLTtcbiAgfVxufVxuY2xhc3MgZ2EgZXh0ZW5kcyBFIHtcbiAgLyoqXG4gICAqIFJlbmRlcnMgcGFzc2VkIGJsb2NrcyBhcyBvbmUgYmF0Y2hcbiAgICpcbiAgICogQHBhcmFtIGJsb2Nrc0RhdGEgLSBibG9ja3MgdG8gcmVuZGVyXG4gICAqL1xuICBhc3luYyByZW5kZXIoZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgodCkgPT4ge1xuICAgICAgY29uc3QgeyBUb29sczogbywgQmxvY2tNYW5hZ2VyOiBpIH0gPSB0aGlzLkVkaXRvcjtcbiAgICAgIGlmIChlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgaS5pbnNlcnQoKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzID0gZS5tYXAoKHsgdHlwZTogciwgZGF0YTogYSwgdHVuZXM6IGwsIGlkOiBjIH0pID0+IHtcbiAgICAgICAgICBvLmF2YWlsYWJsZS5oYXMocikgPT09ICExICYmIChYKGBUb29sIMKrJHtyfcK7IGlzIG5vdCBmb3VuZC4gQ2hlY2sgJ3Rvb2xzJyBwcm9wZXJ0eSBhdCB0aGUgRWRpdG9yLmpzIGNvbmZpZy5gLCBcIndhcm5cIiksIGEgPSB0aGlzLmNvbXBvc2VTdHViRGF0YUZvclRvb2wociwgYSwgYyksIHIgPSBvLnN0dWJUb29sKTtcbiAgICAgICAgICBsZXQgdTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdSA9IGkuY29tcG9zZUJsb2NrKHtcbiAgICAgICAgICAgICAgaWQ6IGMsXG4gICAgICAgICAgICAgIHRvb2w6IHIsXG4gICAgICAgICAgICAgIGRhdGE6IGEsXG4gICAgICAgICAgICAgIHR1bmVzOiBsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChoKSB7XG4gICAgICAgICAgICBTKGBCbG9jayDCqyR7cn3CuyBza2lwcGVkIGJlY2F1c2Ugb2YgcGx1Z2lucyBlcnJvcmAsIFwiZXJyb3JcIiwge1xuICAgICAgICAgICAgICBkYXRhOiBhLFxuICAgICAgICAgICAgICBlcnJvcjogaFxuICAgICAgICAgICAgfSksIGEgPSB0aGlzLmNvbXBvc2VTdHViRGF0YUZvclRvb2wociwgYSwgYyksIHIgPSBvLnN0dWJUb29sLCB1ID0gaS5jb21wb3NlQmxvY2soe1xuICAgICAgICAgICAgICBpZDogYyxcbiAgICAgICAgICAgICAgdG9vbDogcixcbiAgICAgICAgICAgICAgZGF0YTogYSxcbiAgICAgICAgICAgICAgdHVuZXM6IGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdTtcbiAgICAgICAgfSk7XG4gICAgICAgIGkuaW5zZXJ0TWFueShzKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgdCgpO1xuICAgICAgfSwgeyB0aW1lb3V0OiAyZTMgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBkYXRhIGZvciB0aGUgU3R1YiBUb29sIHRoYXQgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdW5hdmFpbGFibGUgdG9vbFxuICAgKlxuICAgKiBAcGFyYW0gdG9vbCAtIHVuYXZhaWxhYmxlIHRvb2wgbmFtZSB0byBzdHViXG4gICAqIEBwYXJhbSBkYXRhIC0gZGF0YSBvZiB1bmF2YWlsYWJsZSBibG9ja1xuICAgKiBAcGFyYW0gW2lkXSAtIGlkIG9mIHVuYXZhaWxhYmxlIGJsb2NrXG4gICAqL1xuICBjb21wb3NlU3R1YkRhdGFGb3JUb29sKGUsIHQsIG8pIHtcbiAgICBjb25zdCB7IFRvb2xzOiBpIH0gPSB0aGlzLkVkaXRvcjtcbiAgICBsZXQgcyA9IGU7XG4gICAgaWYgKGkudW5hdmFpbGFibGUuaGFzKGUpKSB7XG4gICAgICBjb25zdCByID0gaS51bmF2YWlsYWJsZS5nZXQoZSkudG9vbGJveDtcbiAgICAgIHIgIT09IHZvaWQgMCAmJiByWzBdLnRpdGxlICE9PSB2b2lkIDAgJiYgKHMgPSByWzBdLnRpdGxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhdmVkRGF0YToge1xuICAgICAgICBpZDogbyxcbiAgICAgICAgdHlwZTogZSxcbiAgICAgICAgZGF0YTogdFxuICAgICAgfSxcbiAgICAgIHRpdGxlOiBzXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgbWEgZXh0ZW5kcyBFIHtcbiAgLyoqXG4gICAqIENvbXBvc2VzIG5ldyBjaGFpbiBvZiBQcm9taXNlcyB0byBmaXJlIHRoZW0gYWx0ZXJuYXRlbGx5XG4gICAqXG4gICAqIEByZXR1cm5zIHtPdXRwdXREYXRhfVxuICAgKi9cbiAgYXN5bmMgc2F2ZSgpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogZSwgVG9vbHM6IHQgfSA9IHRoaXMuRWRpdG9yLCBvID0gZS5ibG9ja3MsIGkgPSBbXTtcbiAgICB0cnkge1xuICAgICAgby5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGkucHVzaCh0aGlzLmdldFNhdmVkRGF0YShhKSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHMgPSBhd2FpdCBQcm9taXNlLmFsbChpKSwgciA9IGF3YWl0IHl0KHMsIChhKSA9PiB0LmJsb2NrVG9vbHMuZ2V0KGEpLnNhbml0aXplQ29uZmlnKTtcbiAgICAgIHJldHVybiB0aGlzLm1ha2VPdXRwdXQocik7XG4gICAgfSBjYXRjaCAocykge1xuICAgICAgWChcIlNhdmluZyBmYWlsZWQgZHVlIHRvIHRoZSBFcnJvciAlb1wiLCBcImVycm9yXCIsIHMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2F2ZXMgYW5kIHZhbGlkYXRlc1xuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2NrfSBibG9jayAtIEVkaXRvcidzIFRvb2xcbiAgICogQHJldHVybnMge1ZhbGlkYXRlZERhdGF9IC0gVG9vbCdzIHZhbGlkYXRlZCBkYXRhXG4gICAqL1xuICBhc3luYyBnZXRTYXZlZERhdGEoZSkge1xuICAgIGNvbnN0IHQgPSBhd2FpdCBlLnNhdmUoKSwgbyA9IHQgJiYgYXdhaXQgZS52YWxpZGF0ZSh0LmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi50LFxuICAgICAgaXNWYWxpZDogb1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgb3V0cHV0IG9iamVjdCB3aXRoIHNhdmVkIGRhdGEsIHRpbWUgYW5kIHZlcnNpb24gb2YgZWRpdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7VmFsaWRhdGVkRGF0YX0gYWxsRXh0cmFjdGVkRGF0YSAtIGRhdGEgZXh0cmFjdGVkIGZyb20gQmxvY2tzXG4gICAqIEByZXR1cm5zIHtPdXRwdXREYXRhfVxuICAgKi9cbiAgbWFrZU91dHB1dChlKSB7XG4gICAgY29uc3QgdCA9IFtdO1xuICAgIHJldHVybiBlLmZvckVhY2goKHsgaWQ6IG8sIHRvb2w6IGksIGRhdGE6IHMsIHR1bmVzOiByLCBpc1ZhbGlkOiBhIH0pID0+IHtcbiAgICAgIGlmICghYSkge1xuICAgICAgICBTKGBCbG9jayDCqyR7aX3CuyBza2lwcGVkIGJlY2F1c2Ugc2F2ZWQgZGF0YSBpcyBpbnZhbGlkYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpID09PSB0aGlzLkVkaXRvci5Ub29scy5zdHViVG9vbCkge1xuICAgICAgICB0LnB1c2gocyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGwgPSB7XG4gICAgICAgIGlkOiBvLFxuICAgICAgICB0eXBlOiBpLFxuICAgICAgICBkYXRhOiBzLFxuICAgICAgICAuLi4hVihyKSAmJiB7XG4gICAgICAgICAgdHVuZXM6IHJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHQucHVzaChsKTtcbiAgICB9KSwge1xuICAgICAgdGltZTogKy8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgYmxvY2tzOiB0LFxuICAgICAgdmVyc2lvbjogXCIyLjMxLjAtcmMuN1wiXG4gICAgfTtcbiAgfVxufVxuKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPCBcInVcIikge1xuICAgICAgdmFyIG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiLmNlLXBhcmFncmFwaHtsaW5lLWhlaWdodDoxLjZlbTtvdXRsaW5lOm5vbmV9LmNlLWJsb2NrOm9ubHktb2YtdHlwZSAuY2UtcGFyYWdyYXBoW2RhdGEtcGxhY2Vob2xkZXItYWN0aXZlXTplbXB0eTpiZWZvcmUsLmNlLWJsb2NrOm9ubHktb2YtdHlwZSAuY2UtcGFyYWdyYXBoW2RhdGEtcGxhY2Vob2xkZXItYWN0aXZlXVtkYXRhLWVtcHR5PXRydWVdOmJlZm9yZXtjb250ZW50OmF0dHIoZGF0YS1wbGFjZWhvbGRlci1hY3RpdmUpfS5jZS1wYXJhZ3JhcGggcDpmaXJzdC1vZi10eXBle21hcmdpbi10b3A6MH0uY2UtcGFyYWdyYXBoIHA6bGFzdC1vZi10eXBle21hcmdpbi1ib3R0b206MH1cIikpLCBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKG4pO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJ2aXRlLXBsdWdpbi1jc3MtaW5qZWN0ZWQtYnktanNcIiwgZSk7XG4gIH1cbn0pKCk7XG5jb25zdCBiYSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNOCA5VjcuMkM4IDcuMDg5NTQgOC4wODk1NCA3IDguMiA3TDEyIDdNMTYgOVY3LjJDMTYgNy4wODk1NCAxNS45MTA1IDcgMTUuOCA3TDEyIDdNMTIgN0wxMiAxN00xMiAxN0gxME0xMiAxN0gxNFwiLz48L3N2Zz4nO1xuZnVuY3Rpb24gdmEobikge1xuICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgZS5pbm5lckhUTUwgPSBuLnRyaW0oKTtcbiAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgcmV0dXJuIHQuYXBwZW5kKC4uLkFycmF5LmZyb20oZS5jaGlsZE5vZGVzKSksIHQ7XG59XG4vKipcbiAqIEJhc2UgUGFyYWdyYXBoIEJsb2NrIGZvciB0aGUgRWRpdG9yLmpzLlxuICogUmVwcmVzZW50cyBhIHJlZ3VsYXIgdGV4dCBibG9ja1xuICpcbiAqIEBhdXRob3IgQ29kZVggKHRlYW1AY29kZXguc28pXG4gKiBAY29weXJpZ2h0IENvZGVYIDIwMThcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICovXG5jbGFzcyBmbyB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IHBsYWNlaG9sZGVyIGZvciBQYXJhZ3JhcGggVG9vbFxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAY2xhc3NcbiAgICovXG4gIHN0YXRpYyBnZXQgREVGQVVMVF9QTEFDRUhPTERFUigpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICAvKipcbiAgICogUmVuZGVyIHBsdWdpbmBzIG1haW4gRWxlbWVudCBhbmQgZmlsbCBpdCB3aXRoIHNhdmVkIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIGNvbnN0cnVjdG9yIHBhcmFtc1xuICAgKiBAcGFyYW0ge1BhcmFncmFwaERhdGF9IHBhcmFtcy5kYXRhIC0gcHJldmlvdXNseSBzYXZlZCBkYXRhXG4gICAqIEBwYXJhbSB7UGFyYWdyYXBoQ29uZmlnfSBwYXJhbXMuY29uZmlnIC0gdXNlciBjb25maWcgZm9yIFRvb2xcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5hcGkgLSBlZGl0b3IuanMgYXBpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVhZE9ubHkgLSByZWFkIG9ubHkgbW9kZSBmbGFnXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGRhdGE6IGUsIGNvbmZpZzogdCwgYXBpOiBvLCByZWFkT25seTogaSB9KSB7XG4gICAgdGhpcy5hcGkgPSBvLCB0aGlzLnJlYWRPbmx5ID0gaSwgdGhpcy5fQ1NTID0ge1xuICAgICAgYmxvY2s6IHRoaXMuYXBpLnN0eWxlcy5ibG9jayxcbiAgICAgIHdyYXBwZXI6IFwiY2UtcGFyYWdyYXBoXCJcbiAgICB9LCB0aGlzLnJlYWRPbmx5IHx8ICh0aGlzLm9uS2V5VXAgPSB0aGlzLm9uS2V5VXAuYmluZCh0aGlzKSksIHRoaXMuX3BsYWNlaG9sZGVyID0gdC5wbGFjZWhvbGRlciA/IHQucGxhY2Vob2xkZXIgOiBmby5ERUZBVUxUX1BMQUNFSE9MREVSLCB0aGlzLl9kYXRhID0gZSA/PyB7fSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX3ByZXNlcnZlQmxhbmsgPSB0LnByZXNlcnZlQmxhbmsgPz8gITE7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRleHQgY29udGVudCBpcyBlbXB0eSBhbmQgc2V0IGVtcHR5IHN0cmluZyB0byBpbm5lciBodG1sLlxuICAgKiBXZSBuZWVkIHRoaXMgYmVjYXVzZSBzb21lIGJyb3dzZXJzIChlLmcuIFNhZmFyaSkgaW5zZXJ0IDxicj4gaW50byBlbXB0eSBjb250ZW50ZWRpdGFubGUgZWxlbWVudHNcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlIC0ga2V5IHVwIGV2ZW50XG4gICAqL1xuICBvbktleVVwKGUpIHtcbiAgICBpZiAoZS5jb2RlICE9PSBcIkJhY2tzcGFjZVwiICYmIGUuY29kZSAhPT0gXCJEZWxldGVcIiB8fCAhdGhpcy5fZWxlbWVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHRleHRDb250ZW50OiB0IH0gPSB0aGlzLl9lbGVtZW50O1xuICAgIHQgPT09IFwiXCIgJiYgKHRoaXMuX2VsZW1lbnQuaW5uZXJIVE1MID0gXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBUb29sJ3Mgdmlld1xuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTERpdkVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkcmF3VmlldygpIHtcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcbiAgICByZXR1cm4gZS5jbGFzc0xpc3QuYWRkKHRoaXMuX0NTUy53cmFwcGVyLCB0aGlzLl9DU1MuYmxvY2spLCBlLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIiwgZS5kYXRhc2V0LnBsYWNlaG9sZGVyQWN0aXZlID0gdGhpcy5hcGkuaTE4bi50KHRoaXMuX3BsYWNlaG9sZGVyKSwgdGhpcy5fZGF0YS50ZXh0ICYmIChlLmlubmVySFRNTCA9IHRoaXMuX2RhdGEudGV4dCksIHRoaXMucmVhZE9ubHkgfHwgKGUuY29udGVudEVkaXRhYmxlID0gXCJ0cnVlXCIsIGUuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMub25LZXlVcCkpLCBlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVG9vbCdzIHZpZXdcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxEaXZFbGVtZW50fVxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50ID0gdGhpcy5kcmF3VmlldygpLCB0aGlzLl9lbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgdGhhdCBzcGVjaWZpZWQgaG93IHRvIG1lcmdlIHR3byBUZXh0IGJsb2Nrcy5cbiAgICogQ2FsbGVkIGJ5IEVkaXRvci5qcyBieSBiYWNrc3BhY2UgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgQmxvY2tcbiAgICpcbiAgICogQHBhcmFtIHtQYXJhZ3JhcGhEYXRhfSBkYXRhXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG1lcmdlKGUpIHtcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fZGF0YS50ZXh0ICs9IGUudGV4dDtcbiAgICBjb25zdCB0ID0gdmEoZS50ZXh0KTtcbiAgICB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKHQpLCB0aGlzLl9lbGVtZW50Lm5vcm1hbGl6ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBQYXJhZ3JhcGggYmxvY2sgZGF0YTpcbiAgICogLSBjaGVjayBmb3IgZW1wdGluZXNzXG4gICAqXG4gICAqIEBwYXJhbSB7UGFyYWdyYXBoRGF0YX0gc2F2ZWREYXRhIOKAlCBkYXRhIHJlY2VpdmVkIGFmdGVyIHNhdmluZ1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWYgc2F2ZWQgZGF0YSBpcyBub3QgY29ycmVjdCwgb3RoZXJ3aXNlIHRydWVcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdmFsaWRhdGUoZSkge1xuICAgIHJldHVybiAhKGUudGV4dC50cmltKCkgPT09IFwiXCIgJiYgIXRoaXMuX3ByZXNlcnZlQmxhbmspO1xuICB9XG4gIC8qKlxuICAgKiBFeHRyYWN0IFRvb2wncyBkYXRhIGZyb20gdGhlIHZpZXdcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudH0gdG9vbHNDb250ZW50IC0gUGFyYWdyYXBoIHRvb2xzIHJlbmRlcmVkIHZpZXdcbiAgICogQHJldHVybnMge1BhcmFncmFwaERhdGF9IC0gc2F2ZWQgZGF0YVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzYXZlKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogZS5pbm5lckhUTUxcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBPbiBwYXN0ZSBjYWxsYmFjayBmaXJlZCBmcm9tIEVkaXRvci5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MUGFzdGVFdmVudH0gZXZlbnQgLSBldmVudCB3aXRoIHBhc3RlZCBkYXRhXG4gICAqL1xuICBvblBhc3RlKGUpIHtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgdGV4dDogZS5kZXRhaWwuZGF0YS5pbm5lckhUTUxcbiAgICB9O1xuICAgIHRoaXMuX2RhdGEgPSB0LCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQgJiYgKHRoaXMuX2VsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5fZGF0YS50ZXh0IHx8IFwiXCIpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGUgQ29udmVyc2lvbiBUb29sYmFyLiBQYXJhZ3JhcGggY2FuIGJlIGNvbnZlcnRlZCB0by9mcm9tIG90aGVyIHRvb2xzXG4gICAqIEByZXR1cm5zIHtDb252ZXJzaW9uQ29uZmlnfVxuICAgKi9cbiAgc3RhdGljIGdldCBjb252ZXJzaW9uQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICBleHBvcnQ6IFwidGV4dFwiLFxuICAgICAgLy8gdG8gY29udmVydCBQYXJhZ3JhcGggdG8gb3RoZXIgYmxvY2ssIHVzZSAndGV4dCcgcHJvcGVydHkgb2Ygc2F2ZWQgZGF0YVxuICAgICAgaW1wb3J0OiBcInRleHRcIlxuICAgICAgLy8gdG8gY292ZXJ0IG90aGVyIGJsb2NrJ3MgZXhwb3J0ZWQgc3RyaW5nIHRvIFBhcmFncmFwaCwgZmlsbCAndGV4dCcgcHJvcGVydHkgb2YgdG9vbCBkYXRhXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2FuaXRpemVyIHJ1bGVzXG4gICAqIEByZXR1cm5zIHtTYW5pdGl6ZXJDb25maWd9IC0gRWR0aW9yLmpzIHNhbml0aXplciBjb25maWdcbiAgICovXG4gIHN0YXRpYyBnZXQgc2FuaXRpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHtcbiAgICAgICAgYnI6ICEwXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIHRvIG5vdGlmeSB0aGUgY29yZSB0aGF0IHJlYWQtb25seSBtb2RlIGlzIHN1cHBvcnRlZFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgaXNSZWFkT25seVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIFVzZWQgYnkgRWRpdG9yIHBhc3RlIGhhbmRsaW5nIEFQSS5cbiAgICogUHJvdmlkZXMgY29uZmlndXJhdGlvbiB0byBoYW5kbGUgUCB0YWdzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UGFzdGVDb25maWd9IC0gUGFyYWdyYXBoIFBhc3RlIFNldHRpbmdcbiAgICovXG4gIHN0YXRpYyBnZXQgcGFzdGVDb25maWcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZ3M6IFtcIlBcIl1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBJY29uIGFuZCB0aXRsZSBmb3IgZGlzcGxheWluZyBhdCB0aGUgVG9vbGJveFxuICAgKlxuICAgKiBAcmV0dXJucyB7VG9vbGJveENvbmZpZ30gLSBQYXJhZ3JhcGggVG9vbGJveCBTZXR0aW5nXG4gICAqL1xuICBzdGF0aWMgZ2V0IHRvb2xib3goKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGljb246IGJhLFxuICAgICAgdGl0bGU6IFwiVGV4dFwiXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgZ28ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbW1hbmROYW1lID0gXCJib2xkXCI7XG4gIH1cbiAgLyoqXG4gICAqIFNhbml0aXplciBSdWxlXG4gICAqIExlYXZlIDxiPiB0YWdzXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHNhbml0aXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICBiOiB7fVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBidXR0b24gZm9yIElubGluZSBUb29sYmFyXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGljb246IEtpLFxuICAgICAgbmFtZTogXCJib2xkXCIsXG4gICAgICBvbkFjdGl2YXRlOiAoKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKHRoaXMuY29tbWFuZE5hbWUpO1xuICAgICAgfSxcbiAgICAgIGlzQWN0aXZlOiAoKSA9PiBkb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZSh0aGlzLmNvbW1hbmROYW1lKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhIHNob3J0Y3V0XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IHNob3J0Y3V0KCkge1xuICAgIHJldHVybiBcIkNNRCtCXCI7XG4gIH1cbn1cbmdvLmlzSW5saW5lID0gITA7XG5nby50aXRsZSA9IFwiQm9sZFwiO1xuY2xhc3MgbW8ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbW1hbmROYW1lID0gXCJpdGFsaWNcIiwgdGhpcy5DU1MgPSB7XG4gICAgICBidXR0b246IFwiY2UtaW5saW5lLXRvb2xcIixcbiAgICAgIGJ1dHRvbkFjdGl2ZTogXCJjZS1pbmxpbmUtdG9vbC0tYWN0aXZlXCIsXG4gICAgICBidXR0b25Nb2RpZmllcjogXCJjZS1pbmxpbmUtdG9vbC0taXRhbGljXCJcbiAgICB9LCB0aGlzLm5vZGVzID0ge1xuICAgICAgYnV0dG9uOiBudWxsXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2FuaXRpemVyIFJ1bGVcbiAgICogTGVhdmUgPGk+IHRhZ3NcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgc2FuaXRpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGk6IHt9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGJ1dHRvbiBmb3IgSW5saW5lIFRvb2xiYXJcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5idXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpLCB0aGlzLm5vZGVzLmJ1dHRvbi50eXBlID0gXCJidXR0b25cIiwgdGhpcy5ub2Rlcy5idXR0b24uY2xhc3NMaXN0LmFkZCh0aGlzLkNTUy5idXR0b24sIHRoaXMuQ1NTLmJ1dHRvbk1vZGlmaWVyKSwgdGhpcy5ub2Rlcy5idXR0b24uaW5uZXJIVE1MID0gSmksIHRoaXMubm9kZXMuYnV0dG9uO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwIHJhbmdlIHdpdGggPGk+IHRhZ1xuICAgKi9cbiAgc3Vycm91bmQoKSB7XG4gICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQodGhpcy5jb21tYW5kTmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIHNlbGVjdGlvbiBhbmQgc2V0IGFjdGl2YXRlZCBzdGF0ZSB0byBidXR0b24gaWYgdGhlcmUgYXJlIDxpPiB0YWdcbiAgICovXG4gIGNoZWNrU3RhdGUoKSB7XG4gICAgY29uc3QgZSA9IGRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN0YXRlKHRoaXMuY29tbWFuZE5hbWUpO1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKHRoaXMuQ1NTLmJ1dHRvbkFjdGl2ZSwgZSksIGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhIHNob3J0Y3V0XG4gICAqL1xuICBnZXQgc2hvcnRjdXQoKSB7XG4gICAgcmV0dXJuIFwiQ01EK0lcIjtcbiAgfVxufVxubW8uaXNJbmxpbmUgPSAhMDtcbm1vLnRpdGxlID0gXCJJdGFsaWNcIjtcbmNsYXNzIGJvIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBhcGkgLSBFZGl0b3IuanMgQVBJXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGFwaTogZSB9KSB7XG4gICAgdGhpcy5jb21tYW5kTGluayA9IFwiY3JlYXRlTGlua1wiLCB0aGlzLmNvbW1hbmRVbmxpbmsgPSBcInVubGlua1wiLCB0aGlzLkVOVEVSX0tFWSA9IDEzLCB0aGlzLkNTUyA9IHtcbiAgICAgIGJ1dHRvbjogXCJjZS1pbmxpbmUtdG9vbFwiLFxuICAgICAgYnV0dG9uQWN0aXZlOiBcImNlLWlubGluZS10b29sLS1hY3RpdmVcIixcbiAgICAgIGJ1dHRvbk1vZGlmaWVyOiBcImNlLWlubGluZS10b29sLS1saW5rXCIsXG4gICAgICBidXR0b25Vbmxpbms6IFwiY2UtaW5saW5lLXRvb2wtLXVubGlua1wiLFxuICAgICAgaW5wdXQ6IFwiY2UtaW5saW5lLXRvb2wtaW5wdXRcIixcbiAgICAgIGlucHV0U2hvd2VkOiBcImNlLWlubGluZS10b29sLWlucHV0LS1zaG93ZWRcIlxuICAgIH0sIHRoaXMubm9kZXMgPSB7XG4gICAgICBidXR0b246IG51bGwsXG4gICAgICBpbnB1dDogbnVsbFxuICAgIH0sIHRoaXMuaW5wdXRPcGVuZWQgPSAhMSwgdGhpcy50b29sYmFyID0gZS50b29sYmFyLCB0aGlzLmlubGluZVRvb2xiYXIgPSBlLmlubGluZVRvb2xiYXIsIHRoaXMubm90aWZpZXIgPSBlLm5vdGlmaWVyLCB0aGlzLmkxOG4gPSBlLmkxOG4sIHRoaXMuc2VsZWN0aW9uID0gbmV3IGIoKTtcbiAgfVxuICAvKipcbiAgICogU2FuaXRpemVyIFJ1bGVcbiAgICogTGVhdmUgPGE+IHRhZ3NcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgc2FuaXRpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IHtcbiAgICAgICAgaHJlZjogITAsXG4gICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgcmVsOiBcIm5vZm9sbG93XCJcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYnV0dG9uIGZvciBJbmxpbmUgVG9vbGJhclxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLmJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiksIHRoaXMubm9kZXMuYnV0dG9uLnR5cGUgPSBcImJ1dHRvblwiLCB0aGlzLm5vZGVzLmJ1dHRvbi5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmJ1dHRvbiwgdGhpcy5DU1MuYnV0dG9uTW9kaWZpZXIpLCB0aGlzLm5vZGVzLmJ1dHRvbi5pbm5lckhUTUwgPSBDbywgdGhpcy5ub2Rlcy5idXR0b247XG4gIH1cbiAgLyoqXG4gICAqIElucHV0IGZvciB0aGUgbGlua1xuICAgKi9cbiAgcmVuZGVyQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSwgdGhpcy5ub2Rlcy5pbnB1dC5wbGFjZWhvbGRlciA9IHRoaXMuaTE4bi50KFwiQWRkIGEgbGlua1wiKSwgdGhpcy5ub2Rlcy5pbnB1dC5lbnRlcktleUhpbnQgPSBcImRvbmVcIiwgdGhpcy5ub2Rlcy5pbnB1dC5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmlucHV0KSwgdGhpcy5ub2Rlcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZSkgPT4ge1xuICAgICAgZS5rZXlDb2RlID09PSB0aGlzLkVOVEVSX0tFWSAmJiB0aGlzLmVudGVyUHJlc3NlZChlKTtcbiAgICB9KSwgdGhpcy5ub2Rlcy5pbnB1dDtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGNsaWNrcyBvbiB0aGUgSW5saW5lIFRvb2xiYXIgaWNvblxuICAgKlxuICAgKiBAcGFyYW0ge1JhbmdlfSByYW5nZSAtIHJhbmdlIHRvIHdyYXAgd2l0aCBsaW5rXG4gICAqL1xuICBzdXJyb3VuZChlKSB7XG4gICAgaWYgKGUpIHtcbiAgICAgIHRoaXMuaW5wdXRPcGVuZWQgPyAodGhpcy5zZWxlY3Rpb24ucmVzdG9yZSgpLCB0aGlzLnNlbGVjdGlvbi5yZW1vdmVGYWtlQmFja2dyb3VuZCgpKSA6ICh0aGlzLnNlbGVjdGlvbi5zZXRGYWtlQmFja2dyb3VuZCgpLCB0aGlzLnNlbGVjdGlvbi5zYXZlKCkpO1xuICAgICAgY29uc3QgdCA9IHRoaXMuc2VsZWN0aW9uLmZpbmRQYXJlbnRUYWcoXCJBXCIpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uZXhwYW5kVG9UYWcodCksIHRoaXMudW5saW5rKCksIHRoaXMuY2xvc2VBY3Rpb25zKCksIHRoaXMuY2hlY2tTdGF0ZSgpLCB0aGlzLnRvb2xiYXIuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRvZ2dsZUFjdGlvbnMoKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgc2VsZWN0aW9uIGFuZCBzZXQgYWN0aXZhdGVkIHN0YXRlIHRvIGJ1dHRvbiBpZiB0aGVyZSBhcmUgPGE+IHRhZ1xuICAgKi9cbiAgY2hlY2tTdGF0ZSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5zZWxlY3Rpb24uZmluZFBhcmVudFRhZyhcIkFcIik7XG4gICAgaWYgKGUpIHtcbiAgICAgIHRoaXMubm9kZXMuYnV0dG9uLmlubmVySFRNTCA9IG5zLCB0aGlzLm5vZGVzLmJ1dHRvbi5jbGFzc0xpc3QuYWRkKHRoaXMuQ1NTLmJ1dHRvblVubGluayksIHRoaXMubm9kZXMuYnV0dG9uLmNsYXNzTGlzdC5hZGQodGhpcy5DU1MuYnV0dG9uQWN0aXZlKSwgdGhpcy5vcGVuQWN0aW9ucygpO1xuICAgICAgY29uc3QgdCA9IGUuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICAgIHRoaXMubm9kZXMuaW5wdXQudmFsdWUgPSB0ICE9PSBcIm51bGxcIiA/IHQgOiBcIlwiLCB0aGlzLnNlbGVjdGlvbi5zYXZlKCk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLm5vZGVzLmJ1dHRvbi5pbm5lckhUTUwgPSBDbywgdGhpcy5ub2Rlcy5idXR0b24uY2xhc3NMaXN0LnJlbW92ZSh0aGlzLkNTUy5idXR0b25VbmxpbmspLCB0aGlzLm5vZGVzLmJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuQ1NTLmJ1dHRvbkFjdGl2ZSk7XG4gICAgcmV0dXJuICEhZTtcbiAgfVxuICAvKipcbiAgICogRnVuY3Rpb24gY2FsbGVkIHdpdGggSW5saW5lIFRvb2xiYXIgY2xvc2luZ1xuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5jbG9zZUFjdGlvbnMoKTtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgc2hvcnRjdXRcbiAgICovXG4gIGdldCBzaG9ydGN1dCgpIHtcbiAgICByZXR1cm4gXCJDTUQrS1wiO1xuICB9XG4gIC8qKlxuICAgKiBTaG93L2Nsb3NlIGxpbmsgaW5wdXRcbiAgICovXG4gIHRvZ2dsZUFjdGlvbnMoKSB7XG4gICAgdGhpcy5pbnB1dE9wZW5lZCA/IHRoaXMuY2xvc2VBY3Rpb25zKCExKSA6IHRoaXMub3BlbkFjdGlvbnMoITApO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5lZWRGb2N1cyAtIG9uIGxpbmsgY3JlYXRpb24gd2UgbmVlZCB0byBmb2N1cyBpbnB1dC4gT24gZWRpdGluZyAtIG5vcGUuXG4gICAqL1xuICBvcGVuQWN0aW9ucyhlID0gITEpIHtcbiAgICB0aGlzLm5vZGVzLmlucHV0LmNsYXNzTGlzdC5hZGQodGhpcy5DU1MuaW5wdXRTaG93ZWQpLCBlICYmIHRoaXMubm9kZXMuaW5wdXQuZm9jdXMoKSwgdGhpcy5pbnB1dE9wZW5lZCA9ICEwO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZSBpbnB1dFxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFyU2F2ZWRTZWxlY3Rpb24g4oCUIHdlIGRvbid0IG5lZWQgdG8gY2xlYXIgc2F2ZWQgc2VsZWN0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uIHRvZ2dsZS1jbGlja3Mgb24gdGhlIGljb24gb2Ygb3BlbmVkIFRvb2xiYXJcbiAgICovXG4gIGNsb3NlQWN0aW9ucyhlID0gITApIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb24uaXNGYWtlQmFja2dyb3VuZEVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IHQgPSBuZXcgYigpO1xuICAgICAgdC5zYXZlKCksIHRoaXMuc2VsZWN0aW9uLnJlc3RvcmUoKSwgdGhpcy5zZWxlY3Rpb24ucmVtb3ZlRmFrZUJhY2tncm91bmQoKSwgdC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMubm9kZXMuaW5wdXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLkNTUy5pbnB1dFNob3dlZCksIHRoaXMubm9kZXMuaW5wdXQudmFsdWUgPSBcIlwiLCBlICYmIHRoaXMuc2VsZWN0aW9uLmNsZWFyU2F2ZWQoKSwgdGhpcy5pbnB1dE9wZW5lZCA9ICExO1xuICB9XG4gIC8qKlxuICAgKiBFbnRlciBwcmVzc2VkIG9uIGlucHV0XG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgLSBlbnRlciBrZXlkb3duIGV2ZW50XG4gICAqL1xuICBlbnRlclByZXNzZWQoZSkge1xuICAgIGxldCB0ID0gdGhpcy5ub2Rlcy5pbnB1dC52YWx1ZSB8fCBcIlwiO1xuICAgIGlmICghdC50cmltKCkpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnJlc3RvcmUoKSwgdGhpcy51bmxpbmsoKSwgZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLmNsb3NlQWN0aW9ucygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudmFsaWRhdGVVUkwodCkpIHtcbiAgICAgIHRoaXMubm90aWZpZXIuc2hvdyh7XG4gICAgICAgIG1lc3NhZ2U6IFwiUGFzdGVkIGxpbmsgaXMgbm90IHZhbGlkLlwiLFxuICAgICAgICBzdHlsZTogXCJlcnJvclwiXG4gICAgICB9KSwgUyhcIkluY29ycmVjdCBMaW5rIHBhc3RlZFwiLCBcIndhcm5cIiwgdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHQgPSB0aGlzLnByZXBhcmVMaW5rKHQpLCB0aGlzLnNlbGVjdGlvbi5yZXN0b3JlKCksIHRoaXMuc2VsZWN0aW9uLnJlbW92ZUZha2VCYWNrZ3JvdW5kKCksIHRoaXMuaW5zZXJ0TGluayh0KSwgZS5wcmV2ZW50RGVmYXVsdCgpLCBlLnN0b3BQcm9wYWdhdGlvbigpLCBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCB0aGlzLnNlbGVjdGlvbi5jb2xsYXBzZVRvRW5kKCksIHRoaXMuaW5saW5lVG9vbGJhci5jbG9zZSgpO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlY3RzIGlmIHBhc3NlZCBzdHJpbmcgaXMgVVJMXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBzdHJpbmcgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICB2YWxpZGF0ZVVSTChlKSB7XG4gICAgcmV0dXJuICEvXFxzLy50ZXN0KGUpO1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzIGxpbmsgYmVmb3JlIGluamVjdGlvblxuICAgKiAtIHNhbml0aXplXG4gICAqIC0gYWRkIHByb3RvY29sIGZvciBsaW5rcyBsaWtlICdnb29nbGUuY29tJ1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGluayAtIHJhdyB1c2VyIGlucHV0XG4gICAqL1xuICBwcmVwYXJlTGluayhlKSB7XG4gICAgcmV0dXJuIGUgPSBlLnRyaW0oKSwgZSA9IHRoaXMuYWRkUHJvdG9jb2woZSksIGU7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCAnaHR0cCcgcHJvdG9jb2wgdG8gdGhlIGxpbmtzIGxpa2UgJ3ZjLnJ1JywgJ2dvb2dsZS5jb20nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaW5rIC0gc3RyaW5nIHRvIHByb2Nlc3NcbiAgICovXG4gIGFkZFByb3RvY29sKGUpIHtcbiAgICBpZiAoL14oXFx3Kyk6KFxcL1xcLyk/Ly50ZXN0KGUpKVxuICAgICAgcmV0dXJuIGU7XG4gICAgY29uc3QgdCA9IC9eXFwvW14vXFxzXS8udGVzdChlKSwgbyA9IGUuc3Vic3RyaW5nKDAsIDEpID09PSBcIiNcIiwgaSA9IC9eXFwvXFwvW14vXFxzXS8udGVzdChlKTtcbiAgICByZXR1cm4gIXQgJiYgIW8gJiYgIWkgJiYgKGUgPSBcImh0dHA6Ly9cIiArIGUpLCBlO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIDxhPiB0YWcgd2l0aCBcImhyZWZcIlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGluayAtIFwiaHJlZlwiIHZhbHVlXG4gICAqL1xuICBpbnNlcnRMaW5rKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5zZWxlY3Rpb24uZmluZFBhcmVudFRhZyhcIkFcIik7XG4gICAgdCAmJiB0aGlzLnNlbGVjdGlvbi5leHBhbmRUb1RhZyh0KSwgZG9jdW1lbnQuZXhlY0NvbW1hbmQodGhpcy5jb21tYW5kTGluaywgITEsIGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIDxhPiB0YWdcbiAgICovXG4gIHVubGluaygpIHtcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZCh0aGlzLmNvbW1hbmRVbmxpbmspO1xuICB9XG59XG5iby5pc0lubGluZSA9ICEwO1xuYm8udGl0bGUgPSBcIkxpbmtcIjtcbmNsYXNzIEZuIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBhcGkgLSBFZGl0b3IuanMgQVBJXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGFwaTogZSB9KSB7XG4gICAgdGhpcy5pMThuQVBJID0gZS5pMThuLCB0aGlzLmJsb2Nrc0FQSSA9IGUuYmxvY2tzLCB0aGlzLnNlbGVjdGlvbkFQSSA9IGUuc2VsZWN0aW9uLCB0aGlzLnRvb2xzQVBJID0gZS50b29scywgdGhpcy5jYXJldEFQSSA9IGUuY2FyZXQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdG9vbCdzIFVJIGNvbmZpZ1xuICAgKi9cbiAgYXN5bmMgcmVuZGVyKCkge1xuICAgIGNvbnN0IGUgPSBiLmdldCgpLCB0ID0gdGhpcy5ibG9ja3NBUEkuZ2V0QmxvY2tCeUVsZW1lbnQoZS5hbmNob3JOb2RlKTtcbiAgICBpZiAodCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IG8gPSB0aGlzLnRvb2xzQVBJLmdldEJsb2NrVG9vbHMoKSwgaSA9IGF3YWl0IFlvKHQsIG8pO1xuICAgIGlmIChpLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBzID0gaS5yZWR1Y2UoKGMsIHUpID0+IHtcbiAgICAgIHZhciBoO1xuICAgICAgcmV0dXJuIChoID0gdS50b29sYm94KSA9PSBudWxsIHx8IGguZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICBjLnB1c2goe1xuICAgICAgICAgIGljb246IHAuaWNvbixcbiAgICAgICAgICB0aXRsZTogei50KEsudG9vbE5hbWVzLCBwLnRpdGxlKSxcbiAgICAgICAgICBuYW1lOiB1Lm5hbWUsXG4gICAgICAgICAgY2xvc2VPbkFjdGl2YXRlOiAhMCxcbiAgICAgICAgICBvbkFjdGl2YXRlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnID0gYXdhaXQgdGhpcy5ibG9ja3NBUEkuY29udmVydCh0LmlkLCB1Lm5hbWUsIHAuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmNhcmV0QVBJLnNldFRvQmxvY2soZywgXCJlbmRcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pLCBjO1xuICAgIH0sIFtdKSwgciA9IGF3YWl0IHQuZ2V0QWN0aXZlVG9vbGJveEVudHJ5KCksIGEgPSByICE9PSB2b2lkIDAgPyByLmljb24gOiBHbywgbCA9ICFiZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiBhLFxuICAgICAgbmFtZTogXCJjb252ZXJ0LXRvXCIsXG4gICAgICBoaW50OiB7XG4gICAgICAgIHRpdGxlOiB0aGlzLmkxOG5BUEkudChcIkNvbnZlcnQgdG9cIilcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjoge1xuICAgICAgICBzZWFyY2hhYmxlOiBsLFxuICAgICAgICBpdGVtczogcyxcbiAgICAgICAgb25PcGVuOiAoKSA9PiB7XG4gICAgICAgICAgbCAmJiAodGhpcy5zZWxlY3Rpb25BUEkuc2V0RmFrZUJhY2tncm91bmQoKSwgdGhpcy5zZWxlY3Rpb25BUEkuc2F2ZSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DbG9zZTogKCkgPT4ge1xuICAgICAgICAgIGwgJiYgKHRoaXMuc2VsZWN0aW9uQVBJLnJlc3RvcmUoKSwgdGhpcy5zZWxlY3Rpb25BUEkucmVtb3ZlRmFrZUJhY2tncm91bmQoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5Gbi5pc0lubGluZSA9ICEwO1xuY2xhc3Mgam4ge1xuICAvKipcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBjb25zdHJ1Y3RvciBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLmRhdGEgLSBzdHViIHRvb2wgZGF0YVxuICAgKiBAcGFyYW0gb3B0aW9ucy5hcGkgLSBFZGl0b3IuanMgQVBJXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGRhdGE6IGUsIGFwaTogdCB9KSB7XG4gICAgdGhpcy5DU1MgPSB7XG4gICAgICB3cmFwcGVyOiBcImNlLXN0dWJcIixcbiAgICAgIGluZm86IFwiY2Utc3R1Yl9faW5mb1wiLFxuICAgICAgdGl0bGU6IFwiY2Utc3R1Yl9fdGl0bGVcIixcbiAgICAgIHN1YnRpdGxlOiBcImNlLXN0dWJfX3N1YnRpdGxlXCJcbiAgICB9LCB0aGlzLmFwaSA9IHQsIHRoaXMudGl0bGUgPSBlLnRpdGxlIHx8IHRoaXMuYXBpLmkxOG4udChcIkVycm9yXCIpLCB0aGlzLnN1YnRpdGxlID0gdGhpcy5hcGkuaTE4bi50KFwiVGhlIGJsb2NrIGNhbiBub3QgYmUgZGlzcGxheWVkIGNvcnJlY3RseS5cIiksIHRoaXMuc2F2ZWREYXRhID0gZS5zYXZlZERhdGEsIHRoaXMud3JhcHBlciA9IHRoaXMubWFrZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHN0dWIgaG9sZGVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gb3JpZ2luYWwgVG9vbCBkYXRhXG4gICAqXG4gICAqIEByZXR1cm5zIHtCbG9ja1Rvb2xEYXRhfVxuICAgKi9cbiAgc2F2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zYXZlZERhdGE7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBUb29sIGh0bWwgbWFya3VwXG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIG1ha2UoKSB7XG4gICAgY29uc3QgZSA9IGQubWFrZShcImRpdlwiLCB0aGlzLkNTUy53cmFwcGVyKSwgdCA9IGlzLCBvID0gZC5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLmluZm8pLCBpID0gZC5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLnRpdGxlLCB7XG4gICAgICB0ZXh0Q29udGVudDogdGhpcy50aXRsZVxuICAgIH0pLCBzID0gZC5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLnN1YnRpdGxlLCB7XG4gICAgICB0ZXh0Q29udGVudDogdGhpcy5zdWJ0aXRsZVxuICAgIH0pO1xuICAgIHJldHVybiBlLmlubmVySFRNTCA9IHQsIG8uYXBwZW5kQ2hpbGQoaSksIG8uYXBwZW5kQ2hpbGQocyksIGUuYXBwZW5kQ2hpbGQobyksIGU7XG4gIH1cbn1cbmpuLmlzUmVhZE9ubHlTdXBwb3J0ZWQgPSAhMDtcbmNsYXNzIGthIGV4dGVuZHMgVHQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLnR5cGUgPSBhZS5JbmxpbmU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGl0bGUgZm9yIElubGluZSBUb29sIGlmIHNwZWNpZmllZCBieSB1c2VyXG4gICAqL1xuICBnZXQgdGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0YWJsZVtXZS5UaXRsZV07XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgbmV3IElubGluZVRvb2wgaW5zdGFuY2UgZnJvbSBjb25zdHJ1Y3RhYmxlXG4gICAqL1xuICBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdGFibGUoe1xuICAgICAgYXBpOiB0aGlzLmFwaSxcbiAgICAgIGNvbmZpZzogdGhpcy5zZXR0aW5nc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvd3MgaW5saW5lIHRvb2wgdG8gYmUgYXZhaWxhYmxlIGluIHJlYWQtb25seSBtb2RlXG4gICAqIENhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgYnkgY29tbWVudHMgdG9vbFxuICAgKi9cbiAgZ2V0IGlzUmVhZE9ubHlTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0YWJsZVtXZS5Jc1JlYWRPbmx5U3VwcG9ydGVkXSA/PyAhMTtcbiAgfVxufVxuY2xhc3MgeWEgZXh0ZW5kcyBUdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudHlwZSA9IGFlLlR1bmU7XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgbmV3IEJsb2NrVHVuZSBpbnN0YW5jZSBmcm9tIGNvbnN0cnVjdGFibGVcbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBUdW5lIGRhdGFcbiAgICogQHBhcmFtIGJsb2NrIC0gQmxvY2sgQVBJIG9iamVjdFxuICAgKi9cbiAgY3JlYXRlKGUsIHQpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0YWJsZSh7XG4gICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgY29uZmlnOiB0aGlzLnNldHRpbmdzLFxuICAgICAgYmxvY2s6IHQsXG4gICAgICBkYXRhOiBlXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIGogZXh0ZW5kcyBNYXAge1xuICAvKipcbiAgICogUmV0dXJucyBCbG9jayBUb29scyBjb2xsZWN0aW9uXG4gICAqL1xuICBnZXQgYmxvY2tUb29scygpIHtcbiAgICBjb25zdCBlID0gQXJyYXkuZnJvbSh0aGlzLmVudHJpZXMoKSkuZmlsdGVyKChbLCB0XSkgPT4gdC5pc0Jsb2NrKCkpO1xuICAgIHJldHVybiBuZXcgaihlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBJbmxpbmUgVG9vbHMgY29sbGVjdGlvblxuICAgKi9cbiAgZ2V0IGlubGluZVRvb2xzKCkge1xuICAgIGNvbnN0IGUgPSBBcnJheS5mcm9tKHRoaXMuZW50cmllcygpKS5maWx0ZXIoKFssIHRdKSA9PiB0LmlzSW5saW5lKCkpO1xuICAgIHJldHVybiBuZXcgaihlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBCbG9jayBUdW5lcyBjb2xsZWN0aW9uXG4gICAqL1xuICBnZXQgYmxvY2tUdW5lcygpIHtcbiAgICBjb25zdCBlID0gQXJyYXkuZnJvbSh0aGlzLmVudHJpZXMoKSkuZmlsdGVyKChbLCB0XSkgPT4gdC5pc1R1bmUoKSk7XG4gICAgcmV0dXJuIG5ldyBqKGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGludGVybmFsIFRvb2xzIGNvbGxlY3Rpb25cbiAgICovXG4gIGdldCBpbnRlcm5hbFRvb2xzKCkge1xuICAgIGNvbnN0IGUgPSBBcnJheS5mcm9tKHRoaXMuZW50cmllcygpKS5maWx0ZXIoKFssIHRdKSA9PiB0LmlzSW50ZXJuYWwpO1xuICAgIHJldHVybiBuZXcgaihlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBUb29scyBjb2xsZWN0aW9uIHByb3ZpZGVkIGJ5IHVzZXJcbiAgICovXG4gIGdldCBleHRlcm5hbFRvb2xzKCkge1xuICAgIGNvbnN0IGUgPSBBcnJheS5mcm9tKHRoaXMuZW50cmllcygpKS5maWx0ZXIoKFssIHRdKSA9PiAhdC5pc0ludGVybmFsKTtcbiAgICByZXR1cm4gbmV3IGooZSk7XG4gIH1cbn1cbnZhciB3YSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgRWEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCBIbiA9IChuLCBlLCB0LCBvKSA9PiB7XG4gIGZvciAodmFyIGkgPSBvID4gMSA/IHZvaWQgMCA6IG8gPyBFYShlLCB0KSA6IGUsIHMgPSBuLmxlbmd0aCAtIDEsIHI7IHMgPj0gMDsgcy0tKVxuICAgIChyID0gbltzXSkgJiYgKGkgPSAobyA/IHIoZSwgdCwgaSkgOiByKGkpKSB8fCBpKTtcbiAgcmV0dXJuIG8gJiYgaSAmJiB3YShlLCB0LCBpKSwgaTtcbn07XG5jbGFzcyB2byBleHRlbmRzIFR0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy50eXBlID0gYWUuQmxvY2ssIHRoaXMuaW5saW5lVG9vbHMgPSBuZXcgaigpLCB0aGlzLnR1bmVzID0gbmV3IGooKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBuZXcgVG9vbCBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFRvb2wgZGF0YVxuICAgKiBAcGFyYW0gYmxvY2sgLSBCbG9ja0FQSSBmb3IgY3VycmVudCBCbG9ja1xuICAgKiBAcGFyYW0gcmVhZE9ubHkgLSBUcnVlIGlmIEVkaXRvciBpcyBpbiByZWFkLW9ubHkgbW9kZVxuICAgKi9cbiAgY3JlYXRlKGUsIHQsIG8pIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0YWJsZSh7XG4gICAgICBkYXRhOiBlLFxuICAgICAgYmxvY2s6IHQsXG4gICAgICByZWFkT25seTogbyxcbiAgICAgIGFwaTogdGhpcy5hcGksXG4gICAgICBjb25maWc6IHRoaXMuc2V0dGluZ3NcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHJlYWQtb25seSBtb2RlIGlzIHN1cHBvcnRlZCBieSBUb29sXG4gICAqL1xuICBnZXQgaXNSZWFkT25seVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RhYmxlW3BlLklzUmVhZE9ubHlTdXBwb3J0ZWRdID09PSAhMDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIFRvb2wgc3VwcG9ydHMgbGluZWJyZWFrc1xuICAgKi9cbiAgZ2V0IGlzTGluZUJyZWFrc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0YWJsZVtwZS5Jc0VuYWJsZWRMaW5lQnJlYWtzXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBUb29sIHRvb2xib3ggY29uZmlndXJhdGlvbiAoaW50ZXJuYWwgb3IgdXNlci1zcGVjaWZpZWQpLlxuICAgKlxuICAgKiBNZXJnZXMgaW50ZXJuYWwgYW5kIHVzZXItZGVmaW5lZCB0b29sYm94IGNvbmZpZ3MgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBydWxlczpcbiAgICpcbiAgICogLSBJZiBib3RoIGludGVybmFsIGFuZCB1c2VyLWRlZmluZWQgdG9vbGJveCBjb25maWdzIGFyZSBhcnJheXMgdGhlaXIgaXRlbXMgYXJlIG1lcmdlZC5cbiAgICogTGVuZ3RoIG9mIHRoZSBzZWNvbmQgb25lIGlzIGtlcHQuXG4gICAqXG4gICAqIC0gSWYgYm90aCBhcmUgb2JqZWN0cyB0aGVpciBwcm9wZXJ0aWVzIGFyZSBtZXJnZWQuXG4gICAqXG4gICAqIC0gSWYgb25lIGlzIGFuIG9iamVjdCBhbmQgYW5vdGhlciBpcyBhbiBhcnJheSB0aGFuIGludGVybmFsIGNvbmZpZyBpcyByZXBsYWNlZCB3aXRoIHVzZXItZGVmaW5lZFxuICAgKiBjb25maWcuIFRoaXMgaXMgbWFkZSB0byBhbGxvdyB1c2VyIHRvIG92ZXJyaWRlIGRlZmF1bHQgdG9vbCdzIHRvb2xib3ggcmVwcmVzZW50YXRpb24gKHNpbmdsZS9tdWx0aXBsZSBlbnRyaWVzKVxuICAgKi9cbiAgZ2V0IHRvb2xib3goKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuY29uc3RydWN0YWJsZVtwZS5Ub29sYm94XSwgdCA9IHRoaXMuY29uZmlnW1BlLlRvb2xib3hdO1xuICAgIGlmICghVihlKSAmJiB0ICE9PSAhMSlcbiAgICAgIHJldHVybiB0ID8gQXJyYXkuaXNBcnJheShlKSA/IEFycmF5LmlzQXJyYXkodCkgPyB0Lm1hcCgobywgaSkgPT4ge1xuICAgICAgICBjb25zdCBzID0gZVtpXTtcbiAgICAgICAgcmV0dXJuIHMgPyB7XG4gICAgICAgICAgLi4ucyxcbiAgICAgICAgICAuLi5vXG4gICAgICAgIH0gOiBvO1xuICAgICAgfSkgOiBbdF0gOiBBcnJheS5pc0FycmF5KHQpID8gdCA6IFtcbiAgICAgICAge1xuICAgICAgICAgIC4uLmUsXG4gICAgICAgICAgLi4udFxuICAgICAgICB9XG4gICAgICBdIDogQXJyYXkuaXNBcnJheShlKSA/IGUgOiBbZV07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgVG9vbCBjb252ZXJzaW9uIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGdldCBjb252ZXJzaW9uQ29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdGFibGVbcGUuQ29udmVyc2lvbkNvbmZpZ107XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgZW5hYmxlZCBpbmxpbmUgdG9vbHMgZm9yIFRvb2xcbiAgICovXG4gIGdldCBlbmFibGVkSW5saW5lVG9vbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnW1BlLkVuYWJsZWRJbmxpbmVUb29sc10gfHwgITE7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgZW5hYmxlZCB0dW5lcyBmb3IgVG9vbFxuICAgKi9cbiAgZ2V0IGVuYWJsZWRCbG9ja1R1bmVzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZ1tQZS5FbmFibGVkQmxvY2tUdW5lc107XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgVG9vbCBwYXN0ZSBjb25maWd1cmF0aW9uXG4gICAqL1xuICBnZXQgcGFzdGVDb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0YWJsZVtwZS5QYXN0ZUNvbmZpZ10gPz8ge307XG4gIH1cbiAgZ2V0IHNhbml0aXplQ29uZmlnKCkge1xuICAgIGNvbnN0IGUgPSBzdXBlci5zYW5pdGl6ZUNvbmZpZywgdCA9IHRoaXMuYmFzZVNhbml0aXplQ29uZmlnO1xuICAgIGlmIChWKGUpKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgY29uc3QgbyA9IHt9O1xuICAgIGZvciAoY29uc3QgaSBpbiBlKVxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCBpKSkge1xuICAgICAgICBjb25zdCBzID0gZVtpXTtcbiAgICAgICAgRChzKSA/IG9baV0gPSBPYmplY3QuYXNzaWduKHt9LCB0LCBzKSA6IG9baV0gPSBzO1xuICAgICAgfVxuICAgIHJldHVybiBvO1xuICB9XG4gIGdldCBiYXNlU2FuaXRpemVDb25maWcoKSB7XG4gICAgY29uc3QgZSA9IHt9O1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuaW5saW5lVG9vbHMudmFsdWVzKCkpLmZvckVhY2goKHQpID0+IE9iamVjdC5hc3NpZ24oZSwgdC5zYW5pdGl6ZUNvbmZpZykpLCBBcnJheS5mcm9tKHRoaXMudHVuZXMudmFsdWVzKCkpLmZvckVhY2goKHQpID0+IE9iamVjdC5hc3NpZ24oZSwgdC5zYW5pdGl6ZUNvbmZpZykpLCBlO1xuICB9XG59XG5IbihbXG4gIG1lXG5dLCB2by5wcm90b3R5cGUsIFwic2FuaXRpemVDb25maWdcIiwgMSk7XG5IbihbXG4gIG1lXG5dLCB2by5wcm90b3R5cGUsIFwiYmFzZVNhbml0aXplQ29uZmlnXCIsIDEpO1xuY2xhc3MgeGEge1xuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSBjb25maWcgLSB0b29scyBjb25maWdcbiAgICogQHBhcmFtIGVkaXRvckNvbmZpZyAtIEVkaXRvckpTIGNvbmZpZ1xuICAgKiBAcGFyYW0gYXBpIC0gRWRpdG9ySlMgQVBJIG1vZHVsZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZSwgdCwgbykge1xuICAgIHRoaXMuYXBpID0gbywgdGhpcy5jb25maWcgPSBlLCB0aGlzLmVkaXRvckNvbmZpZyA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgVG9vbCBvYmplY3QgYmFzZWQgb24gaXQncyB0eXBlXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gdG9vbCBuYW1lXG4gICAqL1xuICBnZXQoZSkge1xuICAgIGNvbnN0IHsgY2xhc3M6IHQsIGlzSW50ZXJuYWw6IG8gPSAhMSwgLi4uaSB9ID0gdGhpcy5jb25maWdbZV0sIHMgPSB0aGlzLmdldENvbnN0cnVjdG9yKHQpLCByID0gdFttdC5Jc1R1bmVdO1xuICAgIHJldHVybiBuZXcgcyh7XG4gICAgICBuYW1lOiBlLFxuICAgICAgY29uc3RydWN0YWJsZTogdCxcbiAgICAgIGNvbmZpZzogaSxcbiAgICAgIGFwaTogdGhpcy5hcGkuZ2V0TWV0aG9kc0ZvclRvb2woZSwgciksXG4gICAgICBpc0RlZmF1bHQ6IGUgPT09IHRoaXMuZWRpdG9yQ29uZmlnLmRlZmF1bHRCbG9jayxcbiAgICAgIGRlZmF1bHRQbGFjZWhvbGRlcjogdGhpcy5lZGl0b3JDb25maWcucGxhY2Vob2xkZXIsXG4gICAgICBpc0ludGVybmFsOiBvXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgYXBwcm9wcmlhdGUgVG9vbCBvYmplY3QgY29uc3RydWN0b3IgZm9yIFRvb2wgY29uc3RydWN0YWJsZVxuICAgKlxuICAgKiBAcGFyYW0gY29uc3RydWN0YWJsZSAtIFRvb2xzIGNvbnN0cnVjdGFibGVcbiAgICovXG4gIGdldENvbnN0cnVjdG9yKGUpIHtcbiAgICBzd2l0Y2ggKCEwKSB7XG4gICAgICBjYXNlIGVbV2UuSXNJbmxpbmVdOlxuICAgICAgICByZXR1cm4ga2E7XG4gICAgICBjYXNlIGVbbXQuSXNUdW5lXTpcbiAgICAgICAgcmV0dXJuIHlhO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHZvO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgJG4ge1xuICAvKipcbiAgICogTW92ZURvd25UdW5lIGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7QVBJfSBhcGkg4oCUIEVkaXRvcidzIEFQSVxuICAgKi9cbiAgY29uc3RydWN0b3IoeyBhcGk6IGUgfSkge1xuICAgIHRoaXMuQ1NTID0ge1xuICAgICAgYW5pbWF0aW9uOiBcIndvYmJsZVwiXG4gICAgfSwgdGhpcy5hcGkgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBUdW5lJ3MgYXBwZWFyYW5jZSBpbiBibG9jayBzZXR0aW5ncyBtZW51XG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGljb246IFhpLFxuICAgICAgdGl0bGU6IHRoaXMuYXBpLmkxOG4udChcIk1vdmUgZG93blwiKSxcbiAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHRoaXMuaGFuZGxlQ2xpY2soKSxcbiAgICAgIG5hbWU6IFwibW92ZS1kb3duXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgY2xpY2tzIG9uICdtb3ZlIGRvd24nIGJ1dHRvblxuICAgKi9cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuYXBpLmJsb2Nrcy5nZXRDdXJyZW50QmxvY2tJbmRleCgpLCB0ID0gdGhpcy5hcGkuYmxvY2tzLmdldEJsb2NrQnlJbmRleChlICsgMSk7XG4gICAgaWYgKCF0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIG1vdmUgQmxvY2sgZG93biBzaW5jZSBpdCBpcyBhbHJlYWR5IHRoZSBsYXN0XCIpO1xuICAgIGNvbnN0IG8gPSB0LmhvbGRlciwgaSA9IG8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHMgPSBNYXRoLmFicyh3aW5kb3cuaW5uZXJIZWlnaHQgLSBvLm9mZnNldEhlaWdodCk7XG4gICAgaS50b3AgPCB3aW5kb3cuaW5uZXJIZWlnaHQgJiYgKHMgPSB3aW5kb3cuc2Nyb2xsWSArIG8ub2Zmc2V0SGVpZ2h0KSwgd2luZG93LnNjcm9sbFRvKDAsIHMpLCB0aGlzLmFwaS5ibG9ja3MubW92ZShlICsgMSksIHRoaXMuYXBpLnRvb2xiYXIudG9nZ2xlQmxvY2tTZXR0aW5ncyghMCk7XG4gIH1cbn1cbiRuLmlzVHVuZSA9ICEwO1xuY2xhc3Mgem4ge1xuICAvKipcbiAgICogRGVsZXRlVHVuZSBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge0FQSX0gYXBpIC0gRWRpdG9yJ3MgQVBJXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGFwaTogZSB9KSB7XG4gICAgdGhpcy5hcGkgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBUdW5lJ3MgYXBwZWFyYW5jZSBpbiBibG9jayBzZXR0aW5ncyBtZW51XG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGljb246IEdpLFxuICAgICAgdGl0bGU6IHRoaXMuYXBpLmkxOG4udChcIkRlbGV0ZVwiKSxcbiAgICAgIG5hbWU6IFwiZGVsZXRlXCIsXG4gICAgICBjb25maXJtYXRpb246IHtcbiAgICAgICAgdGl0bGU6IHRoaXMuYXBpLmkxOG4udChcIkNsaWNrIHRvIGRlbGV0ZVwiKSxcbiAgICAgICAgb25BY3RpdmF0ZTogKCkgPT4gdGhpcy5oYW5kbGVDbGljaygpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGJsb2NrIGNvbmRpdGlvbnMgcGFzc2VkXG4gICAqL1xuICBoYW5kbGVDbGljaygpIHtcbiAgICB0aGlzLmFwaS5ibG9ja3MuZGVsZXRlKCk7XG4gIH1cbn1cbnpuLmlzVHVuZSA9ICEwO1xuY2xhc3MgVW4ge1xuICAvKipcbiAgICogTW92ZVVwVHVuZSBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge0FQSX0gYXBpIC0gRWRpdG9yJ3MgQVBJXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGFwaTogZSB9KSB7XG4gICAgdGhpcy5DU1MgPSB7XG4gICAgICBhbmltYXRpb246IFwid29iYmxlXCJcbiAgICB9LCB0aGlzLmFwaSA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIFR1bmUncyBhcHBlYXJhbmNlIGluIGJsb2NrIHNldHRpbmdzIG1lbnVcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWNvbjogWmksXG4gICAgICB0aXRsZTogdGhpcy5hcGkuaTE4bi50KFwiTW92ZSB1cFwiKSxcbiAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHRoaXMuaGFuZGxlQ2xpY2soKSxcbiAgICAgIG5hbWU6IFwibW92ZS11cFwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTW92ZSBjdXJyZW50IGJsb2NrIHVwXG4gICAqL1xuICBoYW5kbGVDbGljaygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5hcGkuYmxvY2tzLmdldEN1cnJlbnRCbG9ja0luZGV4KCksIHQgPSB0aGlzLmFwaS5ibG9ja3MuZ2V0QmxvY2tCeUluZGV4KGUpLCBvID0gdGhpcy5hcGkuYmxvY2tzLmdldEJsb2NrQnlJbmRleChlIC0gMSk7XG4gICAgaWYgKGUgPT09IDAgfHwgIXQgfHwgIW8pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gbW92ZSBCbG9jayB1cCBzaW5jZSBpdCBpcyBhbHJlYWR5IHRoZSBmaXJzdFwiKTtcbiAgICBjb25zdCBpID0gdC5ob2xkZXIsIHMgPSBvLmhvbGRlciwgciA9IGkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGEgPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBsO1xuICAgIGEudG9wID4gMCA/IGwgPSBNYXRoLmFicyhyLnRvcCkgLSBNYXRoLmFicyhhLnRvcCkgOiBsID0gTWF0aC5hYnMoci50b3ApICsgYS5oZWlnaHQsIHdpbmRvdy5zY3JvbGxCeSgwLCAtMSAqIGwpLCB0aGlzLmFwaS5ibG9ja3MubW92ZShlIC0gMSksIHRoaXMuYXBpLnRvb2xiYXIudG9nZ2xlQmxvY2tTZXR0aW5ncyghMCk7XG4gIH1cbn1cblVuLmlzVHVuZSA9ICEwO1xudmFyIEJhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBDYSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIFRhID0gKG4sIGUsIHQsIG8pID0+IHtcbiAgZm9yICh2YXIgaSA9IG8gPiAxID8gdm9pZCAwIDogbyA/IENhKGUsIHQpIDogZSwgcyA9IG4ubGVuZ3RoIC0gMSwgcjsgcyA+PSAwOyBzLS0pXG4gICAgKHIgPSBuW3NdKSAmJiAoaSA9IChvID8gcihlLCB0LCBpKSA6IHIoaSkpIHx8IGkpO1xuICByZXR1cm4gbyAmJiBpICYmIEJhKGUsIHQsIGkpLCBpO1xufTtcbmNsYXNzIFduIGV4dGVuZHMgRSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuc3R1YlRvb2wgPSBcInN0dWJcIiwgdGhpcy50b29sc0F2YWlsYWJsZSA9IG5ldyBqKCksIHRoaXMudG9vbHNVbmF2YWlsYWJsZSA9IG5ldyBqKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYXZhaWxhYmxlIFRvb2xzXG4gICAqL1xuICBnZXQgYXZhaWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xzQXZhaWxhYmxlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHVuYXZhaWxhYmxlIFRvb2xzXG4gICAqL1xuICBnZXQgdW5hdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9vbHNVbmF2YWlsYWJsZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIFRvb2xzIGZvciB0aGUgSW5saW5lIFRvb2xiYXJcbiAgICovXG4gIGdldCBpbmxpbmVUb29scygpIHtcbiAgICByZXR1cm4gdGhpcy5hdmFpbGFibGUuaW5saW5lVG9vbHM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBlZGl0b3IgYmxvY2sgdG9vbHNcbiAgICovXG4gIGdldCBibG9ja1Rvb2xzKCkge1xuICAgIHJldHVybiB0aGlzLmF2YWlsYWJsZS5ibG9ja1Rvb2xzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYXZhaWxhYmxlIEJsb2NrIFR1bmVzXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IC0gb2JqZWN0IG9mIElubGluZSBUb29sJ3MgY2xhc3Nlc1xuICAgKi9cbiAgZ2V0IGJsb2NrVHVuZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXZhaWxhYmxlLmJsb2NrVHVuZXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgZGVmYXVsdCBUb29sIG9iamVjdFxuICAgKi9cbiAgZ2V0IGRlZmF1bHRUb29sKCkge1xuICAgIHJldHVybiB0aGlzLmJsb2NrVG9vbHMuZ2V0KHRoaXMuY29uZmlnLmRlZmF1bHRCbG9jayk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgaW50ZXJuYWwgdG9vbHNcbiAgICovXG4gIGdldCBpbnRlcm5hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5hdmFpbGFibGUuaW50ZXJuYWxUb29scztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBpbnN0YW5jZXMgdmlhIHBhc3NlZCBvciBkZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBhc3luYyBwcmVwYXJlKCkge1xuICAgIGlmICh0aGlzLnZhbGlkYXRlVG9vbHMoKSwgdGhpcy5jb25maWcudG9vbHMgPSB1dCh7fSwgdGhpcy5pbnRlcm5hbFRvb2xzLCB0aGlzLmNvbmZpZy50b29scyksICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb25maWcsIFwidG9vbHNcIikgfHwgT2JqZWN0LmtleXModGhpcy5jb25maWcudG9vbHMpLmxlbmd0aCA9PT0gMClcbiAgICAgIHRocm93IEVycm9yKFwiQ2FuJ3Qgc3RhcnQgd2l0aG91dCB0b29sc1wiKTtcbiAgICBjb25zdCBlID0gdGhpcy5wcmVwYXJlQ29uZmlnKCk7XG4gICAgdGhpcy5mYWN0b3J5ID0gbmV3IHhhKGUsIHRoaXMuY29uZmlnLCB0aGlzLkVkaXRvci5BUEkpO1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldExpc3RPZlByZXBhcmVGdW5jdGlvbnMoZSk7XG4gICAgaWYgKHQubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGF3YWl0IFFuKHQsIChvKSA9PiB7XG4gICAgICB0aGlzLnRvb2xQcmVwYXJlTWV0aG9kU3VjY2VzcyhvKTtcbiAgICB9LCAobykgPT4ge1xuICAgICAgdGhpcy50b29sUHJlcGFyZU1ldGhvZEZhbGxiYWNrKG8pO1xuICAgIH0pLCB0aGlzLnByZXBhcmVCbG9ja1Rvb2xzKCk7XG4gIH1cbiAgZ2V0QWxsSW5saW5lVG9vbHNTYW5pdGl6ZUNvbmZpZygpIHtcbiAgICBjb25zdCBlID0ge307XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5pbmxpbmVUb29scy52YWx1ZXMoKSkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgT2JqZWN0LmFzc2lnbihlLCB0LnNhbml0aXplQ29uZmlnKTtcbiAgICB9KSwgZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbHMgZWFjaCBUb29sIHJlc2V0IG1ldGhvZCB0byBjbGVhbiB1cCBhbnl0aGluZyBzZXQgYnkgVG9vbFxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBPYmplY3QudmFsdWVzKHRoaXMuYXZhaWxhYmxlKS5mb3JFYWNoKGFzeW5jIChlKSA9PiB7XG4gICAgICBBKGUucmVzZXQpICYmIGF3YWl0IGUucmVzZXQoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBpbnRlcm5hbCB0b29sc1xuICAgKiBJbmNsdWRlcyBCb2xkLCBJdGFsaWMsIExpbmsgYW5kIFBhcmFncmFwaFxuICAgKi9cbiAgZ2V0IGludGVybmFsVG9vbHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnZlcnRUbzoge1xuICAgICAgICBjbGFzczogRm4sXG4gICAgICAgIGlzSW50ZXJuYWw6ICEwXG4gICAgICB9LFxuICAgICAgbGluazoge1xuICAgICAgICBjbGFzczogYm8sXG4gICAgICAgIGlzSW50ZXJuYWw6ICEwXG4gICAgICB9LFxuICAgICAgYm9sZDoge1xuICAgICAgICBjbGFzczogZ28sXG4gICAgICAgIGlzSW50ZXJuYWw6ICEwXG4gICAgICB9LFxuICAgICAgaXRhbGljOiB7XG4gICAgICAgIGNsYXNzOiBtbyxcbiAgICAgICAgaXNJbnRlcm5hbDogITBcbiAgICAgIH0sXG4gICAgICBwYXJhZ3JhcGg6IHtcbiAgICAgICAgY2xhc3M6IGZvLFxuICAgICAgICBpbmxpbmVUb29sYmFyOiAhMCxcbiAgICAgICAgaXNJbnRlcm5hbDogITBcbiAgICAgIH0sXG4gICAgICBzdHViOiB7XG4gICAgICAgIGNsYXNzOiBqbixcbiAgICAgICAgaXNJbnRlcm5hbDogITBcbiAgICAgIH0sXG4gICAgICBtb3ZlVXA6IHtcbiAgICAgICAgY2xhc3M6IFVuLFxuICAgICAgICBpc0ludGVybmFsOiAhMFxuICAgICAgfSxcbiAgICAgIGRlbGV0ZToge1xuICAgICAgICBjbGFzczogem4sXG4gICAgICAgIGlzSW50ZXJuYWw6ICEwXG4gICAgICB9LFxuICAgICAgbW92ZURvd246IHtcbiAgICAgICAgY2xhc3M6ICRuLFxuICAgICAgICBpc0ludGVybmFsOiAhMFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFRvb2wgcHJlcGFyZSBtZXRob2Qgc3VjY2VzcyBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIGFwcGVuZCB0b29sIHRvIGF2YWlsYWJsZSBsaXN0XG4gICAqL1xuICB0b29sUHJlcGFyZU1ldGhvZFN1Y2Nlc3MoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmZhY3RvcnkuZ2V0KGUudG9vbE5hbWUpO1xuICAgIGlmICh0LmlzSW5saW5lKCkpIHtcbiAgICAgIGNvbnN0IGkgPSBbXCJyZW5kZXJcIl0uZmlsdGVyKChzKSA9PiAhdC5jcmVhdGUoKVtzXSk7XG4gICAgICBpZiAoaS5sZW5ndGgpIHtcbiAgICAgICAgUyhcbiAgICAgICAgICBgSW5jb3JyZWN0IElubGluZSBUb29sOiAke3QubmFtZX0uIFNvbWUgb2YgcmVxdWlyZWQgbWV0aG9kcyBpcyBub3QgaW1wbGVtZW50ZWQgJW9gLFxuICAgICAgICAgIFwid2FyblwiLFxuICAgICAgICAgIGlcbiAgICAgICAgKSwgdGhpcy50b29sc1VuYXZhaWxhYmxlLnNldCh0Lm5hbWUsIHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudG9vbHNBdmFpbGFibGUuc2V0KHQubmFtZSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFRvb2wgcHJlcGFyZSBtZXRob2QgZmFpbCBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIGFwcGVuZCB0b29sIHRvIHVuYXZhaWxhYmxlIGxpc3RcbiAgICovXG4gIHRvb2xQcmVwYXJlTWV0aG9kRmFsbGJhY2soZSkge1xuICAgIHRoaXMudG9vbHNVbmF2YWlsYWJsZS5zZXQoZS50b29sTmFtZSwgdGhpcy5mYWN0b3J5LmdldChlLnRvb2xOYW1lKSk7XG4gIH1cbiAgLyoqXG4gICAqIEJpbmRzIHByZXBhcmUgZnVuY3Rpb24gb2YgcGx1Z2lucyB3aXRoIHVzZXIgb3IgZGVmYXVsdCBjb25maWdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSBsaXN0IG9mIGZ1bmN0aW9ucyB0aGF0IG5lZWRzIHRvIGJlIGZpcmVkIHNlcXVlbnRpYWxseVxuICAgKiBAcGFyYW0gY29uZmlnIC0gdG9vbHMgY29uZmlnXG4gICAqL1xuICBnZXRMaXN0T2ZQcmVwYXJlRnVuY3Rpb25zKGUpIHtcbiAgICBjb25zdCB0ID0gW107XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKFtvLCBpXSkgPT4ge1xuICAgICAgdC5wdXNoKHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgICAgICBmdW5jdGlvbjogQShpLmNsYXNzLnByZXBhcmUpID8gaS5jbGFzcy5wcmVwYXJlIDogKCkgPT4ge1xuICAgICAgICB9LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdG9vbE5hbWU6IG8sXG4gICAgICAgICAgY29uZmlnOiBpLmNvbmZpZ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSwgdDtcbiAgfVxuICAvKipcbiAgICogQXNzaWduIGVuYWJsZWQgSW5saW5lIFRvb2xzIGFuZCBCbG9jayBUdW5lcyBmb3IgQmxvY2sgVG9vbFxuICAgKi9cbiAgcHJlcGFyZUJsb2NrVG9vbHMoKSB7XG4gICAgQXJyYXkuZnJvbSh0aGlzLmJsb2NrVG9vbHMudmFsdWVzKCkpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIHRoaXMuYXNzaWduSW5saW5lVG9vbHNUb0Jsb2NrVG9vbChlKSwgdGhpcy5hc3NpZ25CbG9ja1R1bmVzVG9CbG9ja1Rvb2woZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFzc2lnbiBlbmFibGVkIElubGluZSBUb29scyBmb3IgQmxvY2sgVG9vbFxuICAgKlxuICAgKiBAcGFyYW0gdG9vbCAtIEJsb2NrIFRvb2xcbiAgICovXG4gIGFzc2lnbklubGluZVRvb2xzVG9CbG9ja1Rvb2woZSkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5pbmxpbmVUb29sYmFyICE9PSAhMSkge1xuICAgICAgaWYgKGUuZW5hYmxlZElubGluZVRvb2xzID09PSAhMCkge1xuICAgICAgICBlLmlubGluZVRvb2xzID0gbmV3IGooXG4gICAgICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLmNvbmZpZy5pbmxpbmVUb29sYmFyKSA/IHRoaXMuY29uZmlnLmlubGluZVRvb2xiYXIubWFwKCh0KSA9PiBbdCwgdGhpcy5pbmxpbmVUb29scy5nZXQodCldKSA6IEFycmF5LmZyb20odGhpcy5pbmxpbmVUb29scy5lbnRyaWVzKCkpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIEFycmF5LmlzQXJyYXkoZS5lbmFibGVkSW5saW5lVG9vbHMpICYmIChlLmlubGluZVRvb2xzID0gbmV3IGooXG4gICAgICAgIC8qKiBQcmVwZW5kIENvbnZlcnRUbyBJbmxpbmUgVG9vbCAqL1xuICAgICAgICBbXCJjb252ZXJ0VG9cIiwgLi4uZS5lbmFibGVkSW5saW5lVG9vbHNdLm1hcCgodCkgPT4gW3QsIHRoaXMuaW5saW5lVG9vbHMuZ2V0KHQpXSlcbiAgICAgICkpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQXNzaWduIGVuYWJsZWQgQmxvY2sgVHVuZXMgZm9yIEJsb2NrIFRvb2xcbiAgICpcbiAgICogQHBhcmFtIHRvb2wg4oCUIEJsb2NrIFRvb2xcbiAgICovXG4gIGFzc2lnbkJsb2NrVHVuZXNUb0Jsb2NrVG9vbChlKSB7XG4gICAgaWYgKGUuZW5hYmxlZEJsb2NrVHVuZXMgIT09ICExKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlLmVuYWJsZWRCbG9ja1R1bmVzKSkge1xuICAgICAgICBjb25zdCB0ID0gbmV3IGooXG4gICAgICAgICAgZS5lbmFibGVkQmxvY2tUdW5lcy5tYXAoKG8pID0+IFtvLCB0aGlzLmJsb2NrVHVuZXMuZ2V0KG8pXSlcbiAgICAgICAgKTtcbiAgICAgICAgZS50dW5lcyA9IG5ldyBqKFsuLi50LCAuLi50aGlzLmJsb2NrVHVuZXMuaW50ZXJuYWxUb29sc10pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmNvbmZpZy50dW5lcykpIHtcbiAgICAgICAgY29uc3QgdCA9IG5ldyBqKFxuICAgICAgICAgIHRoaXMuY29uZmlnLnR1bmVzLm1hcCgobykgPT4gW28sIHRoaXMuYmxvY2tUdW5lcy5nZXQobyldKVxuICAgICAgICApO1xuICAgICAgICBlLnR1bmVzID0gbmV3IGooWy4uLnQsIC4uLnRoaXMuYmxvY2tUdW5lcy5pbnRlcm5hbFRvb2xzXSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGUudHVuZXMgPSB0aGlzLmJsb2NrVHVuZXMuaW50ZXJuYWxUb29scztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIFRvb2xzIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyBhbmQgdGhyb3cgRXJyb3IgZm9yIHVzZXIgaWYgaXQgaXMgaW52YWxpZFxuICAgKi9cbiAgdmFsaWRhdGVUb29scygpIHtcbiAgICBmb3IgKGNvbnN0IGUgaW4gdGhpcy5jb25maWcudG9vbHMpXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29uZmlnLnRvb2xzLCBlKSkge1xuICAgICAgICBpZiAoZSBpbiB0aGlzLmludGVybmFsVG9vbHMpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5jb25maWcudG9vbHNbZV07XG4gICAgICAgIGlmICghQSh0KSAmJiAhQSh0LmNsYXNzKSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIGBUb29sIMKrJHtlfcK7IG11c3QgYmUgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBvciBhbiBvYmplY3Qgd2l0aCBmdW5jdGlvbiBpbiB0aGUgwqtjbGFzc8K7IHByb3BlcnR5YFxuICAgICAgICAgICk7XG4gICAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVuaWZ5IHRvb2xzIGNvbmZpZ1xuICAgKi9cbiAgcHJlcGFyZUNvbmZpZygpIHtcbiAgICBjb25zdCBlID0ge307XG4gICAgZm9yIChjb25zdCB0IGluIHRoaXMuY29uZmlnLnRvb2xzKVxuICAgICAgRCh0aGlzLmNvbmZpZy50b29sc1t0XSkgPyBlW3RdID0gdGhpcy5jb25maWcudG9vbHNbdF0gOiBlW3RdID0geyBjbGFzczogdGhpcy5jb25maWcudG9vbHNbdF0gfTtcbiAgICByZXR1cm4gZTtcbiAgfVxufVxuVGEoW1xuICBtZVxuXSwgV24ucHJvdG90eXBlLCBcImdldEFsbElubGluZVRvb2xzU2FuaXRpemVDb25maWdcIiwgMSk7XG5jb25zdCBTYSA9IGA6cm9vdHstLXNlbGVjdGlvbkNvbG9yOiAjZTFmMmZmOy0taW5saW5lU2VsZWN0aW9uQ29sb3I6ICNkNGVjZmY7LS1iZy1saWdodDogI2VmZjJmNTstLWdyYXlUZXh0OiAjNzA3Njg0Oy0tY29sb3ItZGFyazogIzFEMjAyQjstLWNvbG9yLWFjdGl2ZS1pY29uOiAjMzg4QUU1Oy0tY29sb3ItZ3JheS1ib3JkZXI6IHJnYmEoMjAxLCAyMDEsIDIwNCwgLjQ4KTstLWNvbnRlbnQtd2lkdGg6IDY1MHB4Oy0tbmFycm93LW1vZGUtcmlnaHQtcGFkZGluZzogNTBweDstLXRvb2xib3gtYnV0dG9ucy1zaXplOiAyNnB4Oy0tdG9vbGJveC1idXR0b25zLXNpemUtLW1vYmlsZTogMzZweDstLWljb24tc2l6ZTogMjBweDstLWljb24tc2l6ZS0tbW9iaWxlOiAyOHB4Oy0tYmxvY2stcGFkZGluZy12ZXJ0aWNhbDogLjRlbTstLWNvbG9yLWxpbmUtZ3JheTogI0VGRjBGMSB9LmNvZGV4LWVkaXRvcntwb3NpdGlvbjpyZWxhdGl2ZTstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7ei1pbmRleDoxfS5jb2RleC1lZGl0b3IgLmhpZGV7ZGlzcGxheTpub25lfS5jb2RleC1lZGl0b3JfX3JlZGFjdG9yIFtjb250ZW50ZWRpdGFibGVdOmVtcHR5OmFmdGVye2NvbnRlbnQ6XCJcXFxcZmVmZlwifUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNvZGV4LWVkaXRvci0tbmFycm93IC5jb2RleC1lZGl0b3JfX3JlZGFjdG9ye21hcmdpbi1yaWdodDo1MHB4fX1AbWVkaWEgKG1pbi13aWR0aDogNjUxcHgpey5jb2RleC1lZGl0b3ItLW5hcnJvdy5jb2RleC1lZGl0b3ItLXJ0bCAuY29kZXgtZWRpdG9yX19yZWRhY3RvcnttYXJnaW4tbGVmdDo1MHB4O21hcmdpbi1yaWdodDowfX1AbWVkaWEgKG1pbi13aWR0aDogNjUxcHgpey5jb2RleC1lZGl0b3ItLW5hcnJvdyAuY2UtdG9vbGJhcl9fYWN0aW9uc3tyaWdodDotNXB4fX0uY29kZXgtZWRpdG9yLWNvcHlhYmxle3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDoxcHg7d2lkdGg6MXB4O3RvcDotNDAwJTtvcGFjaXR5Oi4wMDF9LmNvZGV4LWVkaXRvci1vdmVybGF5e3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDtyaWdodDowO2JvdHRvbTowO3otaW5kZXg6OTk5O3BvaW50ZXItZXZlbnRzOm5vbmU7b3ZlcmZsb3c6aGlkZGVufS5jb2RleC1lZGl0b3Itb3ZlcmxheV9fY29udGFpbmVye3Bvc2l0aW9uOnJlbGF0aXZlO3BvaW50ZXItZXZlbnRzOmF1dG87ei1pbmRleDowfS5jb2RleC1lZGl0b3Itb3ZlcmxheV9fcmVjdGFuZ2xle3Bvc2l0aW9uOmFic29sdXRlO3BvaW50ZXItZXZlbnRzOm5vbmU7YmFja2dyb3VuZC1jb2xvcjojMmVhYWRjMzM7Ym9yZGVyOjFweCBzb2xpZCB0cmFuc3BhcmVudH0uY29kZXgtZWRpdG9yIHN2Z3ttYXgtaGVpZ2h0OjEwMCV9LmNvZGV4LWVkaXRvciBwYXRoe3N0cm9rZTpjdXJyZW50Q29sb3J9LmNvZGV4LWVkaXRvciA6Oi1tb3otc2VsZWN0aW9ue2JhY2tncm91bmQtY29sb3I6I2Q0ZWNmZn0uY29kZXgtZWRpdG9yIDo6c2VsZWN0aW9ue2JhY2tncm91bmQtY29sb3I6I2Q0ZWNmZn0uY29kZXgtZWRpdG9yLS10b29sYm94LW9wZW5lZCBbY29udGVudEVkaXRhYmxlPXRydWVdW2RhdGEtcGxhY2Vob2xkZXJdOmZvY3VzOmJlZm9yZXtvcGFjaXR5OjAhaW1wb3J0YW50fS5jZS1zY3JvbGwtbG9ja2Vke292ZXJmbG93OmhpZGRlbn0uY2Utc2Nyb2xsLWxvY2tlZC0taGFyZHtvdmVyZmxvdzpoaWRkZW47dG9wOmNhbGMoLTEgKiB2YXIoLS13aW5kb3ctc2Nyb2xsLW9mZnNldCkpO3Bvc2l0aW9uOmZpeGVkO3dpZHRoOjEwMCV9LmNlLXRvb2xiYXJ7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3JpZ2h0OjA7dG9wOjA7LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2U7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlO3dpbGwtY2hhbmdlOm9wYWNpdHksdG9wO2Rpc3BsYXk6bm9uZX0uY2UtdG9vbGJhci0tb3BlbmVke2Rpc3BsYXk6YmxvY2t9LmNlLXRvb2xiYXJfX2NvbnRlbnR7bWF4LXdpZHRoOjY1MHB4O21hcmdpbjowIGF1dG87cG9zaXRpb246cmVsYXRpdmV9LmNlLXRvb2xiYXJfX3BsdXN7Y29sb3I6IzFkMjAyYjtjdXJzb3I6cG9pbnRlcjt3aWR0aDoyNnB4O2hlaWdodDoyNnB4O2JvcmRlci1yYWRpdXM6N3B4O2Rpc3BsYXk6LXdlYmtpdC1pbmxpbmUtYm94O2Rpc3BsYXk6LW1zLWlubGluZS1mbGV4Ym94O2Rpc3BsYXk6aW5saW5lLWZsZXg7LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7LW1zLWZsZXgtbmVnYXRpdmU6MDtmbGV4LXNocmluazowfUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXRvb2xiYXJfX3BsdXN7d2lkdGg6MzZweDtoZWlnaHQ6MzZweH19QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZS10b29sYmFyX19wbHVzOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2VmZjJmNX19LmNlLXRvb2xiYXJfX3BsdXMtLWFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOiNlZmYyZjU7LXdlYmtpdC1hbmltYXRpb246Ym91bmNlSW4gLjc1cyAxO2FuaW1hdGlvbjpib3VuY2VJbiAuNzVzIDE7LXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOmZvcndhcmRzO2FuaW1hdGlvbi1maWxsLW1vZGU6Zm9yd2FyZHN9LmNlLXRvb2xiYXJfX3BsdXMtc2hvcnRjdXR7b3BhY2l0eTouNjt3b3JkLXNwYWNpbmc6LTJweDttYXJnaW4tdG9wOjVweH1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS10b29sYmFyX19wbHVze3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXI6MXB4IHNvbGlkICNFOEU4RUI7LXdlYmtpdC1ib3gtc2hhZG93OjAgM3B4IDE1cHggLTNweCByZ2JhKDEzLDIwLDMzLC4xMyk7Ym94LXNoYWRvdzowIDNweCAxNXB4IC0zcHggIzBkMTQyMTIxO2JvcmRlci1yYWRpdXM6NnB4O3otaW5kZXg6Mjtwb3NpdGlvbjpzdGF0aWN9LmNlLXRvb2xiYXJfX3BsdXMtLWxlZnQtb3JpZW50ZWQ6YmVmb3Jle2xlZnQ6MTVweDttYXJnaW4tbGVmdDowfS5jZS10b29sYmFyX19wbHVzLS1yaWdodC1vcmllbnRlZDpiZWZvcmV7bGVmdDphdXRvO3JpZ2h0OjE1cHg7bWFyZ2luLWxlZnQ6MH19LmNlLXRvb2xiYXJfX2FjdGlvbnN7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MTAwJTtvcGFjaXR5OjA7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDtwYWRkaW5nLXJpZ2h0OjVweH0uY2UtdG9vbGJhcl9fYWN0aW9ucy0tb3BlbmVke29wYWNpdHk6MX1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS10b29sYmFyX19hY3Rpb25ze3JpZ2h0OmF1dG99fS5jZS10b29sYmFyX19zZXR0aW5ncy1idG57Y29sb3I6IzFkMjAyYjt3aWR0aDoyNnB4O2hlaWdodDoyNnB4O2JvcmRlci1yYWRpdXM6N3B4O2Rpc3BsYXk6LXdlYmtpdC1pbmxpbmUtYm94O2Rpc3BsYXk6LW1zLWlubGluZS1mbGV4Ym94O2Rpc3BsYXk6aW5saW5lLWZsZXg7LXdlYmtpdC1ib3gtcGFjazpjZW50ZXI7LW1zLWZsZXgtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO21hcmdpbi1sZWZ0OjNweDtjdXJzb3I6cG9pbnRlcjt1c2VyLXNlbGVjdDpub25lfUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bnt3aWR0aDozNnB4O2hlaWdodDozNnB4fX1AbWVkaWEgKGhvdmVyOiBob3Zlcil7LmNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNlZmYyZjV9fS5jZS10b29sYmFyX19zZXR0aW5ncy1idG4tLWFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOiNlZmYyZjU7LXdlYmtpdC1hbmltYXRpb246Ym91bmNlSW4gLjc1cyAxO2FuaW1hdGlvbjpib3VuY2VJbiAuNzVzIDE7LXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOmZvcndhcmRzO2FuaW1hdGlvbi1maWxsLW1vZGU6Zm9yd2FyZHN9QG1lZGlhIChtaW4td2lkdGg6IDY1MXB4KXsuY2UtdG9vbGJhcl9fc2V0dGluZ3MtYnRue3dpZHRoOjI0cHh9fS5jZS10b29sYmFyX19zZXR0aW5ncy1idG4tLWhpZGRlbntkaXNwbGF5Om5vbmV9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtdG9vbGJhcl9fc2V0dGluZ3MtYnRue3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXI6MXB4IHNvbGlkICNFOEU4RUI7LXdlYmtpdC1ib3gtc2hhZG93OjAgM3B4IDE1cHggLTNweCByZ2JhKDEzLDIwLDMzLC4xMyk7Ym94LXNoYWRvdzowIDNweCAxNXB4IC0zcHggIzBkMTQyMTIxO2JvcmRlci1yYWRpdXM6NnB4O3otaW5kZXg6Mjtwb3NpdGlvbjpzdGF0aWN9LmNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bi0tbGVmdC1vcmllbnRlZDpiZWZvcmV7bGVmdDoxNXB4O21hcmdpbi1sZWZ0OjB9LmNlLXRvb2xiYXJfX3NldHRpbmdzLWJ0bi0tcmlnaHQtb3JpZW50ZWQ6YmVmb3Jle2xlZnQ6YXV0bztyaWdodDoxNXB4O21hcmdpbi1sZWZ0OjB9fS5jZS10b29sYmFyX19wbHVzIHN2ZywuY2UtdG9vbGJhcl9fc2V0dGluZ3MtYnRuIHN2Z3t3aWR0aDoyNHB4O2hlaWdodDoyNHB4fUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNvZGV4LWVkaXRvci0tbmFycm93IC5jZS10b29sYmFyX19wbHVze2xlZnQ6NXB4fX1AbWVkaWEgKG1pbi13aWR0aDogNjUxcHgpey5jb2RleC1lZGl0b3ItLW5hcnJvdyAuY2UtdG9vbGJveCAuY2UtcG9wb3ZlcntyaWdodDowO2xlZnQ6YXV0bztsZWZ0OmluaXRpYWx9fS5jZS1pbmxpbmUtdG9vbGJhcnstLXktb2Zmc2V0OiA4cHg7LS1jb2xvci1iYWNrZ3JvdW5kLWljb24tYWN0aXZlOiByZ2JhKDU2LCAxMzgsIDIyOSwgLjEpOy0tY29sb3ItdGV4dC1pY29uLWFjdGl2ZTogIzM4OEFFNTstLWNvbG9yLXRleHQtcHJpbWFyeTogYmxhY2s7cG9zaXRpb246YWJzb2x1dGU7dmlzaWJpbGl0eTpoaWRkZW47LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjI1cyBlYXNlO3RyYW5zaXRpb246b3BhY2l0eSAuMjVzIGVhc2U7d2lsbC1jaGFuZ2U6b3BhY2l0eSxsZWZ0LHRvcDt0b3A6MDtsZWZ0OjA7ei1pbmRleDozO29wYWNpdHk6MTt2aXNpYmlsaXR5OnZpc2libGV9LmNlLWlubGluZS10b29sYmFyIFtoaWRkZW5de2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9LmNlLWlubGluZS10b29sYmFyX190b2dnbGVyLWFuZC1idXR0b24td3JhcHBlcntkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4O3dpZHRoOjEwMCU7cGFkZGluZzowIDZweH0uY2UtaW5saW5lLXRvb2xiYXJfX2J1dHRvbnN7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleH0uY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3due2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7cGFkZGluZzo2cHg7bWFyZ2luOjAgNnB4IDAgLTZweDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtjdXJzb3I6cG9pbnRlcjtib3JkZXItcmlnaHQ6MXB4IHNvbGlkIHJnYmEoMjAxLDIwMSwyMDQsLjQ4KTstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3h9QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd246aG92ZXJ7YmFja2dyb3VuZDojZWZmMmY1fX0uY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3duLS1oaWRkZW57ZGlzcGxheTpub25lfS5jZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd24tY29udGVudCwuY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3duLWFycm93e2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXh9LmNlLWlubGluZS10b29sYmFyX19kcm9wZG93bi1jb250ZW50IHN2ZywuY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3duLWFycm93IHN2Z3t3aWR0aDoyMHB4O2hlaWdodDoyMHB4fS5jZS1pbmxpbmUtdG9vbGJhcl9fc2hvcnRjdXR7b3BhY2l0eTouNjt3b3JkLXNwYWNpbmc6LTNweDttYXJnaW4tdG9wOjNweH0uY2UtaW5saW5lLXRvb2x7Y29sb3I6dmFyKC0tY29sb3ItdGV4dC1wcmltYXJ5KTtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7Ym9yZGVyOjA7Ym9yZGVyLXJhZGl1czo0cHg7bGluZS1oZWlnaHQ6bm9ybWFsO2hlaWdodDoxMDAlO3BhZGRpbmc6MDt3aWR0aDoyOHB4O2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7Y3Vyc29yOnBvaW50ZXJ9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtaW5saW5lLXRvb2x7d2lkdGg6MzZweDtoZWlnaHQ6MzZweH19QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZS1pbmxpbmUtdG9vbDpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmOGY4Zjh9fS5jZS1pbmxpbmUtdG9vbCBzdmd7ZGlzcGxheTpibG9jazt3aWR0aDoyMHB4O2hlaWdodDoyMHB4fUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLWlubGluZS10b29sIHN2Z3t3aWR0aDoyOHB4O2hlaWdodDoyOHB4fX0uY2UtaW5saW5lLXRvb2wtLWxpbmsgLmljb24tLXVubGluaywuY2UtaW5saW5lLXRvb2wtLXVubGluayAuaWNvbi0tbGlua3tkaXNwbGF5Om5vbmV9LmNlLWlubGluZS10b29sLS11bmxpbmsgLmljb24tLXVubGlua3tkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tYm90dG9tOi0xcHh9LmNlLWlubGluZS10b29sLWlucHV0e2JhY2tncm91bmQ6I0Y4RjhGODtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMjI2LDIyNiwyMjksLjIpO2JvcmRlci1yYWRpdXM6NnB4O3BhZGRpbmc6NHB4IDhweDtmb250LXNpemU6MTRweDtsaW5lLWhlaWdodDoyMnB4O291dGxpbmU6bm9uZTttYXJnaW46MDt3aWR0aDoxMDAlOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5Om5vbmU7Zm9udC13ZWlnaHQ6NTAwOy13ZWJraXQtYXBwZWFyYW5jZTpub25lO2ZvbnQtZmFtaWx5OmluaGVyaXR9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtaW5saW5lLXRvb2wtaW5wdXR7Zm9udC1zaXplOjE1cHg7Zm9udC13ZWlnaHQ6NTAwfX0uY2UtaW5saW5lLXRvb2wtaW5wdXQ6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6IzcwNzY4NH0uY2UtaW5saW5lLXRvb2wtaW5wdXQ6Oi1tb3otcGxhY2Vob2xkZXJ7Y29sb3I6IzcwNzY4NH0uY2UtaW5saW5lLXRvb2wtaW5wdXQ6LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODR9LmNlLWlubGluZS10b29sLWlucHV0OjotbXMtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6IzcwNzY4NH0uY2UtaW5saW5lLXRvb2wtaW5wdXQ6OnBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODR9LmNlLWlubGluZS10b29sLWlucHV0LS1zaG93ZWR7ZGlzcGxheTpibG9ja30uY2UtaW5saW5lLXRvb2wtLWFjdGl2ZXtiYWNrZ3JvdW5kOnZhcigtLWNvbG9yLWJhY2tncm91bmQtaWNvbi1hY3RpdmUpO2NvbG9yOnZhcigtLWNvbG9yLXRleHQtaWNvbi1hY3RpdmUpfUAtd2Via2l0LWtleWZyYW1lcyBmYWRlLWluezAle29wYWNpdHk6MH10b3tvcGFjaXR5OjF9fUBrZXlmcmFtZXMgZmFkZS1pbnswJXtvcGFjaXR5OjB9dG97b3BhY2l0eToxfX0uY2UtYmxvY2t7LXdlYmtpdC1hbmltYXRpb246ZmFkZS1pbiAuM3MgZWFzZTthbmltYXRpb246ZmFkZS1pbiAuM3MgZWFzZTstd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6bm9uZTthbmltYXRpb24tZmlsbC1tb2RlOm5vbmU7LXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlOmluaXRpYWw7YW5pbWF0aW9uLWZpbGwtbW9kZTppbml0aWFsfS5jZS1ibG9jazpmaXJzdC1vZi10eXBle21hcmdpbi10b3A6MH0uY2UtYmxvY2stLXNlbGVjdGVkIC5jZS1ibG9ja19fY29udGVudHtiYWNrZ3JvdW5kOiNlMWYyZmZ9LmNlLWJsb2NrLS1zZWxlY3RlZCAuY2UtYmxvY2tfX2NvbnRlbnQgW2NvbnRlbnRlZGl0YWJsZV17LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5jZS1ibG9jay0tc2VsZWN0ZWQgLmNlLWJsb2NrX19jb250ZW50IGltZywuY2UtYmxvY2stLXNlbGVjdGVkIC5jZS1ibG9ja19fY29udGVudCAuY2Utc3R1YntvcGFjaXR5Oi41NX0uY2UtYmxvY2stLXN0cmV0Y2hlZCAuY2UtYmxvY2tfX2NvbnRlbnR7bWF4LXdpZHRoOm5vbmV9LmNlLWJsb2NrX19jb250ZW50e3Bvc2l0aW9uOnJlbGF0aXZlO21heC13aWR0aDo2NTBweDttYXJnaW46MCBhdXRvOy13ZWJraXQtdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4xNXMgZWFzZTt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjE1cyBlYXNlfS5jZS1ibG9jay0tZHJvcC10YXJnZXQgLmNlLWJsb2NrX19jb250ZW50OmJlZm9yZXtjb250ZW50OlwiXCI7cG9zaXRpb246YWJzb2x1dGU7dG9wOjEwMCU7bGVmdDotMjBweDttYXJnaW4tdG9wOi0xcHg7aGVpZ2h0OjhweDt3aWR0aDo4cHg7Ym9yZGVyOnNvbGlkICMzODhBRTU7Ym9yZGVyLXdpZHRoOjFweCAxcHggMCAwOy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjpyaWdodDt0cmFuc2Zvcm0tb3JpZ2luOnJpZ2h0Oy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyk7dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9LmNlLWJsb2NrLS1kcm9wLXRhcmdldCAuY2UtYmxvY2tfX2NvbnRlbnQ6YWZ0ZXJ7Y29udGVudDpcIlwiO3Bvc2l0aW9uOmFic29sdXRlO3RvcDoxMDAlO2hlaWdodDoxcHg7d2lkdGg6MTAwJTtjb2xvcjojMzg4YWU1O2JhY2tncm91bmQ6cmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudCg5MGRlZywjMzg4QUU1LCMzODhBRTUgMXB4LCNmZmYgMXB4LCNmZmYgNnB4KX0uY2UtYmxvY2sgYXtjdXJzb3I6cG9pbnRlcjstd2Via2l0LXRleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmU7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZX0uY2UtYmxvY2sgYntmb250LXdlaWdodDo3MDB9LmNlLWJsb2NrIGl7Zm9udC1zdHlsZTppdGFsaWN9QC13ZWJraXQta2V5ZnJhbWVzIGJvdW5jZUluezAlLDIwJSw0MCUsNjAlLDgwJSx0b3std2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSk7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKX0wJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKC45LC45LC45KTt0cmFuc2Zvcm06c2NhbGUzZCguOSwuOSwuOSl9MjAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMS4wMywxLjAzLDEuMDMpO3RyYW5zZm9ybTpzY2FsZTNkKDEuMDMsMS4wMywxLjAzKX02MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLDEsMSk7dHJhbnNmb3JtOnNjYWxlWigxKX19QGtleWZyYW1lcyBib3VuY2VJbnswJSwyMCUsNDAlLDYwJSw4MCUsdG97LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSl9MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCguOSwuOSwuOSk7dHJhbnNmb3JtOnNjYWxlM2QoLjksLjksLjkpfTIwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEuMDMsMS4wMywxLjAzKTt0cmFuc2Zvcm06c2NhbGUzZCgxLjAzLDEuMDMsMS4wMyl9NjAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMSwxLDEpO3RyYW5zZm9ybTpzY2FsZVooMSl9fUAtd2Via2l0LWtleWZyYW1lcyBzZWxlY3Rpb25Cb3VuY2V7MCUsMjAlLDQwJSw2MCUsODAlLHRvey13ZWJraXQtYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKTthbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpfTUwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEuMDEsMS4wMSwxLjAxKTt0cmFuc2Zvcm06c2NhbGUzZCgxLjAxLDEuMDEsMS4wMSl9NzAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMSwxLDEpO3RyYW5zZm9ybTpzY2FsZVooMSl9fUBrZXlmcmFtZXMgc2VsZWN0aW9uQm91bmNlezAlLDIwJSw0MCUsNjAlLDgwJSx0b3std2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSk7YW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjIxNSwuNjEsLjM1NSwxKX01MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCgxLjAxLDEuMDEsMS4wMSk7dHJhbnNmb3JtOnNjYWxlM2QoMS4wMSwxLjAxLDEuMDEpfTcwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEsMSwxKTt0cmFuc2Zvcm06c2NhbGVaKDEpfX1ALXdlYmtpdC1rZXlmcmFtZXMgYnV0dG9uQ2xpY2tlZHswJSwyMCUsNDAlLDYwJSw4MCUsdG97LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSl9MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCguOTUsLjk1LC45NSk7dHJhbnNmb3JtOnNjYWxlM2QoLjk1LC45NSwuOTUpfTYwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEuMDIsMS4wMiwxLjAyKTt0cmFuc2Zvcm06c2NhbGUzZCgxLjAyLDEuMDIsMS4wMil9ODAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMSwxLDEpO3RyYW5zZm9ybTpzY2FsZVooMSl9fUBrZXlmcmFtZXMgYnV0dG9uQ2xpY2tlZHswJSwyMCUsNDAlLDYwJSw4MCUsdG97LXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMjE1LC42MSwuMzU1LDEpO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4yMTUsLjYxLC4zNTUsMSl9MCV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUzZCguOTUsLjk1LC45NSk7dHJhbnNmb3JtOnNjYWxlM2QoLjk1LC45NSwuOTUpfTYwJXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZTNkKDEuMDIsMS4wMiwxLjAyKTt0cmFuc2Zvcm06c2NhbGUzZCgxLjAyLDEuMDIsMS4wMil9ODAley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlM2QoMSwxLDEpO3RyYW5zZm9ybTpzY2FsZVooMSl9fS5jZHgtYmxvY2t7cGFkZGluZzouNGVtIDB9LmNkeC1ibG9jazo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcntsaW5lLWhlaWdodDpub3JtYWwhaW1wb3J0YW50fS5jZHgtaW5wdXR7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDIwMSwyMDEsMjA0LC40OCk7LXdlYmtpdC1ib3gtc2hhZG93Omluc2V0IDAgMXB4IDJweCAwIHJnYmEoMzUsNDQsNzIsLjA2KTtib3gtc2hhZG93Omluc2V0IDAgMXB4IDJweCAjMjMyYzQ4MGY7Ym9yZGVyLXJhZGl1czozcHg7cGFkZGluZzoxMHB4IDEycHg7b3V0bGluZTpub25lO3dpZHRoOjEwMCU7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94fS5jZHgtaW5wdXRbZGF0YS1wbGFjZWhvbGRlcl06YmVmb3Jle3Bvc2l0aW9uOnN0YXRpYyFpbXBvcnRhbnR9LmNkeC1pbnB1dFtkYXRhLXBsYWNlaG9sZGVyXTpiZWZvcmV7ZGlzcGxheTppbmxpbmUtYmxvY2s7d2lkdGg6MDt3aGl0ZS1zcGFjZTpub3dyYXA7cG9pbnRlci1ldmVudHM6bm9uZX0uY2R4LXNldHRpbmdzLWJ1dHRvbntkaXNwbGF5Oi13ZWJraXQtaW5saW5lLWJveDtkaXNwbGF5Oi1tcy1pbmxpbmUtZmxleGJveDtkaXNwbGF5OmlubGluZS1mbGV4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7Ym9yZGVyLXJhZGl1czozcHg7Y3Vyc29yOnBvaW50ZXI7Ym9yZGVyOjA7b3V0bGluZTpub25lO2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7dmVydGljYWwtYWxpZ246Ym90dG9tO2NvbG9yOmluaGVyaXQ7bWFyZ2luOjA7bWluLXdpZHRoOjI2cHg7bWluLWhlaWdodDoyNnB4fS5jZHgtc2V0dGluZ3MtYnV0dG9uLS1mb2N1c2Vke2JhY2tncm91bmQ6cmdiYSgzNCwxODYsMjU1LC4wOCkhaW1wb3J0YW50fS5jZHgtc2V0dGluZ3MtYnV0dG9uLS1mb2N1c2Vkey13ZWJraXQtYm94LXNoYWRvdzppbnNldCAwIDAgMHB4IDFweCByZ2JhKDcsMTYxLDIyNywuMDgpO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgMXB4ICMwN2ExZTMxNH0uY2R4LXNldHRpbmdzLWJ1dHRvbi0tZm9jdXNlZC1hbmltYXRlZHstd2Via2l0LWFuaW1hdGlvbi1uYW1lOmJ1dHRvbkNsaWNrZWQ7YW5pbWF0aW9uLW5hbWU6YnV0dG9uQ2xpY2tlZDstd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjouMjVzO2FuaW1hdGlvbi1kdXJhdGlvbjouMjVzfS5jZHgtc2V0dGluZ3MtYnV0dG9uLS1hY3RpdmV7Y29sb3I6IzM4OGFlNX0uY2R4LXNldHRpbmdzLWJ1dHRvbiBzdmd7d2lkdGg6YXV0bztoZWlnaHQ6YXV0b31AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZHgtc2V0dGluZ3MtYnV0dG9uIHN2Z3t3aWR0aDoyOHB4O2hlaWdodDoyOHB4fX1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZHgtc2V0dGluZ3MtYnV0dG9ue3dpZHRoOjM2cHg7aGVpZ2h0OjM2cHg7Ym9yZGVyLXJhZGl1czo4cHh9fUBtZWRpYSAoaG92ZXI6IGhvdmVyKXsuY2R4LXNldHRpbmdzLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNlZmYyZjV9fS5jZHgtbG9hZGVye3Bvc2l0aW9uOnJlbGF0aXZlO2JvcmRlcjoxcHggc29saWQgcmdiYSgyMDEsMjAxLDIwNCwuNDgpfS5jZHgtbG9hZGVyOmJlZm9yZXtjb250ZW50OlwiXCI7cG9zaXRpb246YWJzb2x1dGU7bGVmdDo1MCU7dG9wOjUwJTt3aWR0aDoxOHB4O2hlaWdodDoxOHB4O21hcmdpbjotMTFweCAwIDAgLTExcHg7Ym9yZGVyOjJweCBzb2xpZCByZ2JhKDIwMSwyMDEsMjA0LC40OCk7Ym9yZGVyLWxlZnQtY29sb3I6IzM4OGFlNTtib3JkZXItcmFkaXVzOjUwJTstd2Via2l0LWFuaW1hdGlvbjpjZHhSb3RhdGlvbiAxLjJzIGluZmluaXRlIGxpbmVhcjthbmltYXRpb246Y2R4Um90YXRpb24gMS4ycyBpbmZpbml0ZSBsaW5lYXJ9QC13ZWJraXQta2V5ZnJhbWVzIGNkeFJvdGF0aW9uezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDApfXRvey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19QGtleWZyYW1lcyBjZHhSb3RhdGlvbnswJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgwKX10b3std2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fS5jZHgtYnV0dG9ue3BhZGRpbmc6MTNweDtib3JkZXItcmFkaXVzOjNweDtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMjAxLDIwMSwyMDQsLjQ4KTtmb250LXNpemU6MTQuOXB4O2JhY2tncm91bmQ6I2ZmZjstd2Via2l0LWJveC1zaGFkb3c6MCAycHggMnB4IDAgcmdiYSgxOCwzMCw1NywuMDQpO2JveC1zaGFkb3c6MCAycHggMnB4ICMxMjFlMzkwYTtjb2xvcjojNzA3Njg0O3RleHQtYWxpZ246Y2VudGVyO2N1cnNvcjpwb2ludGVyfUBtZWRpYSAoaG92ZXI6IGhvdmVyKXsuY2R4LWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kOiNGQkZDRkU7LXdlYmtpdC1ib3gtc2hhZG93OjAgMXB4IDNweCAwIHJnYmEoMTgsMzAsNTcsLjA4KTtib3gtc2hhZG93OjAgMXB4IDNweCAjMTIxZTM5MTR9fS5jZHgtYnV0dG9uIHN2Z3toZWlnaHQ6MjBweDttYXJnaW4tcmlnaHQ6LjJlbTttYXJnaW4tdG9wOi0ycHh9LmNlLXN0dWJ7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtwYWRkaW5nOjEycHggMThweDttYXJnaW46MTBweCAwO2JvcmRlci1yYWRpdXM6MTBweDtiYWNrZ3JvdW5kOiNlZmYyZjU7Ym9yZGVyOjFweCBzb2xpZCAjRUZGMEYxO2NvbG9yOiM3MDc2ODQ7Zm9udC1zaXplOjE0cHh9LmNlLXN0dWIgc3Zne3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHh9LmNlLXN0dWJfX2luZm97bWFyZ2luLWxlZnQ6MTRweH0uY2Utc3R1Yl9fdGl0bGV7Zm9udC13ZWlnaHQ6NTAwO3RleHQtdHJhbnNmb3JtOmNhcGl0YWxpemV9LmNvZGV4LWVkaXRvci5jb2RleC1lZGl0b3ItLXJ0bHtkaXJlY3Rpb246cnRsfS5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNkeC1saXN0e3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6NDBweH0uY29kZXgtZWRpdG9yLmNvZGV4LWVkaXRvci0tcnRsIC5jZS10b29sYmFyX19wbHVze3JpZ2h0Oi0yNnB4O2xlZnQ6YXV0b30uY29kZXgtZWRpdG9yLmNvZGV4LWVkaXRvci0tcnRsIC5jZS10b29sYmFyX19hY3Rpb25ze3JpZ2h0OmF1dG87bGVmdDotMjZweH1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNlLXRvb2xiYXJfX2FjdGlvbnN7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6YXV0bztwYWRkaW5nLXJpZ2h0OjA7cGFkZGluZy1sZWZ0OjEwcHh9fS5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNlLXNldHRpbmdze2xlZnQ6NXB4O3JpZ2h0OmF1dG99LmNvZGV4LWVkaXRvci5jb2RleC1lZGl0b3ItLXJ0bCAuY2Utc2V0dGluZ3M6YmVmb3Jle3JpZ2h0OmF1dG87bGVmdDoyNXB4fS5jb2RleC1lZGl0b3IuY29kZXgtZWRpdG9yLS1ydGwgLmNlLXNldHRpbmdzX19idXR0b246bm90KDpudGgtY2hpbGQoM24rMykpe21hcmdpbi1sZWZ0OjNweDttYXJnaW4tcmlnaHQ6MH0uY29kZXgtZWRpdG9yLmNvZGV4LWVkaXRvci0tcnRsIC5jZS1jb252ZXJzaW9uLXRvb2xfX2ljb257bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLWxlZnQ6MTBweH0uY29kZXgtZWRpdG9yLmNvZGV4LWVkaXRvci0tcnRsIC5jZS1pbmxpbmUtdG9vbGJhcl9fZHJvcGRvd257Ym9yZGVyLXJpZ2h0OjBweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItbGVmdDoxcHggc29saWQgcmdiYSgyMDEsMjAxLDIwNCwuNDgpO21hcmdpbjowIC02cHggMCA2cHh9LmNvZGV4LWVkaXRvci5jb2RleC1lZGl0b3ItLXJ0bCAuY2UtaW5saW5lLXRvb2xiYXJfX2Ryb3Bkb3duIC5pY29uLS10b2dnbGVyLWRvd257bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6NHB4fUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNvZGV4LWVkaXRvci0tbmFycm93LmNvZGV4LWVkaXRvci0tcnRsIC5jZS10b29sYmFyX19wbHVze2xlZnQ6MDtyaWdodDo1cHh9fUBtZWRpYSAobWluLXdpZHRoOiA2NTFweCl7LmNvZGV4LWVkaXRvci0tbmFycm93LmNvZGV4LWVkaXRvci0tcnRsIC5jZS10b29sYmFyX19hY3Rpb25ze2xlZnQ6LTVweH19LmNkeC1zZWFyY2gtZmllbGR7LS1pY29uLW1hcmdpbi1yaWdodDogMTBweDtiYWNrZ3JvdW5kOiNGOEY4Rjg7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDIyNiwyMjYsMjI5LC4yKTtib3JkZXItcmFkaXVzOjZweDtwYWRkaW5nOjJweDtkaXNwbGF5OmdyaWQ7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOmF1dG8gYXV0byAxZnI7Z3JpZC10ZW1wbGF0ZS1yb3dzOmF1dG99LmNkeC1zZWFyY2gtZmllbGRfX2ljb257d2lkdGg6MjZweDtoZWlnaHQ6MjZweDtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy13ZWJraXQtYm94LXBhY2s6Y2VudGVyOy1tcy1mbGV4LXBhY2s6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luLXJpZ2h0OnZhcigtLWljb24tbWFyZ2luLXJpZ2h0KX0uY2R4LXNlYXJjaC1maWVsZF9faWNvbiBzdmd7d2lkdGg6MjBweDtoZWlnaHQ6MjBweDtjb2xvcjojNzA3Njg0fS5jZHgtc2VhcmNoLWZpZWxkX19pbnB1dHtmb250LXNpemU6MTRweDtvdXRsaW5lOm5vbmU7Zm9udC13ZWlnaHQ6NTAwO2ZvbnQtZmFtaWx5OmluaGVyaXQ7Ym9yZGVyOjA7YmFja2dyb3VuZDp0cmFuc3BhcmVudDttYXJnaW46MDtwYWRkaW5nOjA7bGluZS1oZWlnaHQ6MjJweDttaW4td2lkdGg6Y2FsYygxMDAlIC0gMjZweCAtIHZhcigtLWljb24tbWFyZ2luLXJpZ2h0KSl9LmNkeC1zZWFyY2gtZmllbGRfX2lucHV0Ojotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODQ7Zm9udC13ZWlnaHQ6NTAwfS5jZHgtc2VhcmNoLWZpZWxkX19pbnB1dDo6LW1vei1wbGFjZWhvbGRlcntjb2xvcjojNzA3Njg0O2ZvbnQtd2VpZ2h0OjUwMH0uY2R4LXNlYXJjaC1maWVsZF9faW5wdXQ6LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODQ7Zm9udC13ZWlnaHQ6NTAwfS5jZHgtc2VhcmNoLWZpZWxkX19pbnB1dDo6LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM3MDc2ODQ7Zm9udC13ZWlnaHQ6NTAwfS5jZHgtc2VhcmNoLWZpZWxkX19pbnB1dDo6cGxhY2Vob2xkZXJ7Y29sb3I6IzcwNzY4NDtmb250LXdlaWdodDo1MDB9LmNlLXBvcG92ZXJ7LS1ib3JkZXItcmFkaXVzOiA2cHg7LS13aWR0aDogMjAwcHg7LS1tYXgtaGVpZ2h0OiAyNzBweDstLXBhZGRpbmc6IDZweDstLW9mZnNldC1mcm9tLXRhcmdldDogOHB4Oy0tY29sb3ItYm9yZGVyOiAjRUZGMEYxOy0tY29sb3Itc2hhZG93OiByZ2JhKDEzLCAyMCwgMzMsIC4xKTstLWNvbG9yLWJhY2tncm91bmQ6IHdoaXRlOy0tY29sb3ItdGV4dC1wcmltYXJ5OiBibGFjazstLWNvbG9yLXRleHQtc2Vjb25kYXJ5OiAjNzA3Njg0Oy0tY29sb3ItYm9yZGVyLWljb246IHJnYmEoMjAxLCAyMDEsIDIwNCwgLjQ4KTstLWNvbG9yLWJvcmRlci1pY29uLWRpc2FibGVkOiAjRUZGMEYxOy0tY29sb3ItdGV4dC1pY29uLWFjdGl2ZTogIzM4OEFFNTstLWNvbG9yLWJhY2tncm91bmQtaWNvbi1hY3RpdmU6IHJnYmEoNTYsIDEzOCwgMjI5LCAuMSk7LS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0tZm9jdXM6IHJnYmEoMzQsIDE4NiwgMjU1LCAuMDgpOy0tY29sb3Itc2hhZG93LWl0ZW0tZm9jdXM6IHJnYmEoNywgMTYxLCAyMjcsIC4wOCk7LS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0taG92ZXI6ICNGOEY4Rjg7LS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0tY29uZmlybTogI0UyNEE0QTstLWNvbG9yLWJhY2tncm91bmQtaXRlbS1jb25maXJtLWhvdmVyOiAjQ0U0MzQzOy0tcG9wb3Zlci10b3A6IGNhbGMoMTAwJSArIHZhcigtLW9mZnNldC1mcm9tLXRhcmdldCkpOy0tcG9wb3Zlci1sZWZ0OiAwOy0tbmVzdGVkLXBvcG92ZXItb3ZlcmxhcDogNHB4Oy0taWNvbi1zaXplOiAyMHB4Oy0taXRlbS1wYWRkaW5nOiAzcHg7LS1pdGVtLWhlaWdodDogY2FsYyh2YXIoLS1pY29uLXNpemUpICsgMiAqIHZhcigtLWl0ZW0tcGFkZGluZykpfS5jZS1wb3BvdmVyX19jb250YWluZXJ7bWluLXdpZHRoOnZhcigtLXdpZHRoKTt3aWR0aDp2YXIoLS13aWR0aCk7bWF4LWhlaWdodDp2YXIoLS1tYXgtaGVpZ2h0KTtib3JkZXItcmFkaXVzOnZhcigtLWJvcmRlci1yYWRpdXMpO292ZXJmbG93OmhpZGRlbjstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7LXdlYmtpdC1ib3gtc2hhZG93OjBweCAzcHggMTVweCAtM3B4IHZhcigtLWNvbG9yLXNoYWRvdyk7Ym94LXNoYWRvdzowIDNweCAxNXB4IC0zcHggdmFyKC0tY29sb3Itc2hhZG93KTtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OnZhcigtLXBvcG92ZXItbGVmdCk7dG9wOnZhcigtLXBvcG92ZXItdG9wKTtiYWNrZ3JvdW5kOnZhcigtLWNvbG9yLWJhY2tncm91bmQpO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47ei1pbmRleDo0O29wYWNpdHk6MDttYXgtaGVpZ2h0OjA7cG9pbnRlci1ldmVudHM6bm9uZTtwYWRkaW5nOjA7Ym9yZGVyOm5vbmV9LmNlLXBvcG92ZXItLW9wZW5lZD4uY2UtcG9wb3Zlcl9fY29udGFpbmVye29wYWNpdHk6MTtwYWRkaW5nOnZhcigtLXBhZGRpbmcpO21heC1oZWlnaHQ6dmFyKC0tbWF4LWhlaWdodCk7cG9pbnRlci1ldmVudHM6YXV0bzstd2Via2l0LWFuaW1hdGlvbjpwYW5lbFNob3dpbmcgLjFzIGVhc2U7YW5pbWF0aW9uOnBhbmVsU2hvd2luZyAuMXMgZWFzZTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWNvbG9yLWJvcmRlcil9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtcG9wb3Zlci0tb3BlbmVkPi5jZS1wb3BvdmVyX19jb250YWluZXJ7LXdlYmtpdC1hbmltYXRpb246cGFuZWxTaG93aW5nTW9iaWxlIC4yNXMgZWFzZTthbmltYXRpb246cGFuZWxTaG93aW5nTW9iaWxlIC4yNXMgZWFzZX19LmNlLXBvcG92ZXItLW9wZW4tdG9wIC5jZS1wb3BvdmVyX19jb250YWluZXJ7LS1wb3BvdmVyLXRvcDogY2FsYygtMSAqICh2YXIoLS1vZmZzZXQtZnJvbS10YXJnZXQpICsgdmFyKC0tcG9wb3Zlci1oZWlnaHQpKSl9LmNlLXBvcG92ZXItLW9wZW4tbGVmdCAuY2UtcG9wb3Zlcl9fY29udGFpbmVyey0tcG9wb3Zlci1sZWZ0OiBjYWxjKC0xICogdmFyKC0td2lkdGgpICsgMTAwJSl9LmNlLXBvcG92ZXJfX2l0ZW1ze292ZXJmbG93LXk6YXV0bzstbXMtc2Nyb2xsLWNoYWluaW5nOm5vbmU7b3ZlcnNjcm9sbC1iZWhhdmlvcjpjb250YWlufUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXBvcG92ZXJfX292ZXJsYXl7cG9zaXRpb246Zml4ZWQ7dG9wOjA7Ym90dG9tOjA7bGVmdDowO3JpZ2h0OjA7YmFja2dyb3VuZDojMUQyMDJCO3otaW5kZXg6MztvcGFjaXR5Oi41Oy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4xMnMgZWFzZS1pbjt0cmFuc2l0aW9uOm9wYWNpdHkgLjEycyBlYXNlLWluO3dpbGwtY2hhbmdlOm9wYWNpdHk7dmlzaWJpbGl0eTp2aXNpYmxlfX0uY2UtcG9wb3Zlcl9fb3ZlcmxheS0taGlkZGVue2Rpc3BsYXk6bm9uZX1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1wb3BvdmVyIC5jZS1wb3BvdmVyX19jb250YWluZXJ7LS1vZmZzZXQ6IDVweDtwb3NpdGlvbjpmaXhlZDttYXgtd2lkdGg6bm9uZTttaW4td2lkdGg6Y2FsYygxMDAlIC0gdmFyKC0tb2Zmc2V0KSAqIDIpO2xlZnQ6dmFyKC0tb2Zmc2V0KTtyaWdodDp2YXIoLS1vZmZzZXQpO2JvdHRvbTpjYWxjKHZhcigtLW9mZnNldCkgKyBlbnYoc2FmZS1hcmVhLWluc2V0LWJvdHRvbSkpO3RvcDphdXRvO2JvcmRlci1yYWRpdXM6MTBweH19LmNlLXBvcG92ZXJfX3NlYXJjaHttYXJnaW4tYm90dG9tOjVweH0uY2UtcG9wb3Zlcl9fbm90aGluZy1mb3VuZC1tZXNzYWdle2NvbG9yOiM3MDc2ODQ7ZGlzcGxheTpub25lO2N1cnNvcjpkZWZhdWx0O3BhZGRpbmc6M3B4O2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjIwcHg7Zm9udC13ZWlnaHQ6NTAwO3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdzpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpc30uY2UtcG9wb3Zlcl9fbm90aGluZy1mb3VuZC1tZXNzYWdlLS1kaXNwbGF5ZWR7ZGlzcGxheTpibG9ja30uY2UtcG9wb3Zlci0tbmVzdGVkIC5jZS1wb3BvdmVyX19jb250YWluZXJ7LS1wb3BvdmVyLWxlZnQ6IGNhbGModmFyKC0tbmVzdGluZy1sZXZlbCkgKiAodmFyKC0td2lkdGgpIC0gdmFyKC0tbmVzdGVkLXBvcG92ZXItb3ZlcmxhcCkpKTt0b3A6Y2FsYyh2YXIoLS10cmlnZ2VyLWl0ZW0tdG9wKSAtIHZhcigtLW5lc3RlZC1wb3BvdmVyLW92ZXJsYXApKTtwb3NpdGlvbjphYnNvbHV0ZX0uY2UtcG9wb3Zlci0tb3Blbi10b3AuY2UtcG9wb3Zlci0tbmVzdGVkIC5jZS1wb3BvdmVyX19jb250YWluZXJ7dG9wOmNhbGModmFyKC0tdHJpZ2dlci1pdGVtLXRvcCkgLSB2YXIoLS1wb3BvdmVyLWhlaWdodCkgKyB2YXIoLS1pdGVtLWhlaWdodCkgKyB2YXIoLS1vZmZzZXQtZnJvbS10YXJnZXQpICsgdmFyKC0tbmVzdGVkLXBvcG92ZXItb3ZlcmxhcCkpfS5jZS1wb3BvdmVyLS1vcGVuLWxlZnQgLmNlLXBvcG92ZXItLW5lc3RlZCAuY2UtcG9wb3Zlcl9fY29udGFpbmVyey0tcG9wb3Zlci1sZWZ0OiBjYWxjKC0xICogKHZhcigtLW5lc3RpbmctbGV2ZWwpICsgMSkgKiB2YXIoLS13aWR0aCkgKyAxMDAlKX0uY2UtcG9wb3Zlci1pdGVtLXNlcGFyYXRvcntwYWRkaW5nOjRweCAzcHh9LmNlLXBvcG92ZXItaXRlbS1zZXBhcmF0b3ItLWhpZGRlbntkaXNwbGF5Om5vbmV9LmNlLXBvcG92ZXItaXRlbS1zZXBhcmF0b3JfX2xpbmV7aGVpZ2h0OjFweDtiYWNrZ3JvdW5kOnZhcigtLWNvbG9yLWJvcmRlcik7d2lkdGg6MTAwJX0uY2UtcG9wb3Zlci1pdGVtLWh0bWwtLWhpZGRlbntkaXNwbGF5Om5vbmV9LmNlLXBvcG92ZXItaXRlbXstLWJvcmRlci1yYWRpdXM6IDZweDtib3JkZXItcmFkaXVzOnZhcigtLWJvcmRlci1yYWRpdXMpO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyOy1tcy1mbGV4LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7cGFkZGluZzp2YXIoLS1pdGVtLXBhZGRpbmcpO2NvbG9yOnZhcigtLWNvbG9yLXRleHQtcHJpbWFyeSk7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO2JvcmRlcjpub25lO2JhY2tncm91bmQ6dHJhbnNwYXJlbnR9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtcG9wb3Zlci1pdGVte3BhZGRpbmc6NHB4fX0uY2UtcG9wb3Zlci1pdGVtOm5vdCg6bGFzdC1vZi10eXBlKXttYXJnaW4tYm90dG9tOjFweH0uY2UtcG9wb3Zlci1pdGVtX19pY29ue3dpZHRoOjI2cHg7aGVpZ2h0OjI2cHg7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjstd2Via2l0LWJveC1wYWNrOmNlbnRlcjstbXMtZmxleC1wYWNrOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5jZS1wb3BvdmVyLWl0ZW1fX2ljb24gc3Zne3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHh9QG1lZGlhIChtYXgtd2lkdGg6IDY1MHB4KXsuY2UtcG9wb3Zlci1pdGVtX19pY29ue3dpZHRoOjM2cHg7aGVpZ2h0OjM2cHg7Ym9yZGVyLXJhZGl1czo4cHh9LmNlLXBvcG92ZXItaXRlbV9faWNvbiBzdmd7d2lkdGg6MjhweDtoZWlnaHQ6MjhweH19LmNlLXBvcG92ZXItaXRlbV9faWNvbi0tdG9vbHttYXJnaW4tcmlnaHQ6NHB4fS5jZS1wb3BvdmVyLWl0ZW1fX3RpdGxle2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjIwcHg7Zm9udC13ZWlnaHQ6NTAwO292ZXJmbG93OmhpZGRlbjt3aGl0ZS1zcGFjZTpub3dyYXA7dGV4dC1vdmVyZmxvdzplbGxpcHNpczttYXJnaW4tcmlnaHQ6YXV0b31AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1wb3BvdmVyLWl0ZW1fX3RpdGxle2ZvbnQtc2l6ZToxNnB4fX0uY2UtcG9wb3Zlci1pdGVtX19zZWNvbmRhcnktdGl0bGV7Y29sb3I6dmFyKC0tY29sb3ItdGV4dC1zZWNvbmRhcnkpO2ZvbnQtc2l6ZToxMnB4O3doaXRlLXNwYWNlOm5vd3JhcDtsZXR0ZXItc3BhY2luZzotLjFlbTtwYWRkaW5nLXJpZ2h0OjVweDtvcGFjaXR5Oi42fUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXBvcG92ZXItaXRlbV9fc2Vjb25kYXJ5LXRpdGxle2Rpc3BsYXk6bm9uZX19LmNlLXBvcG92ZXItaXRlbS0tYWN0aXZle2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmFja2dyb3VuZC1pY29uLWFjdGl2ZSk7Y29sb3I6dmFyKC0tY29sb3ItdGV4dC1pY29uLWFjdGl2ZSl9LmNlLXBvcG92ZXItaXRlbS0tZGlzYWJsZWR7Y29sb3I6dmFyKC0tY29sb3ItdGV4dC1zZWNvbmRhcnkpO2N1cnNvcjpkZWZhdWx0O3BvaW50ZXItZXZlbnRzOm5vbmV9LmNlLXBvcG92ZXItaXRlbS0tZm9jdXNlZDpub3QoLmNlLXBvcG92ZXItaXRlbS0tbm8tZm9jdXMpe2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmFja2dyb3VuZC1pdGVtLWZvY3VzKSFpbXBvcnRhbnR9LmNlLXBvcG92ZXItaXRlbS0taGlkZGVue2Rpc3BsYXk6bm9uZX1AbWVkaWEgKGhvdmVyOiBob3Zlcil7LmNlLXBvcG92ZXItaXRlbTpob3ZlcntjdXJzb3I6cG9pbnRlcn0uY2UtcG9wb3Zlci1pdGVtOmhvdmVyOm5vdCguY2UtcG9wb3Zlci1pdGVtLS1uby1ob3Zlcil7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0taG92ZXIpfX0uY2UtcG9wb3Zlci1pdGVtLS1jb25maXJtYXRpb257YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0tY29uZmlybSl9LmNlLXBvcG92ZXItaXRlbS0tY29uZmlybWF0aW9uIC5jZS1wb3BvdmVyLWl0ZW1fX3RpdGxlLC5jZS1wb3BvdmVyLWl0ZW0tLWNvbmZpcm1hdGlvbiAuY2UtcG9wb3Zlci1pdGVtX19pY29ue2NvbG9yOiNmZmZ9QG1lZGlhIChob3ZlcjogaG92ZXIpey5jZS1wb3BvdmVyLWl0ZW0tLWNvbmZpcm1hdGlvbjpub3QoLmNlLXBvcG92ZXItaXRlbS0tbm8taG92ZXIpOmhvdmVye2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmFja2dyb3VuZC1pdGVtLWNvbmZpcm0taG92ZXIpfX0uY2UtcG9wb3Zlci1pdGVtLS1jb25maXJtYXRpb246bm90KC5jZS1wb3BvdmVyLWl0ZW0tLW5vLWZvY3VzKS5jZS1wb3BvdmVyLWl0ZW0tLWZvY3VzZWR7YmFja2dyb3VuZDp2YXIoLS1jb2xvci1iYWNrZ3JvdW5kLWl0ZW0tY29uZmlybS1ob3ZlcikhaW1wb3J0YW50fUAtd2Via2l0LWtleWZyYW1lcyBwYW5lbFNob3dpbmd7MCV7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLThweCkgc2NhbGUoLjkpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC04cHgpIHNjYWxlKC45KX03MCV7b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMnB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgycHgpfXRvey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCl9fUBrZXlmcmFtZXMgcGFuZWxTaG93aW5nezAle29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC04cHgpIHNjYWxlKC45KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtOHB4KSBzY2FsZSguOSl9NzAle29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDJweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMnB4KX10b3std2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApfX1ALXdlYmtpdC1rZXlmcmFtZXMgcGFuZWxTaG93aW5nTW9iaWxlezAle29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDE0cHgpIHNjYWxlKC45OCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTRweCkgc2NhbGUoLjk4KX03MCV7b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTRweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTRweCl9dG97LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKX19QGtleWZyYW1lcyBwYW5lbFNob3dpbmdNb2JpbGV7MCV7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTRweCkgc2NhbGUoLjk4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgxNHB4KSBzY2FsZSguOTgpfTcwJXtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtNHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNHB4KX10b3std2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApfX0ud29iYmxley13ZWJraXQtYW5pbWF0aW9uLW5hbWU6d29iYmxlO2FuaW1hdGlvbi1uYW1lOndvYmJsZTstd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjouNHM7YW5pbWF0aW9uLWR1cmF0aW9uOi40c31ALXdlYmtpdC1rZXlmcmFtZXMgd29iYmxlezAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKX0xNSV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTklLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC05JSwwLDApfTMwJXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCg5JSwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCg5JSwwLDApfTQ1JXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgtNCUsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTQlLDAsMCl9NjAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDQlLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDQlLDAsMCl9NzUley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC0xJSwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMSUsMCwwKX10b3std2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCl9fUBrZXlmcmFtZXMgd29iYmxlezAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKX0xNSV7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTklLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC05JSwwLDApfTMwJXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCg5JSwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCg5JSwwLDApfTQ1JXstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgtNCUsMCwwKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTQlLDAsMCl9NjAley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDQlLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDQlLDAsMCl9NzUley13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC0xJSwwLDApO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMSUsMCwwKX10b3std2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCl9fS5jZS1wb3BvdmVyLWhlYWRlcnttYXJnaW4tYm90dG9tOjhweDttYXJnaW4tdG9wOjRweDtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyfS5jZS1wb3BvdmVyLWhlYWRlcl9fdGV4dHtmb250LXNpemU6MThweDtmb250LXdlaWdodDo2MDB9LmNlLXBvcG92ZXItaGVhZGVyX19iYWNrLWJ1dHRvbntib3JkZXI6MDtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O3dpZHRoOjM2cHg7aGVpZ2h0OjM2cHg7Y29sb3I6dmFyKC0tY29sb3ItdGV4dC1wcmltYXJ5KX0uY2UtcG9wb3Zlci1oZWFkZXJfX2JhY2stYnV0dG9uIHN2Z3tkaXNwbGF5OmJsb2NrO3dpZHRoOjI4cHg7aGVpZ2h0OjI4cHh9LmNlLXBvcG92ZXItLWlubGluZXstLWhlaWdodDogMzhweDstLWhlaWdodC1tb2JpbGU6IDQ2cHg7LS1jb250YWluZXItcGFkZGluZzogNHB4O3Bvc2l0aW9uOnJlbGF0aXZlfS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXJfX2N1c3RvbS1jb250ZW50e21hcmdpbi1ib3R0b206MH0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyX19pdGVtc3tkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4fS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXJfX2NvbnRhaW5lcnstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpyb3c7ZmxleC1kaXJlY3Rpb246cm93O3BhZGRpbmc6dmFyKC0tY29udGFpbmVyLXBhZGRpbmcpO2hlaWdodDp2YXIoLS1oZWlnaHQpO3RvcDowO21pbi13aWR0aDotd2Via2l0LW1heC1jb250ZW50O21pbi13aWR0aDotbW96LW1heC1jb250ZW50O21pbi13aWR0aDptYXgtY29udGVudDt3aWR0aDotd2Via2l0LW1heC1jb250ZW50O3dpZHRoOi1tb3otbWF4LWNvbnRlbnQ7d2lkdGg6bWF4LWNvbnRlbnQ7LXdlYmtpdC1hbmltYXRpb246bm9uZTthbmltYXRpb246bm9uZX1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXJfX2NvbnRhaW5lcntoZWlnaHQ6dmFyKC0taGVpZ2h0LW1vYmlsZSk7cG9zaXRpb246YWJzb2x1dGV9fS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItaXRlbS1zZXBhcmF0b3J7cGFkZGluZzowIDRweH0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLWl0ZW0tc2VwYXJhdG9yX19saW5le2hlaWdodDoxMDAlO3dpZHRoOjFweH0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLWl0ZW17Ym9yZGVyLXJhZGl1czo0cHg7cGFkZGluZzo0cHh9LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci1pdGVtX19pY29uLS10b29sey13ZWJraXQtYm94LXNoYWRvdzpub25lO2JveC1zaGFkb3c6bm9uZTtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O21hcmdpbi1yaWdodDowfS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItaXRlbV9faWNvbnt3aWR0aDphdXRvO3dpZHRoOmluaXRpYWw7aGVpZ2h0OmF1dG87aGVpZ2h0OmluaXRpYWx9LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci1pdGVtX19pY29uIHN2Z3t3aWR0aDoyMHB4O2hlaWdodDoyMHB4fUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci1pdGVtX19pY29uIHN2Z3t3aWR0aDoyOHB4O2hlaWdodDoyOHB4fX0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLWl0ZW06bm90KDpsYXN0LW9mLXR5cGUpe21hcmdpbi1ib3R0b206MDttYXJnaW4tYm90dG9tOmluaXRpYWx9LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci1pdGVtLWh0bWx7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LW1zLWZsZXgtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcn0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLWl0ZW1fX2ljb24tLWNoZXZyb24tcmlnaHR7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDkwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDkwZGVnKX0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLS1uZXN0ZWQtbGV2ZWwtMSAuY2UtcG9wb3Zlcl9fY29udGFpbmVyey0tb2Zmc2V0OiAzcHg7bGVmdDowO3RvcDpjYWxjKHZhcigtLWhlaWdodCkgKyB2YXIoLS1vZmZzZXQpKX1AbWVkaWEgKG1heC13aWR0aDogNjUwcHgpey5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItLW5lc3RlZC1sZXZlbC0xIC5jZS1wb3BvdmVyX19jb250YWluZXJ7dG9wOmNhbGModmFyKC0taGVpZ2h0LW1vYmlsZSkgKyB2YXIoLS1vZmZzZXQpKX19LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci0tbmVzdGVkIC5jZS1wb3BvdmVyX19jb250YWluZXJ7bWluLXdpZHRoOnZhcigtLXdpZHRoKTt3aWR0aDp2YXIoLS13aWR0aCk7aGVpZ2h0Oi13ZWJraXQtZml0LWNvbnRlbnQ7aGVpZ2h0Oi1tb3otZml0LWNvbnRlbnQ7aGVpZ2h0OmZpdC1jb250ZW50O3BhZGRpbmc6NnB4Oy13ZWJraXQtYm94LW9yaWVudDp2ZXJ0aWNhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy1tcy1mbGV4LWRpcmVjdGlvbjpjb2x1bW47ZmxleC1kaXJlY3Rpb246Y29sdW1ufS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItLW5lc3RlZCAuY2UtcG9wb3Zlcl9faXRlbXN7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlfS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItLW5lc3RlZCAuY2UtcG9wb3Zlci1pdGVte2JvcmRlci1yYWRpdXM6NnB4O3BhZGRpbmc6M3B4fUBtZWRpYSAobWF4LXdpZHRoOiA2NTBweCl7LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci0tbmVzdGVkIC5jZS1wb3BvdmVyLWl0ZW17cGFkZGluZzo0cHh9fS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItLW5lc3RlZCAuY2UtcG9wb3Zlci1pdGVtX19pY29uLS10b29se21hcmdpbi1yaWdodDo0cHh9LmNlLXBvcG92ZXItLWlubGluZSAuY2UtcG9wb3Zlci0tbmVzdGVkIC5jZS1wb3BvdmVyLWl0ZW1fX2ljb257d2lkdGg6MjZweDtoZWlnaHQ6MjZweH0uY2UtcG9wb3Zlci0taW5saW5lIC5jZS1wb3BvdmVyLS1uZXN0ZWQgLmNlLXBvcG92ZXItaXRlbS1zZXBhcmF0b3J7cGFkZGluZzo0cHggM3B4fS5jZS1wb3BvdmVyLS1pbmxpbmUgLmNlLXBvcG92ZXItLW5lc3RlZCAuY2UtcG9wb3Zlci1pdGVtLXNlcGFyYXRvcl9fbGluZXt3aWR0aDoxMDAlO2hlaWdodDoxcHh9LmNvZGV4LWVkaXRvciBbZGF0YS1wbGFjZWhvbGRlcl06ZW1wdHk6YmVmb3JlLC5jb2RleC1lZGl0b3IgW2RhdGEtcGxhY2Vob2xkZXJdW2RhdGEtZW1wdHk9dHJ1ZV06YmVmb3Jle3BvaW50ZXItZXZlbnRzOm5vbmU7Y29sb3I6IzcwNzY4NDtjdXJzb3I6dGV4dDtjb250ZW50OmF0dHIoZGF0YS1wbGFjZWhvbGRlcil9LmNvZGV4LWVkaXRvciBbZGF0YS1wbGFjZWhvbGRlci1hY3RpdmVdOmVtcHR5OmJlZm9yZSwuY29kZXgtZWRpdG9yIFtkYXRhLXBsYWNlaG9sZGVyLWFjdGl2ZV1bZGF0YS1lbXB0eT10cnVlXTpiZWZvcmV7cG9pbnRlci1ldmVudHM6bm9uZTtjb2xvcjojNzA3Njg0O2N1cnNvcjp0ZXh0fS5jb2RleC1lZGl0b3IgW2RhdGEtcGxhY2Vob2xkZXItYWN0aXZlXTplbXB0eTpmb2N1czpiZWZvcmUsLmNvZGV4LWVkaXRvciBbZGF0YS1wbGFjZWhvbGRlci1hY3RpdmVdW2RhdGEtZW1wdHk9dHJ1ZV06Zm9jdXM6YmVmb3Jle2NvbnRlbnQ6YXR0cihkYXRhLXBsYWNlaG9sZGVyLWFjdGl2ZSl9XG5gO1xuY2xhc3MgSWEgZXh0ZW5kcyBFIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5pc01vYmlsZSA9ICExLCB0aGlzLmNvbnRlbnRSZWN0Q2FjaGUgPSBudWxsLCB0aGlzLnJlc2l6ZURlYm91bmNlciA9IEVvKCgpID0+IHtcbiAgICAgIHRoaXMud2luZG93UmVzaXplKCk7XG4gICAgfSwgMjAwKSwgdGhpcy5zZWxlY3Rpb25DaGFuZ2VEZWJvdW5jZWQgPSBFbygoKSA9PiB7XG4gICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICB9LCBkYSksIHRoaXMuZG9jdW1lbnRUb3VjaGVkTGlzdGVuZXIgPSAoZSkgPT4ge1xuICAgICAgdGhpcy5kb2N1bWVudFRvdWNoZWQoZSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRWRpdG9yLmpzIFVJIENTUyBjbGFzcyBuYW1lc1xuICAgKlxuICAgKiBAcmV0dXJucyB7e2VkaXRvcldyYXBwZXI6IHN0cmluZywgZWRpdG9yWm9uZTogc3RyaW5nfX1cbiAgICovXG4gIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVkaXRvcldyYXBwZXI6IFwiY29kZXgtZWRpdG9yXCIsXG4gICAgICBlZGl0b3JXcmFwcGVyTmFycm93OiBcImNvZGV4LWVkaXRvci0tbmFycm93XCIsXG4gICAgICBlZGl0b3Jab25lOiBcImNvZGV4LWVkaXRvcl9fcmVkYWN0b3JcIixcbiAgICAgIGVkaXRvclpvbmVIaWRkZW46IFwiY29kZXgtZWRpdG9yX19yZWRhY3Rvci0taGlkZGVuXCIsXG4gICAgICBlZGl0b3JFbXB0eTogXCJjb2RleC1lZGl0b3ItLWVtcHR5XCIsXG4gICAgICBlZGl0b3JSdGxGaXg6IFwiY29kZXgtZWRpdG9yLS1ydGxcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBXaWR0aCBvZiBjZW50ZXIgY29sdW1uIG9mIEVkaXRvclxuICAgKlxuICAgKiBAcmV0dXJucyB7RE9NUmVjdH1cbiAgICovXG4gIGdldCBjb250ZW50UmVjdCgpIHtcbiAgICBpZiAodGhpcy5jb250ZW50UmVjdENhY2hlICE9PSBudWxsKVxuICAgICAgcmV0dXJuIHRoaXMuY29udGVudFJlY3RDYWNoZTtcbiAgICBjb25zdCBlID0gdGhpcy5ub2Rlcy53cmFwcGVyLnF1ZXJ5U2VsZWN0b3IoYC4ke1IuQ1NTLmNvbnRlbnR9YCk7XG4gICAgcmV0dXJuIGUgPyAodGhpcy5jb250ZW50UmVjdENhY2hlID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdGhpcy5jb250ZW50UmVjdENhY2hlKSA6IHtcbiAgICAgIHdpZHRoOiA2NTAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDBcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNYWtpbmcgbWFpbiBpbnRlcmZhY2VcbiAgICovXG4gIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgdGhpcy5zZXRJc01vYmlsZSgpLCB0aGlzLm1ha2UoKSwgdGhpcy5sb2FkU3R5bGVzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZSByZWFkLW9ubHkgc3RhdGVcbiAgICpcbiAgICogSWYgcmVhZE9ubHkgaXMgdHJ1ZTpcbiAgICogIC0gcmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGZyb20gbWFpbiBVSSBtb2R1bGUgZWxlbWVudHNcbiAgICpcbiAgICogaWYgcmVhZE9ubHkgaXMgZmFsc2U6XG4gICAqICAtIGVuYWJsZXMgYWxsIGxpc3RlbmVycyB0byBVSSBtb2R1bGUgZWxlbWVudHNcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByZWFkT25seUVuYWJsZWQgLSBcInJlYWQgb25seVwiIHN0YXRlXG4gICAqL1xuICB0b2dnbGVSZWFkT25seShlKSB7XG4gICAgZSA/IHRoaXMudW5iaW5kUmVhZE9ubHlTZW5zaXRpdmVMaXN0ZW5lcnMoKSA6IHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIHRoaXMuYmluZFJlYWRPbmx5U2Vuc2l0aXZlTGlzdGVuZXJzKCk7XG4gICAgfSwge1xuICAgICAgdGltZW91dDogMmUzXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIEVkaXRvciBpcyBlbXB0eSBhbmQgc2V0IENTUyBjbGFzcyB0byB3cmFwcGVyXG4gICAqL1xuICBjaGVja0VtcHRpbmVzcygpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogZSB9ID0gdGhpcy5FZGl0b3I7XG4gICAgdGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC50b2dnbGUodGhpcy5DU1MuZWRpdG9yRW1wdHksIGUuaXNFZGl0b3JFbXB0eSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIG9uZSBvZiBUb29sYmFyIGlzIG9wZW5lZFxuICAgKiBVc2VkIHRvIHByZXZlbnQgZ2xvYmFsIGtleWRvd25zIChmb3IgZXhhbXBsZSwgRW50ZXIpIGNvbmZsaWN0cyB3aXRoIEVudGVyLW9uLXRvb2xiYXJcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgc29tZVRvb2xiYXJPcGVuZWQoKSB7XG4gICAgY29uc3QgeyBUb29sYmFyOiBlLCBCbG9ja1NldHRpbmdzOiB0LCBJbmxpbmVUb29sYmFyOiBvIH0gPSB0aGlzLkVkaXRvcjtcbiAgICByZXR1cm4gISEodC5vcGVuZWQgfHwgby5vcGVuZWQgfHwgZS50b29sYm94Lm9wZW5lZCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGZvciBzb21lIEZsaXBwZXItYnV0dG9ucyBpcyB1bmRlciBmb2N1c1xuICAgKi9cbiAgZ2V0IHNvbWVGbGlwcGVyQnV0dG9uRm9jdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5FZGl0b3IuVG9vbGJhci50b29sYm94Lmhhc0ZvY3VzKCkgPyAhMCA6IE9iamVjdC5lbnRyaWVzKHRoaXMuRWRpdG9yKS5maWx0ZXIoKFtlLCB0XSkgPT4gdC5mbGlwcGVyIGluc3RhbmNlb2YgY2UpLnNvbWUoKFtlLCB0XSkgPT4gdC5mbGlwcGVyLmhhc0ZvY3VzKCkpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhbiBlZGl0b3JgcyBVSVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm5vZGVzLmhvbGRlci5pbm5lckhUTUwgPSBcIlwiLCB0aGlzLnVuYmluZFJlYWRPbmx5SW5zZW5zaXRpdmVMaXN0ZW5lcnMoKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2UgYWxsIEVkaXRvcidzIHRvb2xiYXJzXG4gICAqL1xuICBjbG9zZUFsbFRvb2xiYXJzKCkge1xuICAgIGNvbnN0IHsgVG9vbGJhcjogZSwgQmxvY2tTZXR0aW5nczogdCwgSW5saW5lVG9vbGJhcjogbyB9ID0gdGhpcy5FZGl0b3I7XG4gICAgdC5jbG9zZSgpLCBvLmNsb3NlKCksIGUudG9vbGJveC5jbG9zZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBmb3IgbW9iaWxlIG1vZGUgYW5kIHNhdmUgdGhlIHJlc3VsdFxuICAgKi9cbiAgc2V0SXNNb2JpbGUoKSB7XG4gICAgY29uc3QgZSA9IHdpbmRvdy5pbm5lcldpZHRoIDwgUm87XG4gICAgZSAhPT0gdGhpcy5pc01vYmlsZSAmJiB0aGlzLmV2ZW50c0Rpc3BhdGNoZXIuZW1pdChUZSwge1xuICAgICAgaXNFbmFibGVkOiB0aGlzLmlzTW9iaWxlXG4gICAgfSksIHRoaXMuaXNNb2JpbGUgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBFZGl0b3IuanMgaW50ZXJmYWNlXG4gICAqL1xuICBtYWtlKCkge1xuICAgIHRoaXMubm9kZXMuaG9sZGVyID0gZC5nZXRIb2xkZXIodGhpcy5jb25maWcuaG9sZGVyKSwgdGhpcy5ub2Rlcy53cmFwcGVyID0gZC5tYWtlKFwiZGl2XCIsIFtcbiAgICAgIHRoaXMuQ1NTLmVkaXRvcldyYXBwZXIsXG4gICAgICAuLi50aGlzLmlzUnRsID8gW3RoaXMuQ1NTLmVkaXRvclJ0bEZpeF0gOiBbXVxuICAgIF0pLCB0aGlzLm5vZGVzLnJlZGFjdG9yID0gZC5tYWtlKFwiZGl2XCIsIHRoaXMuQ1NTLmVkaXRvclpvbmUpLCB0aGlzLm5vZGVzLmhvbGRlci5vZmZzZXRXaWR0aCA8IHRoaXMuY29udGVudFJlY3Qud2lkdGggJiYgdGhpcy5ub2Rlcy53cmFwcGVyLmNsYXNzTGlzdC5hZGQodGhpcy5DU1MuZWRpdG9yV3JhcHBlck5hcnJvdyksIHRoaXMubm9kZXMucmVkYWN0b3Iuc3R5bGUucGFkZGluZ0JvdHRvbSA9IHRoaXMuY29uZmlnLm1pbkhlaWdodCArIFwicHhcIiwgdGhpcy5ub2Rlcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMubm9kZXMucmVkYWN0b3IpLCB0aGlzLm5vZGVzLmhvbGRlci5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLndyYXBwZXIpLCB0aGlzLmJpbmRSZWFkT25seUluc2Vuc2l0aXZlTGlzdGVuZXJzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGVuZHMgQ1NTXG4gICAqL1xuICBsb2FkU3R5bGVzKCkge1xuICAgIGNvbnN0IGUgPSBcImVkaXRvci1qcy1zdHlsZXNcIjtcbiAgICBpZiAoZC5nZXQoZSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IGQubWFrZShcInN0eWxlXCIsIG51bGwsIHtcbiAgICAgIGlkOiBlLFxuICAgICAgdGV4dENvbnRlbnQ6IFNhLnRvU3RyaW5nKClcbiAgICB9KTtcbiAgICB0aGlzLmNvbmZpZy5zdHlsZSAmJiAhVih0aGlzLmNvbmZpZy5zdHlsZSkgJiYgdGhpcy5jb25maWcuc3R5bGUubm9uY2UgJiYgdC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCB0aGlzLmNvbmZpZy5zdHlsZS5ub25jZSksIGQucHJlcGVuZChkb2N1bWVudC5oZWFkLCB0KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBsaXN0ZW5lcnMgdGhhdCBzaG91bGQgd29yayBib3RoIGluIHJlYWQtb25seSBhbmQgcmVhZC13cml0ZSBtb2Rlc1xuICAgKi9cbiAgYmluZFJlYWRPbmx5SW5zZW5zaXRpdmVMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMub24oZG9jdW1lbnQsIFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMuc2VsZWN0aW9uQ2hhbmdlRGVib3VuY2VkKSwgdGhpcy5saXN0ZW5lcnMub24od2luZG93LCBcInJlc2l6ZVwiLCB0aGlzLnJlc2l6ZURlYm91bmNlciwge1xuICAgICAgcGFzc2l2ZTogITBcbiAgICB9KSwgdGhpcy5saXN0ZW5lcnMub24odGhpcy5ub2Rlcy5yZWRhY3RvciwgXCJtb3VzZWRvd25cIiwgdGhpcy5kb2N1bWVudFRvdWNoZWRMaXN0ZW5lciwge1xuICAgICAgY2FwdHVyZTogITAsXG4gICAgICBwYXNzaXZlOiAhMFxuICAgIH0pLCB0aGlzLmxpc3RlbmVycy5vbih0aGlzLm5vZGVzLnJlZGFjdG9yLCBcInRvdWNoc3RhcnRcIiwgdGhpcy5kb2N1bWVudFRvdWNoZWRMaXN0ZW5lciwge1xuICAgICAgY2FwdHVyZTogITAsXG4gICAgICBwYXNzaXZlOiAhMFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGxpc3RlbmVycyB0aGF0IHNob3VsZCB3b3JrIGJvdGggaW4gcmVhZC1vbmx5IGFuZCByZWFkLXdyaXRlIG1vZGVzXG4gICAqL1xuICB1bmJpbmRSZWFkT25seUluc2Vuc2l0aXZlTGlzdGVuZXJzKCkge1xuICAgIHRoaXMubGlzdGVuZXJzLm9mZihkb2N1bWVudCwgXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5zZWxlY3Rpb25DaGFuZ2VEZWJvdW5jZWQpLCB0aGlzLmxpc3RlbmVycy5vZmYod2luZG93LCBcInJlc2l6ZVwiLCB0aGlzLnJlc2l6ZURlYm91bmNlciksIHRoaXMubGlzdGVuZXJzLm9mZih0aGlzLm5vZGVzLnJlZGFjdG9yLCBcIm1vdXNlZG93blwiLCB0aGlzLmRvY3VtZW50VG91Y2hlZExpc3RlbmVyKSwgdGhpcy5saXN0ZW5lcnMub2ZmKHRoaXMubm9kZXMucmVkYWN0b3IsIFwidG91Y2hzdGFydFwiLCB0aGlzLmRvY3VtZW50VG91Y2hlZExpc3RlbmVyKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBsaXN0ZW5lcnMgdGhhdCBzaG91bGQgd29yayBvbmx5IGluIHJlYWQtb25seSBtb2RlXG4gICAqL1xuICBiaW5kUmVhZE9ubHlTZW5zaXRpdmVMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMub24odGhpcy5ub2Rlcy5yZWRhY3RvciwgXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgdGhpcy5yZWRhY3RvckNsaWNrZWQoZSk7XG4gICAgfSwgITEpLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbihkb2N1bWVudCwgXCJrZXlkb3duXCIsIChlKSA9PiB7XG4gICAgICB0aGlzLmRvY3VtZW50S2V5ZG93bihlKTtcbiAgICB9LCAhMCksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKGRvY3VtZW50LCBcIm1vdXNlZG93blwiLCAoZSkgPT4ge1xuICAgICAgdGhpcy5kb2N1bWVudENsaWNrZWQoZSk7XG4gICAgfSwgITApLCB0aGlzLndhdGNoQmxvY2tIb3ZlcmVkRXZlbnRzKCksIHRoaXMuZW5hYmxlSW5wdXRzRW1wdHlNYXJrKCk7XG4gIH1cbiAgLyoqXG4gICAqIExpc3RlbiByZWRhY3RvciBtb3VzZW1vdmUgdG8gZW1pdCAnYmxvY2staG92ZXJlZCcgZXZlbnRcbiAgICovXG4gIHdhdGNoQmxvY2tIb3ZlcmVkRXZlbnRzKCkge1xuICAgIGxldCBlO1xuICAgIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKHRoaXMubm9kZXMucmVkYWN0b3IsIFwibW91c2Vtb3ZlXCIsIGR0KCh0KSA9PiB7XG4gICAgICBjb25zdCBvID0gdC50YXJnZXQuY2xvc2VzdChcIi5jZS1ibG9ja1wiKTtcbiAgICAgIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmFueUJsb2NrU2VsZWN0ZWQgfHwgbyAmJiBlICE9PSBvICYmIChlID0gbywgdGhpcy5ldmVudHNEaXNwYXRjaGVyLmVtaXQobG4sIHtcbiAgICAgICAgYmxvY2s6IHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5nZXRCbG9ja0J5Q2hpbGROb2RlKG8pXG4gICAgICB9KSk7XG4gICAgfSwgMjApLCB7XG4gICAgICBwYXNzaXZlOiAhMFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVbmJpbmQgZXZlbnRzIHRoYXQgc2hvdWxkIHdvcmsgb25seSBpbiByZWFkLW9ubHkgbW9kZVxuICAgKi9cbiAgdW5iaW5kUmVhZE9ubHlTZW5zaXRpdmVMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5yZWFkT25seU11dGFibGVMaXN0ZW5lcnMuY2xlYXJBbGwoKTtcbiAgfVxuICAvKipcbiAgICogUmVzaXplIHdpbmRvdyBoYW5kbGVyXG4gICAqL1xuICB3aW5kb3dSZXNpemUoKSB7XG4gICAgdGhpcy5jb250ZW50UmVjdENhY2hlID0gbnVsbCwgdGhpcy5zZXRJc01vYmlsZSgpO1xuICB9XG4gIC8qKlxuICAgKiBBbGwga2V5ZG93bnMgb24gZG9jdW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWJvYXJkIGV2ZW50XG4gICAqL1xuICBkb2N1bWVudEtleWRvd24oZSkge1xuICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICBjYXNlIHkuRU5URVI6XG4gICAgICAgIHRoaXMuZW50ZXJQcmVzc2VkKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgeS5CQUNLU1BBQ0U6XG4gICAgICBjYXNlIHkuREVMRVRFOlxuICAgICAgICB0aGlzLmJhY2tzcGFjZVByZXNzZWQoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB5LkVTQzpcbiAgICAgICAgdGhpcy5lc2NhcGVQcmVzc2VkKGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuZGVmYXVsdEJlaGF2aW91cihlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBJZ25vcmUgYWxsIG90aGVyIGRvY3VtZW50J3Mga2V5ZG93biBldmVudHNcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWJvYXJkIGV2ZW50XG4gICAqL1xuICBkZWZhdWx0QmVoYXZpb3VyKGUpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRCbG9jazogdCB9ID0gdGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLCBvID0gZS50YXJnZXQuY2xvc2VzdChgLiR7dGhpcy5DU1MuZWRpdG9yV3JhcHBlcn1gKSwgaSA9IGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleTtcbiAgICBpZiAodCAhPT0gdm9pZCAwICYmIG8gPT09IG51bGwpIHtcbiAgICAgIHRoaXMuRWRpdG9yLkJsb2NrRXZlbnRzLmtleWRvd24oZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG8gfHwgdCAmJiBpIHx8ICh0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIudW5zZXRDdXJyZW50QmxvY2soKSwgdGhpcy5FZGl0b3IuVG9vbGJhci5jbG9zZSgpKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCAtIGtleWJvYXJkIGV2ZW50XG4gICAqL1xuICBiYWNrc3BhY2VQcmVzc2VkKGUpIHtcbiAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogdCwgQmxvY2tTZWxlY3Rpb246IG8sIENhcmV0OiBpIH0gPSB0aGlzLkVkaXRvcjtcbiAgICBpZiAoby5hbnlCbG9ja1NlbGVjdGVkICYmICFiLmlzU2VsZWN0aW9uRXhpc3RzKSB7XG4gICAgICBjb25zdCBzID0gdC5yZW1vdmVTZWxlY3RlZEJsb2NrcygpLCByID0gdC5pbnNlcnREZWZhdWx0QmxvY2tBdEluZGV4KHMsICEwKTtcbiAgICAgIGkuc2V0VG9CbG9jayhyLCBpLnBvc2l0aW9ucy5TVEFSVCksIG8uY2xlYXJTZWxlY3Rpb24oZSksIGUucHJldmVudERlZmF1bHQoKSwgZS5zdG9wUHJvcGFnYXRpb24oKSwgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVzY2FwZSBwcmVzc2VkXG4gICAqIElmIHNvbWUgb2YgVG9vbGJhciBjb21wb25lbnRzIGFyZSBvcGVuZWQsIHRoZW4gY2xvc2UgaXQgb3RoZXJ3aXNlIGNsb3NlIFRvb2xiYXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBlc2NhcGUga2V5ZG93biBldmVudFxuICAgKi9cbiAgZXNjYXBlUHJlc3NlZChlKSB7XG4gICAgdGhpcy5FZGl0b3IuQmxvY2tTZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oZSksIHRoaXMuRWRpdG9yLlRvb2xiYXIudG9vbGJveC5vcGVuZWQgPyAodGhpcy5FZGl0b3IuVG9vbGJhci50b29sYm94LmNsb3NlKCksIHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2sodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jaywgdGhpcy5FZGl0b3IuQ2FyZXQucG9zaXRpb25zLkVORCkpIDogdGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuZWQgPyB0aGlzLkVkaXRvci5CbG9ja1NldHRpbmdzLmNsb3NlKCkgOiB0aGlzLkVkaXRvci5JbmxpbmVUb29sYmFyLm9wZW5lZCA/IHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKSA6IHRoaXMuRWRpdG9yLlRvb2xiYXIuY2xvc2UoKTtcbiAgfVxuICAvKipcbiAgICogRW50ZXIgcHJlc3NlZCBvbiBkb2N1bWVudFxuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50IC0ga2V5Ym9hcmQgZXZlbnRcbiAgICovXG4gIGVudGVyUHJlc3NlZChlKSB7XG4gICAgY29uc3QgeyBCbG9ja01hbmFnZXI6IHQsIEJsb2NrU2VsZWN0aW9uOiBvIH0gPSB0aGlzLkVkaXRvcjtcbiAgICBpZiAodGhpcy5zb21lVG9vbGJhck9wZW5lZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gdC5jdXJyZW50QmxvY2tJbmRleCA+PSAwO1xuICAgIGlmIChvLmFueUJsb2NrU2VsZWN0ZWQgJiYgIWIuaXNTZWxlY3Rpb25FeGlzdHMpIHtcbiAgICAgIG8uY2xlYXJTZWxlY3Rpb24oZSksIGUucHJldmVudERlZmF1bHQoKSwgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnNvbWVUb29sYmFyT3BlbmVkICYmIGkgJiYgZS50YXJnZXQudGFnTmFtZSA9PT0gXCJCT0RZXCIpIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuaW5zZXJ0KCk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuRWRpdG9yLkNhcmV0LnNldFRvQmxvY2socyksIHRoaXMuRWRpdG9yLlRvb2xiYXIubW92ZUFuZE9wZW4ocyk7XG4gICAgfVxuICAgIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKGUpO1xuICB9XG4gIC8qKlxuICAgKiBBbGwgY2xpY2tzIG9uIGRvY3VtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBDbGljayBldmVudFxuICAgKi9cbiAgZG9jdW1lbnRDbGlja2VkKGUpIHtcbiAgICB2YXIgYSwgbDtcbiAgICBpZiAoIWUuaXNUcnVzdGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBlLnRhcmdldDtcbiAgICB0aGlzLm5vZGVzLmhvbGRlci5jb250YWlucyh0KSB8fCBiLmlzQXRFZGl0b3IgfHwgKHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci51bnNldEN1cnJlbnRCbG9jaygpLCB0aGlzLkVkaXRvci5Ub29sYmFyLmNsb3NlKCkpO1xuICAgIGNvbnN0IGkgPSAoYSA9IHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3Mubm9kZXMud3JhcHBlcikgPT0gbnVsbCA/IHZvaWQgMCA6IGEuY29udGFpbnModCksIHMgPSAobCA9IHRoaXMuRWRpdG9yLlRvb2xiYXIubm9kZXMuc2V0dGluZ3NUb2dnbGVyKSA9PSBudWxsID8gdm9pZCAwIDogbC5jb250YWlucyh0KSwgciA9IGkgfHwgcztcbiAgICBpZiAodGhpcy5FZGl0b3IuQmxvY2tTZXR0aW5ncy5vcGVuZWQgJiYgIXIpIHtcbiAgICAgIHRoaXMuRWRpdG9yLkJsb2NrU2V0dGluZ3MuY2xvc2UoKTtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUNoaWxkTm9kZSh0KTtcbiAgICAgIHRoaXMuRWRpdG9yLlRvb2xiYXIubW92ZUFuZE9wZW4oYyk7XG4gICAgfVxuICAgIHRoaXMuRWRpdG9yLkJsb2NrU2VsZWN0aW9uLmNsZWFyU2VsZWN0aW9uKGUpO1xuICB9XG4gIC8qKlxuICAgKiBGaXJzdCB0b3VjaCBvbiBlZGl0b3JcbiAgICogRmlyZWQgYmVmb3JlIGNsaWNrXG4gICAqXG4gICAqIFVzZWQgdG8gY2hhbmdlIGN1cnJlbnQgYmxvY2sg4oCUIHdlIG5lZWQgdG8gZG8gaXQgYmVmb3JlICdzZWxlY3Rpb25DaGFuZ2UnIGV2ZW50LlxuICAgKiBBbHNvOlxuICAgKiAtIE1vdmUgYW5kIHNob3cgdGhlIFRvb2xiYXJcbiAgICogLSBTZXQgYSBDYXJldFxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSB0b3VjaCBvciBtb3VzZSBldmVudFxuICAgKi9cbiAgZG9jdW1lbnRUb3VjaGVkKGUpIHtcbiAgICBsZXQgdCA9IGUudGFyZ2V0O1xuICAgIGlmICh0ID09PSB0aGlzLm5vZGVzLnJlZGFjdG9yKSB7XG4gICAgICBjb25zdCBvID0gZSBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgPyBlLmNsaWVudFggOiBlLnRvdWNoZXNbMF0uY2xpZW50WCwgaSA9IGUgaW5zdGFuY2VvZiBNb3VzZUV2ZW50ID8gZS5jbGllbnRZIDogZS50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICB0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChvLCBpKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuRWRpdG9yLkJsb2NrTWFuYWdlci5zZXRDdXJyZW50QmxvY2tCeUNoaWxkTm9kZSh0KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRoaXMuRWRpdG9yLlJlY3RhbmdsZVNlbGVjdGlvbi5pc1JlY3RBY3RpdmF0ZWQoKSB8fCB0aGlzLkVkaXRvci5DYXJldC5zZXRUb1RoZUxhc3RCbG9jaygpO1xuICAgIH1cbiAgICB0aGlzLkVkaXRvci5SZWFkT25seS5pc0VuYWJsZWQgfHwgdGhpcy5FZGl0b3IuVG9vbGJhci5tb3ZlQW5kT3BlbigpO1xuICB9XG4gIC8qKlxuICAgKiBBbGwgY2xpY2tzIG9uIHRoZSByZWRhY3RvciB6b25lXG4gICAqXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBjbGljayBldmVudFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogLSBCeSBjbGlja3Mgb24gdGhlIEVkaXRvcidzIGJvdHRvbSB6b25lOlxuICAgKiAgICAgIC0gaWYgbGFzdCBCbG9jayBpcyBlbXB0eSwgc2V0IGEgQ2FyZXQgdG8gdGhpc1xuICAgKiAgICAgIC0gb3RoZXJ3aXNlLCBhZGQgYSBuZXcgZW1wdHkgQmxvY2sgYW5kIHNldCBhIENhcmV0IHRvIHRoYXRcbiAgICovXG4gIHJlZGFjdG9yQ2xpY2tlZChlKSB7XG4gICAgaWYgKCFiLmlzQ29sbGFwc2VkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBlLnRhcmdldCwgbyA9IGUubWV0YUtleSB8fCBlLmN0cmxLZXk7XG4gICAgaWYgKGQuaXNBbmNob3IodCkgJiYgbykge1xuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGNvbnN0IGkgPSB0LmdldEF0dHJpYnV0ZShcImhyZWZcIiksIHMgPSBvaShpKTtcbiAgICAgIGlpKHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NCb3R0b21ab25lQ2xpY2soZSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHVzZXIgY2xpY2tzIG9uIHRoZSBFZGl0b3IncyBib3R0b20gem9uZTpcbiAgICogIC0gc2V0IGNhcmV0IHRvIHRoZSBsYXN0IGJsb2NrXG4gICAqICAtIG9yIGFkZCBuZXcgZW1wdHkgYmxvY2tcbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gY2xpY2sgZXZlbnRcbiAgICovXG4gIHByb2Nlc3NCb3R0b21ab25lQ2xpY2soZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuZ2V0QmxvY2tCeUluZGV4KC0xKSwgbyA9IGQub2Zmc2V0KHQuaG9sZGVyKS5ib3R0b20sIGkgPSBlLnBhZ2VZLCB7IEJsb2NrU2VsZWN0aW9uOiBzIH0gPSB0aGlzLkVkaXRvcjtcbiAgICBpZiAoZS50YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50ICYmIGUudGFyZ2V0LmlzRXF1YWxOb2RlKHRoaXMubm9kZXMucmVkYWN0b3IpICYmIC8qKlxuICAgICogSWYgdGhlcmUgaXMgY3Jvc3MgYmxvY2sgc2VsZWN0aW9uIHN0YXJ0ZWQsIHRhcmdldCB3aWxsIGJlIGVxdWFsIHRvIHJlZGFjdG9yIHNvIHdlIG5lZWQgYWRkaXRpb25hbCBjaGVja1xuICAgICovXG4gICAgIXMuYW55QmxvY2tTZWxlY3RlZCAmJiAvKipcbiAgICAqIFByZXZlbnQgY2FyZXQganVtcGluZyAodG8gbGFzdCBibG9jaykgd2hlbiBjbGlja2luZyBiZXR3ZWVuIGJsb2Nrc1xuICAgICovXG4gICAgbyA8IGkpIHtcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogYSwgQ2FyZXQ6IGwsIFRvb2xiYXI6IGMgfSA9IHRoaXMuRWRpdG9yO1xuICAgICAgKCFhLmxhc3RCbG9jay50b29sLmlzRGVmYXVsdCB8fCAhYS5sYXN0QmxvY2suaXNFbXB0eSkgJiYgYS5pbnNlcnRBdEVuZCgpLCBsLnNldFRvVGhlTGFzdEJsb2NrKCksIGMubW92ZUFuZE9wZW4oYS5sYXN0QmxvY2spO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlIHNlbGVjdGlvbiBjaGFuZ2VzIG9uIG1vYmlsZSBkZXZpY2VzXG4gICAqIFVzZXMgZm9yIHNob3dpbmcgdGhlIElubGluZSBUb29sYmFyXG4gICAqL1xuICBzZWxlY3Rpb25DaGFuZ2VkKCkge1xuICAgIGNvbnN0IHsgQ3Jvc3NCbG9ja1NlbGVjdGlvbjogZSwgQmxvY2tTZWxlY3Rpb246IHQgfSA9IHRoaXMuRWRpdG9yLCBvID0gYi5hbmNob3JFbGVtZW50O1xuICAgIGlmIChlLmlzQ3Jvc3NCbG9ja1NlbGVjdGlvblN0YXJ0ZWQgJiYgdC5hbnlCbG9ja1NlbGVjdGVkICYmIGIuZ2V0KCkucmVtb3ZlQWxsUmFuZ2VzKCksICFvKSB7XG4gICAgICBiLnJhbmdlIHx8IHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaSA9IG8uY2xvc2VzdChgLiR7Ui5DU1MuY29udGVudH1gKTtcbiAgICAoaSA9PT0gbnVsbCB8fCBpLmNsb3Nlc3QoYC4ke2IuQ1NTLmVkaXRvcldyYXBwZXJ9YCkgIT09IHRoaXMubm9kZXMud3JhcHBlcikgJiYgKHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY29udGFpbnNOb2RlKG8pIHx8IHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIuY2xvc2UoKSwgIShvLmRhdGFzZXQuaW5saW5lVG9vbGJhciA9PT0gXCJ0cnVlXCIpKSB8fCAodGhpcy5FZGl0b3IuQmxvY2tNYW5hZ2VyLmN1cnJlbnRCbG9jayB8fCB0aGlzLkVkaXRvci5CbG9ja01hbmFnZXIuc2V0Q3VycmVudEJsb2NrQnlDaGlsZE5vZGUobyksIHRoaXMuRWRpdG9yLklubGluZVRvb2xiYXIudHJ5VG9TaG93KCEwKSk7XG4gIH1cbiAgLyoqXG4gICAqIEVkaXRvci5qcyBwcm92aWRlcyBhbmQgYWJpbGl0eSB0byBzaG93IHBsYWNlaG9sZGVycyBmb3IgZW1wdHkgY29udGVudGVkaXRhYmxlIGVsZW1lbnRzXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHdhdGNoZXMgZm9yIGlucHV0IGFuZCBmb2N1cyBldmVudHMgYW5kIHRvZ2dsZXMgJ2RhdGEtZW1wdHknIGF0dHJpYnV0ZVxuICAgKiB0byB3b3JrYXJvdWQgdGhlIGNhc2UsIHdoZW4gaW5wdXRzIGNvbnRhaW5zIG9ubHkgPGJyPnMgYW5kIGhhcyBubyB2aXNpYmxlIGNvbnRlbnRcbiAgICogVGhlbiwgQ1NTIGNvdWxkIHJlbHkgb24gdGhpcyBhdHRyaWJ1dGUgdG8gc2hvdyBwbGFjZWhvbGRlcnNcbiAgICovXG4gIGVuYWJsZUlucHV0c0VtcHR5TWFyaygpIHtcbiAgICBmdW5jdGlvbiBlKHQpIHtcbiAgICAgIGNvbnN0IG8gPSB0LnRhcmdldDtcbiAgICAgIERvKG8pO1xuICAgIH1cbiAgICB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbih0aGlzLm5vZGVzLndyYXBwZXIsIFwiaW5wdXRcIiwgZSksIHRoaXMucmVhZE9ubHlNdXRhYmxlTGlzdGVuZXJzLm9uKHRoaXMubm9kZXMud3JhcHBlciwgXCJmb2N1c2luXCIsIGUpLCB0aGlzLnJlYWRPbmx5TXV0YWJsZUxpc3RlbmVycy5vbih0aGlzLm5vZGVzLndyYXBwZXIsIFwiZm9jdXNvdXRcIiwgZSk7XG4gIH1cbn1cbmNvbnN0IE9hID0ge1xuICAvLyBBUEkgTW9kdWxlc1xuICBCbG9ja3NBUEk6IGdpLFxuICBDYXJldEFQSTogYmksXG4gIEV2ZW50c0FQSTogdmksXG4gIEkxOG5BUEk6IGt0LFxuICBBUEk6IGtpLFxuICBJbmxpbmVUb29sYmFyQVBJOiB5aSxcbiAgTGlzdGVuZXJzQVBJOiB3aSxcbiAgTm90aWZpZXJBUEk6IENpLFxuICBSZWFkT25seUFQSTogVGksXG4gIFNhbml0aXplckFQSTogTGksXG4gIFNhdmVyQVBJOiBQaSxcbiAgU2VsZWN0aW9uQVBJOiBOaSxcbiAgVG9vbHNBUEk6IFJpLFxuICBTdHlsZXNBUEk6IERpLFxuICBUb29sYmFyQVBJOiBGaSxcbiAgVG9vbHRpcEFQSTogVWksXG4gIFVpQVBJOiBXaSxcbiAgLy8gVG9vbGJhciBNb2R1bGVzXG4gIEJsb2NrU2V0dGluZ3M6IG1zLFxuICBUb29sYmFyOiBCcyxcbiAgSW5saW5lVG9vbGJhcjogQ3MsXG4gIC8vIE1vZHVsZXNcbiAgQmxvY2tFdmVudHM6IG5hLFxuICBCbG9ja01hbmFnZXI6IHJhLFxuICBCbG9ja1NlbGVjdGlvbjogYWEsXG4gIENhcmV0OiBZZSxcbiAgQ3Jvc3NCbG9ja1NlbGVjdGlvbjogbGEsXG4gIERyYWdORHJvcDogY2EsXG4gIE1vZGlmaWNhdGlvbnNPYnNlcnZlcjogaGEsXG4gIFBhc3RlOiBwYSxcbiAgUmVhZE9ubHk6IGZhLFxuICBSZWN0YW5nbGVTZWxlY3Rpb246IEJlLFxuICBSZW5kZXJlcjogZ2EsXG4gIFNhdmVyOiBtYSxcbiAgVG9vbHM6IFduLFxuICBVSTogSWFcbn07XG5jbGFzcyBfYSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VkaXRvckNvbmZpZ30gY29uZmlnIC0gdXNlciBjb25maWd1cmF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5tb2R1bGVJbnN0YW5jZXMgPSB7fSwgdGhpcy5ldmVudHNEaXNwYXRjaGVyID0gbmV3IE9lKCk7XG4gICAgbGV0IHQsIG87XG4gICAgdGhpcy5pc1JlYWR5ID0gbmV3IFByb21pc2UoKGksIHMpID0+IHtcbiAgICAgIHQgPSBpLCBvID0gcztcbiAgICB9KSwgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBlLCB0aGlzLnZhbGlkYXRlKCksIHRoaXMuaW5pdCgpLCBhd2FpdCB0aGlzLnN0YXJ0KCksIGF3YWl0IHRoaXMucmVuZGVyKCk7XG4gICAgICBjb25zdCB7IEJsb2NrTWFuYWdlcjogaSwgQ2FyZXQ6IHMsIFVJOiByLCBNb2RpZmljYXRpb25zT2JzZXJ2ZXI6IGEgfSA9IHRoaXMubW9kdWxlSW5zdGFuY2VzO1xuICAgICAgci5jaGVja0VtcHRpbmVzcygpLCBhLmVuYWJsZSgpLCB0aGlzLmNvbmZpZ3VyYXRpb24uYXV0b2ZvY3VzID09PSAhMCAmJiB0aGlzLmNvbmZpZ3VyYXRpb24ucmVhZE9ubHkgIT09ICEwICYmIHMuc2V0VG9CbG9jayhpLmJsb2Nrc1swXSwgcy5wb3NpdGlvbnMuU1RBUlQpLCB0KCk7XG4gICAgfSkuY2F0Y2goKGkpID0+IHtcbiAgICAgIFMoYEVkaXRvci5qcyBpcyBub3QgcmVhZHkgYmVjYXVzZSBvZiAke2l9YCwgXCJlcnJvclwiKSwgbyhpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2V0dGluZyBmb3IgY29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0VkaXRvckNvbmZpZ3xzdHJpbmd9IGNvbmZpZyAtIEVkaXRvcidzIGNvbmZpZyB0byBzZXRcbiAgICovXG4gIHNldCBjb25maWd1cmF0aW9uKGUpIHtcbiAgICB2YXIgbywgaTtcbiAgICBEKGUpID8gdGhpcy5jb25maWcgPSB7XG4gICAgICAuLi5lXG4gICAgfSA6IHRoaXMuY29uZmlnID0ge1xuICAgICAgaG9sZGVyOiBlXG4gICAgfSwgaHQoISF0aGlzLmNvbmZpZy5ob2xkZXJJZCwgXCJjb25maWcuaG9sZGVySWRcIiwgXCJjb25maWcuaG9sZGVyXCIpLCB0aGlzLmNvbmZpZy5ob2xkZXJJZCAmJiAhdGhpcy5jb25maWcuaG9sZGVyICYmICh0aGlzLmNvbmZpZy5ob2xkZXIgPSB0aGlzLmNvbmZpZy5ob2xkZXJJZCwgdGhpcy5jb25maWcuaG9sZGVySWQgPSBudWxsKSwgdGhpcy5jb25maWcuaG9sZGVyID09IG51bGwgJiYgKHRoaXMuY29uZmlnLmhvbGRlciA9IFwiZWRpdG9yanNcIiksIHRoaXMuY29uZmlnLmxvZ0xldmVsIHx8ICh0aGlzLmNvbmZpZy5sb2dMZXZlbCA9IExvLlZFUkJPU0UpLCBabih0aGlzLmNvbmZpZy5sb2dMZXZlbCksIGh0KCEhdGhpcy5jb25maWcuaW5pdGlhbEJsb2NrLCBcImNvbmZpZy5pbml0aWFsQmxvY2tcIiwgXCJjb25maWcuZGVmYXVsdEJsb2NrXCIpLCB0aGlzLmNvbmZpZy5kZWZhdWx0QmxvY2sgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QmxvY2sgfHwgdGhpcy5jb25maWcuaW5pdGlhbEJsb2NrIHx8IFwicGFyYWdyYXBoXCIsIHRoaXMuY29uZmlnLm1pbkhlaWdodCA9IHRoaXMuY29uZmlnLm1pbkhlaWdodCAhPT0gdm9pZCAwID8gdGhpcy5jb25maWcubWluSGVpZ2h0IDogMzAwO1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICB0eXBlOiB0aGlzLmNvbmZpZy5kZWZhdWx0QmxvY2ssXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgdGhpcy5jb25maWcucGxhY2Vob2xkZXIgPSB0aGlzLmNvbmZpZy5wbGFjZWhvbGRlciB8fCAhMSwgdGhpcy5jb25maWcuc2FuaXRpemVyID0gdGhpcy5jb25maWcuc2FuaXRpemVyIHx8IHtcbiAgICAgIHA6ICEwLFxuICAgICAgYjogITAsXG4gICAgICBhOiAhMFxuICAgIH0sIHRoaXMuY29uZmlnLmhpZGVUb29sYmFyID0gdGhpcy5jb25maWcuaGlkZVRvb2xiYXIgPyB0aGlzLmNvbmZpZy5oaWRlVG9vbGJhciA6ICExLCB0aGlzLmNvbmZpZy50b29scyA9IHRoaXMuY29uZmlnLnRvb2xzIHx8IHt9LCB0aGlzLmNvbmZpZy5pMThuID0gdGhpcy5jb25maWcuaTE4biB8fCB7fSwgdGhpcy5jb25maWcuZGF0YSA9IHRoaXMuY29uZmlnLmRhdGEgfHwgeyBibG9ja3M6IFtdIH0sIHRoaXMuY29uZmlnLm9uUmVhZHkgPSB0aGlzLmNvbmZpZy5vblJlYWR5IHx8ICgoKSA9PiB7XG4gICAgfSksIHRoaXMuY29uZmlnLm9uQ2hhbmdlID0gdGhpcy5jb25maWcub25DaGFuZ2UgfHwgKCgpID0+IHtcbiAgICB9KSwgdGhpcy5jb25maWcuaW5saW5lVG9vbGJhciA9IHRoaXMuY29uZmlnLmlubGluZVRvb2xiYXIgIT09IHZvaWQgMCA/IHRoaXMuY29uZmlnLmlubGluZVRvb2xiYXIgOiAhMCwgKFYodGhpcy5jb25maWcuZGF0YSkgfHwgIXRoaXMuY29uZmlnLmRhdGEuYmxvY2tzIHx8IHRoaXMuY29uZmlnLmRhdGEuYmxvY2tzLmxlbmd0aCA9PT0gMCkgJiYgKHRoaXMuY29uZmlnLmRhdGEgPSB7IGJsb2NrczogW3RdIH0pLCB0aGlzLmNvbmZpZy5yZWFkT25seSA9IHRoaXMuY29uZmlnLnJlYWRPbmx5IHx8ICExLCAobyA9IHRoaXMuY29uZmlnLmkxOG4pICE9IG51bGwgJiYgby5tZXNzYWdlcyAmJiB6LnNldERpY3Rpb25hcnkodGhpcy5jb25maWcuaTE4bi5tZXNzYWdlcyksIHRoaXMuY29uZmlnLmkxOG4uZGlyZWN0aW9uID0gKChpID0gdGhpcy5jb25maWcuaTE4bikgPT0gbnVsbCA/IHZvaWQgMCA6IGkuZGlyZWN0aW9uKSB8fCBcImx0clwiO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHByaXZhdGUgcHJvcGVydHlcbiAgICpcbiAgICogQHJldHVybnMge0VkaXRvckNvbmZpZ31cbiAgICovXG4gIGdldCBjb25maWd1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGZvciByZXF1aXJlZCBmaWVsZHMgaW4gRWRpdG9yJ3MgY29uZmlnXG4gICAqL1xuICB2YWxpZGF0ZSgpIHtcbiAgICBjb25zdCB7IGhvbGRlcklkOiBlLCBob2xkZXI6IHQgfSA9IHRoaXMuY29uZmlnO1xuICAgIGlmIChlICYmIHQpXG4gICAgICB0aHJvdyBFcnJvcihcIsKraG9sZGVySWTCuyBhbmQgwqtob2xkZXLCuyBwYXJhbSBjYW4ndCBhc3NpZ24gYXQgdGhlIHNhbWUgdGltZS5cIik7XG4gICAgaWYgKHRlKHQpICYmICFkLmdldCh0KSlcbiAgICAgIHRocm93IEVycm9yKGBlbGVtZW50IHdpdGggSUQgwqske3R9wrsgaXMgbWlzc2luZy4gUGFzcyBjb3JyZWN0IGhvbGRlcidzIElELmApO1xuICAgIGlmICh0ICYmIEQodCkgJiYgIWQuaXNFbGVtZW50KHQpKVxuICAgICAgdGhyb3cgRXJyb3IoXCLCq2hvbGRlcsK7IHZhbHVlIG11c3QgYmUgYW4gRWxlbWVudCBub2RlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBtb2R1bGVzOlxuICAgKiAgLSBtYWtlIGFuZCBzYXZlIGluc3RhbmNlc1xuICAgKiAgLSBjb25maWd1cmVcbiAgICovXG4gIGluaXQoKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RNb2R1bGVzKCksIHRoaXMuY29uZmlndXJlTW9kdWxlcygpO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBFZGl0b3IhXG4gICAqXG4gICAqIEdldCBsaXN0IG9mIG1vZHVsZXMgdGhhdCBuZWVkcyB0byBiZSBwcmVwYXJlZCBhbmQgcmV0dXJuIGEgc2VxdWVuY2UgKFByb21pc2UpXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgc3RhcnQoKSB7XG4gICAgYXdhaXQgW1xuICAgICAgXCJUb29sc1wiLFxuICAgICAgXCJVSVwiLFxuICAgICAgXCJCbG9ja01hbmFnZXJcIixcbiAgICAgIFwiUGFzdGVcIixcbiAgICAgIFwiQmxvY2tTZWxlY3Rpb25cIixcbiAgICAgIFwiUmVjdGFuZ2xlU2VsZWN0aW9uXCIsXG4gICAgICBcIkNyb3NzQmxvY2tTZWxlY3Rpb25cIixcbiAgICAgIFwiUmVhZE9ubHlcIlxuICAgIF0ucmVkdWNlKFxuICAgICAgKHQsIG8pID0+IHQudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5tb2R1bGVJbnN0YW5jZXNbb10ucHJlcGFyZSgpO1xuICAgICAgICB9IGNhdGNoIChpKSB7XG4gICAgICAgICAgaWYgKGkgaW5zdGFuY2VvZiBIbylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpLm1lc3NhZ2UpO1xuICAgICAgICAgIFMoYE1vZHVsZSAke299IHdhcyBza2lwcGVkIGJlY2F1c2Ugb2YgJW9gLCBcIndhcm5cIiwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXIgaW5pdGlhbCBkYXRhXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlSW5zdGFuY2VzLlJlbmRlcmVyLnJlbmRlcih0aGlzLmNvbmZpZy5kYXRhLmJsb2Nrcyk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2UgbW9kdWxlcyBpbnN0YW5jZXMgYW5kIHNhdmUgaXQgdG8gdGhlIEBwcm9wZXJ0eSB0aGlzLm1vZHVsZUluc3RhbmNlc1xuICAgKi9cbiAgY29uc3RydWN0TW9kdWxlcygpIHtcbiAgICBPYmplY3QuZW50cmllcyhPYSkuZm9yRWFjaCgoW2UsIHRdKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm1vZHVsZUluc3RhbmNlc1tlXSA9IG5ldyB0KHtcbiAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlndXJhdGlvbixcbiAgICAgICAgICBldmVudHNEaXNwYXRjaGVyOiB0aGlzLmV2ZW50c0Rpc3BhdGNoZXJcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChvKSB7XG4gICAgICAgIFMoXCJbY29uc3RydWN0TW9kdWxlc11cIiwgYE1vZHVsZSAke2V9IHNraXBwZWQgYmVjYXVzZWAsIFwiZXJyb3JcIiwgbyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIE1vZHVsZXMgaW5zdGFuY2VzIGNvbmZpZ3VyYXRpb246XG4gICAqICAtIHBhc3Mgb3RoZXIgbW9kdWxlcyB0byB0aGUgJ3N0YXRlJyBwcm9wZXJ0eVxuICAgKiAgLSAuLi5cbiAgICovXG4gIGNvbmZpZ3VyZU1vZHVsZXMoKSB7XG4gICAgZm9yIChjb25zdCBlIGluIHRoaXMubW9kdWxlSW5zdGFuY2VzKVxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMubW9kdWxlSW5zdGFuY2VzLCBlKSAmJiAodGhpcy5tb2R1bGVJbnN0YW5jZXNbZV0uc3RhdGUgPSB0aGlzLmdldE1vZHVsZXNEaWZmKGUpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIG1vZHVsZXMgd2l0aG91dCBwYXNzZWQgbmFtZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIG1vZHVsZSBmb3Igd2l0Y2ggbW9kdWxlcyBkaWZmZXJlbmNlIHNob3VsZCBiZSBjYWxjdWxhdGVkXG4gICAqL1xuICBnZXRNb2R1bGVzRGlmZihlKSB7XG4gICAgY29uc3QgdCA9IHt9O1xuICAgIGZvciAoY29uc3QgbyBpbiB0aGlzLm1vZHVsZUluc3RhbmNlcylcbiAgICAgIG8gIT09IGUgJiYgKHRbb10gPSB0aGlzLm1vZHVsZUluc3RhbmNlc1tvXSk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbn1cbi8qKlxuICogRWRpdG9yLmpzXG4gKlxuICogQGxpY2Vuc2UgQXBhY2hlLTIuMFxuICogQHNlZSBFZGl0b3IuanMgPGh0dHBzOi8vZWRpdG9yanMuaW8+XG4gKiBAYXV0aG9yIENvZGVYIFRlYW0gPGh0dHBzOi8vY29kZXguc28+XG4gKi9cbmNsYXNzIEFhIHtcbiAgLyoqIEVkaXRvciB2ZXJzaW9uICovXG4gIHN0YXRpYyBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gXCIyLjMxLjAtcmMuN1wiO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VkaXRvckNvbmZpZ3xzdHJpbmd8dW5kZWZpbmVkfSBbY29uZmlndXJhdGlvbl0gLSB1c2VyIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBsZXQgdCA9ICgpID0+IHtcbiAgICB9O1xuICAgIEQoZSkgJiYgQShlLm9uUmVhZHkpICYmICh0ID0gZS5vblJlYWR5KTtcbiAgICBjb25zdCBvID0gbmV3IF9hKGUpO1xuICAgIHRoaXMuaXNSZWFkeSA9IG8uaXNSZWFkeS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuZXhwb3J0QVBJKG8pLCB0KCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4cG9ydCBleHRlcm5hbCBBUEkgbWV0aG9kc1xuICAgKlxuICAgKiBAcGFyYW0ge0NvcmV9IGVkaXRvciDigJQgRWRpdG9yJ3MgaW5zdGFuY2VcbiAgICovXG4gIGV4cG9ydEFQSShlKSB7XG4gICAgY29uc3QgdCA9IFtcImNvbmZpZ3VyYXRpb25cIl0sIG8gPSAoKSA9PiB7XG4gICAgICBPYmplY3QudmFsdWVzKGUubW9kdWxlSW5zdGFuY2VzKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgIEEocy5kZXN0cm95KSAmJiBzLmRlc3Ryb3koKSwgcy5saXN0ZW5lcnMucmVtb3ZlQWxsKCk7XG4gICAgICB9KSwgemkoKSwgZSA9IG51bGw7XG4gICAgICBmb3IgKGNvbnN0IHMgaW4gdGhpcylcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIHMpICYmIGRlbGV0ZSB0aGlzW3NdO1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG51bGwpO1xuICAgIH07XG4gICAgdC5mb3JFYWNoKChzKSA9PiB7XG4gICAgICB0aGlzW3NdID0gZVtzXTtcbiAgICB9KSwgdGhpcy5kZXN0cm95ID0gbywgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIGUubW9kdWxlSW5zdGFuY2VzLkFQSS5tZXRob2RzKSwgZGVsZXRlIHRoaXMuZXhwb3J0QVBJLCBPYmplY3QuZW50cmllcyh7XG4gICAgICBibG9ja3M6IHtcbiAgICAgICAgY2xlYXI6IFwiY2xlYXJcIixcbiAgICAgICAgcmVuZGVyOiBcInJlbmRlclwiXG4gICAgICB9LFxuICAgICAgY2FyZXQ6IHtcbiAgICAgICAgZm9jdXM6IFwiZm9jdXNcIlxuICAgICAgfSxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBvbjogXCJvblwiLFxuICAgICAgICBvZmY6IFwib2ZmXCIsXG4gICAgICAgIGVtaXQ6IFwiZW1pdFwiXG4gICAgICB9LFxuICAgICAgc2F2ZXI6IHtcbiAgICAgICAgc2F2ZTogXCJzYXZlXCJcbiAgICAgIH1cbiAgICB9KS5mb3JFYWNoKChbcywgcl0pID0+IHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHIpLmZvckVhY2goKFthLCBsXSkgPT4ge1xuICAgICAgICB0aGlzW2xdID0gZS5tb2R1bGVJbnN0YW5jZXMuQVBJLm1ldGhvZHNbc11bYV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgQWEgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@editorjs/editorjs/dist/editorjs.mjs\n\n}");

/***/ }),

/***/ "./node_modules/@editorjs/header/dist/header.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@editorjs/header/dist/header.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(\".ce-header{padding:.6em 0 3px;margin:0;line-height:1.25em;outline:none}.ce-header p,.ce-header div{padding:0!important;margin:0!important}\")),document.head.appendChild(e)}}catch(n){console.error(\"vite-plugin-css-injected-by-js\",n)}})();\nconst a = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M19 17V10.2135C19 10.1287 18.9011 10.0824 18.836 10.1367L16 12.5\"/></svg>', l = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 11C16 10 19 9.5 19 12C19 13.9771 16.0684 13.9997 16.0012 16.8981C15.9999 16.9533 16.0448 17 16.1 17L19.3 17\"/></svg>', o = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 11C16 10.5 16.8323 10 17.6 10C18.3677 10 19.5 10.311 19.5 11.5C19.5 12.5315 18.7474 12.9022 18.548 12.9823C18.5378 12.9864 18.5395 13.0047 18.5503 13.0063C18.8115 13.0456 20 13.3065 20 14.8C20 16 19.5 17 17.8 17C17.8 17 16 17 16 16.3\"/></svg>', h = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M18 10L15.2834 14.8511C15.246 14.9178 15.294 15 15.3704 15C16.8489 15 18.7561 15 20.2 15M19 17C19 15.7187 19 14.8813 19 13.6\"/></svg>', d = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 15.9C16 15.9 16.3768 17 17.8 17C19.5 17 20 15.6199 20 14.7C20 12.7323 17.6745 12.0486 16.1635 12.9894C16.094 13.0327 16 12.9846 16 12.9027V10.1C16 10.0448 16.0448 10 16.1 10H19.8\"/></svg>', u = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M6 7L6 12M6 17L6 12M6 12L12 12M12 7V12M12 17L12 12\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M19.5 10C16.5 10.5 16 13.3285 16 15M16 15V15C16 16.1046 16.8954 17 18 17H18.3246C19.3251 17 20.3191 16.3492 20.2522 15.3509C20.0612 12.4958 16 12.6611 16 15Z\"/></svg>', g = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M9 7L9 12M9 17V12M9 12L15 12M15 7V12M15 17L15 12\"/></svg>';\n/**\n * Header block for the Editor.js.\n *\n * @author CodeX (team@ifmo.su)\n * @copyright CodeX 2018\n * @license MIT\n * @version 2.0.0\n */\nclass v {\n  constructor({ data: e, config: t, api: s, readOnly: r }) {\n    this.api = s, this.readOnly = r, this._settings = t, this._data = this.normalizeData(e), this._element = this.getTag();\n  }\n  /**\n   * Styles\n   */\n  get _CSS() {\n    return {\n      block: this.api.styles.block,\n      wrapper: \"ce-header\"\n    };\n  }\n  /**\n   * Check if data is valid\n   * \n   * @param {any} data - data to check\n   * @returns {data is HeaderData}\n   * @private\n   */\n  isHeaderData(e) {\n    return e.text !== void 0;\n  }\n  /**\n   * Normalize input data\n   *\n   * @param {HeaderData} data - saved data to process\n   *\n   * @returns {HeaderData}\n   * @private\n   */\n  normalizeData(e) {\n    const t = { text: \"\", level: this.defaultLevel.number };\n    return this.isHeaderData(e) && (t.text = e.text || \"\", e.level !== void 0 && !isNaN(parseInt(e.level.toString())) && (t.level = parseInt(e.level.toString()))), t;\n  }\n  /**\n   * Return Tool's view\n   *\n   * @returns {HTMLHeadingElement}\n   * @public\n   */\n  render() {\n    return this._element;\n  }\n  /**\n   * Returns header block tunes config\n   *\n   * @returns {Array}\n   */\n  renderSettings() {\n    return this.levels.map((e) => ({\n      icon: e.svg,\n      label: this.api.i18n.t(`Heading ${e.number}`),\n      onActivate: () => this.setLevel(e.number),\n      closeOnActivate: !0,\n      isActive: this.currentLevel.number === e.number,\n      render: () => document.createElement(\"div\")\n    }));\n  }\n  /**\n   * Callback for Block's settings buttons\n   *\n   * @param {number} level - level to set\n   */\n  setLevel(e) {\n    this.data = {\n      level: e,\n      text: this.data.text\n    };\n  }\n  /**\n   * Method that specified how to merge two Text blocks.\n   * Called by Editor.js by backspace at the beginning of the Block\n   *\n   * @param {HeaderData} data - saved data to merger with current block\n   * @public\n   */\n  merge(e) {\n    this._element.insertAdjacentHTML(\"beforeend\", e.text);\n  }\n  /**\n   * Validate Text block data:\n   * - check for emptiness\n   *\n   * @param {HeaderData} blockData — data received after saving\n   * @returns {boolean} false if saved data is not correct, otherwise true\n   * @public\n   */\n  validate(e) {\n    return e.text.trim() !== \"\";\n  }\n  /**\n   * Extract Tool's data from the view\n   *\n   * @param {HTMLHeadingElement} toolsContent - Text tools rendered view\n   * @returns {HeaderData} - saved data\n   * @public\n   */\n  save(e) {\n    return {\n      text: e.innerHTML,\n      level: this.currentLevel.number\n    };\n  }\n  /**\n   * Allow Header to be converted to/from other blocks\n   */\n  static get conversionConfig() {\n    return {\n      export: \"text\",\n      // use 'text' property for other blocks\n      import: \"text\"\n      // fill 'text' property from other block's export string\n    };\n  }\n  /**\n   * Sanitizer Rules\n   */\n  static get sanitize() {\n    return {\n      level: !1,\n      text: {}\n    };\n  }\n  /**\n   * Returns true to notify core that read-only is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Get current Tools`s data\n   *\n   * @returns {HeaderData} Current data\n   * @private\n   */\n  get data() {\n    return this._data.text = this._element.innerHTML, this._data.level = this.currentLevel.number, this._data;\n  }\n  /**\n   * Store data in plugin:\n   * - at the this._data property\n   * - at the HTML\n   *\n   * @param {HeaderData} data — data to set\n   * @private\n   */\n  set data(e) {\n    if (this._data = this.normalizeData(e), e.level !== void 0 && this._element.parentNode) {\n      const t = this.getTag();\n      t.innerHTML = this._element.innerHTML, this._element.parentNode.replaceChild(t, this._element), this._element = t;\n    }\n    e.text !== void 0 && (this._element.innerHTML = this._data.text || \"\");\n  }\n  /**\n   * Get tag for target level\n   * By default returns second-leveled header\n   *\n   * @returns {HTMLElement}\n   */\n  getTag() {\n    const e = document.createElement(this.currentLevel.tag);\n    return e.innerHTML = this._data.text || \"\", e.classList.add(this._CSS.wrapper), e.contentEditable = this.readOnly ? \"false\" : \"true\", e.dataset.placeholder = this.api.i18n.t(this._settings.placeholder || \"\"), e;\n  }\n  /**\n   * Get current level\n   *\n   * @returns {level}\n   */\n  get currentLevel() {\n    let e = this.levels.find((t) => t.number === this._data.level);\n    return e || (e = this.defaultLevel), e;\n  }\n  /**\n   * Return default level\n   *\n   * @returns {level}\n   */\n  get defaultLevel() {\n    if (this._settings.defaultLevel) {\n      const e = this.levels.find((t) => t.number === this._settings.defaultLevel);\n      if (e)\n        return e;\n      console.warn(\"(ง'̀-'́)ง Heading Tool: the default level specified was not found in available levels\");\n    }\n    return this.levels[1];\n  }\n  /**\n   * @typedef {object} level\n   * @property {number} number - level number\n   * @property {string} tag - tag corresponds with level number\n   * @property {string} svg - icon\n   */\n  /**\n   * Available header levels\n   *\n   * @returns {level[]}\n   */\n  get levels() {\n    const e = [\n      {\n        number: 1,\n        tag: \"H1\",\n        svg: a\n      },\n      {\n        number: 2,\n        tag: \"H2\",\n        svg: l\n      },\n      {\n        number: 3,\n        tag: \"H3\",\n        svg: o\n      },\n      {\n        number: 4,\n        tag: \"H4\",\n        svg: h\n      },\n      {\n        number: 5,\n        tag: \"H5\",\n        svg: d\n      },\n      {\n        number: 6,\n        tag: \"H6\",\n        svg: u\n      }\n    ];\n    return this._settings.levels ? e.filter(\n      (t) => this._settings.levels.includes(t.number)\n    ) : e;\n  }\n  /**\n   * Handle H1-H6 tags on paste to substitute it with header Tool\n   *\n   * @param {PasteEvent} event - event with pasted content\n   */\n  onPaste(e) {\n    const t = e.detail;\n    if (\"data\" in t) {\n      const s = t.data;\n      let r = this.defaultLevel.number;\n      switch (s.tagName) {\n        case \"H1\":\n          r = 1;\n          break;\n        case \"H2\":\n          r = 2;\n          break;\n        case \"H3\":\n          r = 3;\n          break;\n        case \"H4\":\n          r = 4;\n          break;\n        case \"H5\":\n          r = 5;\n          break;\n        case \"H6\":\n          r = 6;\n          break;\n      }\n      this._settings.levels && (r = this._settings.levels.reduce((n, i) => Math.abs(i - r) < Math.abs(n - r) ? i : n)), this.data = {\n        level: r,\n        text: s.innerHTML\n      };\n    }\n  }\n  /**\n   * Used by Editor.js paste handling API.\n   * Provides configuration to handle H1-H6 tags.\n   *\n   * @returns {{handler: (function(HTMLElement): {text: string}), tags: string[]}}\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\"]\n    };\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   *\n   * @returns {{icon: string, title: string}}\n   */\n  static get toolbox() {\n    return {\n      icon: g,\n      title: \"Heading\"\n    };\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2hlYWRlci9kaXN0L2hlYWRlci5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFlBQVksYUFBYSxJQUFJLHdCQUF3QixzQ0FBc0Msa0RBQWtELG1CQUFtQixTQUFTLG1CQUFtQixhQUFhLDRCQUE0QixvQkFBb0IsbUJBQW1CLGtDQUFrQyxTQUFTLG1EQUFtRDtBQUMxVztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5Q0FBeUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQyxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQyxhQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvaGVhZGVyL2Rpc3QvaGVhZGVyLm1qcz80NjY3Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3RyeXtpZih0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiLmNlLWhlYWRlcntwYWRkaW5nOi42ZW0gMCAzcHg7bWFyZ2luOjA7bGluZS1oZWlnaHQ6MS4yNWVtO291dGxpbmU6bm9uZX0uY2UtaGVhZGVyIHAsLmNlLWhlYWRlciBkaXZ7cGFkZGluZzowIWltcG9ydGFudDttYXJnaW46MCFpbXBvcnRhbnR9XCIpKSxkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGUpfX1jYXRjaChuKXtjb25zb2xlLmVycm9yKFwidml0ZS1wbHVnaW4tY3NzLWluamVjdGVkLWJ5LWpzXCIsbil9fSkoKTtcbmNvbnN0IGEgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTYgN0w2IDEyTTYgMTdMNiAxMk02IDEyTDEyIDEyTTEyIDdWMTJNMTIgMTdMMTIgMTJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE5IDE3VjEwLjIxMzVDMTkgMTAuMTI4NyAxOC45MDExIDEwLjA4MjQgMTguODM2IDEwLjEzNjdMMTYgMTIuNVwiLz48L3N2Zz4nLCBsID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk02IDdMNiAxMk02IDE3TDYgMTJNNiAxMkwxMiAxMk0xMiA3VjEyTTEyIDE3TDEyIDEyXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNiAxMUMxNiAxMCAxOSA5LjUgMTkgMTJDMTkgMTMuOTc3MSAxNi4wNjg0IDEzLjk5OTcgMTYuMDAxMiAxNi44OTgxQzE1Ljk5OTkgMTYuOTUzMyAxNi4wNDQ4IDE3IDE2LjEgMTdMMTkuMyAxN1wiLz48L3N2Zz4nLCBvID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk02IDdMNiAxMk02IDE3TDYgMTJNNiAxMkwxMiAxMk0xMiA3VjEyTTEyIDE3TDEyIDEyXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNiAxMUMxNiAxMC41IDE2LjgzMjMgMTAgMTcuNiAxMEMxOC4zNjc3IDEwIDE5LjUgMTAuMzExIDE5LjUgMTEuNUMxOS41IDEyLjUzMTUgMTguNzQ3NCAxMi45MDIyIDE4LjU0OCAxMi45ODIzQzE4LjUzNzggMTIuOTg2NCAxOC41Mzk1IDEzLjAwNDcgMTguNTUwMyAxMy4wMDYzQzE4LjgxMTUgMTMuMDQ1NiAyMCAxMy4zMDY1IDIwIDE0LjhDMjAgMTYgMTkuNSAxNyAxNy44IDE3QzE3LjggMTcgMTYgMTcgMTYgMTYuM1wiLz48L3N2Zz4nLCBoID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk02IDdMNiAxMk02IDE3TDYgMTJNNiAxMkwxMiAxMk0xMiA3VjEyTTEyIDE3TDEyIDEyXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xOCAxMEwxNS4yODM0IDE0Ljg1MTFDMTUuMjQ2IDE0LjkxNzggMTUuMjk0IDE1IDE1LjM3MDQgMTVDMTYuODQ4OSAxNSAxOC43NTYxIDE1IDIwLjIgMTVNMTkgMTdDMTkgMTUuNzE4NyAxOSAxNC44ODEzIDE5IDEzLjZcIi8+PC9zdmc+JywgZCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNiA3TDYgMTJNNiAxN0w2IDEyTTYgMTJMMTIgMTJNMTIgN1YxMk0xMiAxN0wxMiAxMlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTYgMTUuOUMxNiAxNS45IDE2LjM3NjggMTcgMTcuOCAxN0MxOS41IDE3IDIwIDE1LjYxOTkgMjAgMTQuN0MyMCAxMi43MzIzIDE3LjY3NDUgMTIuMDQ4NiAxNi4xNjM1IDEyLjk4OTRDMTYuMDk0IDEzLjAzMjcgMTYgMTIuOTg0NiAxNiAxMi45MDI3VjEwLjFDMTYgMTAuMDQ0OCAxNi4wNDQ4IDEwIDE2LjEgMTBIMTkuOFwiLz48L3N2Zz4nLCB1ID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk02IDdMNiAxMk02IDE3TDYgMTJNNiAxMkwxMiAxMk0xMiA3VjEyTTEyIDE3TDEyIDEyXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xOS41IDEwQzE2LjUgMTAuNSAxNiAxMy4zMjg1IDE2IDE1TTE2IDE1VjE1QzE2IDE2LjEwNDYgMTYuODk1NCAxNyAxOCAxN0gxOC4zMjQ2QzE5LjMyNTEgMTcgMjAuMzE5MSAxNi4zNDkyIDIwLjI1MjIgMTUuMzUwOUMyMC4wNjEyIDEyLjQ5NTggMTYgMTIuNjYxMSAxNiAxNVpcIi8+PC9zdmc+JywgZyA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNOSA3TDkgMTJNOSAxN1YxMk05IDEyTDE1IDEyTTE1IDdWMTJNMTUgMTdMMTUgMTJcIi8+PC9zdmc+Jztcbi8qKlxuICogSGVhZGVyIGJsb2NrIGZvciB0aGUgRWRpdG9yLmpzLlxuICpcbiAqIEBhdXRob3IgQ29kZVggKHRlYW1AaWZtby5zdSlcbiAqIEBjb3B5cmlnaHQgQ29kZVggMjAxOFxuICogQGxpY2Vuc2UgTUlUXG4gKiBAdmVyc2lvbiAyLjAuMFxuICovXG5jbGFzcyB2IHtcbiAgY29uc3RydWN0b3IoeyBkYXRhOiBlLCBjb25maWc6IHQsIGFwaTogcywgcmVhZE9ubHk6IHIgfSkge1xuICAgIHRoaXMuYXBpID0gcywgdGhpcy5yZWFkT25seSA9IHIsIHRoaXMuX3NldHRpbmdzID0gdCwgdGhpcy5fZGF0YSA9IHRoaXMubm9ybWFsaXplRGF0YShlKSwgdGhpcy5fZWxlbWVudCA9IHRoaXMuZ2V0VGFnKCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0eWxlc1xuICAgKi9cbiAgZ2V0IF9DU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJsb2NrOiB0aGlzLmFwaS5zdHlsZXMuYmxvY2ssXG4gICAgICB3cmFwcGVyOiBcImNlLWhlYWRlclwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgZGF0YSBpcyB2YWxpZFxuICAgKiBcbiAgICogQHBhcmFtIHthbnl9IGRhdGEgLSBkYXRhIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtkYXRhIGlzIEhlYWRlckRhdGF9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0hlYWRlckRhdGEoZSkge1xuICAgIHJldHVybiBlLnRleHQgIT09IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogTm9ybWFsaXplIGlucHV0IGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtIZWFkZXJEYXRhfSBkYXRhIC0gc2F2ZWQgZGF0YSB0byBwcm9jZXNzXG4gICAqXG4gICAqIEByZXR1cm5zIHtIZWFkZXJEYXRhfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbm9ybWFsaXplRGF0YShlKSB7XG4gICAgY29uc3QgdCA9IHsgdGV4dDogXCJcIiwgbGV2ZWw6IHRoaXMuZGVmYXVsdExldmVsLm51bWJlciB9O1xuICAgIHJldHVybiB0aGlzLmlzSGVhZGVyRGF0YShlKSAmJiAodC50ZXh0ID0gZS50ZXh0IHx8IFwiXCIsIGUubGV2ZWwgIT09IHZvaWQgMCAmJiAhaXNOYU4ocGFyc2VJbnQoZS5sZXZlbC50b1N0cmluZygpKSkgJiYgKHQubGV2ZWwgPSBwYXJzZUludChlLmxldmVsLnRvU3RyaW5nKCkpKSksIHQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBUb29sJ3Mgdmlld1xuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEhlYWRpbmdFbGVtZW50fVxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgaGVhZGVyIGJsb2NrIHR1bmVzIGNvbmZpZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICByZW5kZXJTZXR0aW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbHMubWFwKChlKSA9PiAoe1xuICAgICAgaWNvbjogZS5zdmcsXG4gICAgICBsYWJlbDogdGhpcy5hcGkuaTE4bi50KGBIZWFkaW5nICR7ZS5udW1iZXJ9YCksXG4gICAgICBvbkFjdGl2YXRlOiAoKSA9PiB0aGlzLnNldExldmVsKGUubnVtYmVyKSxcbiAgICAgIGNsb3NlT25BY3RpdmF0ZTogITAsXG4gICAgICBpc0FjdGl2ZTogdGhpcy5jdXJyZW50TGV2ZWwubnVtYmVyID09PSBlLm51bWJlcixcbiAgICAgIHJlbmRlcjogKCkgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIEJsb2NrJ3Mgc2V0dGluZ3MgYnV0dG9uc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWwgLSBsZXZlbCB0byBzZXRcbiAgICovXG4gIHNldExldmVsKGUpIHtcbiAgICB0aGlzLmRhdGEgPSB7XG4gICAgICBsZXZlbDogZSxcbiAgICAgIHRleHQ6IHRoaXMuZGF0YS50ZXh0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kIHRoYXQgc3BlY2lmaWVkIGhvdyB0byBtZXJnZSB0d28gVGV4dCBibG9ja3MuXG4gICAqIENhbGxlZCBieSBFZGl0b3IuanMgYnkgYmFja3NwYWNlIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIEJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSB7SGVhZGVyRGF0YX0gZGF0YSAtIHNhdmVkIGRhdGEgdG8gbWVyZ2VyIHdpdGggY3VycmVudCBibG9ja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBtZXJnZShlKSB7XG4gICAgdGhpcy5fZWxlbWVudC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgZS50ZXh0KTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgVGV4dCBibG9jayBkYXRhOlxuICAgKiAtIGNoZWNrIGZvciBlbXB0aW5lc3NcbiAgICpcbiAgICogQHBhcmFtIHtIZWFkZXJEYXRhfSBibG9ja0RhdGEg4oCUIGRhdGEgcmVjZWl2ZWQgYWZ0ZXIgc2F2aW5nXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpZiBzYXZlZCBkYXRhIGlzIG5vdCBjb3JyZWN0LCBvdGhlcndpc2UgdHJ1ZVxuICAgKiBAcHVibGljXG4gICAqL1xuICB2YWxpZGF0ZShlKSB7XG4gICAgcmV0dXJuIGUudGV4dC50cmltKCkgIT09IFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3QgVG9vbCdzIGRhdGEgZnJvbSB0aGUgdmlld1xuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxIZWFkaW5nRWxlbWVudH0gdG9vbHNDb250ZW50IC0gVGV4dCB0b29scyByZW5kZXJlZCB2aWV3XG4gICAqIEByZXR1cm5zIHtIZWFkZXJEYXRhfSAtIHNhdmVkIGRhdGFcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2F2ZShlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IGUuaW5uZXJIVE1MLFxuICAgICAgbGV2ZWw6IHRoaXMuY3VycmVudExldmVsLm51bWJlclxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93IEhlYWRlciB0byBiZSBjb252ZXJ0ZWQgdG8vZnJvbSBvdGhlciBibG9ja3NcbiAgICovXG4gIHN0YXRpYyBnZXQgY29udmVyc2lvbkNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwb3J0OiBcInRleHRcIixcbiAgICAgIC8vIHVzZSAndGV4dCcgcHJvcGVydHkgZm9yIG90aGVyIGJsb2Nrc1xuICAgICAgaW1wb3J0OiBcInRleHRcIlxuICAgICAgLy8gZmlsbCAndGV4dCcgcHJvcGVydHkgZnJvbSBvdGhlciBibG9jaydzIGV4cG9ydCBzdHJpbmdcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTYW5pdGl6ZXIgUnVsZXNcbiAgICovXG4gIHN0YXRpYyBnZXQgc2FuaXRpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsOiAhMSxcbiAgICAgIHRleHQ6IHt9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIHRvIG5vdGlmeSBjb3JlIHRoYXQgcmVhZC1vbmx5IGlzIHN1cHBvcnRlZFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgaXNSZWFkT25seVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IFRvb2xzYHMgZGF0YVxuICAgKlxuICAgKiBAcmV0dXJucyB7SGVhZGVyRGF0YX0gQ3VycmVudCBkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS50ZXh0ID0gdGhpcy5fZWxlbWVudC5pbm5lckhUTUwsIHRoaXMuX2RhdGEubGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbC5udW1iZXIsIHRoaXMuX2RhdGE7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3JlIGRhdGEgaW4gcGx1Z2luOlxuICAgKiAtIGF0IHRoZSB0aGlzLl9kYXRhIHByb3BlcnR5XG4gICAqIC0gYXQgdGhlIEhUTUxcbiAgICpcbiAgICogQHBhcmFtIHtIZWFkZXJEYXRhfSBkYXRhIOKAlCBkYXRhIHRvIHNldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0IGRhdGEoZSkge1xuICAgIGlmICh0aGlzLl9kYXRhID0gdGhpcy5ub3JtYWxpemVEYXRhKGUpLCBlLmxldmVsICE9PSB2b2lkIDAgJiYgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5nZXRUYWcoKTtcbiAgICAgIHQuaW5uZXJIVE1MID0gdGhpcy5fZWxlbWVudC5pbm5lckhUTUwsIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodCwgdGhpcy5fZWxlbWVudCksIHRoaXMuX2VsZW1lbnQgPSB0O1xuICAgIH1cbiAgICBlLnRleHQgIT09IHZvaWQgMCAmJiAodGhpcy5fZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl9kYXRhLnRleHQgfHwgXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0YWcgZm9yIHRhcmdldCBsZXZlbFxuICAgKiBCeSBkZWZhdWx0IHJldHVybnMgc2Vjb25kLWxldmVsZWQgaGVhZGVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIGdldFRhZygpIHtcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLmN1cnJlbnRMZXZlbC50YWcpO1xuICAgIHJldHVybiBlLmlubmVySFRNTCA9IHRoaXMuX2RhdGEudGV4dCB8fCBcIlwiLCBlLmNsYXNzTGlzdC5hZGQodGhpcy5fQ1NTLndyYXBwZXIpLCBlLmNvbnRlbnRFZGl0YWJsZSA9IHRoaXMucmVhZE9ubHkgPyBcImZhbHNlXCIgOiBcInRydWVcIiwgZS5kYXRhc2V0LnBsYWNlaG9sZGVyID0gdGhpcy5hcGkuaTE4bi50KHRoaXMuX3NldHRpbmdzLnBsYWNlaG9sZGVyIHx8IFwiXCIpLCBlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBsZXZlbFxuICAgKlxuICAgKiBAcmV0dXJucyB7bGV2ZWx9XG4gICAqL1xuICBnZXQgY3VycmVudExldmVsKCkge1xuICAgIGxldCBlID0gdGhpcy5sZXZlbHMuZmluZCgodCkgPT4gdC5udW1iZXIgPT09IHRoaXMuX2RhdGEubGV2ZWwpO1xuICAgIHJldHVybiBlIHx8IChlID0gdGhpcy5kZWZhdWx0TGV2ZWwpLCBlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gZGVmYXVsdCBsZXZlbFxuICAgKlxuICAgKiBAcmV0dXJucyB7bGV2ZWx9XG4gICAqL1xuICBnZXQgZGVmYXVsdExldmVsKCkge1xuICAgIGlmICh0aGlzLl9zZXR0aW5ncy5kZWZhdWx0TGV2ZWwpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLmxldmVscy5maW5kKCh0KSA9PiB0Lm51bWJlciA9PT0gdGhpcy5fc2V0dGluZ3MuZGVmYXVsdExldmVsKTtcbiAgICAgIGlmIChlKVxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIGNvbnNvbGUud2FybihcIijguIcnzIAtJ8yBKeC4hyBIZWFkaW5nIFRvb2w6IHRoZSBkZWZhdWx0IGxldmVsIHNwZWNpZmllZCB3YXMgbm90IGZvdW5kIGluIGF2YWlsYWJsZSBsZXZlbHNcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxldmVsc1sxXTtcbiAgfVxuICAvKipcbiAgICogQHR5cGVkZWYge29iamVjdH0gbGV2ZWxcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IG51bWJlciAtIGxldmVsIG51bWJlclxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdGFnIC0gdGFnIGNvcnJlc3BvbmRzIHdpdGggbGV2ZWwgbnVtYmVyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdmcgLSBpY29uXG4gICAqL1xuICAvKipcbiAgICogQXZhaWxhYmxlIGhlYWRlciBsZXZlbHNcbiAgICpcbiAgICogQHJldHVybnMge2xldmVsW119XG4gICAqL1xuICBnZXQgbGV2ZWxzKCkge1xuICAgIGNvbnN0IGUgPSBbXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogMSxcbiAgICAgICAgdGFnOiBcIkgxXCIsXG4gICAgICAgIHN2ZzogYVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiAyLFxuICAgICAgICB0YWc6IFwiSDJcIixcbiAgICAgICAgc3ZnOiBsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDMsXG4gICAgICAgIHRhZzogXCJIM1wiLFxuICAgICAgICBzdmc6IG9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG51bWJlcjogNCxcbiAgICAgICAgdGFnOiBcIkg0XCIsXG4gICAgICAgIHN2ZzogaFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbnVtYmVyOiA1LFxuICAgICAgICB0YWc6IFwiSDVcIixcbiAgICAgICAgc3ZnOiBkXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBudW1iZXI6IDYsXG4gICAgICAgIHRhZzogXCJINlwiLFxuICAgICAgICBzdmc6IHVcbiAgICAgIH1cbiAgICBdO1xuICAgIHJldHVybiB0aGlzLl9zZXR0aW5ncy5sZXZlbHMgPyBlLmZpbHRlcihcbiAgICAgICh0KSA9PiB0aGlzLl9zZXR0aW5ncy5sZXZlbHMuaW5jbHVkZXModC5udW1iZXIpXG4gICAgKSA6IGU7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBIMS1INiB0YWdzIG9uIHBhc3RlIHRvIHN1YnN0aXR1dGUgaXQgd2l0aCBoZWFkZXIgVG9vbFxuICAgKlxuICAgKiBAcGFyYW0ge1Bhc3RlRXZlbnR9IGV2ZW50IC0gZXZlbnQgd2l0aCBwYXN0ZWQgY29udGVudFxuICAgKi9cbiAgb25QYXN0ZShlKSB7XG4gICAgY29uc3QgdCA9IGUuZGV0YWlsO1xuICAgIGlmIChcImRhdGFcIiBpbiB0KSB7XG4gICAgICBjb25zdCBzID0gdC5kYXRhO1xuICAgICAgbGV0IHIgPSB0aGlzLmRlZmF1bHRMZXZlbC5udW1iZXI7XG4gICAgICBzd2l0Y2ggKHMudGFnTmFtZSkge1xuICAgICAgICBjYXNlIFwiSDFcIjpcbiAgICAgICAgICByID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkgyXCI6XG4gICAgICAgICAgciA9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJIM1wiOlxuICAgICAgICAgIHIgPSAzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiSDRcIjpcbiAgICAgICAgICByID0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkg1XCI6XG4gICAgICAgICAgciA9IDU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJINlwiOlxuICAgICAgICAgIHIgPSA2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0dGluZ3MubGV2ZWxzICYmIChyID0gdGhpcy5fc2V0dGluZ3MubGV2ZWxzLnJlZHVjZSgobiwgaSkgPT4gTWF0aC5hYnMoaSAtIHIpIDwgTWF0aC5hYnMobiAtIHIpID8gaSA6IG4pKSwgdGhpcy5kYXRhID0ge1xuICAgICAgICBsZXZlbDogcixcbiAgICAgICAgdGV4dDogcy5pbm5lckhUTUxcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVc2VkIGJ5IEVkaXRvci5qcyBwYXN0ZSBoYW5kbGluZyBBUEkuXG4gICAqIFByb3ZpZGVzIGNvbmZpZ3VyYXRpb24gdG8gaGFuZGxlIEgxLUg2IHRhZ3MuXG4gICAqXG4gICAqIEByZXR1cm5zIHt7aGFuZGxlcjogKGZ1bmN0aW9uKEhUTUxFbGVtZW50KToge3RleHQ6IHN0cmluZ30pLCB0YWdzOiBzdHJpbmdbXX19XG4gICAqL1xuICBzdGF0aWMgZ2V0IHBhc3RlQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWdzOiBbXCJIMVwiLCBcIkgyXCIsIFwiSDNcIiwgXCJINFwiLCBcIkg1XCIsIFwiSDZcIl1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgVG9vbCB0b29sYm94IHNldHRpbmdzXG4gICAqIGljb24gLSBUb29sIGljb24ncyBTVkdcbiAgICogdGl0bGUgLSB0aXRsZSB0byBzaG93IGluIHRvb2xib3hcbiAgICpcbiAgICogQHJldHVybnMge3tpY29uOiBzdHJpbmcsIHRpdGxlOiBzdHJpbmd9fVxuICAgKi9cbiAgc3RhdGljIGdldCB0b29sYm94KCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiBnLFxuICAgICAgdGl0bGU6IFwiSGVhZGluZ1wiXG4gICAgfTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgdiBhcyBkZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@editorjs/header/dist/header.mjs\n\n}");

/***/ }),

/***/ "./node_modules/@editorjs/image/dist/image.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@editorjs/image/dist/image.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ P)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var o=document.createElement(\"style\");o.appendChild(document.createTextNode('.image-tool{--bg-color: #cdd1e0;--front-color: #388ae5;--border-color: #e8e8eb}.image-tool__image{border-radius:3px;overflow:hidden;margin-bottom:10px;padding-bottom:0}.image-tool__image-picture{max-width:100%;vertical-align:bottom;display:block}.image-tool__image-preloader{width:50px;height:50px;border-radius:50%;background-size:cover;margin:auto;position:relative;background-color:var(--bg-color);background-position:center center}.image-tool__image-preloader:after{content:\"\";position:absolute;z-index:3;width:60px;height:60px;border-radius:50%;border:2px solid var(--bg-color);border-top-color:var(--front-color);left:50%;top:50%;margin-top:-30px;margin-left:-30px;animation:image-preloader-spin 2s infinite linear;box-sizing:border-box}.image-tool__caption{visibility:hidden;position:absolute;bottom:0;left:0;margin-bottom:10px}.image-tool__caption[contentEditable=true][data-placeholder]:before{position:absolute!important;content:attr(data-placeholder);color:#707684;font-weight:400;display:none}.image-tool__caption[contentEditable=true][data-placeholder]:empty:before{display:block}.image-tool__caption[contentEditable=true][data-placeholder]:empty:focus:before{display:none}.image-tool--empty .image-tool__image,.image-tool--empty .image-tool__image-preloader{display:none}.image-tool--empty .image-tool__caption,.image-tool--uploading .image-tool__caption{visibility:hidden!important}.image-tool .cdx-button{display:flex;align-items:center;justify-content:center}.image-tool .cdx-button svg{height:auto;margin:0 6px 0 0}.image-tool--filled .cdx-button,.image-tool--filled .image-tool__image-preloader{display:none}.image-tool--uploading .image-tool__image{min-height:200px;display:flex;border:1px solid var(--border-color);background-color:#fff}.image-tool--uploading .image-tool__image-picture,.image-tool--uploading .cdx-button{display:none}.image-tool--withBorder .image-tool__image{border:1px solid var(--border-color)}.image-tool--withBackground .image-tool__image{padding:15px;background:var(--bg-color)}.image-tool--withBackground .image-tool__image-picture{max-width:60%;margin:0 auto}.image-tool--stretched .image-tool__image-picture{width:100%}.image-tool--caption .image-tool__caption{visibility:visible}.image-tool--caption{padding-bottom:50px}@keyframes image-preloader-spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}')),document.head.appendChild(o)}}catch(e){console.error(\"vite-plugin-css-injected-by-js\",e)}})();\nconst R = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M11 19V19C9.13623 19 8.20435 19 7.46927 18.6955C6.48915 18.2895 5.71046 17.5108 5.30448 16.5307C5 15.7956 5 14.8638 5 13V12C5 9.19108 5 7.78661 5.67412 6.77772C5.96596 6.34096 6.34096 5.96596 6.77772 5.67412C7.78661 5 9.19108 5 12 5H13.5C14.8956 5 15.5933 5 16.1611 5.17224C17.4395 5.56004 18.44 6.56046 18.8278 7.83886C19 8.40666 19 9.10444 19 10.5V10.5\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 13V16M16 19V16M19 16H16M16 16H13\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M6.5 17.5L17.5 6.5\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M18.9919 10.5H19.0015\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M10.9919 19H11.0015\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M5 13L13 5\"/></svg>', I = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M18.9919 9.5H19.0015\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M14.5 5H14.5096\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M14.625 5H15C17.2091 5 19 6.79086 19 9V9.375\"/><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M9.375 5L9 5C6.79086 5 5 6.79086 5 9V9.375\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9.3725 5H9.38207\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M5 9.5H5.00957\"/><path stroke=\"currentColor\" stroke-width=\"2\" d=\"M9.375 19H9C6.79086 19 5 17.2091 5 15V14.625\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9.3725 19H9.38207\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M5 14.55H5.00957\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 13V16M16 19V16M19 16H16M16 16H13\"/></svg>', L = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><rect width=\"14\" height=\"14\" x=\"5\" y=\"5\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"4\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M5.13968 15.32L8.69058 11.5661C9.02934 11.2036 9.48873 11 9.96774 11C10.4467 11 10.9061 11.2036 11.2449 11.5661L15.3871 16M13.5806 14.0664L15.0132 12.533C15.3519 12.1705 15.8113 11.9668 16.2903 11.9668C16.7693 11.9668 17.2287 12.1705 17.5675 12.533L18.841 13.9634\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13.7778 9.33331H13.7867\"/></svg>', x = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M17 9L20 12L17 15\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M14 12H20\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M7 9L4 12L7 15\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M4 12H10\"/></svg>', B = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 9V7.2C8 7.08954 8.08954 7 8.2 7L12 7M16 9V7.2C16 7.08954 15.9105 7 15.8 7L12 7M12 7L12 17M12 17H10M12 17H14\"/></svg>';\nfunction S(C, i = null, a = {}) {\n  const s = document.createElement(C);\n  Array.isArray(i) ? s.classList.add(...i) : i !== null && s.classList.add(i);\n  for (const r in a)\n    a.hasOwnProperty(r) && (s[r] = a[r]);\n  return s;\n}\nvar _ = /* @__PURE__ */ ((C) => (C.Empty = \"empty\", C.Uploading = \"uploading\", C.Filled = \"filled\", C))(_ || {});\nclass D {\n  /**\n   * @param ui - image tool Ui module\n   * @param ui.api - Editor.js API\n   * @param ui.config - user config\n   * @param ui.onSelectFile - callback for clicks on Select file button\n   * @param ui.readOnly - read-only mode flag\n   */\n  constructor({ api: i, config: a, onSelectFile: s, readOnly: r }) {\n    this.api = i, this.config = a, this.onSelectFile = s, this.readOnly = r, this.nodes = {\n      wrapper: S(\"div\", [this.CSS.baseClass, this.CSS.wrapper]),\n      imageContainer: S(\"div\", [this.CSS.imageContainer]),\n      fileButton: this.createFileButton(),\n      imageEl: void 0,\n      imagePreloader: S(\"div\", this.CSS.imagePreloader),\n      caption: S(\"div\", [this.CSS.input, this.CSS.caption], {\n        contentEditable: !this.readOnly\n      })\n    }, this.nodes.caption.dataset.placeholder = this.config.captionPlaceholder, this.nodes.imageContainer.appendChild(this.nodes.imagePreloader), this.nodes.wrapper.appendChild(this.nodes.imageContainer), this.nodes.wrapper.appendChild(this.nodes.caption), this.nodes.wrapper.appendChild(this.nodes.fileButton);\n  }\n  /**\n   * Apply visual representation of activated tune\n   * @param tuneName - one of available tunes {@link Tunes.tunes}\n   * @param status - true for enable, false for disable\n   */\n  applyTune(i, a) {\n    this.nodes.wrapper.classList.toggle(`${this.CSS.wrapper}--${i}`, a);\n  }\n  /**\n   * Renders tool UI\n   */\n  render() {\n    return this.toggleStatus(\n      \"empty\"\n      /* Empty */\n    ), this.nodes.wrapper;\n  }\n  /**\n   * Shows uploading preloader\n   * @param src - preview source\n   */\n  showPreloader(i) {\n    this.nodes.imagePreloader.style.backgroundImage = `url(${i})`, this.toggleStatus(\n      \"uploading\"\n      /* Uploading */\n    );\n  }\n  /**\n   * Hide uploading preloader\n   */\n  hidePreloader() {\n    this.nodes.imagePreloader.style.backgroundImage = \"\", this.toggleStatus(\n      \"empty\"\n      /* Empty */\n    );\n  }\n  /**\n   * Shows an image\n   * @param url - image source\n   */\n  fillImage(i) {\n    const a = /\\.mp4$/.test(i) ? \"VIDEO\" : \"IMG\", s = {\n      src: i\n    };\n    let r = \"load\";\n    a === \"VIDEO\" && (s.autoplay = !0, s.loop = !0, s.muted = !0, s.playsinline = !0, r = \"loadeddata\"), this.nodes.imageEl = S(a, this.CSS.imageEl, s), this.nodes.imageEl.addEventListener(r, () => {\n      this.toggleStatus(\n        \"filled\"\n        /* Filled */\n      ), this.nodes.imagePreloader !== void 0 && (this.nodes.imagePreloader.style.backgroundImage = \"\");\n    }), this.nodes.imageContainer.appendChild(this.nodes.imageEl);\n  }\n  /**\n   * Shows caption input\n   * @param text - caption content text\n   */\n  fillCaption(i) {\n    this.nodes.caption !== void 0 && (this.nodes.caption.innerHTML = i);\n  }\n  /**\n   * Changes UI status\n   * @param status - see {@link Ui.status} constants\n   */\n  toggleStatus(i) {\n    for (const a in _)\n      if (Object.prototype.hasOwnProperty.call(_, a)) {\n        const s = _[a];\n        this.nodes.wrapper.classList.toggle(`${this.CSS.wrapper}--${s}`, s === i);\n      }\n  }\n  /**\n   * CSS classes\n   */\n  get CSS() {\n    return {\n      baseClass: this.api.styles.block,\n      loading: this.api.styles.loader,\n      input: this.api.styles.input,\n      button: this.api.styles.button,\n      /**\n       * Tool's classes\n       */\n      wrapper: \"image-tool\",\n      imageContainer: \"image-tool__image\",\n      imagePreloader: \"image-tool__image-preloader\",\n      imageEl: \"image-tool__image-picture\",\n      caption: \"image-tool__caption\"\n    };\n  }\n  /**\n   * Creates upload-file button\n   */\n  createFileButton() {\n    const i = S(\"div\", [this.CSS.button]);\n    return i.innerHTML = this.config.buttonContent ?? `${L} ${this.api.i18n.t(\"Select an Image\")}`, i.addEventListener(\"click\", () => {\n      this.onSelectFile();\n    }), i;\n  }\n}\nfunction U(C) {\n  return C && C.__esModule && Object.prototype.hasOwnProperty.call(C, \"default\") ? C.default : C;\n}\nvar H = { exports: {} };\n(function(C, i) {\n  (function(a, s) {\n    C.exports = s();\n  })(window, function() {\n    return function(a) {\n      var s = {};\n      function r(o) {\n        if (s[o]) return s[o].exports;\n        var e = s[o] = { i: o, l: !1, exports: {} };\n        return a[o].call(e.exports, e, e.exports, r), e.l = !0, e.exports;\n      }\n      return r.m = a, r.c = s, r.d = function(o, e, d) {\n        r.o(o, e) || Object.defineProperty(o, e, { enumerable: !0, get: d });\n      }, r.r = function(o) {\n        typeof Symbol < \"u\" && Symbol.toStringTag && Object.defineProperty(o, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(o, \"__esModule\", { value: !0 });\n      }, r.t = function(o, e) {\n        if (1 & e && (o = r(o)), 8 & e || 4 & e && typeof o == \"object\" && o && o.__esModule) return o;\n        var d = /* @__PURE__ */ Object.create(null);\n        if (r.r(d), Object.defineProperty(d, \"default\", { enumerable: !0, value: o }), 2 & e && typeof o != \"string\") for (var v in o) r.d(d, v, (function(l) {\n          return o[l];\n        }).bind(null, v));\n        return d;\n      }, r.n = function(o) {\n        var e = o && o.__esModule ? function() {\n          return o.default;\n        } : function() {\n          return o;\n        };\n        return r.d(e, \"a\", e), e;\n      }, r.o = function(o, e) {\n        return Object.prototype.hasOwnProperty.call(o, e);\n      }, r.p = \"\", r(r.s = 3);\n    }([function(a, s) {\n      var r;\n      r = /* @__PURE__ */ function() {\n        return this;\n      }();\n      try {\n        r = r || new Function(\"return this\")();\n      } catch {\n        typeof window == \"object\" && (r = window);\n      }\n      a.exports = r;\n    }, function(a, s, r) {\n      (function(o) {\n        var e = r(2), d = setTimeout;\n        function v() {\n        }\n        function l(n) {\n          if (!(this instanceof l)) throw new TypeError(\"Promises must be constructed via new\");\n          if (typeof n != \"function\") throw new TypeError(\"not a function\");\n          this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], t(n, this);\n        }\n        function f(n, c) {\n          for (; n._state === 3; ) n = n._value;\n          n._state !== 0 ? (n._handled = !0, l._immediateFn(function() {\n            var u = n._state === 1 ? c.onFulfilled : c.onRejected;\n            if (u !== null) {\n              var g;\n              try {\n                g = u(n._value);\n              } catch (m) {\n                return void y(c.promise, m);\n              }\n              p(c.promise, g);\n            } else (n._state === 1 ? p : y)(c.promise, n._value);\n          })) : n._deferreds.push(c);\n        }\n        function p(n, c) {\n          try {\n            if (c === n) throw new TypeError(\"A promise cannot be resolved with itself.\");\n            if (c && (typeof c == \"object\" || typeof c == \"function\")) {\n              var u = c.then;\n              if (c instanceof l) return n._state = 3, n._value = c, void w(n);\n              if (typeof u == \"function\") return void t((g = u, m = c, function() {\n                g.apply(m, arguments);\n              }), n);\n            }\n            n._state = 1, n._value = c, w(n);\n          } catch (h) {\n            y(n, h);\n          }\n          var g, m;\n        }\n        function y(n, c) {\n          n._state = 2, n._value = c, w(n);\n        }\n        function w(n) {\n          n._state === 2 && n._deferreds.length === 0 && l._immediateFn(function() {\n            n._handled || l._unhandledRejectionFn(n._value);\n          });\n          for (var c = 0, u = n._deferreds.length; c < u; c++) f(n, n._deferreds[c]);\n          n._deferreds = null;\n        }\n        function b(n, c, u) {\n          this.onFulfilled = typeof n == \"function\" ? n : null, this.onRejected = typeof c == \"function\" ? c : null, this.promise = u;\n        }\n        function t(n, c) {\n          var u = !1;\n          try {\n            n(function(g) {\n              u || (u = !0, p(c, g));\n            }, function(g) {\n              u || (u = !0, y(c, g));\n            });\n          } catch (g) {\n            if (u) return;\n            u = !0, y(c, g);\n          }\n        }\n        l.prototype.catch = function(n) {\n          return this.then(null, n);\n        }, l.prototype.then = function(n, c) {\n          var u = new this.constructor(v);\n          return f(this, new b(n, c, u)), u;\n        }, l.prototype.finally = e.a, l.all = function(n) {\n          return new l(function(c, u) {\n            if (!n || n.length === void 0) throw new TypeError(\"Promise.all accepts an array\");\n            var g = Array.prototype.slice.call(n);\n            if (g.length === 0) return c([]);\n            var m = g.length;\n            function h(T, E) {\n              try {\n                if (E && (typeof E == \"object\" || typeof E == \"function\")) {\n                  var M = E.then;\n                  if (typeof M == \"function\") return void M.call(E, function(F) {\n                    h(T, F);\n                  }, u);\n                }\n                g[T] = E, --m == 0 && c(g);\n              } catch (F) {\n                u(F);\n              }\n            }\n            for (var k = 0; k < g.length; k++) h(k, g[k]);\n          });\n        }, l.resolve = function(n) {\n          return n && typeof n == \"object\" && n.constructor === l ? n : new l(function(c) {\n            c(n);\n          });\n        }, l.reject = function(n) {\n          return new l(function(c, u) {\n            u(n);\n          });\n        }, l.race = function(n) {\n          return new l(function(c, u) {\n            for (var g = 0, m = n.length; g < m; g++) n[g].then(c, u);\n          });\n        }, l._immediateFn = typeof o == \"function\" && function(n) {\n          o(n);\n        } || function(n) {\n          d(n, 0);\n        }, l._unhandledRejectionFn = function(n) {\n          typeof console < \"u\" && console && console.warn(\"Possible Unhandled Promise Rejection:\", n);\n        }, s.a = l;\n      }).call(this, r(5).setImmediate);\n    }, function(a, s, r) {\n      s.a = function(o) {\n        var e = this.constructor;\n        return this.then(function(d) {\n          return e.resolve(o()).then(function() {\n            return d;\n          });\n        }, function(d) {\n          return e.resolve(o()).then(function() {\n            return e.reject(d);\n          });\n        });\n      };\n    }, function(a, s, r) {\n      function o(t) {\n        return (o = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(n) {\n          return typeof n;\n        } : function(n) {\n          return n && typeof Symbol == \"function\" && n.constructor === Symbol && n !== Symbol.prototype ? \"symbol\" : typeof n;\n        })(t);\n      }\n      r(4);\n      var e, d, v, l, f, p, y, w = r(8), b = (d = function(t) {\n        return new Promise(function(n, c) {\n          t = l(t), (t = f(t)).beforeSend && t.beforeSend();\n          var u = window.XMLHttpRequest ? new window.XMLHttpRequest() : new window.ActiveXObject(\"Microsoft.XMLHTTP\");\n          u.open(t.method, t.url), u.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\"), Object.keys(t.headers).forEach(function(m) {\n            var h = t.headers[m];\n            u.setRequestHeader(m, h);\n          });\n          var g = t.ratio;\n          u.upload.addEventListener(\"progress\", function(m) {\n            var h = Math.round(m.loaded / m.total * 100), k = Math.ceil(h * g / 100);\n            t.progress(Math.min(k, 100));\n          }, !1), u.addEventListener(\"progress\", function(m) {\n            var h = Math.round(m.loaded / m.total * 100), k = Math.ceil(h * (100 - g) / 100) + g;\n            t.progress(Math.min(k, 100));\n          }, !1), u.onreadystatechange = function() {\n            if (u.readyState === 4) {\n              var m = u.response;\n              try {\n                m = JSON.parse(m);\n              } catch {\n              }\n              var h = w.parseHeaders(u.getAllResponseHeaders()), k = { body: m, code: u.status, headers: h };\n              y(u.status) ? n(k) : c(k);\n            }\n          }, u.send(t.data);\n        });\n      }, v = function(t) {\n        return t.method = \"POST\", d(t);\n      }, l = function() {\n        var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        if (t.url && typeof t.url != \"string\") throw new Error(\"Url must be a string\");\n        if (t.url = t.url || \"\", t.method && typeof t.method != \"string\") throw new Error(\"`method` must be a string or null\");\n        if (t.method = t.method ? t.method.toUpperCase() : \"GET\", t.headers && o(t.headers) !== \"object\") throw new Error(\"`headers` must be an object or null\");\n        if (t.headers = t.headers || {}, t.type && (typeof t.type != \"string\" || !Object.values(e).includes(t.type))) throw new Error(\"`type` must be taken from module's «contentType» library\");\n        if (t.progress && typeof t.progress != \"function\") throw new Error(\"`progress` must be a function or null\");\n        if (t.progress = t.progress || function(n) {\n        }, t.beforeSend = t.beforeSend || function(n) {\n        }, t.ratio && typeof t.ratio != \"number\") throw new Error(\"`ratio` must be a number\");\n        if (t.ratio < 0 || t.ratio > 100) throw new Error(\"`ratio` must be in a 0-100 interval\");\n        if (t.ratio = t.ratio || 90, t.accept && typeof t.accept != \"string\") throw new Error(\"`accept` must be a string with a list of allowed mime-types\");\n        if (t.accept = t.accept || \"*/*\", t.multiple && typeof t.multiple != \"boolean\") throw new Error(\"`multiple` must be a true or false\");\n        if (t.multiple = t.multiple || !1, t.fieldName && typeof t.fieldName != \"string\") throw new Error(\"`fieldName` must be a string\");\n        return t.fieldName = t.fieldName || \"files\", t;\n      }, f = function(t) {\n        switch (t.method) {\n          case \"GET\":\n            var n = p(t.data, e.URLENCODED);\n            delete t.data, t.url = /\\?/.test(t.url) ? t.url + \"&\" + n : t.url + \"?\" + n;\n            break;\n          case \"POST\":\n          case \"PUT\":\n          case \"DELETE\":\n          case \"UPDATE\":\n            var c = function() {\n              return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}).type || e.JSON;\n            }(t);\n            (w.isFormData(t.data) || w.isFormElement(t.data)) && (c = e.FORM), t.data = p(t.data, c), c !== b.contentType.FORM && (t.headers[\"content-type\"] = c);\n        }\n        return t;\n      }, p = function() {\n        var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        switch (arguments.length > 1 ? arguments[1] : void 0) {\n          case e.URLENCODED:\n            return w.urlEncode(t);\n          case e.JSON:\n            return w.jsonEncode(t);\n          case e.FORM:\n            return w.formEncode(t);\n          default:\n            return t;\n        }\n      }, y = function(t) {\n        return t >= 200 && t < 300;\n      }, { contentType: e = { URLENCODED: \"application/x-www-form-urlencoded; charset=utf-8\", FORM: \"multipart/form-data\", JSON: \"application/json; charset=utf-8\" }, request: d, get: function(t) {\n        return t.method = \"GET\", d(t);\n      }, post: v, transport: function(t) {\n        return t = l(t), w.selectFiles(t).then(function(n) {\n          for (var c = new FormData(), u = 0; u < n.length; u++) c.append(t.fieldName, n[u], n[u].name);\n          w.isObject(t.data) && Object.keys(t.data).forEach(function(m) {\n            var h = t.data[m];\n            c.append(m, h);\n          });\n          var g = t.beforeSend;\n          return t.beforeSend = function() {\n            return g(n);\n          }, t.data = c, v(t);\n        });\n      }, selectFiles: function(t) {\n        return delete (t = l(t)).beforeSend, w.selectFiles(t);\n      } });\n      a.exports = b;\n    }, function(a, s, r) {\n      r.r(s);\n      var o = r(1);\n      window.Promise = window.Promise || o.a;\n    }, function(a, s, r) {\n      (function(o) {\n        var e = o !== void 0 && o || typeof self < \"u\" && self || window, d = Function.prototype.apply;\n        function v(l, f) {\n          this._id = l, this._clearFn = f;\n        }\n        s.setTimeout = function() {\n          return new v(d.call(setTimeout, e, arguments), clearTimeout);\n        }, s.setInterval = function() {\n          return new v(d.call(setInterval, e, arguments), clearInterval);\n        }, s.clearTimeout = s.clearInterval = function(l) {\n          l && l.close();\n        }, v.prototype.unref = v.prototype.ref = function() {\n        }, v.prototype.close = function() {\n          this._clearFn.call(e, this._id);\n        }, s.enroll = function(l, f) {\n          clearTimeout(l._idleTimeoutId), l._idleTimeout = f;\n        }, s.unenroll = function(l) {\n          clearTimeout(l._idleTimeoutId), l._idleTimeout = -1;\n        }, s._unrefActive = s.active = function(l) {\n          clearTimeout(l._idleTimeoutId);\n          var f = l._idleTimeout;\n          f >= 0 && (l._idleTimeoutId = setTimeout(function() {\n            l._onTimeout && l._onTimeout();\n          }, f));\n        }, r(6), s.setImmediate = typeof self < \"u\" && self.setImmediate || o !== void 0 && o.setImmediate || this && this.setImmediate, s.clearImmediate = typeof self < \"u\" && self.clearImmediate || o !== void 0 && o.clearImmediate || this && this.clearImmediate;\n      }).call(this, r(0));\n    }, function(a, s, r) {\n      (function(o, e) {\n        (function(d, v) {\n          if (!d.setImmediate) {\n            var l, f, p, y, w, b = 1, t = {}, n = !1, c = d.document, u = Object.getPrototypeOf && Object.getPrototypeOf(d);\n            u = u && u.setTimeout ? u : d, {}.toString.call(d.process) === \"[object process]\" ? l = function(h) {\n              e.nextTick(function() {\n                m(h);\n              });\n            } : function() {\n              if (d.postMessage && !d.importScripts) {\n                var h = !0, k = d.onmessage;\n                return d.onmessage = function() {\n                  h = !1;\n                }, d.postMessage(\"\", \"*\"), d.onmessage = k, h;\n              }\n            }() ? (y = \"setImmediate$\" + Math.random() + \"$\", w = function(h) {\n              h.source === d && typeof h.data == \"string\" && h.data.indexOf(y) === 0 && m(+h.data.slice(y.length));\n            }, d.addEventListener ? d.addEventListener(\"message\", w, !1) : d.attachEvent(\"onmessage\", w), l = function(h) {\n              d.postMessage(y + h, \"*\");\n            }) : d.MessageChannel ? ((p = new MessageChannel()).port1.onmessage = function(h) {\n              m(h.data);\n            }, l = function(h) {\n              p.port2.postMessage(h);\n            }) : c && \"onreadystatechange\" in c.createElement(\"script\") ? (f = c.documentElement, l = function(h) {\n              var k = c.createElement(\"script\");\n              k.onreadystatechange = function() {\n                m(h), k.onreadystatechange = null, f.removeChild(k), k = null;\n              }, f.appendChild(k);\n            }) : l = function(h) {\n              setTimeout(m, 0, h);\n            }, u.setImmediate = function(h) {\n              typeof h != \"function\" && (h = new Function(\"\" + h));\n              for (var k = new Array(arguments.length - 1), T = 0; T < k.length; T++) k[T] = arguments[T + 1];\n              var E = { callback: h, args: k };\n              return t[b] = E, l(b), b++;\n            }, u.clearImmediate = g;\n          }\n          function g(h) {\n            delete t[h];\n          }\n          function m(h) {\n            if (n) setTimeout(m, 0, h);\n            else {\n              var k = t[h];\n              if (k) {\n                n = !0;\n                try {\n                  (function(T) {\n                    var E = T.callback, M = T.args;\n                    switch (M.length) {\n                      case 0:\n                        E();\n                        break;\n                      case 1:\n                        E(M[0]);\n                        break;\n                      case 2:\n                        E(M[0], M[1]);\n                        break;\n                      case 3:\n                        E(M[0], M[1], M[2]);\n                        break;\n                      default:\n                        E.apply(v, M);\n                    }\n                  })(k);\n                } finally {\n                  g(h), n = !1;\n                }\n              }\n            }\n          }\n        })(typeof self > \"u\" ? o === void 0 ? this : o : self);\n      }).call(this, r(0), r(7));\n    }, function(a, s) {\n      var r, o, e = a.exports = {};\n      function d() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n      function v() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n      function l(u) {\n        if (r === setTimeout) return setTimeout(u, 0);\n        if ((r === d || !r) && setTimeout) return r = setTimeout, setTimeout(u, 0);\n        try {\n          return r(u, 0);\n        } catch {\n          try {\n            return r.call(null, u, 0);\n          } catch {\n            return r.call(this, u, 0);\n          }\n        }\n      }\n      (function() {\n        try {\n          r = typeof setTimeout == \"function\" ? setTimeout : d;\n        } catch {\n          r = d;\n        }\n        try {\n          o = typeof clearTimeout == \"function\" ? clearTimeout : v;\n        } catch {\n          o = v;\n        }\n      })();\n      var f, p = [], y = !1, w = -1;\n      function b() {\n        y && f && (y = !1, f.length ? p = f.concat(p) : w = -1, p.length && t());\n      }\n      function t() {\n        if (!y) {\n          var u = l(b);\n          y = !0;\n          for (var g = p.length; g; ) {\n            for (f = p, p = []; ++w < g; ) f && f[w].run();\n            w = -1, g = p.length;\n          }\n          f = null, y = !1, function(m) {\n            if (o === clearTimeout) return clearTimeout(m);\n            if ((o === v || !o) && clearTimeout) return o = clearTimeout, clearTimeout(m);\n            try {\n              o(m);\n            } catch {\n              try {\n                return o.call(null, m);\n              } catch {\n                return o.call(this, m);\n              }\n            }\n          }(u);\n        }\n      }\n      function n(u, g) {\n        this.fun = u, this.array = g;\n      }\n      function c() {\n      }\n      e.nextTick = function(u) {\n        var g = new Array(arguments.length - 1);\n        if (arguments.length > 1) for (var m = 1; m < arguments.length; m++) g[m - 1] = arguments[m];\n        p.push(new n(u, g)), p.length !== 1 || y || l(t);\n      }, n.prototype.run = function() {\n        this.fun.apply(null, this.array);\n      }, e.title = \"browser\", e.browser = !0, e.env = {}, e.argv = [], e.version = \"\", e.versions = {}, e.on = c, e.addListener = c, e.once = c, e.off = c, e.removeListener = c, e.removeAllListeners = c, e.emit = c, e.prependListener = c, e.prependOnceListener = c, e.listeners = function(u) {\n        return [];\n      }, e.binding = function(u) {\n        throw new Error(\"process.binding is not supported\");\n      }, e.cwd = function() {\n        return \"/\";\n      }, e.chdir = function(u) {\n        throw new Error(\"process.chdir is not supported\");\n      }, e.umask = function() {\n        return 0;\n      };\n    }, function(a, s, r) {\n      function o(d, v) {\n        for (var l = 0; l < v.length; l++) {\n          var f = v[l];\n          f.enumerable = f.enumerable || !1, f.configurable = !0, \"value\" in f && (f.writable = !0), Object.defineProperty(d, f.key, f);\n        }\n      }\n      var e = r(9);\n      a.exports = function() {\n        function d() {\n          (function(p, y) {\n            if (!(p instanceof y)) throw new TypeError(\"Cannot call a class as a function\");\n          })(this, d);\n        }\n        var v, l, f;\n        return v = d, f = [{ key: \"urlEncode\", value: function(p) {\n          return e(p);\n        } }, { key: \"jsonEncode\", value: function(p) {\n          return JSON.stringify(p);\n        } }, { key: \"formEncode\", value: function(p) {\n          if (this.isFormData(p)) return p;\n          if (this.isFormElement(p)) return new FormData(p);\n          if (this.isObject(p)) {\n            var y = new FormData();\n            return Object.keys(p).forEach(function(w) {\n              var b = p[w];\n              y.append(w, b);\n            }), y;\n          }\n          throw new Error(\"`data` must be an instance of Object, FormData or <FORM> HTMLElement\");\n        } }, { key: \"isObject\", value: function(p) {\n          return Object.prototype.toString.call(p) === \"[object Object]\";\n        } }, { key: \"isFormData\", value: function(p) {\n          return p instanceof FormData;\n        } }, { key: \"isFormElement\", value: function(p) {\n          return p instanceof HTMLFormElement;\n        } }, { key: \"selectFiles\", value: function() {\n          var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n          return new Promise(function(y, w) {\n            var b = document.createElement(\"INPUT\");\n            b.type = \"file\", p.multiple && b.setAttribute(\"multiple\", \"multiple\"), p.accept && b.setAttribute(\"accept\", p.accept), b.style.display = \"none\", document.body.appendChild(b), b.addEventListener(\"change\", function(t) {\n              var n = t.target.files;\n              y(n), document.body.removeChild(b);\n            }, !1), b.click();\n          });\n        } }, { key: \"parseHeaders\", value: function(p) {\n          var y = p.trim().split(/[\\r\\n]+/), w = {};\n          return y.forEach(function(b) {\n            var t = b.split(\": \"), n = t.shift(), c = t.join(\": \");\n            n && (w[n] = c);\n          }), w;\n        } }], (l = null) && o(v.prototype, l), f && o(v, f), d;\n      }();\n    }, function(a, s) {\n      var r = function(e) {\n        return encodeURIComponent(e).replace(/[!'()*]/g, escape).replace(/%20/g, \"+\");\n      }, o = function(e, d, v, l) {\n        return d = d || null, v = v || \"&\", l = l || null, e ? function(f) {\n          for (var p = new Array(), y = 0; y < f.length; y++) f[y] && p.push(f[y]);\n          return p;\n        }(Object.keys(e).map(function(f) {\n          var p, y, w = f;\n          if (l && (w = l + \"[\" + w + \"]\"), typeof e[f] == \"object\" && e[f] !== null) p = o(e[f], null, v, w);\n          else {\n            d && (y = w, w = !isNaN(parseFloat(y)) && isFinite(y) ? d + Number(w) : w);\n            var b = e[f];\n            b = (b = (b = (b = b === !0 ? \"1\" : b) === !1 ? \"0\" : b) === 0 ? \"0\" : b) || \"\", p = r(w) + \"=\" + r(b);\n          }\n          return p;\n        })).join(v).replace(/[!'()*]/g, \"\") : \"\";\n      };\n      a.exports = o;\n    }]);\n  });\n})(H);\nvar q = H.exports;\nconst j = /* @__PURE__ */ U(q);\nfunction O(C) {\n  return C !== void 0 && typeof C.then == \"function\";\n}\nclass A {\n  /**\n   * @param params - uploader module params\n   * @param params.config - image tool config\n   * @param params.onUpload - one callback for all uploading (file, url, d-n-d, pasting)\n   * @param params.onError - callback for uploading errors\n   */\n  constructor({ config: i, onUpload: a, onError: s }) {\n    this.config = i, this.onUpload = a, this.onError = s;\n  }\n  /**\n   * Handle clicks on the upload file button\n   * Fires ajax.transport()\n   * @param onPreview - callback fired when preview is ready\n   */\n  uploadSelectedFile({ onPreview: i }) {\n    const a = function(r) {\n      const o = new FileReader();\n      o.readAsDataURL(r), o.onload = (e) => {\n        i(e.target.result);\n      };\n    };\n    let s;\n    if (this.config.uploader && typeof this.config.uploader.uploadByFile == \"function\") {\n      const r = this.config.uploader.uploadByFile;\n      s = j.selectFiles({ accept: this.config.types ?? \"image/*\" }).then((o) => {\n        a(o[0]);\n        const e = r(o[0]);\n        return O(e) || console.warn(\"Custom uploader method uploadByFile should return a Promise\"), e;\n      });\n    } else\n      s = j.transport({\n        url: this.config.endpoints.byFile,\n        data: this.config.additionalRequestData,\n        accept: this.config.types ?? \"image/*\",\n        headers: this.config.additionalRequestHeaders,\n        beforeSend: (r) => {\n          a(r[0]);\n        },\n        fieldName: this.config.field ?? \"image\"\n      }).then((r) => r.body);\n    s.then((r) => {\n      this.onUpload(r);\n    }).catch((r) => {\n      this.onError(r);\n    });\n  }\n  /**\n   * Handle clicks on the upload file button\n   * Fires ajax.post()\n   * @param url - image source url\n   */\n  uploadByUrl(i) {\n    let a;\n    this.config.uploader && typeof this.config.uploader.uploadByUrl == \"function\" ? (a = this.config.uploader.uploadByUrl(i), O(a) || console.warn(\"Custom uploader method uploadByUrl should return a Promise\")) : a = j.post({\n      url: this.config.endpoints.byUrl,\n      data: Object.assign({\n        url: i\n      }, this.config.additionalRequestData),\n      type: j.contentType.JSON,\n      headers: this.config.additionalRequestHeaders\n    }).then((s) => s.body), a.then((s) => {\n      this.onUpload(s);\n    }).catch((s) => {\n      this.onError(s);\n    });\n  }\n  /**\n   * Handle clicks on the upload file button\n   * Fires ajax.post()\n   * @param file - file pasted by drag-n-drop\n   * @param onPreview - file pasted by drag-n-drop\n   */\n  uploadByFile(i, { onPreview: a }) {\n    const s = new FileReader();\n    s.readAsDataURL(i), s.onload = (o) => {\n      a(o.target.result);\n    };\n    let r;\n    if (this.config.uploader && typeof this.config.uploader.uploadByFile == \"function\")\n      r = this.config.uploader.uploadByFile(i), O(r) || console.warn(\"Custom uploader method uploadByFile should return a Promise\");\n    else {\n      const o = new FormData();\n      o.append(this.config.field ?? \"image\", i), this.config.additionalRequestData && Object.keys(this.config.additionalRequestData).length && Object.entries(this.config.additionalRequestData).forEach(([e, d]) => {\n        o.append(e, d);\n      }), r = j.post({\n        url: this.config.endpoints.byFile,\n        data: o,\n        type: j.contentType.JSON,\n        headers: this.config.additionalRequestHeaders\n      }).then((e) => e.body);\n    }\n    r.then((o) => {\n      this.onUpload(o);\n    }).catch((o) => {\n      this.onError(o);\n    });\n  }\n}\n/**\n * Image Tool for the Editor.js\n * @author CodeX <team@codex.so>\n * @license MIT\n * @see {@link https://github.com/editor-js/image}\n *\n * To developers.\n * To simplify Tool structure, we split it to 4 parts:\n *  1) index.ts — main Tool's interface, public API and methods for working with data\n *  2) uploader.ts — module that has methods for sending files via AJAX: from device, by URL or File pasting\n *  3) ui.ts — module for UI manipulations: render, showing preloader, etc\n *\n * For debug purposes there is a testing server\n * that can save uploaded files and return a Response {@link UploadResponseFormat}\n *\n *       $ node dev/server.js\n *\n * It will expose 8008 port, so you can pass http://localhost:8008 with the Tools config:\n *\n * image: {\n *   class: ImageTool,\n *   config: {\n *     endpoints: {\n *       byFile: 'http://localhost:8008/uploadFile',\n *       byUrl: 'http://localhost:8008/fetchUrl',\n *     }\n *   },\n * },\n */\nclass P {\n  /**\n   * @param tool - tool properties got from editor.js\n   * @param tool.data - previously saved data\n   * @param tool.config - user config for Tool\n   * @param tool.api - Editor.js API\n   * @param tool.readOnly - read-only mode flag\n   * @param tool.block - current Block API\n   */\n  constructor({ data: i, config: a, api: s, readOnly: r, block: o }) {\n    this.isCaptionEnabled = null, this.api = s, this.block = o, this.config = {\n      endpoints: a.endpoints,\n      additionalRequestData: a.additionalRequestData,\n      additionalRequestHeaders: a.additionalRequestHeaders,\n      field: a.field,\n      types: a.types,\n      captionPlaceholder: this.api.i18n.t(a.captionPlaceholder ?? \"Caption\"),\n      buttonContent: a.buttonContent,\n      uploader: a.uploader,\n      actions: a.actions,\n      features: a.features || {}\n    }, this.uploader = new A({\n      config: this.config,\n      onUpload: (e) => this.onUpload(e),\n      onError: (e) => this.uploadingFailed(e)\n    }), this.ui = new D({\n      api: s,\n      config: this.config,\n      onSelectFile: () => {\n        this.uploader.uploadSelectedFile({\n          onPreview: (e) => {\n            this.ui.showPreloader(e);\n          }\n        });\n      },\n      readOnly: r\n    }), this._data = {\n      caption: \"\",\n      withBorder: !1,\n      withBackground: !1,\n      stretched: !1,\n      file: {\n        url: \"\"\n      }\n    }, this.data = i;\n  }\n  /**\n   * Notify core that read-only mode is supported\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   */\n  static get toolbox() {\n    return {\n      icon: L,\n      title: \"Image\"\n    };\n  }\n  /**\n   * Available image tools\n   */\n  static get tunes() {\n    return [\n      {\n        name: \"withBorder\",\n        icon: I,\n        title: \"With border\",\n        toggle: !0\n      },\n      {\n        name: \"stretched\",\n        icon: x,\n        title: \"Stretch image\",\n        toggle: !0\n      },\n      {\n        name: \"withBackground\",\n        icon: R,\n        title: \"With background\",\n        toggle: !0\n      }\n    ];\n  }\n  /**\n   * Renders Block content\n   */\n  render() {\n    var i, a, s;\n    return (((i = this.config.features) == null ? void 0 : i.caption) === !0 || ((a = this.config.features) == null ? void 0 : a.caption) === void 0 || ((s = this.config.features) == null ? void 0 : s.caption) === \"optional\" && this.data.caption) && (this.isCaptionEnabled = !0, this.ui.applyTune(\"caption\", !0)), this.ui.render();\n  }\n  /**\n   * Validate data: check if Image exists\n   * @param savedData — data received after saving\n   * @returns false if saved data is not correct, otherwise true\n   */\n  validate(i) {\n    return !!i.file.url;\n  }\n  /**\n   * Return Block data\n   */\n  save() {\n    const i = this.ui.nodes.caption;\n    return this._data.caption = i.innerHTML, this.data;\n  }\n  /**\n   * Returns configuration for block tunes: add background, add border, stretch image\n   * @returns TunesMenuConfig\n   */\n  renderSettings() {\n    var o;\n    const i = P.tunes.concat(this.config.actions || []), a = {\n      border: \"withBorder\",\n      background: \"withBackground\",\n      stretch: \"stretched\",\n      caption: \"caption\"\n    };\n    ((o = this.config.features) == null ? void 0 : o.caption) === \"optional\" && i.push({\n      name: \"caption\",\n      icon: B,\n      title: \"With caption\",\n      toggle: !0\n    });\n    const s = i.filter((e) => {\n      var v, l;\n      const d = Object.keys(a).find((f) => a[f] === e.name);\n      return d === \"caption\" ? ((v = this.config.features) == null ? void 0 : v.caption) !== !1 : d == null || ((l = this.config.features) == null ? void 0 : l[d]) !== !1;\n    }), r = (e) => {\n      let d = this.data[e.name];\n      return e.name === \"caption\" && (d = this.isCaptionEnabled ?? d), d;\n    };\n    return s.map((e) => ({\n      icon: e.icon,\n      label: this.api.i18n.t(e.title),\n      name: e.name,\n      toggle: e.toggle,\n      isActive: r(e),\n      onActivate: () => {\n        if (typeof e.action == \"function\") {\n          e.action(e.name);\n          return;\n        }\n        let d = !r(e);\n        e.name === \"caption\" && (this.isCaptionEnabled = !(this.isCaptionEnabled ?? !1), d = this.isCaptionEnabled), this.tuneToggled(e.name, d);\n      }\n    }));\n  }\n  /**\n   * Fires after clicks on the Toolbox Image Icon\n   * Initiates click on the Select File button\n   */\n  appendCallback() {\n    this.ui.nodes.fileButton.click();\n  }\n  /**\n   * Specify paste substitutes\n   * @see {@link https://github.com/codex-team/editor.js/blob/master/docs/tools.md#paste-handling}\n   */\n  static get pasteConfig() {\n    return {\n      /**\n       * Paste HTML into Editor\n       */\n      tags: [\n        {\n          img: { src: !0 }\n        }\n      ],\n      /**\n       * Paste URL of image into the Editor\n       */\n      patterns: {\n        image: /https?:\\/\\/\\S+\\.(gif|jpe?g|tiff|png|svg|webp)(\\?[a-z0-9=]*)?$/i\n      },\n      /**\n       * Drag n drop file from into the Editor\n       */\n      files: {\n        mimeTypes: [\"image/*\"]\n      }\n    };\n  }\n  /**\n   * Specify paste handlers\n   * @see {@link https://github.com/codex-team/editor.js/blob/master/docs/tools.md#paste-handling}\n   * @param event - editor.js custom paste event\n   *                              {@link https://github.com/codex-team/editor.js/blob/master/types/tools/paste-events.d.ts}\n   */\n  async onPaste(i) {\n    switch (i.type) {\n      case \"tag\": {\n        const a = i.detail.data;\n        if (/^blob:/.test(a.src)) {\n          const r = await (await fetch(a.src)).blob();\n          this.uploadFile(r);\n          break;\n        }\n        this.uploadUrl(a.src);\n        break;\n      }\n      case \"pattern\": {\n        const a = i.detail.data;\n        this.uploadUrl(a);\n        break;\n      }\n      case \"file\": {\n        const a = i.detail.file;\n        this.uploadFile(a);\n        break;\n      }\n    }\n  }\n  /**\n   * Private methods\n   * ̿̿ ̿̿ ̿̿ ̿'̿'\\̵͇̿̿\\з= ( ▀ ͜͞ʖ▀) =ε/̵͇̿̿/’̿’̿ ̿ ̿̿ ̿̿ ̿̿\n   */\n  /**\n   * Stores all Tool's data\n   * @param data - data in Image Tool format\n   */\n  set data(i) {\n    var a;\n    this.image = i.file, this._data.caption = i.caption || \"\", this.ui.fillCaption(this._data.caption), P.tunes.forEach(({ name: s }) => {\n      const r = typeof i[s] < \"u\" ? i[s] === !0 || i[s] === \"true\" : !1;\n      this.setTune(s, r);\n    }), i.caption ? this.setTune(\"caption\", !0) : ((a = this.config.features) == null ? void 0 : a.caption) === !0 && this.setTune(\"caption\", !0);\n  }\n  /**\n   * Return Tool data\n   */\n  get data() {\n    return this._data;\n  }\n  /**\n   * Set new image file\n   * @param file - uploaded file data\n   */\n  set image(i) {\n    this._data.file = i || { url: \"\" }, i && i.url && this.ui.fillImage(i.url);\n  }\n  /**\n   * File uploading callback\n   * @param response - uploading server response\n   */\n  onUpload(i) {\n    i.success && i.file ? this.image = i.file : this.uploadingFailed(\"incorrect response: \" + JSON.stringify(i));\n  }\n  /**\n   * Handle uploader errors\n   * @param errorText - uploading error info\n   */\n  uploadingFailed(i) {\n    console.log(\"Image Tool: uploading failed because of\", i), this.api.notifier.show({\n      message: this.api.i18n.t(\"Couldn’t upload image. Please try another.\"),\n      style: \"error\"\n    }), this.ui.hidePreloader();\n  }\n  /**\n   * Callback fired when Block Tune is activated\n   * @param tuneName - tune that has been clicked\n   * @param state - new state\n   */\n  tuneToggled(i, a) {\n    i === \"caption\" ? (this.ui.applyTune(i, a), a == !1 && (this._data.caption = \"\", this.ui.fillCaption(\"\"))) : this.setTune(i, a);\n  }\n  /**\n   * Set one tune\n   * @param tuneName - {@link Tunes.tunes}\n   * @param value - tune state\n   */\n  setTune(i, a) {\n    this._data[i] = a, this.ui.applyTune(i, a), i === \"stretched\" && Promise.resolve().then(() => {\n      this.block.stretched = a;\n    }).catch((s) => {\n      console.error(s);\n    });\n  }\n  /**\n   * Show preloader and upload image file\n   * @param file - file that is currently uploading (from paste)\n   */\n  uploadFile(i) {\n    this.uploader.uploadByFile(i, {\n      onPreview: (a) => {\n        this.ui.showPreloader(a);\n      }\n    });\n  }\n  /**\n   * Show preloader and upload image by target url\n   * @param url - url pasted\n   */\n  uploadUrl(i) {\n    this.ui.showPreloader(i), this.uploader.uploadByUrl(i);\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2ltYWdlL2Rpc3QvaW1hZ2UubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxZQUFZLGFBQWEsSUFBSSx3QkFBd0Isc0NBQXNDLG1EQUFtRCxvQkFBb0IsdUJBQXVCLHdCQUF3QixtQkFBbUIsa0JBQWtCLGdCQUFnQixtQkFBbUIsaUJBQWlCLDJCQUEyQixlQUFlLHNCQUFzQixjQUFjLDZCQUE2QixXQUFXLFlBQVksa0JBQWtCLHNCQUFzQixZQUFZLGtCQUFrQixpQ0FBaUMsa0NBQWtDLG1DQUFtQyxXQUFXLGtCQUFrQixVQUFVLFdBQVcsWUFBWSxrQkFBa0IsaUNBQWlDLG9DQUFvQyxTQUFTLFFBQVEsaUJBQWlCLGtCQUFrQixrREFBa0Qsc0JBQXNCLHFCQUFxQixrQkFBa0Isa0JBQWtCLFNBQVMsT0FBTyxtQkFBbUIsb0VBQW9FLDRCQUE0QiwrQkFBK0IsY0FBYyxnQkFBZ0IsYUFBYSwwRUFBMEUsY0FBYyxnRkFBZ0YsYUFBYSxzRkFBc0YsYUFBYSxvRkFBb0YsNEJBQTRCLHdCQUF3QixhQUFhLG1CQUFtQix1QkFBdUIsNEJBQTRCLFlBQVksaUJBQWlCLGlGQUFpRixhQUFhLDBDQUEwQyxpQkFBaUIsYUFBYSxxQ0FBcUMsc0JBQXNCLHFGQUFxRixhQUFhLDJDQUEyQyxxQ0FBcUMsK0NBQStDLGFBQWEsMkJBQTJCLHVEQUF1RCxjQUFjLGNBQWMsa0RBQWtELFdBQVcsMENBQTBDLG1CQUFtQixxQkFBcUIsb0JBQW9CLGdDQUFnQyxHQUFHLG9CQUFvQixHQUFHLDBCQUEwQixrQ0FBa0MsU0FBUyxtREFBbUQ7QUFDamhGO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtHQUErRztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFpRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQ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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkhBQTJILFNBQVM7QUFDcEk7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vbm9kZV9tb2R1bGVzL0BlZGl0b3Jqcy9pbWFnZS9kaXN0L2ltYWdlLm1qcz9jOTRhIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3RyeXtpZih0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIpe3ZhciBvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtvLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcuaW1hZ2UtdG9vbHstLWJnLWNvbG9yOiAjY2RkMWUwOy0tZnJvbnQtY29sb3I6ICMzODhhZTU7LS1ib3JkZXItY29sb3I6ICNlOGU4ZWJ9LmltYWdlLXRvb2xfX2ltYWdle2JvcmRlci1yYWRpdXM6M3B4O292ZXJmbG93OmhpZGRlbjttYXJnaW4tYm90dG9tOjEwcHg7cGFkZGluZy1ib3R0b206MH0uaW1hZ2UtdG9vbF9faW1hZ2UtcGljdHVyZXttYXgtd2lkdGg6MTAwJTt2ZXJ0aWNhbC1hbGlnbjpib3R0b207ZGlzcGxheTpibG9ja30uaW1hZ2UtdG9vbF9faW1hZ2UtcHJlbG9hZGVye3dpZHRoOjUwcHg7aGVpZ2h0OjUwcHg7Ym9yZGVyLXJhZGl1czo1MCU7YmFja2dyb3VuZC1zaXplOmNvdmVyO21hcmdpbjphdXRvO3Bvc2l0aW9uOnJlbGF0aXZlO2JhY2tncm91bmQtY29sb3I6dmFyKC0tYmctY29sb3IpO2JhY2tncm91bmQtcG9zaXRpb246Y2VudGVyIGNlbnRlcn0uaW1hZ2UtdG9vbF9faW1hZ2UtcHJlbG9hZGVyOmFmdGVye2NvbnRlbnQ6XCJcIjtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjM7d2lkdGg6NjBweDtoZWlnaHQ6NjBweDtib3JkZXItcmFkaXVzOjUwJTtib3JkZXI6MnB4IHNvbGlkIHZhcigtLWJnLWNvbG9yKTtib3JkZXItdG9wLWNvbG9yOnZhcigtLWZyb250LWNvbG9yKTtsZWZ0OjUwJTt0b3A6NTAlO21hcmdpbi10b3A6LTMwcHg7bWFyZ2luLWxlZnQ6LTMwcHg7YW5pbWF0aW9uOmltYWdlLXByZWxvYWRlci1zcGluIDJzIGluZmluaXRlIGxpbmVhcjtib3gtc2l6aW5nOmJvcmRlci1ib3h9LmltYWdlLXRvb2xfX2NhcHRpb257dmlzaWJpbGl0eTpoaWRkZW47cG9zaXRpb246YWJzb2x1dGU7Ym90dG9tOjA7bGVmdDowO21hcmdpbi1ib3R0b206MTBweH0uaW1hZ2UtdG9vbF9fY2FwdGlvbltjb250ZW50RWRpdGFibGU9dHJ1ZV1bZGF0YS1wbGFjZWhvbGRlcl06YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlIWltcG9ydGFudDtjb250ZW50OmF0dHIoZGF0YS1wbGFjZWhvbGRlcik7Y29sb3I6IzcwNzY4NDtmb250LXdlaWdodDo0MDA7ZGlzcGxheTpub25lfS5pbWFnZS10b29sX19jYXB0aW9uW2NvbnRlbnRFZGl0YWJsZT10cnVlXVtkYXRhLXBsYWNlaG9sZGVyXTplbXB0eTpiZWZvcmV7ZGlzcGxheTpibG9ja30uaW1hZ2UtdG9vbF9fY2FwdGlvbltjb250ZW50RWRpdGFibGU9dHJ1ZV1bZGF0YS1wbGFjZWhvbGRlcl06ZW1wdHk6Zm9jdXM6YmVmb3Jle2Rpc3BsYXk6bm9uZX0uaW1hZ2UtdG9vbC0tZW1wdHkgLmltYWdlLXRvb2xfX2ltYWdlLC5pbWFnZS10b29sLS1lbXB0eSAuaW1hZ2UtdG9vbF9faW1hZ2UtcHJlbG9hZGVye2Rpc3BsYXk6bm9uZX0uaW1hZ2UtdG9vbC0tZW1wdHkgLmltYWdlLXRvb2xfX2NhcHRpb24sLmltYWdlLXRvb2wtLXVwbG9hZGluZyAuaW1hZ2UtdG9vbF9fY2FwdGlvbnt2aXNpYmlsaXR5OmhpZGRlbiFpbXBvcnRhbnR9LmltYWdlLXRvb2wgLmNkeC1idXR0b257ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5pbWFnZS10b29sIC5jZHgtYnV0dG9uIHN2Z3toZWlnaHQ6YXV0bzttYXJnaW46MCA2cHggMCAwfS5pbWFnZS10b29sLS1maWxsZWQgLmNkeC1idXR0b24sLmltYWdlLXRvb2wtLWZpbGxlZCAuaW1hZ2UtdG9vbF9faW1hZ2UtcHJlbG9hZGVye2Rpc3BsYXk6bm9uZX0uaW1hZ2UtdG9vbC0tdXBsb2FkaW5nIC5pbWFnZS10b29sX19pbWFnZXttaW4taGVpZ2h0OjIwMHB4O2Rpc3BsYXk6ZmxleDtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWJvcmRlci1jb2xvcik7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5pbWFnZS10b29sLS11cGxvYWRpbmcgLmltYWdlLXRvb2xfX2ltYWdlLXBpY3R1cmUsLmltYWdlLXRvb2wtLXVwbG9hZGluZyAuY2R4LWJ1dHRvbntkaXNwbGF5Om5vbmV9LmltYWdlLXRvb2wtLXdpdGhCb3JkZXIgLmltYWdlLXRvb2xfX2ltYWdle2JvcmRlcjoxcHggc29saWQgdmFyKC0tYm9yZGVyLWNvbG9yKX0uaW1hZ2UtdG9vbC0td2l0aEJhY2tncm91bmQgLmltYWdlLXRvb2xfX2ltYWdle3BhZGRpbmc6MTVweDtiYWNrZ3JvdW5kOnZhcigtLWJnLWNvbG9yKX0uaW1hZ2UtdG9vbC0td2l0aEJhY2tncm91bmQgLmltYWdlLXRvb2xfX2ltYWdlLXBpY3R1cmV7bWF4LXdpZHRoOjYwJTttYXJnaW46MCBhdXRvfS5pbWFnZS10b29sLS1zdHJldGNoZWQgLmltYWdlLXRvb2xfX2ltYWdlLXBpY3R1cmV7d2lkdGg6MTAwJX0uaW1hZ2UtdG9vbC0tY2FwdGlvbiAuaW1hZ2UtdG9vbF9fY2FwdGlvbnt2aXNpYmlsaXR5OnZpc2libGV9LmltYWdlLXRvb2wtLWNhcHRpb257cGFkZGluZy1ib3R0b206NTBweH1Aa2V5ZnJhbWVzIGltYWdlLXByZWxvYWRlci1zcGluezAle3RyYW5zZm9ybTpyb3RhdGUoMCl9dG97dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX0nKSksZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChvKX19Y2F0Y2goZSl7Y29uc29sZS5lcnJvcihcInZpdGUtcGx1Z2luLWNzcy1pbmplY3RlZC1ieS1qc1wiLGUpfX0pKCk7XG5jb25zdCBSID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTExIDE5VjE5QzkuMTM2MjMgMTkgOC4yMDQzNSAxOSA3LjQ2OTI3IDE4LjY5NTVDNi40ODkxNSAxOC4yODk1IDUuNzEwNDYgMTcuNTEwOCA1LjMwNDQ4IDE2LjUzMDdDNSAxNS43OTU2IDUgMTQuODYzOCA1IDEzVjEyQzUgOS4xOTEwOCA1IDcuNzg2NjEgNS42NzQxMiA2Ljc3NzcyQzUuOTY1OTYgNi4zNDA5NiA2LjM0MDk2IDUuOTY1OTYgNi43Nzc3MiA1LjY3NDEyQzcuNzg2NjEgNSA5LjE5MTA4IDUgMTIgNUgxMy41QzE0Ljg5NTYgNSAxNS41OTMzIDUgMTYuMTYxMSA1LjE3MjI0QzE3LjQzOTUgNS41NjAwNCAxOC40NCA2LjU2MDQ2IDE4LjgyNzggNy44Mzg4NkMxOSA4LjQwNjY2IDE5IDkuMTA0NDQgMTkgMTAuNVYxMC41XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNiAxM1YxNk0xNiAxOVYxNk0xOSAxNkgxNk0xNiAxNkgxM1wiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk02LjUgMTcuNUwxNy41IDYuNVwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xOC45OTE5IDEwLjVIMTkuMDAxNVwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xMC45OTE5IDE5SDExLjAwMTVcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNSAxM0wxMyA1XCIvPjwvc3ZnPicsIEkgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTguOTkxOSA5LjVIMTkuMDAxNVwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNC41IDVIMTQuNTA5NlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTQuNjI1IDVIMTVDMTcuMjA5MSA1IDE5IDYuNzkwODYgMTkgOVY5LjM3NVwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk05LjM3NSA1TDkgNUM2Ljc5MDg2IDUgNSA2Ljc5MDg2IDUgOVY5LjM3NVwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk05LjM3MjUgNUg5LjM4MjA3XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTUgOS41SDUuMDA5NTdcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNOS4zNzUgMTlIOUM2Ljc5MDg2IDE5IDUgMTcuMjA5MSA1IDE1VjE0LjYyNVwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk05LjM3MjUgMTlIOS4zODIwN1wiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk01IDE0LjU1SDUuMDA5NTdcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE2IDEzVjE2TTE2IDE5VjE2TTE5IDE2SDE2TTE2IDE2SDEzXCIvPjwvc3ZnPicsIEwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHJlY3Qgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCIgeD1cIjVcIiB5PVwiNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiByeD1cIjRcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNS4xMzk2OCAxNS4zMkw4LjY5MDU4IDExLjU2NjFDOS4wMjkzNCAxMS4yMDM2IDkuNDg4NzMgMTEgOS45Njc3NCAxMUMxMC40NDY3IDExIDEwLjkwNjEgMTEuMjAzNiAxMS4yNDQ5IDExLjU2NjFMMTUuMzg3MSAxNk0xMy41ODA2IDE0LjA2NjRMMTUuMDEzMiAxMi41MzNDMTUuMzUxOSAxMi4xNzA1IDE1LjgxMTMgMTEuOTY2OCAxNi4yOTAzIDExLjk2NjhDMTYuNzY5MyAxMS45NjY4IDE3LjIyODcgMTIuMTcwNSAxNy41Njc1IDEyLjUzM0wxOC44NDEgMTMuOTYzNFwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xMy43Nzc4IDkuMzMzMzFIMTMuNzg2N1wiLz48L3N2Zz4nLCB4ID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE3IDlMMjAgMTJMMTcgMTVcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTQgMTJIMjBcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNyA5TDQgMTJMNyAxNVwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk00IDEySDEwXCIvPjwvc3ZnPicsIEIgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTggOVY3LjJDOCA3LjA4OTU0IDguMDg5NTQgNyA4LjIgN0wxMiA3TTE2IDlWNy4yQzE2IDcuMDg5NTQgMTUuOTEwNSA3IDE1LjggN0wxMiA3TTEyIDdMMTIgMTdNMTIgMTdIMTBNMTIgMTdIMTRcIi8+PC9zdmc+JztcbmZ1bmN0aW9uIFMoQywgaSA9IG51bGwsIGEgPSB7fSkge1xuICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChDKTtcbiAgQXJyYXkuaXNBcnJheShpKSA/IHMuY2xhc3NMaXN0LmFkZCguLi5pKSA6IGkgIT09IG51bGwgJiYgcy5jbGFzc0xpc3QuYWRkKGkpO1xuICBmb3IgKGNvbnN0IHIgaW4gYSlcbiAgICBhLmhhc093blByb3BlcnR5KHIpICYmIChzW3JdID0gYVtyXSk7XG4gIHJldHVybiBzO1xufVxudmFyIF8gPSAvKiBAX19QVVJFX18gKi8gKChDKSA9PiAoQy5FbXB0eSA9IFwiZW1wdHlcIiwgQy5VcGxvYWRpbmcgPSBcInVwbG9hZGluZ1wiLCBDLkZpbGxlZCA9IFwiZmlsbGVkXCIsIEMpKShfIHx8IHt9KTtcbmNsYXNzIEQge1xuICAvKipcbiAgICogQHBhcmFtIHVpIC0gaW1hZ2UgdG9vbCBVaSBtb2R1bGVcbiAgICogQHBhcmFtIHVpLmFwaSAtIEVkaXRvci5qcyBBUElcbiAgICogQHBhcmFtIHVpLmNvbmZpZyAtIHVzZXIgY29uZmlnXG4gICAqIEBwYXJhbSB1aS5vblNlbGVjdEZpbGUgLSBjYWxsYmFjayBmb3IgY2xpY2tzIG9uIFNlbGVjdCBmaWxlIGJ1dHRvblxuICAgKiBAcGFyYW0gdWkucmVhZE9ubHkgLSByZWFkLW9ubHkgbW9kZSBmbGFnXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGFwaTogaSwgY29uZmlnOiBhLCBvblNlbGVjdEZpbGU6IHMsIHJlYWRPbmx5OiByIH0pIHtcbiAgICB0aGlzLmFwaSA9IGksIHRoaXMuY29uZmlnID0gYSwgdGhpcy5vblNlbGVjdEZpbGUgPSBzLCB0aGlzLnJlYWRPbmx5ID0gciwgdGhpcy5ub2RlcyA9IHtcbiAgICAgIHdyYXBwZXI6IFMoXCJkaXZcIiwgW3RoaXMuQ1NTLmJhc2VDbGFzcywgdGhpcy5DU1Mud3JhcHBlcl0pLFxuICAgICAgaW1hZ2VDb250YWluZXI6IFMoXCJkaXZcIiwgW3RoaXMuQ1NTLmltYWdlQ29udGFpbmVyXSksXG4gICAgICBmaWxlQnV0dG9uOiB0aGlzLmNyZWF0ZUZpbGVCdXR0b24oKSxcbiAgICAgIGltYWdlRWw6IHZvaWQgMCxcbiAgICAgIGltYWdlUHJlbG9hZGVyOiBTKFwiZGl2XCIsIHRoaXMuQ1NTLmltYWdlUHJlbG9hZGVyKSxcbiAgICAgIGNhcHRpb246IFMoXCJkaXZcIiwgW3RoaXMuQ1NTLmlucHV0LCB0aGlzLkNTUy5jYXB0aW9uXSwge1xuICAgICAgICBjb250ZW50RWRpdGFibGU6ICF0aGlzLnJlYWRPbmx5XG4gICAgICB9KVxuICAgIH0sIHRoaXMubm9kZXMuY2FwdGlvbi5kYXRhc2V0LnBsYWNlaG9sZGVyID0gdGhpcy5jb25maWcuY2FwdGlvblBsYWNlaG9sZGVyLCB0aGlzLm5vZGVzLmltYWdlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubm9kZXMuaW1hZ2VQcmVsb2FkZXIpLCB0aGlzLm5vZGVzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5pbWFnZUNvbnRhaW5lciksIHRoaXMubm9kZXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLm5vZGVzLmNhcHRpb24pLCB0aGlzLm5vZGVzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5maWxlQnV0dG9uKTtcbiAgfVxuICAvKipcbiAgICogQXBwbHkgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIGFjdGl2YXRlZCB0dW5lXG4gICAqIEBwYXJhbSB0dW5lTmFtZSAtIG9uZSBvZiBhdmFpbGFibGUgdHVuZXMge0BsaW5rIFR1bmVzLnR1bmVzfVxuICAgKiBAcGFyYW0gc3RhdHVzIC0gdHJ1ZSBmb3IgZW5hYmxlLCBmYWxzZSBmb3IgZGlzYWJsZVxuICAgKi9cbiAgYXBwbHlUdW5lKGksIGEpIHtcbiAgICB0aGlzLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LnRvZ2dsZShgJHt0aGlzLkNTUy53cmFwcGVyfS0tJHtpfWAsIGEpO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHRvb2wgVUlcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy50b2dnbGVTdGF0dXMoXG4gICAgICBcImVtcHR5XCJcbiAgICAgIC8qIEVtcHR5ICovXG4gICAgKSwgdGhpcy5ub2Rlcy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyB1cGxvYWRpbmcgcHJlbG9hZGVyXG4gICAqIEBwYXJhbSBzcmMgLSBwcmV2aWV3IHNvdXJjZVxuICAgKi9cbiAgc2hvd1ByZWxvYWRlcihpKSB7XG4gICAgdGhpcy5ub2Rlcy5pbWFnZVByZWxvYWRlci5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCR7aX0pYCwgdGhpcy50b2dnbGVTdGF0dXMoXG4gICAgICBcInVwbG9hZGluZ1wiXG4gICAgICAvKiBVcGxvYWRpbmcgKi9cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBIaWRlIHVwbG9hZGluZyBwcmVsb2FkZXJcbiAgICovXG4gIGhpZGVQcmVsb2FkZXIoKSB7XG4gICAgdGhpcy5ub2Rlcy5pbWFnZVByZWxvYWRlci5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBcIlwiLCB0aGlzLnRvZ2dsZVN0YXR1cyhcbiAgICAgIFwiZW1wdHlcIlxuICAgICAgLyogRW1wdHkgKi9cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBTaG93cyBhbiBpbWFnZVxuICAgKiBAcGFyYW0gdXJsIC0gaW1hZ2Ugc291cmNlXG4gICAqL1xuICBmaWxsSW1hZ2UoaSkge1xuICAgIGNvbnN0IGEgPSAvXFwubXA0JC8udGVzdChpKSA/IFwiVklERU9cIiA6IFwiSU1HXCIsIHMgPSB7XG4gICAgICBzcmM6IGlcbiAgICB9O1xuICAgIGxldCByID0gXCJsb2FkXCI7XG4gICAgYSA9PT0gXCJWSURFT1wiICYmIChzLmF1dG9wbGF5ID0gITAsIHMubG9vcCA9ICEwLCBzLm11dGVkID0gITAsIHMucGxheXNpbmxpbmUgPSAhMCwgciA9IFwibG9hZGVkZGF0YVwiKSwgdGhpcy5ub2Rlcy5pbWFnZUVsID0gUyhhLCB0aGlzLkNTUy5pbWFnZUVsLCBzKSwgdGhpcy5ub2Rlcy5pbWFnZUVsLmFkZEV2ZW50TGlzdGVuZXIociwgKCkgPT4ge1xuICAgICAgdGhpcy50b2dnbGVTdGF0dXMoXG4gICAgICAgIFwiZmlsbGVkXCJcbiAgICAgICAgLyogRmlsbGVkICovXG4gICAgICApLCB0aGlzLm5vZGVzLmltYWdlUHJlbG9hZGVyICE9PSB2b2lkIDAgJiYgKHRoaXMubm9kZXMuaW1hZ2VQcmVsb2FkZXIuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJcIik7XG4gICAgfSksIHRoaXMubm9kZXMuaW1hZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2Rlcy5pbWFnZUVsKTtcbiAgfVxuICAvKipcbiAgICogU2hvd3MgY2FwdGlvbiBpbnB1dFxuICAgKiBAcGFyYW0gdGV4dCAtIGNhcHRpb24gY29udGVudCB0ZXh0XG4gICAqL1xuICBmaWxsQ2FwdGlvbihpKSB7XG4gICAgdGhpcy5ub2Rlcy5jYXB0aW9uICE9PSB2b2lkIDAgJiYgKHRoaXMubm9kZXMuY2FwdGlvbi5pbm5lckhUTUwgPSBpKTtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyBVSSBzdGF0dXNcbiAgICogQHBhcmFtIHN0YXR1cyAtIHNlZSB7QGxpbmsgVWkuc3RhdHVzfSBjb25zdGFudHNcbiAgICovXG4gIHRvZ2dsZVN0YXR1cyhpKSB7XG4gICAgZm9yIChjb25zdCBhIGluIF8pXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF8sIGEpKSB7XG4gICAgICAgIGNvbnN0IHMgPSBfW2FdO1xuICAgICAgICB0aGlzLm5vZGVzLndyYXBwZXIuY2xhc3NMaXN0LnRvZ2dsZShgJHt0aGlzLkNTUy53cmFwcGVyfS0tJHtzfWAsIHMgPT09IGkpO1xuICAgICAgfVxuICB9XG4gIC8qKlxuICAgKiBDU1MgY2xhc3Nlc1xuICAgKi9cbiAgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmFzZUNsYXNzOiB0aGlzLmFwaS5zdHlsZXMuYmxvY2ssXG4gICAgICBsb2FkaW5nOiB0aGlzLmFwaS5zdHlsZXMubG9hZGVyLFxuICAgICAgaW5wdXQ6IHRoaXMuYXBpLnN0eWxlcy5pbnB1dCxcbiAgICAgIGJ1dHRvbjogdGhpcy5hcGkuc3R5bGVzLmJ1dHRvbixcbiAgICAgIC8qKlxuICAgICAgICogVG9vbCdzIGNsYXNzZXNcbiAgICAgICAqL1xuICAgICAgd3JhcHBlcjogXCJpbWFnZS10b29sXCIsXG4gICAgICBpbWFnZUNvbnRhaW5lcjogXCJpbWFnZS10b29sX19pbWFnZVwiLFxuICAgICAgaW1hZ2VQcmVsb2FkZXI6IFwiaW1hZ2UtdG9vbF9faW1hZ2UtcHJlbG9hZGVyXCIsXG4gICAgICBpbWFnZUVsOiBcImltYWdlLXRvb2xfX2ltYWdlLXBpY3R1cmVcIixcbiAgICAgIGNhcHRpb246IFwiaW1hZ2UtdG9vbF9fY2FwdGlvblwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB1cGxvYWQtZmlsZSBidXR0b25cbiAgICovXG4gIGNyZWF0ZUZpbGVCdXR0b24oKSB7XG4gICAgY29uc3QgaSA9IFMoXCJkaXZcIiwgW3RoaXMuQ1NTLmJ1dHRvbl0pO1xuICAgIHJldHVybiBpLmlubmVySFRNTCA9IHRoaXMuY29uZmlnLmJ1dHRvbkNvbnRlbnQgPz8gYCR7TH0gJHt0aGlzLmFwaS5pMThuLnQoXCJTZWxlY3QgYW4gSW1hZ2VcIil9YCwgaS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5vblNlbGVjdEZpbGUoKTtcbiAgICB9KSwgaTtcbiAgfVxufVxuZnVuY3Rpb24gVShDKSB7XG4gIHJldHVybiBDICYmIEMuX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQywgXCJkZWZhdWx0XCIpID8gQy5kZWZhdWx0IDogQztcbn1cbnZhciBIID0geyBleHBvcnRzOiB7fSB9O1xuKGZ1bmN0aW9uKEMsIGkpIHtcbiAgKGZ1bmN0aW9uKGEsIHMpIHtcbiAgICBDLmV4cG9ydHMgPSBzKCk7XG4gIH0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEpIHtcbiAgICAgIHZhciBzID0ge307XG4gICAgICBmdW5jdGlvbiByKG8pIHtcbiAgICAgICAgaWYgKHNbb10pIHJldHVybiBzW29dLmV4cG9ydHM7XG4gICAgICAgIHZhciBlID0gc1tvXSA9IHsgaTogbywgbDogITEsIGV4cG9ydHM6IHt9IH07XG4gICAgICAgIHJldHVybiBhW29dLmNhbGwoZS5leHBvcnRzLCBlLCBlLmV4cG9ydHMsIHIpLCBlLmwgPSAhMCwgZS5leHBvcnRzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHIubSA9IGEsIHIuYyA9IHMsIHIuZCA9IGZ1bmN0aW9uKG8sIGUsIGQpIHtcbiAgICAgICAgci5vKG8sIGUpIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBlLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGQgfSk7XG4gICAgICB9LCByLnIgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIHR5cGVvZiBTeW1ib2wgPCBcInVcIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgICAgIH0sIHIudCA9IGZ1bmN0aW9uKG8sIGUpIHtcbiAgICAgICAgaWYgKDEgJiBlICYmIChvID0gcihvKSksIDggJiBlIHx8IDQgJiBlICYmIHR5cGVvZiBvID09IFwib2JqZWN0XCIgJiYgbyAmJiBvLl9fZXNNb2R1bGUpIHJldHVybiBvO1xuICAgICAgICB2YXIgZCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBpZiAoci5yKGQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZCwgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogITAsIHZhbHVlOiBvIH0pLCAyICYgZSAmJiB0eXBlb2YgbyAhPSBcInN0cmluZ1wiKSBmb3IgKHZhciB2IGluIG8pIHIuZChkLCB2LCAoZnVuY3Rpb24obCkge1xuICAgICAgICAgIHJldHVybiBvW2xdO1xuICAgICAgICB9KS5iaW5kKG51bGwsIHYpKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9LCByLm4gPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIHZhciBlID0gbyAmJiBvLl9fZXNNb2R1bGUgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gby5kZWZhdWx0O1xuICAgICAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByLmQoZSwgXCJhXCIsIGUpLCBlO1xuICAgICAgfSwgci5vID0gZnVuY3Rpb24obywgZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGUpO1xuICAgICAgfSwgci5wID0gXCJcIiwgcihyLnMgPSAzKTtcbiAgICB9KFtmdW5jdGlvbihhLCBzKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIHIgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgciA9IHIgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICB0eXBlb2Ygd2luZG93ID09IFwib2JqZWN0XCIgJiYgKHIgPSB3aW5kb3cpO1xuICAgICAgfVxuICAgICAgYS5leHBvcnRzID0gcjtcbiAgICB9LCBmdW5jdGlvbihhLCBzLCByKSB7XG4gICAgICAoZnVuY3Rpb24obykge1xuICAgICAgICB2YXIgZSA9IHIoMiksIGQgPSBzZXRUaW1lb3V0O1xuICAgICAgICBmdW5jdGlvbiB2KCkge1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGwobikge1xuICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ld1wiKTtcbiAgICAgICAgICBpZiAodHlwZW9mIG4gIT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwibm90IGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgdGhpcy5fc3RhdGUgPSAwLCB0aGlzLl9oYW5kbGVkID0gITEsIHRoaXMuX3ZhbHVlID0gdm9pZCAwLCB0aGlzLl9kZWZlcnJlZHMgPSBbXSwgdChuLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmKG4sIGMpIHtcbiAgICAgICAgICBmb3IgKDsgbi5fc3RhdGUgPT09IDM7ICkgbiA9IG4uX3ZhbHVlO1xuICAgICAgICAgIG4uX3N0YXRlICE9PSAwID8gKG4uX2hhbmRsZWQgPSAhMCwgbC5faW1tZWRpYXRlRm4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdSA9IG4uX3N0YXRlID09PSAxID8gYy5vbkZ1bGZpbGxlZCA6IGMub25SZWplY3RlZDtcbiAgICAgICAgICAgIGlmICh1ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBnO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGcgPSB1KG4uX3ZhbHVlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAobSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIHkoYy5wcm9taXNlLCBtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwKGMucHJvbWlzZSwgZyk7XG4gICAgICAgICAgICB9IGVsc2UgKG4uX3N0YXRlID09PSAxID8gcCA6IHkpKGMucHJvbWlzZSwgbi5fdmFsdWUpO1xuICAgICAgICAgIH0pKSA6IG4uX2RlZmVycmVkcy5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHAobiwgYykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gbikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuXCIpO1xuICAgICAgICAgICAgaWYgKGMgJiYgKHR5cGVvZiBjID09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGMgPT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgICB2YXIgdSA9IGMudGhlbjtcbiAgICAgICAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBsKSByZXR1cm4gbi5fc3RhdGUgPSAzLCBuLl92YWx1ZSA9IGMsIHZvaWQgdyhuKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB1ID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHZvaWQgdCgoZyA9IHUsIG0gPSBjLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBnLmFwcGx5KG0sIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIH0pLCBuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4uX3N0YXRlID0gMSwgbi5fdmFsdWUgPSBjLCB3KG4pO1xuICAgICAgICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgICAgICAgIHkobiwgaCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBnLCBtO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHkobiwgYykge1xuICAgICAgICAgIG4uX3N0YXRlID0gMiwgbi5fdmFsdWUgPSBjLCB3KG4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHcobikge1xuICAgICAgICAgIG4uX3N0YXRlID09PSAyICYmIG4uX2RlZmVycmVkcy5sZW5ndGggPT09IDAgJiYgbC5faW1tZWRpYXRlRm4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBuLl9oYW5kbGVkIHx8IGwuX3VuaGFuZGxlZFJlamVjdGlvbkZuKG4uX3ZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKHZhciBjID0gMCwgdSA9IG4uX2RlZmVycmVkcy5sZW5ndGg7IGMgPCB1OyBjKyspIGYobiwgbi5fZGVmZXJyZWRzW2NdKTtcbiAgICAgICAgICBuLl9kZWZlcnJlZHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGIobiwgYywgdSkge1xuICAgICAgICAgIHRoaXMub25GdWxmaWxsZWQgPSB0eXBlb2YgbiA9PSBcImZ1bmN0aW9uXCIgPyBuIDogbnVsbCwgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIGMgPT0gXCJmdW5jdGlvblwiID8gYyA6IG51bGwsIHRoaXMucHJvbWlzZSA9IHU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdChuLCBjKSB7XG4gICAgICAgICAgdmFyIHUgPSAhMTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbihmdW5jdGlvbihnKSB7XG4gICAgICAgICAgICAgIHUgfHwgKHUgPSAhMCwgcChjLCBnKSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgICAgIHUgfHwgKHUgPSAhMCwgeShjLCBnKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChnKSB7XG4gICAgICAgICAgICBpZiAodSkgcmV0dXJuO1xuICAgICAgICAgICAgdSA9ICEwLCB5KGMsIGcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG4pO1xuICAgICAgICB9LCBsLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24obiwgYykge1xuICAgICAgICAgIHZhciB1ID0gbmV3IHRoaXMuY29uc3RydWN0b3Iodik7XG4gICAgICAgICAgcmV0dXJuIGYodGhpcywgbmV3IGIobiwgYywgdSkpLCB1O1xuICAgICAgICB9LCBsLnByb3RvdHlwZS5maW5hbGx5ID0gZS5hLCBsLmFsbCA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IGwoZnVuY3Rpb24oYywgdSkge1xuICAgICAgICAgICAgaWYgKCFuIHx8IG4ubGVuZ3RoID09PSB2b2lkIDApIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9taXNlLmFsbCBhY2NlcHRzIGFuIGFycmF5XCIpO1xuICAgICAgICAgICAgdmFyIGcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuKTtcbiAgICAgICAgICAgIGlmIChnLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGMoW10pO1xuICAgICAgICAgICAgdmFyIG0gPSBnLmxlbmd0aDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGgoVCwgRSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChFICYmICh0eXBlb2YgRSA9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBFID09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBNID0gRS50aGVuO1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBNID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHZvaWQgTS5jYWxsKEUsIGZ1bmN0aW9uKEYpIHtcbiAgICAgICAgICAgICAgICAgICAgaChULCBGKTtcbiAgICAgICAgICAgICAgICAgIH0sIHUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnW1RdID0gRSwgLS1tID09IDAgJiYgYyhnKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoRikge1xuICAgICAgICAgICAgICAgIHUoRik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZy5sZW5ndGg7IGsrKykgaChrLCBnW2tdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgbC5yZXNvbHZlID0gZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiBuICYmIHR5cGVvZiBuID09IFwib2JqZWN0XCIgJiYgbi5jb25zdHJ1Y3RvciA9PT0gbCA/IG4gOiBuZXcgbChmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICBjKG4pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBsLnJlamVjdCA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IGwoZnVuY3Rpb24oYywgdSkge1xuICAgICAgICAgICAgdShuKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgbC5yYWNlID0gZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiBuZXcgbChmdW5jdGlvbihjLCB1KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBnID0gMCwgbSA9IG4ubGVuZ3RoOyBnIDwgbTsgZysrKSBuW2ddLnRoZW4oYywgdSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGwuX2ltbWVkaWF0ZUZuID0gdHlwZW9mIG8gPT0gXCJmdW5jdGlvblwiICYmIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICBvKG4pO1xuICAgICAgICB9IHx8IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICBkKG4sIDApO1xuICAgICAgICB9LCBsLl91bmhhbmRsZWRSZWplY3Rpb25GbiA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICB0eXBlb2YgY29uc29sZSA8IFwidVwiICYmIGNvbnNvbGUgJiYgY29uc29sZS53YXJuKFwiUG9zc2libGUgVW5oYW5kbGVkIFByb21pc2UgUmVqZWN0aW9uOlwiLCBuKTtcbiAgICAgICAgfSwgcy5hID0gbDtcbiAgICAgIH0pLmNhbGwodGhpcywgcig1KS5zZXRJbW1lZGlhdGUpO1xuICAgIH0sIGZ1bmN0aW9uKGEsIHMsIHIpIHtcbiAgICAgIHMuYSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gZS5yZXNvbHZlKG8oKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIGUucmVzb2x2ZShvKCkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5yZWplY3QoZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9LCBmdW5jdGlvbihhLCBzLCByKSB7XG4gICAgICBmdW5jdGlvbiBvKHQpIHtcbiAgICAgICAgcmV0dXJuIChvID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgbjtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gbiAmJiB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBuLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbjtcbiAgICAgICAgfSkodCk7XG4gICAgICB9XG4gICAgICByKDQpO1xuICAgICAgdmFyIGUsIGQsIHYsIGwsIGYsIHAsIHksIHcgPSByKDgpLCBiID0gKGQgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihuLCBjKSB7XG4gICAgICAgICAgdCA9IGwodCksICh0ID0gZih0KSkuYmVmb3JlU2VuZCAmJiB0LmJlZm9yZVNlbmQoKTtcbiAgICAgICAgICB2YXIgdSA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCA/IG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKSA6IG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpO1xuICAgICAgICAgIHUub3Blbih0Lm1ldGhvZCwgdC51cmwpLCB1LnNldFJlcXVlc3RIZWFkZXIoXCJYLVJlcXVlc3RlZC1XaXRoXCIsIFwiWE1MSHR0cFJlcXVlc3RcIiksIE9iamVjdC5rZXlzKHQuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICB2YXIgaCA9IHQuaGVhZGVyc1ttXTtcbiAgICAgICAgICAgIHUuc2V0UmVxdWVzdEhlYWRlcihtLCBoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgZyA9IHQucmF0aW87XG4gICAgICAgICAgdS51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgIHZhciBoID0gTWF0aC5yb3VuZChtLmxvYWRlZCAvIG0udG90YWwgKiAxMDApLCBrID0gTWF0aC5jZWlsKGggKiBnIC8gMTAwKTtcbiAgICAgICAgICAgIHQucHJvZ3Jlc3MoTWF0aC5taW4oaywgMTAwKSk7XG4gICAgICAgICAgfSwgITEpLCB1LmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICB2YXIgaCA9IE1hdGgucm91bmQobS5sb2FkZWQgLyBtLnRvdGFsICogMTAwKSwgayA9IE1hdGguY2VpbChoICogKDEwMCAtIGcpIC8gMTAwKSArIGc7XG4gICAgICAgICAgICB0LnByb2dyZXNzKE1hdGgubWluKGssIDEwMCkpO1xuICAgICAgICAgIH0sICExKSwgdS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh1LnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgdmFyIG0gPSB1LnJlc3BvbnNlO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG0gPSBKU09OLnBhcnNlKG0pO1xuICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgaCA9IHcucGFyc2VIZWFkZXJzKHUuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpLCBrID0geyBib2R5OiBtLCBjb2RlOiB1LnN0YXR1cywgaGVhZGVyczogaCB9O1xuICAgICAgICAgICAgICB5KHUuc3RhdHVzKSA/IG4oaykgOiBjKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHUuc2VuZCh0LmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIHYgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0Lm1ldGhvZCA9IFwiUE9TVFwiLCBkKHQpO1xuICAgICAgfSwgbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIGlmICh0LnVybCAmJiB0eXBlb2YgdC51cmwgIT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IEVycm9yKFwiVXJsIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIGlmICh0LnVybCA9IHQudXJsIHx8IFwiXCIsIHQubWV0aG9kICYmIHR5cGVvZiB0Lm1ldGhvZCAhPSBcInN0cmluZ1wiKSB0aHJvdyBuZXcgRXJyb3IoXCJgbWV0aG9kYCBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bGxcIik7XG4gICAgICAgIGlmICh0Lm1ldGhvZCA9IHQubWV0aG9kID8gdC5tZXRob2QudG9VcHBlckNhc2UoKSA6IFwiR0VUXCIsIHQuaGVhZGVycyAmJiBvKHQuaGVhZGVycykgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcImBoZWFkZXJzYCBtdXN0IGJlIGFuIG9iamVjdCBvciBudWxsXCIpO1xuICAgICAgICBpZiAodC5oZWFkZXJzID0gdC5oZWFkZXJzIHx8IHt9LCB0LnR5cGUgJiYgKHR5cGVvZiB0LnR5cGUgIT0gXCJzdHJpbmdcIiB8fCAhT2JqZWN0LnZhbHVlcyhlKS5pbmNsdWRlcyh0LnR5cGUpKSkgdGhyb3cgbmV3IEVycm9yKFwiYHR5cGVgIG11c3QgYmUgdGFrZW4gZnJvbSBtb2R1bGUncyDCq2NvbnRlbnRUeXBlwrsgbGlicmFyeVwiKTtcbiAgICAgICAgaWYgKHQucHJvZ3Jlc3MgJiYgdHlwZW9mIHQucHJvZ3Jlc3MgIT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJgcHJvZ3Jlc3NgIG11c3QgYmUgYSBmdW5jdGlvbiBvciBudWxsXCIpO1xuICAgICAgICBpZiAodC5wcm9ncmVzcyA9IHQucHJvZ3Jlc3MgfHwgZnVuY3Rpb24obikge1xuICAgICAgICB9LCB0LmJlZm9yZVNlbmQgPSB0LmJlZm9yZVNlbmQgfHwgZnVuY3Rpb24obikge1xuICAgICAgICB9LCB0LnJhdGlvICYmIHR5cGVvZiB0LnJhdGlvICE9IFwibnVtYmVyXCIpIHRocm93IG5ldyBFcnJvcihcImByYXRpb2AgbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgICAgICAgaWYgKHQucmF0aW8gPCAwIHx8IHQucmF0aW8gPiAxMDApIHRocm93IG5ldyBFcnJvcihcImByYXRpb2AgbXVzdCBiZSBpbiBhIDAtMTAwIGludGVydmFsXCIpO1xuICAgICAgICBpZiAodC5yYXRpbyA9IHQucmF0aW8gfHwgOTAsIHQuYWNjZXB0ICYmIHR5cGVvZiB0LmFjY2VwdCAhPSBcInN0cmluZ1wiKSB0aHJvdyBuZXcgRXJyb3IoXCJgYWNjZXB0YCBtdXN0IGJlIGEgc3RyaW5nIHdpdGggYSBsaXN0IG9mIGFsbG93ZWQgbWltZS10eXBlc1wiKTtcbiAgICAgICAgaWYgKHQuYWNjZXB0ID0gdC5hY2NlcHQgfHwgXCIqLypcIiwgdC5tdWx0aXBsZSAmJiB0eXBlb2YgdC5tdWx0aXBsZSAhPSBcImJvb2xlYW5cIikgdGhyb3cgbmV3IEVycm9yKFwiYG11bHRpcGxlYCBtdXN0IGJlIGEgdHJ1ZSBvciBmYWxzZVwiKTtcbiAgICAgICAgaWYgKHQubXVsdGlwbGUgPSB0Lm11bHRpcGxlIHx8ICExLCB0LmZpZWxkTmFtZSAmJiB0eXBlb2YgdC5maWVsZE5hbWUgIT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IEVycm9yKFwiYGZpZWxkTmFtZWAgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgcmV0dXJuIHQuZmllbGROYW1lID0gdC5maWVsZE5hbWUgfHwgXCJmaWxlc1wiLCB0O1xuICAgICAgfSwgZiA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgc3dpdGNoICh0Lm1ldGhvZCkge1xuICAgICAgICAgIGNhc2UgXCJHRVRcIjpcbiAgICAgICAgICAgIHZhciBuID0gcCh0LmRhdGEsIGUuVVJMRU5DT0RFRCk7XG4gICAgICAgICAgICBkZWxldGUgdC5kYXRhLCB0LnVybCA9IC9cXD8vLnRlc3QodC51cmwpID8gdC51cmwgKyBcIiZcIiArIG4gOiB0LnVybCArIFwiP1wiICsgbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJQT1NUXCI6XG4gICAgICAgICAgY2FzZSBcIlBVVFwiOlxuICAgICAgICAgIGNhc2UgXCJERUxFVEVcIjpcbiAgICAgICAgICBjYXNlIFwiVVBEQVRFXCI6XG4gICAgICAgICAgICB2YXIgYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge30pLnR5cGUgfHwgZS5KU09OO1xuICAgICAgICAgICAgfSh0KTtcbiAgICAgICAgICAgICh3LmlzRm9ybURhdGEodC5kYXRhKSB8fCB3LmlzRm9ybUVsZW1lbnQodC5kYXRhKSkgJiYgKGMgPSBlLkZPUk0pLCB0LmRhdGEgPSBwKHQuZGF0YSwgYyksIGMgIT09IGIuY29udGVudFR5cGUuRk9STSAmJiAodC5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdID0gYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9LCBwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMCkge1xuICAgICAgICAgIGNhc2UgZS5VUkxFTkNPREVEOlxuICAgICAgICAgICAgcmV0dXJuIHcudXJsRW5jb2RlKHQpO1xuICAgICAgICAgIGNhc2UgZS5KU09OOlxuICAgICAgICAgICAgcmV0dXJuIHcuanNvbkVuY29kZSh0KTtcbiAgICAgICAgICBjYXNlIGUuRk9STTpcbiAgICAgICAgICAgIHJldHVybiB3LmZvcm1FbmNvZGUodCk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9XG4gICAgICB9LCB5ID0gZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCA+PSAyMDAgJiYgdCA8IDMwMDtcbiAgICAgIH0sIHsgY29udGVudFR5cGU6IGUgPSB7IFVSTEVOQ09ERUQ6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PXV0Zi04XCIsIEZPUk06IFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLCBKU09OOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIiB9LCByZXF1ZXN0OiBkLCBnZXQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQubWV0aG9kID0gXCJHRVRcIiwgZCh0KTtcbiAgICAgIH0sIHBvc3Q6IHYsIHRyYW5zcG9ydDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCA9IGwodCksIHcuc2VsZWN0RmlsZXModCkudGhlbihmdW5jdGlvbihuKSB7XG4gICAgICAgICAgZm9yICh2YXIgYyA9IG5ldyBGb3JtRGF0YSgpLCB1ID0gMDsgdSA8IG4ubGVuZ3RoOyB1KyspIGMuYXBwZW5kKHQuZmllbGROYW1lLCBuW3VdLCBuW3VdLm5hbWUpO1xuICAgICAgICAgIHcuaXNPYmplY3QodC5kYXRhKSAmJiBPYmplY3Qua2V5cyh0LmRhdGEpLmZvckVhY2goZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgdmFyIGggPSB0LmRhdGFbbV07XG4gICAgICAgICAgICBjLmFwcGVuZChtLCBoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgZyA9IHQuYmVmb3JlU2VuZDtcbiAgICAgICAgICByZXR1cm4gdC5iZWZvcmVTZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZyhuKTtcbiAgICAgICAgICB9LCB0LmRhdGEgPSBjLCB2KHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIHNlbGVjdEZpbGVzOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBkZWxldGUgKHQgPSBsKHQpKS5iZWZvcmVTZW5kLCB3LnNlbGVjdEZpbGVzKHQpO1xuICAgICAgfSB9KTtcbiAgICAgIGEuZXhwb3J0cyA9IGI7XG4gICAgfSwgZnVuY3Rpb24oYSwgcywgcikge1xuICAgICAgci5yKHMpO1xuICAgICAgdmFyIG8gPSByKDEpO1xuICAgICAgd2luZG93LlByb21pc2UgPSB3aW5kb3cuUHJvbWlzZSB8fCBvLmE7XG4gICAgfSwgZnVuY3Rpb24oYSwgcywgcikge1xuICAgICAgKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgdmFyIGUgPSBvICE9PSB2b2lkIDAgJiYgbyB8fCB0eXBlb2Ygc2VsZiA8IFwidVwiICYmIHNlbGYgfHwgd2luZG93LCBkID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuICAgICAgICBmdW5jdGlvbiB2KGwsIGYpIHtcbiAgICAgICAgICB0aGlzLl9pZCA9IGwsIHRoaXMuX2NsZWFyRm4gPSBmO1xuICAgICAgICB9XG4gICAgICAgIHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgdihkLmNhbGwoc2V0VGltZW91dCwgZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbiAgICAgICAgfSwgcy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgdihkLmNhbGwoc2V0SW50ZXJ2YWwsIGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xuICAgICAgICB9LCBzLmNsZWFyVGltZW91dCA9IHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICBsICYmIGwuY2xvc2UoKTtcbiAgICAgICAgfSwgdi5wcm90b3R5cGUudW5yZWYgPSB2LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgfSwgdi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9jbGVhckZuLmNhbGwoZSwgdGhpcy5faWQpO1xuICAgICAgICB9LCBzLmVucm9sbCA9IGZ1bmN0aW9uKGwsIGYpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQobC5faWRsZVRpbWVvdXRJZCksIGwuX2lkbGVUaW1lb3V0ID0gZjtcbiAgICAgICAgfSwgcy51bmVucm9sbCA9IGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQobC5faWRsZVRpbWVvdXRJZCksIGwuX2lkbGVUaW1lb3V0ID0gLTE7XG4gICAgICAgIH0sIHMuX3VucmVmQWN0aXZlID0gcy5hY3RpdmUgPSBmdW5jdGlvbihsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGwuX2lkbGVUaW1lb3V0SWQpO1xuICAgICAgICAgIHZhciBmID0gbC5faWRsZVRpbWVvdXQ7XG4gICAgICAgICAgZiA+PSAwICYmIChsLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGwuX29uVGltZW91dCAmJiBsLl9vblRpbWVvdXQoKTtcbiAgICAgICAgICB9LCBmKSk7XG4gICAgICAgIH0sIHIoNiksIHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNlbGYgPCBcInVcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSB8fCBvICE9PSB2b2lkIDAgJiYgby5zZXRJbW1lZGlhdGUgfHwgdGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSwgcy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBzZWxmIDwgXCJ1XCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSB8fCBvICE9PSB2b2lkIDAgJiYgby5jbGVhckltbWVkaWF0ZSB8fCB0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGU7XG4gICAgICB9KS5jYWxsKHRoaXMsIHIoMCkpO1xuICAgIH0sIGZ1bmN0aW9uKGEsIHMsIHIpIHtcbiAgICAgIChmdW5jdGlvbihvLCBlKSB7XG4gICAgICAgIChmdW5jdGlvbihkLCB2KSB7XG4gICAgICAgICAgaWYgKCFkLnNldEltbWVkaWF0ZSkge1xuICAgICAgICAgICAgdmFyIGwsIGYsIHAsIHksIHcsIGIgPSAxLCB0ID0ge30sIG4gPSAhMSwgYyA9IGQuZG9jdW1lbnQsIHUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGQpO1xuICAgICAgICAgICAgdSA9IHUgJiYgdS5zZXRUaW1lb3V0ID8gdSA6IGQsIHt9LnRvU3RyaW5nLmNhbGwoZC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIgPyBsID0gZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgICBlLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG0oaCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoZC5wb3N0TWVzc2FnZSAmJiAhZC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGggPSAhMCwgayA9IGQub25tZXNzYWdlO1xuICAgICAgICAgICAgICAgIHJldHVybiBkLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgaCA9ICExO1xuICAgICAgICAgICAgICAgIH0sIGQucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpLCBkLm9ubWVzc2FnZSA9IGssIGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0oKSA/ICh5ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCIsIHcgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICAgIGguc291cmNlID09PSBkICYmIHR5cGVvZiBoLmRhdGEgPT0gXCJzdHJpbmdcIiAmJiBoLmRhdGEuaW5kZXhPZih5KSA9PT0gMCAmJiBtKCtoLmRhdGEuc2xpY2UoeS5sZW5ndGgpKTtcbiAgICAgICAgICAgIH0sIGQuYWRkRXZlbnRMaXN0ZW5lciA/IGQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdywgITEpIDogZC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCB3KSwgbCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgICAgZC5wb3N0TWVzc2FnZSh5ICsgaCwgXCIqXCIpO1xuICAgICAgICAgICAgfSkgOiBkLk1lc3NhZ2VDaGFubmVsID8gKChwID0gbmV3IE1lc3NhZ2VDaGFubmVsKCkpLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgICAgbShoLmRhdGEpO1xuICAgICAgICAgICAgfSwgbCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgICAgcC5wb3J0Mi5wb3N0TWVzc2FnZShoKTtcbiAgICAgICAgICAgIH0pIDogYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGMuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSA/IChmID0gYy5kb2N1bWVudEVsZW1lbnQsIGwgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICAgIHZhciBrID0gYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgICBrLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG0oaCksIGsub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbCwgZi5yZW1vdmVDaGlsZChrKSwgayA9IG51bGw7XG4gICAgICAgICAgICAgIH0sIGYuYXBwZW5kQ2hpbGQoayk7XG4gICAgICAgICAgICB9KSA6IGwgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQobSwgMCwgaCk7XG4gICAgICAgICAgICB9LCB1LnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgICAgdHlwZW9mIGggIT0gXCJmdW5jdGlvblwiICYmIChoID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBoKSk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGsgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLCBUID0gMDsgVCA8IGsubGVuZ3RoOyBUKyspIGtbVF0gPSBhcmd1bWVudHNbVCArIDFdO1xuICAgICAgICAgICAgICB2YXIgRSA9IHsgY2FsbGJhY2s6IGgsIGFyZ3M6IGsgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRbYl0gPSBFLCBsKGIpLCBiKys7XG4gICAgICAgICAgICB9LCB1LmNsZWFySW1tZWRpYXRlID0gZztcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gZyhoKSB7XG4gICAgICAgICAgICBkZWxldGUgdFtoXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gbShoKSB7XG4gICAgICAgICAgICBpZiAobikgc2V0VGltZW91dChtLCAwLCBoKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgayA9IHRbaF07XG4gICAgICAgICAgICAgIGlmIChrKSB7XG4gICAgICAgICAgICAgICAgbiA9ICEwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAoZnVuY3Rpb24oVCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgRSA9IFQuY2FsbGJhY2ssIE0gPSBULmFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoTS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBFKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBFKE1bMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgRShNWzBdLCBNWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIEUoTVswXSwgTVsxXSwgTVsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgRS5hcHBseSh2LCBNKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSkoayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIGcoaCksIG4gPSAhMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pKHR5cGVvZiBzZWxmID4gXCJ1XCIgPyBvID09PSB2b2lkIDAgPyB0aGlzIDogbyA6IHNlbGYpO1xuICAgICAgfSkuY2FsbCh0aGlzLCByKDApLCByKDcpKTtcbiAgICB9LCBmdW5jdGlvbihhLCBzKSB7XG4gICAgICB2YXIgciwgbywgZSA9IGEuZXhwb3J0cyA9IHt9O1xuICAgICAgZnVuY3Rpb24gZCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHYoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGwodSkge1xuICAgICAgICBpZiAociA9PT0gc2V0VGltZW91dCkgcmV0dXJuIHNldFRpbWVvdXQodSwgMCk7XG4gICAgICAgIGlmICgociA9PT0gZCB8fCAhcikgJiYgc2V0VGltZW91dCkgcmV0dXJuIHIgPSBzZXRUaW1lb3V0LCBzZXRUaW1lb3V0KHUsIDApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByKHUsIDApO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHIuY2FsbChudWxsLCB1LCAwKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiByLmNhbGwodGhpcywgdSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgciA9IHR5cGVvZiBzZXRUaW1lb3V0ID09IFwiZnVuY3Rpb25cIiA/IHNldFRpbWVvdXQgOiBkO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICByID0gZDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIG8gPSB0eXBlb2YgY2xlYXJUaW1lb3V0ID09IFwiZnVuY3Rpb25cIiA/IGNsZWFyVGltZW91dCA6IHY7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIG8gPSB2O1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgICAgdmFyIGYsIHAgPSBbXSwgeSA9ICExLCB3ID0gLTE7XG4gICAgICBmdW5jdGlvbiBiKCkge1xuICAgICAgICB5ICYmIGYgJiYgKHkgPSAhMSwgZi5sZW5ndGggPyBwID0gZi5jb25jYXQocCkgOiB3ID0gLTEsIHAubGVuZ3RoICYmIHQoKSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB0KCkge1xuICAgICAgICBpZiAoIXkpIHtcbiAgICAgICAgICB2YXIgdSA9IGwoYik7XG4gICAgICAgICAgeSA9ICEwO1xuICAgICAgICAgIGZvciAodmFyIGcgPSBwLmxlbmd0aDsgZzsgKSB7XG4gICAgICAgICAgICBmb3IgKGYgPSBwLCBwID0gW107ICsrdyA8IGc7ICkgZiAmJiBmW3ddLnJ1bigpO1xuICAgICAgICAgICAgdyA9IC0xLCBnID0gcC5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGYgPSBudWxsLCB5ID0gITEsIGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgIGlmIChvID09PSBjbGVhclRpbWVvdXQpIHJldHVybiBjbGVhclRpbWVvdXQobSk7XG4gICAgICAgICAgICBpZiAoKG8gPT09IHYgfHwgIW8pICYmIGNsZWFyVGltZW91dCkgcmV0dXJuIG8gPSBjbGVhclRpbWVvdXQsIGNsZWFyVGltZW91dChtKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG8obSk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gby5jYWxsKG51bGwsIG0pO1xuICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gby5jYWxsKHRoaXMsIG0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSh1KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbih1LCBnKSB7XG4gICAgICAgIHRoaXMuZnVuID0gdSwgdGhpcy5hcnJheSA9IGc7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjKCkge1xuICAgICAgfVxuICAgICAgZS5uZXh0VGljayA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgdmFyIGcgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGZvciAodmFyIG0gPSAxOyBtIDwgYXJndW1lbnRzLmxlbmd0aDsgbSsrKSBnW20gLSAxXSA9IGFyZ3VtZW50c1ttXTtcbiAgICAgICAgcC5wdXNoKG5ldyBuKHUsIGcpKSwgcC5sZW5ndGggIT09IDEgfHwgeSB8fCBsKHQpO1xuICAgICAgfSwgbi5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xuICAgICAgfSwgZS50aXRsZSA9IFwiYnJvd3NlclwiLCBlLmJyb3dzZXIgPSAhMCwgZS5lbnYgPSB7fSwgZS5hcmd2ID0gW10sIGUudmVyc2lvbiA9IFwiXCIsIGUudmVyc2lvbnMgPSB7fSwgZS5vbiA9IGMsIGUuYWRkTGlzdGVuZXIgPSBjLCBlLm9uY2UgPSBjLCBlLm9mZiA9IGMsIGUucmVtb3ZlTGlzdGVuZXIgPSBjLCBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGMsIGUuZW1pdCA9IGMsIGUucHJlcGVuZExpc3RlbmVyID0gYywgZS5wcmVwZW5kT25jZUxpc3RlbmVyID0gYywgZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0sIGUuYmluZGluZyA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICB9LCBlLmN3ZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCIvXCI7XG4gICAgICB9LCBlLmNoZGlyID0gZnVuY3Rpb24odSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICB9LCBlLnVtYXNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfTtcbiAgICB9LCBmdW5jdGlvbihhLCBzLCByKSB7XG4gICAgICBmdW5jdGlvbiBvKGQsIHYpIHtcbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCB2Lmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgdmFyIGYgPSB2W2xdO1xuICAgICAgICAgIGYuZW51bWVyYWJsZSA9IGYuZW51bWVyYWJsZSB8fCAhMSwgZi5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIGYgJiYgKGYud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkLCBmLmtleSwgZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBlID0gcig5KTtcbiAgICAgIGEuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBkKCkge1xuICAgICAgICAgIChmdW5jdGlvbihwLCB5KSB7XG4gICAgICAgICAgICBpZiAoIShwIGluc3RhbmNlb2YgeSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgfSkodGhpcywgZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHYsIGwsIGY7XG4gICAgICAgIHJldHVybiB2ID0gZCwgZiA9IFt7IGtleTogXCJ1cmxFbmNvZGVcIiwgdmFsdWU6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gZShwKTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJqc29uRW5jb2RlXCIsIHZhbHVlOiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHApO1xuICAgICAgICB9IH0sIHsga2V5OiBcImZvcm1FbmNvZGVcIiwgdmFsdWU6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICBpZiAodGhpcy5pc0Zvcm1EYXRhKHApKSByZXR1cm4gcDtcbiAgICAgICAgICBpZiAodGhpcy5pc0Zvcm1FbGVtZW50KHApKSByZXR1cm4gbmV3IEZvcm1EYXRhKHApO1xuICAgICAgICAgIGlmICh0aGlzLmlzT2JqZWN0KHApKSB7XG4gICAgICAgICAgICB2YXIgeSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHApLmZvckVhY2goZnVuY3Rpb24odykge1xuICAgICAgICAgICAgICB2YXIgYiA9IHBbd107XG4gICAgICAgICAgICAgIHkuYXBwZW5kKHcsIGIpO1xuICAgICAgICAgICAgfSksIHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBkYXRhYCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIE9iamVjdCwgRm9ybURhdGEgb3IgPEZPUk0+IEhUTUxFbGVtZW50XCIpO1xuICAgICAgICB9IH0sIHsga2V5OiBcImlzT2JqZWN0XCIsIHZhbHVlOiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbiAgICAgICAgfSB9LCB7IGtleTogXCJpc0Zvcm1EYXRhXCIsIHZhbHVlOiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIHAgaW5zdGFuY2VvZiBGb3JtRGF0YTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJpc0Zvcm1FbGVtZW50XCIsIHZhbHVlOiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIHAgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQ7XG4gICAgICAgIH0gfSwgeyBrZXk6IFwic2VsZWN0RmlsZXNcIiwgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oeSwgdykge1xuICAgICAgICAgICAgdmFyIGIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiSU5QVVRcIik7XG4gICAgICAgICAgICBiLnR5cGUgPSBcImZpbGVcIiwgcC5tdWx0aXBsZSAmJiBiLnNldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIsIFwibXVsdGlwbGVcIiksIHAuYWNjZXB0ICYmIGIuc2V0QXR0cmlidXRlKFwiYWNjZXB0XCIsIHAuYWNjZXB0KSwgYi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIsIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYiksIGIuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgIHZhciBuID0gdC50YXJnZXQuZmlsZXM7XG4gICAgICAgICAgICAgIHkobiksIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYik7XG4gICAgICAgICAgICB9LCAhMSksIGIuY2xpY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSB9LCB7IGtleTogXCJwYXJzZUhlYWRlcnNcIiwgdmFsdWU6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICB2YXIgeSA9IHAudHJpbSgpLnNwbGl0KC9bXFxyXFxuXSsvKSwgdyA9IHt9O1xuICAgICAgICAgIHJldHVybiB5LmZvckVhY2goZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgdmFyIHQgPSBiLnNwbGl0KFwiOiBcIiksIG4gPSB0LnNoaWZ0KCksIGMgPSB0LmpvaW4oXCI6IFwiKTtcbiAgICAgICAgICAgIG4gJiYgKHdbbl0gPSBjKTtcbiAgICAgICAgICB9KSwgdztcbiAgICAgICAgfSB9XSwgKGwgPSBudWxsKSAmJiBvKHYucHJvdG90eXBlLCBsKSwgZiAmJiBvKHYsIGYpLCBkO1xuICAgICAgfSgpO1xuICAgIH0sIGZ1bmN0aW9uKGEsIHMpIHtcbiAgICAgIHZhciByID0gZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGUpLnJlcGxhY2UoL1shJygpKl0vZywgZXNjYXBlKS5yZXBsYWNlKC8lMjAvZywgXCIrXCIpO1xuICAgICAgfSwgbyA9IGZ1bmN0aW9uKGUsIGQsIHYsIGwpIHtcbiAgICAgICAgcmV0dXJuIGQgPSBkIHx8IG51bGwsIHYgPSB2IHx8IFwiJlwiLCBsID0gbCB8fCBudWxsLCBlID8gZnVuY3Rpb24oZikge1xuICAgICAgICAgIGZvciAodmFyIHAgPSBuZXcgQXJyYXkoKSwgeSA9IDA7IHkgPCBmLmxlbmd0aDsgeSsrKSBmW3ldICYmIHAucHVzaChmW3ldKTtcbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfShPYmplY3Qua2V5cyhlKS5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgICAgIHZhciBwLCB5LCB3ID0gZjtcbiAgICAgICAgICBpZiAobCAmJiAodyA9IGwgKyBcIltcIiArIHcgKyBcIl1cIiksIHR5cGVvZiBlW2ZdID09IFwib2JqZWN0XCIgJiYgZVtmXSAhPT0gbnVsbCkgcCA9IG8oZVtmXSwgbnVsbCwgdiwgdyk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkICYmICh5ID0gdywgdyA9ICFpc05hTihwYXJzZUZsb2F0KHkpKSAmJiBpc0Zpbml0ZSh5KSA/IGQgKyBOdW1iZXIodykgOiB3KTtcbiAgICAgICAgICAgIHZhciBiID0gZVtmXTtcbiAgICAgICAgICAgIGIgPSAoYiA9IChiID0gKGIgPSBiID09PSAhMCA/IFwiMVwiIDogYikgPT09ICExID8gXCIwXCIgOiBiKSA9PT0gMCA/IFwiMFwiIDogYikgfHwgXCJcIiwgcCA9IHIodykgKyBcIj1cIiArIHIoYik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9KSkuam9pbih2KS5yZXBsYWNlKC9bIScoKSpdL2csIFwiXCIpIDogXCJcIjtcbiAgICAgIH07XG4gICAgICBhLmV4cG9ydHMgPSBvO1xuICAgIH1dKTtcbiAgfSk7XG59KShIKTtcbnZhciBxID0gSC5leHBvcnRzO1xuY29uc3QgaiA9IC8qIEBfX1BVUkVfXyAqLyBVKHEpO1xuZnVuY3Rpb24gTyhDKSB7XG4gIHJldHVybiBDICE9PSB2b2lkIDAgJiYgdHlwZW9mIEMudGhlbiA9PSBcImZ1bmN0aW9uXCI7XG59XG5jbGFzcyBBIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSB1cGxvYWRlciBtb2R1bGUgcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMuY29uZmlnIC0gaW1hZ2UgdG9vbCBjb25maWdcbiAgICogQHBhcmFtIHBhcmFtcy5vblVwbG9hZCAtIG9uZSBjYWxsYmFjayBmb3IgYWxsIHVwbG9hZGluZyAoZmlsZSwgdXJsLCBkLW4tZCwgcGFzdGluZylcbiAgICogQHBhcmFtIHBhcmFtcy5vbkVycm9yIC0gY2FsbGJhY2sgZm9yIHVwbG9hZGluZyBlcnJvcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgY29uZmlnOiBpLCBvblVwbG9hZDogYSwgb25FcnJvcjogcyB9KSB7XG4gICAgdGhpcy5jb25maWcgPSBpLCB0aGlzLm9uVXBsb2FkID0gYSwgdGhpcy5vbkVycm9yID0gcztcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGNsaWNrcyBvbiB0aGUgdXBsb2FkIGZpbGUgYnV0dG9uXG4gICAqIEZpcmVzIGFqYXgudHJhbnNwb3J0KClcbiAgICogQHBhcmFtIG9uUHJldmlldyAtIGNhbGxiYWNrIGZpcmVkIHdoZW4gcHJldmlldyBpcyByZWFkeVxuICAgKi9cbiAgdXBsb2FkU2VsZWN0ZWRGaWxlKHsgb25QcmV2aWV3OiBpIH0pIHtcbiAgICBjb25zdCBhID0gZnVuY3Rpb24ocikge1xuICAgICAgY29uc3QgbyA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBvLnJlYWRBc0RhdGFVUkwociksIG8ub25sb2FkID0gKGUpID0+IHtcbiAgICAgICAgaShlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGxldCBzO1xuICAgIGlmICh0aGlzLmNvbmZpZy51cGxvYWRlciAmJiB0eXBlb2YgdGhpcy5jb25maWcudXBsb2FkZXIudXBsb2FkQnlGaWxlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3QgciA9IHRoaXMuY29uZmlnLnVwbG9hZGVyLnVwbG9hZEJ5RmlsZTtcbiAgICAgIHMgPSBqLnNlbGVjdEZpbGVzKHsgYWNjZXB0OiB0aGlzLmNvbmZpZy50eXBlcyA/PyBcImltYWdlLypcIiB9KS50aGVuKChvKSA9PiB7XG4gICAgICAgIGEob1swXSk7XG4gICAgICAgIGNvbnN0IGUgPSByKG9bMF0pO1xuICAgICAgICByZXR1cm4gTyhlKSB8fCBjb25zb2xlLndhcm4oXCJDdXN0b20gdXBsb2FkZXIgbWV0aG9kIHVwbG9hZEJ5RmlsZSBzaG91bGQgcmV0dXJuIGEgUHJvbWlzZVwiKSwgZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZVxuICAgICAgcyA9IGoudHJhbnNwb3J0KHtcbiAgICAgICAgdXJsOiB0aGlzLmNvbmZpZy5lbmRwb2ludHMuYnlGaWxlLFxuICAgICAgICBkYXRhOiB0aGlzLmNvbmZpZy5hZGRpdGlvbmFsUmVxdWVzdERhdGEsXG4gICAgICAgIGFjY2VwdDogdGhpcy5jb25maWcudHlwZXMgPz8gXCJpbWFnZS8qXCIsXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmFkZGl0aW9uYWxSZXF1ZXN0SGVhZGVycyxcbiAgICAgICAgYmVmb3JlU2VuZDogKHIpID0+IHtcbiAgICAgICAgICBhKHJbMF0pO1xuICAgICAgICB9LFxuICAgICAgICBmaWVsZE5hbWU6IHRoaXMuY29uZmlnLmZpZWxkID8/IFwiaW1hZ2VcIlxuICAgICAgfSkudGhlbigocikgPT4gci5ib2R5KTtcbiAgICBzLnRoZW4oKHIpID0+IHtcbiAgICAgIHRoaXMub25VcGxvYWQocik7XG4gICAgfSkuY2F0Y2goKHIpID0+IHtcbiAgICAgIHRoaXMub25FcnJvcihyKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGNsaWNrcyBvbiB0aGUgdXBsb2FkIGZpbGUgYnV0dG9uXG4gICAqIEZpcmVzIGFqYXgucG9zdCgpXG4gICAqIEBwYXJhbSB1cmwgLSBpbWFnZSBzb3VyY2UgdXJsXG4gICAqL1xuICB1cGxvYWRCeVVybChpKSB7XG4gICAgbGV0IGE7XG4gICAgdGhpcy5jb25maWcudXBsb2FkZXIgJiYgdHlwZW9mIHRoaXMuY29uZmlnLnVwbG9hZGVyLnVwbG9hZEJ5VXJsID09IFwiZnVuY3Rpb25cIiA/IChhID0gdGhpcy5jb25maWcudXBsb2FkZXIudXBsb2FkQnlVcmwoaSksIE8oYSkgfHwgY29uc29sZS53YXJuKFwiQ3VzdG9tIHVwbG9hZGVyIG1ldGhvZCB1cGxvYWRCeVVybCBzaG91bGQgcmV0dXJuIGEgUHJvbWlzZVwiKSkgOiBhID0gai5wb3N0KHtcbiAgICAgIHVybDogdGhpcy5jb25maWcuZW5kcG9pbnRzLmJ5VXJsLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHVybDogaVxuICAgICAgfSwgdGhpcy5jb25maWcuYWRkaXRpb25hbFJlcXVlc3REYXRhKSxcbiAgICAgIHR5cGU6IGouY29udGVudFR5cGUuSlNPTixcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmFkZGl0aW9uYWxSZXF1ZXN0SGVhZGVyc1xuICAgIH0pLnRoZW4oKHMpID0+IHMuYm9keSksIGEudGhlbigocykgPT4ge1xuICAgICAgdGhpcy5vblVwbG9hZChzKTtcbiAgICB9KS5jYXRjaCgocykgPT4ge1xuICAgICAgdGhpcy5vbkVycm9yKHMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgY2xpY2tzIG9uIHRoZSB1cGxvYWQgZmlsZSBidXR0b25cbiAgICogRmlyZXMgYWpheC5wb3N0KClcbiAgICogQHBhcmFtIGZpbGUgLSBmaWxlIHBhc3RlZCBieSBkcmFnLW4tZHJvcFxuICAgKiBAcGFyYW0gb25QcmV2aWV3IC0gZmlsZSBwYXN0ZWQgYnkgZHJhZy1uLWRyb3BcbiAgICovXG4gIHVwbG9hZEJ5RmlsZShpLCB7IG9uUHJldmlldzogYSB9KSB7XG4gICAgY29uc3QgcyA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgcy5yZWFkQXNEYXRhVVJMKGkpLCBzLm9ubG9hZCA9IChvKSA9PiB7XG4gICAgICBhKG8udGFyZ2V0LnJlc3VsdCk7XG4gICAgfTtcbiAgICBsZXQgcjtcbiAgICBpZiAodGhpcy5jb25maWcudXBsb2FkZXIgJiYgdHlwZW9mIHRoaXMuY29uZmlnLnVwbG9hZGVyLnVwbG9hZEJ5RmlsZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICByID0gdGhpcy5jb25maWcudXBsb2FkZXIudXBsb2FkQnlGaWxlKGkpLCBPKHIpIHx8IGNvbnNvbGUud2FybihcIkN1c3RvbSB1cGxvYWRlciBtZXRob2QgdXBsb2FkQnlGaWxlIHNob3VsZCByZXR1cm4gYSBQcm9taXNlXCIpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbyA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgby5hcHBlbmQodGhpcy5jb25maWcuZmllbGQgPz8gXCJpbWFnZVwiLCBpKSwgdGhpcy5jb25maWcuYWRkaXRpb25hbFJlcXVlc3REYXRhICYmIE9iamVjdC5rZXlzKHRoaXMuY29uZmlnLmFkZGl0aW9uYWxSZXF1ZXN0RGF0YSkubGVuZ3RoICYmIE9iamVjdC5lbnRyaWVzKHRoaXMuY29uZmlnLmFkZGl0aW9uYWxSZXF1ZXN0RGF0YSkuZm9yRWFjaCgoW2UsIGRdKSA9PiB7XG4gICAgICAgIG8uYXBwZW5kKGUsIGQpO1xuICAgICAgfSksIHIgPSBqLnBvc3Qoe1xuICAgICAgICB1cmw6IHRoaXMuY29uZmlnLmVuZHBvaW50cy5ieUZpbGUsXG4gICAgICAgIGRhdGE6IG8sXG4gICAgICAgIHR5cGU6IGouY29udGVudFR5cGUuSlNPTixcbiAgICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuYWRkaXRpb25hbFJlcXVlc3RIZWFkZXJzXG4gICAgICB9KS50aGVuKChlKSA9PiBlLmJvZHkpO1xuICAgIH1cbiAgICByLnRoZW4oKG8pID0+IHtcbiAgICAgIHRoaXMub25VcGxvYWQobyk7XG4gICAgfSkuY2F0Y2goKG8pID0+IHtcbiAgICAgIHRoaXMub25FcnJvcihvKTtcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBJbWFnZSBUb29sIGZvciB0aGUgRWRpdG9yLmpzXG4gKiBAYXV0aG9yIENvZGVYIDx0ZWFtQGNvZGV4LnNvPlxuICogQGxpY2Vuc2UgTUlUXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZWRpdG9yLWpzL2ltYWdlfVxuICpcbiAqIFRvIGRldmVsb3BlcnMuXG4gKiBUbyBzaW1wbGlmeSBUb29sIHN0cnVjdHVyZSwgd2Ugc3BsaXQgaXQgdG8gNCBwYXJ0czpcbiAqICAxKSBpbmRleC50cyDigJQgbWFpbiBUb29sJ3MgaW50ZXJmYWNlLCBwdWJsaWMgQVBJIGFuZCBtZXRob2RzIGZvciB3b3JraW5nIHdpdGggZGF0YVxuICogIDIpIHVwbG9hZGVyLnRzIOKAlCBtb2R1bGUgdGhhdCBoYXMgbWV0aG9kcyBmb3Igc2VuZGluZyBmaWxlcyB2aWEgQUpBWDogZnJvbSBkZXZpY2UsIGJ5IFVSTCBvciBGaWxlIHBhc3RpbmdcbiAqICAzKSB1aS50cyDigJQgbW9kdWxlIGZvciBVSSBtYW5pcHVsYXRpb25zOiByZW5kZXIsIHNob3dpbmcgcHJlbG9hZGVyLCBldGNcbiAqXG4gKiBGb3IgZGVidWcgcHVycG9zZXMgdGhlcmUgaXMgYSB0ZXN0aW5nIHNlcnZlclxuICogdGhhdCBjYW4gc2F2ZSB1cGxvYWRlZCBmaWxlcyBhbmQgcmV0dXJuIGEgUmVzcG9uc2Uge0BsaW5rIFVwbG9hZFJlc3BvbnNlRm9ybWF0fVxuICpcbiAqICAgICAgICQgbm9kZSBkZXYvc2VydmVyLmpzXG4gKlxuICogSXQgd2lsbCBleHBvc2UgODAwOCBwb3J0LCBzbyB5b3UgY2FuIHBhc3MgaHR0cDovL2xvY2FsaG9zdDo4MDA4IHdpdGggdGhlIFRvb2xzIGNvbmZpZzpcbiAqXG4gKiBpbWFnZToge1xuICogICBjbGFzczogSW1hZ2VUb29sLFxuICogICBjb25maWc6IHtcbiAqICAgICBlbmRwb2ludHM6IHtcbiAqICAgICAgIGJ5RmlsZTogJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwOC91cGxvYWRGaWxlJyxcbiAqICAgICAgIGJ5VXJsOiAnaHR0cDovL2xvY2FsaG9zdDo4MDA4L2ZldGNoVXJsJyxcbiAqICAgICB9XG4gKiAgIH0sXG4gKiB9LFxuICovXG5jbGFzcyBQIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB0b29sIC0gdG9vbCBwcm9wZXJ0aWVzIGdvdCBmcm9tIGVkaXRvci5qc1xuICAgKiBAcGFyYW0gdG9vbC5kYXRhIC0gcHJldmlvdXNseSBzYXZlZCBkYXRhXG4gICAqIEBwYXJhbSB0b29sLmNvbmZpZyAtIHVzZXIgY29uZmlnIGZvciBUb29sXG4gICAqIEBwYXJhbSB0b29sLmFwaSAtIEVkaXRvci5qcyBBUElcbiAgICogQHBhcmFtIHRvb2wucmVhZE9ubHkgLSByZWFkLW9ubHkgbW9kZSBmbGFnXG4gICAqIEBwYXJhbSB0b29sLmJsb2NrIC0gY3VycmVudCBCbG9jayBBUElcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgZGF0YTogaSwgY29uZmlnOiBhLCBhcGk6IHMsIHJlYWRPbmx5OiByLCBibG9jazogbyB9KSB7XG4gICAgdGhpcy5pc0NhcHRpb25FbmFibGVkID0gbnVsbCwgdGhpcy5hcGkgPSBzLCB0aGlzLmJsb2NrID0gbywgdGhpcy5jb25maWcgPSB7XG4gICAgICBlbmRwb2ludHM6IGEuZW5kcG9pbnRzLFxuICAgICAgYWRkaXRpb25hbFJlcXVlc3REYXRhOiBhLmFkZGl0aW9uYWxSZXF1ZXN0RGF0YSxcbiAgICAgIGFkZGl0aW9uYWxSZXF1ZXN0SGVhZGVyczogYS5hZGRpdGlvbmFsUmVxdWVzdEhlYWRlcnMsXG4gICAgICBmaWVsZDogYS5maWVsZCxcbiAgICAgIHR5cGVzOiBhLnR5cGVzLFxuICAgICAgY2FwdGlvblBsYWNlaG9sZGVyOiB0aGlzLmFwaS5pMThuLnQoYS5jYXB0aW9uUGxhY2Vob2xkZXIgPz8gXCJDYXB0aW9uXCIpLFxuICAgICAgYnV0dG9uQ29udGVudDogYS5idXR0b25Db250ZW50LFxuICAgICAgdXBsb2FkZXI6IGEudXBsb2FkZXIsXG4gICAgICBhY3Rpb25zOiBhLmFjdGlvbnMsXG4gICAgICBmZWF0dXJlczogYS5mZWF0dXJlcyB8fCB7fVxuICAgIH0sIHRoaXMudXBsb2FkZXIgPSBuZXcgQSh7XG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgb25VcGxvYWQ6IChlKSA9PiB0aGlzLm9uVXBsb2FkKGUpLFxuICAgICAgb25FcnJvcjogKGUpID0+IHRoaXMudXBsb2FkaW5nRmFpbGVkKGUpXG4gICAgfSksIHRoaXMudWkgPSBuZXcgRCh7XG4gICAgICBhcGk6IHMsXG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgb25TZWxlY3RGaWxlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMudXBsb2FkZXIudXBsb2FkU2VsZWN0ZWRGaWxlKHtcbiAgICAgICAgICBvblByZXZpZXc6IChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVpLnNob3dQcmVsb2FkZXIoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICByZWFkT25seTogclxuICAgIH0pLCB0aGlzLl9kYXRhID0ge1xuICAgICAgY2FwdGlvbjogXCJcIixcbiAgICAgIHdpdGhCb3JkZXI6ICExLFxuICAgICAgd2l0aEJhY2tncm91bmQ6ICExLFxuICAgICAgc3RyZXRjaGVkOiAhMSxcbiAgICAgIGZpbGU6IHtcbiAgICAgICAgdXJsOiBcIlwiXG4gICAgICB9XG4gICAgfSwgdGhpcy5kYXRhID0gaTtcbiAgfVxuICAvKipcbiAgICogTm90aWZ5IGNvcmUgdGhhdCByZWFkLW9ubHkgbW9kZSBpcyBzdXBwb3J0ZWRcbiAgICovXG4gIHN0YXRpYyBnZXQgaXNSZWFkT25seVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBUb29sIHRvb2xib3ggc2V0dGluZ3NcbiAgICogaWNvbiAtIFRvb2wgaWNvbidzIFNWR1xuICAgKiB0aXRsZSAtIHRpdGxlIHRvIHNob3cgaW4gdG9vbGJveFxuICAgKi9cbiAgc3RhdGljIGdldCB0b29sYm94KCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiBMLFxuICAgICAgdGl0bGU6IFwiSW1hZ2VcIlxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEF2YWlsYWJsZSBpbWFnZSB0b29sc1xuICAgKi9cbiAgc3RhdGljIGdldCB0dW5lcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBuYW1lOiBcIndpdGhCb3JkZXJcIixcbiAgICAgICAgaWNvbjogSSxcbiAgICAgICAgdGl0bGU6IFwiV2l0aCBib3JkZXJcIixcbiAgICAgICAgdG9nZ2xlOiAhMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJzdHJldGNoZWRcIixcbiAgICAgICAgaWNvbjogeCxcbiAgICAgICAgdGl0bGU6IFwiU3RyZXRjaCBpbWFnZVwiLFxuICAgICAgICB0b2dnbGU6ICEwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiBcIndpdGhCYWNrZ3JvdW5kXCIsXG4gICAgICAgIGljb246IFIsXG4gICAgICAgIHRpdGxlOiBcIldpdGggYmFja2dyb3VuZFwiLFxuICAgICAgICB0b2dnbGU6ICEwXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyBCbG9jayBjb250ZW50XG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgdmFyIGksIGEsIHM7XG4gICAgcmV0dXJuICgoKGkgPSB0aGlzLmNvbmZpZy5mZWF0dXJlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGkuY2FwdGlvbikgPT09ICEwIHx8ICgoYSA9IHRoaXMuY29uZmlnLmZlYXR1cmVzKSA9PSBudWxsID8gdm9pZCAwIDogYS5jYXB0aW9uKSA9PT0gdm9pZCAwIHx8ICgocyA9IHRoaXMuY29uZmlnLmZlYXR1cmVzKSA9PSBudWxsID8gdm9pZCAwIDogcy5jYXB0aW9uKSA9PT0gXCJvcHRpb25hbFwiICYmIHRoaXMuZGF0YS5jYXB0aW9uKSAmJiAodGhpcy5pc0NhcHRpb25FbmFibGVkID0gITAsIHRoaXMudWkuYXBwbHlUdW5lKFwiY2FwdGlvblwiLCAhMCkpLCB0aGlzLnVpLnJlbmRlcigpO1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBkYXRhOiBjaGVjayBpZiBJbWFnZSBleGlzdHNcbiAgICogQHBhcmFtIHNhdmVkRGF0YSDigJQgZGF0YSByZWNlaXZlZCBhZnRlciBzYXZpbmdcbiAgICogQHJldHVybnMgZmFsc2UgaWYgc2F2ZWQgZGF0YSBpcyBub3QgY29ycmVjdCwgb3RoZXJ3aXNlIHRydWVcbiAgICovXG4gIHZhbGlkYXRlKGkpIHtcbiAgICByZXR1cm4gISFpLmZpbGUudXJsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gQmxvY2sgZGF0YVxuICAgKi9cbiAgc2F2ZSgpIHtcbiAgICBjb25zdCBpID0gdGhpcy51aS5ub2Rlcy5jYXB0aW9uO1xuICAgIHJldHVybiB0aGlzLl9kYXRhLmNhcHRpb24gPSBpLmlubmVySFRNTCwgdGhpcy5kYXRhO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvbmZpZ3VyYXRpb24gZm9yIGJsb2NrIHR1bmVzOiBhZGQgYmFja2dyb3VuZCwgYWRkIGJvcmRlciwgc3RyZXRjaCBpbWFnZVxuICAgKiBAcmV0dXJucyBUdW5lc01lbnVDb25maWdcbiAgICovXG4gIHJlbmRlclNldHRpbmdzKCkge1xuICAgIHZhciBvO1xuICAgIGNvbnN0IGkgPSBQLnR1bmVzLmNvbmNhdCh0aGlzLmNvbmZpZy5hY3Rpb25zIHx8IFtdKSwgYSA9IHtcbiAgICAgIGJvcmRlcjogXCJ3aXRoQm9yZGVyXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIndpdGhCYWNrZ3JvdW5kXCIsXG4gICAgICBzdHJldGNoOiBcInN0cmV0Y2hlZFwiLFxuICAgICAgY2FwdGlvbjogXCJjYXB0aW9uXCJcbiAgICB9O1xuICAgICgobyA9IHRoaXMuY29uZmlnLmZlYXR1cmVzKSA9PSBudWxsID8gdm9pZCAwIDogby5jYXB0aW9uKSA9PT0gXCJvcHRpb25hbFwiICYmIGkucHVzaCh7XG4gICAgICBuYW1lOiBcImNhcHRpb25cIixcbiAgICAgIGljb246IEIsXG4gICAgICB0aXRsZTogXCJXaXRoIGNhcHRpb25cIixcbiAgICAgIHRvZ2dsZTogITBcbiAgICB9KTtcbiAgICBjb25zdCBzID0gaS5maWx0ZXIoKGUpID0+IHtcbiAgICAgIHZhciB2LCBsO1xuICAgICAgY29uc3QgZCA9IE9iamVjdC5rZXlzKGEpLmZpbmQoKGYpID0+IGFbZl0gPT09IGUubmFtZSk7XG4gICAgICByZXR1cm4gZCA9PT0gXCJjYXB0aW9uXCIgPyAoKHYgPSB0aGlzLmNvbmZpZy5mZWF0dXJlcykgPT0gbnVsbCA/IHZvaWQgMCA6IHYuY2FwdGlvbikgIT09ICExIDogZCA9PSBudWxsIHx8ICgobCA9IHRoaXMuY29uZmlnLmZlYXR1cmVzKSA9PSBudWxsID8gdm9pZCAwIDogbFtkXSkgIT09ICExO1xuICAgIH0pLCByID0gKGUpID0+IHtcbiAgICAgIGxldCBkID0gdGhpcy5kYXRhW2UubmFtZV07XG4gICAgICByZXR1cm4gZS5uYW1lID09PSBcImNhcHRpb25cIiAmJiAoZCA9IHRoaXMuaXNDYXB0aW9uRW5hYmxlZCA/PyBkKSwgZDtcbiAgICB9O1xuICAgIHJldHVybiBzLm1hcCgoZSkgPT4gKHtcbiAgICAgIGljb246IGUuaWNvbixcbiAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoZS50aXRsZSksXG4gICAgICBuYW1lOiBlLm5hbWUsXG4gICAgICB0b2dnbGU6IGUudG9nZ2xlLFxuICAgICAgaXNBY3RpdmU6IHIoZSksXG4gICAgICBvbkFjdGl2YXRlOiAoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgZS5hY3Rpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgZS5hY3Rpb24oZS5uYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGQgPSAhcihlKTtcbiAgICAgICAgZS5uYW1lID09PSBcImNhcHRpb25cIiAmJiAodGhpcy5pc0NhcHRpb25FbmFibGVkID0gISh0aGlzLmlzQ2FwdGlvbkVuYWJsZWQgPz8gITEpLCBkID0gdGhpcy5pc0NhcHRpb25FbmFibGVkKSwgdGhpcy50dW5lVG9nZ2xlZChlLm5hbWUsIGQpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogRmlyZXMgYWZ0ZXIgY2xpY2tzIG9uIHRoZSBUb29sYm94IEltYWdlIEljb25cbiAgICogSW5pdGlhdGVzIGNsaWNrIG9uIHRoZSBTZWxlY3QgRmlsZSBidXR0b25cbiAgICovXG4gIGFwcGVuZENhbGxiYWNrKCkge1xuICAgIHRoaXMudWkubm9kZXMuZmlsZUJ1dHRvbi5jbGljaygpO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHBhc3RlIHN1YnN0aXR1dGVzXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RleC10ZWFtL2VkaXRvci5qcy9ibG9iL21hc3Rlci9kb2NzL3Rvb2xzLm1kI3Bhc3RlLWhhbmRsaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBwYXN0ZUNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBQYXN0ZSBIVE1MIGludG8gRWRpdG9yXG4gICAgICAgKi9cbiAgICAgIHRhZ3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIGltZzogeyBzcmM6ICEwIH1cbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIC8qKlxuICAgICAgICogUGFzdGUgVVJMIG9mIGltYWdlIGludG8gdGhlIEVkaXRvclxuICAgICAgICovXG4gICAgICBwYXR0ZXJuczoge1xuICAgICAgICBpbWFnZTogL2h0dHBzPzpcXC9cXC9cXFMrXFwuKGdpZnxqcGU/Z3x0aWZmfHBuZ3xzdmd8d2VicCkoXFw/W2EtejAtOT1dKik/JC9pXG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBEcmFnIG4gZHJvcCBmaWxlIGZyb20gaW50byB0aGUgRWRpdG9yXG4gICAgICAgKi9cbiAgICAgIGZpbGVzOiB7XG4gICAgICAgIG1pbWVUeXBlczogW1wiaW1hZ2UvKlwiXVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZnkgcGFzdGUgaGFuZGxlcnNcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2NvZGV4LXRlYW0vZWRpdG9yLmpzL2Jsb2IvbWFzdGVyL2RvY3MvdG9vbHMubWQjcGFzdGUtaGFuZGxpbmd9XG4gICAqIEBwYXJhbSBldmVudCAtIGVkaXRvci5qcyBjdXN0b20gcGFzdGUgZXZlbnRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2NvZGV4LXRlYW0vZWRpdG9yLmpzL2Jsb2IvbWFzdGVyL3R5cGVzL3Rvb2xzL3Bhc3RlLWV2ZW50cy5kLnRzfVxuICAgKi9cbiAgYXN5bmMgb25QYXN0ZShpKSB7XG4gICAgc3dpdGNoIChpLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJ0YWdcIjoge1xuICAgICAgICBjb25zdCBhID0gaS5kZXRhaWwuZGF0YTtcbiAgICAgICAgaWYgKC9eYmxvYjovLnRlc3QoYS5zcmMpKSB7XG4gICAgICAgICAgY29uc3QgciA9IGF3YWl0IChhd2FpdCBmZXRjaChhLnNyYykpLmJsb2IoKTtcbiAgICAgICAgICB0aGlzLnVwbG9hZEZpbGUocik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGxvYWRVcmwoYS5zcmMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJwYXR0ZXJuXCI6IHtcbiAgICAgICAgY29uc3QgYSA9IGkuZGV0YWlsLmRhdGE7XG4gICAgICAgIHRoaXMudXBsb2FkVXJsKGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgY29uc3QgYSA9IGkuZGV0YWlsLmZpbGU7XG4gICAgICAgIHRoaXMudXBsb2FkRmlsZShhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQcml2YXRlIG1ldGhvZHNcbiAgICogzL/MvyDMv8y/IMy/zL8gzL8nzL8nXFzMtc2HzL/Mv1xc0Lc9ICgg4paAIM2czZ7KluKWgCkgPc61L8y1zYfMv8y/L+KAmcy/4oCZzL8gzL8gzL/MvyDMv8y/IMy/zL9cbiAgICovXG4gIC8qKlxuICAgKiBTdG9yZXMgYWxsIFRvb2wncyBkYXRhXG4gICAqIEBwYXJhbSBkYXRhIC0gZGF0YSBpbiBJbWFnZSBUb29sIGZvcm1hdFxuICAgKi9cbiAgc2V0IGRhdGEoaSkge1xuICAgIHZhciBhO1xuICAgIHRoaXMuaW1hZ2UgPSBpLmZpbGUsIHRoaXMuX2RhdGEuY2FwdGlvbiA9IGkuY2FwdGlvbiB8fCBcIlwiLCB0aGlzLnVpLmZpbGxDYXB0aW9uKHRoaXMuX2RhdGEuY2FwdGlvbiksIFAudHVuZXMuZm9yRWFjaCgoeyBuYW1lOiBzIH0pID0+IHtcbiAgICAgIGNvbnN0IHIgPSB0eXBlb2YgaVtzXSA8IFwidVwiID8gaVtzXSA9PT0gITAgfHwgaVtzXSA9PT0gXCJ0cnVlXCIgOiAhMTtcbiAgICAgIHRoaXMuc2V0VHVuZShzLCByKTtcbiAgICB9KSwgaS5jYXB0aW9uID8gdGhpcy5zZXRUdW5lKFwiY2FwdGlvblwiLCAhMCkgOiAoKGEgPSB0aGlzLmNvbmZpZy5mZWF0dXJlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGEuY2FwdGlvbikgPT09ICEwICYmIHRoaXMuc2V0VHVuZShcImNhcHRpb25cIiwgITApO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gVG9vbCBkYXRhXG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuICAvKipcbiAgICogU2V0IG5ldyBpbWFnZSBmaWxlXG4gICAqIEBwYXJhbSBmaWxlIC0gdXBsb2FkZWQgZmlsZSBkYXRhXG4gICAqL1xuICBzZXQgaW1hZ2UoaSkge1xuICAgIHRoaXMuX2RhdGEuZmlsZSA9IGkgfHwgeyB1cmw6IFwiXCIgfSwgaSAmJiBpLnVybCAmJiB0aGlzLnVpLmZpbGxJbWFnZShpLnVybCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbGUgdXBsb2FkaW5nIGNhbGxiYWNrXG4gICAqIEBwYXJhbSByZXNwb25zZSAtIHVwbG9hZGluZyBzZXJ2ZXIgcmVzcG9uc2VcbiAgICovXG4gIG9uVXBsb2FkKGkpIHtcbiAgICBpLnN1Y2Nlc3MgJiYgaS5maWxlID8gdGhpcy5pbWFnZSA9IGkuZmlsZSA6IHRoaXMudXBsb2FkaW5nRmFpbGVkKFwiaW5jb3JyZWN0IHJlc3BvbnNlOiBcIiArIEpTT04uc3RyaW5naWZ5KGkpKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIHVwbG9hZGVyIGVycm9yc1xuICAgKiBAcGFyYW0gZXJyb3JUZXh0IC0gdXBsb2FkaW5nIGVycm9yIGluZm9cbiAgICovXG4gIHVwbG9hZGluZ0ZhaWxlZChpKSB7XG4gICAgY29uc29sZS5sb2coXCJJbWFnZSBUb29sOiB1cGxvYWRpbmcgZmFpbGVkIGJlY2F1c2Ugb2ZcIiwgaSksIHRoaXMuYXBpLm5vdGlmaWVyLnNob3coe1xuICAgICAgbWVzc2FnZTogdGhpcy5hcGkuaTE4bi50KFwiQ291bGRu4oCZdCB1cGxvYWQgaW1hZ2UuIFBsZWFzZSB0cnkgYW5vdGhlci5cIiksXG4gICAgICBzdHlsZTogXCJlcnJvclwiXG4gICAgfSksIHRoaXMudWkuaGlkZVByZWxvYWRlcigpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCB3aGVuIEJsb2NrIFR1bmUgaXMgYWN0aXZhdGVkXG4gICAqIEBwYXJhbSB0dW5lTmFtZSAtIHR1bmUgdGhhdCBoYXMgYmVlbiBjbGlja2VkXG4gICAqIEBwYXJhbSBzdGF0ZSAtIG5ldyBzdGF0ZVxuICAgKi9cbiAgdHVuZVRvZ2dsZWQoaSwgYSkge1xuICAgIGkgPT09IFwiY2FwdGlvblwiID8gKHRoaXMudWkuYXBwbHlUdW5lKGksIGEpLCBhID09ICExICYmICh0aGlzLl9kYXRhLmNhcHRpb24gPSBcIlwiLCB0aGlzLnVpLmZpbGxDYXB0aW9uKFwiXCIpKSkgOiB0aGlzLnNldFR1bmUoaSwgYSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBvbmUgdHVuZVxuICAgKiBAcGFyYW0gdHVuZU5hbWUgLSB7QGxpbmsgVHVuZXMudHVuZXN9XG4gICAqIEBwYXJhbSB2YWx1ZSAtIHR1bmUgc3RhdGVcbiAgICovXG4gIHNldFR1bmUoaSwgYSkge1xuICAgIHRoaXMuX2RhdGFbaV0gPSBhLCB0aGlzLnVpLmFwcGx5VHVuZShpLCBhKSwgaSA9PT0gXCJzdHJldGNoZWRcIiAmJiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuYmxvY2suc3RyZXRjaGVkID0gYTtcbiAgICB9KS5jYXRjaCgocykgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihzKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2hvdyBwcmVsb2FkZXIgYW5kIHVwbG9hZCBpbWFnZSBmaWxlXG4gICAqIEBwYXJhbSBmaWxlIC0gZmlsZSB0aGF0IGlzIGN1cnJlbnRseSB1cGxvYWRpbmcgKGZyb20gcGFzdGUpXG4gICAqL1xuICB1cGxvYWRGaWxlKGkpIHtcbiAgICB0aGlzLnVwbG9hZGVyLnVwbG9hZEJ5RmlsZShpLCB7XG4gICAgICBvblByZXZpZXc6IChhKSA9PiB7XG4gICAgICAgIHRoaXMudWkuc2hvd1ByZWxvYWRlcihhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2hvdyBwcmVsb2FkZXIgYW5kIHVwbG9hZCBpbWFnZSBieSB0YXJnZXQgdXJsXG4gICAqIEBwYXJhbSB1cmwgLSB1cmwgcGFzdGVkXG4gICAqL1xuICB1cGxvYWRVcmwoaSkge1xuICAgIHRoaXMudWkuc2hvd1ByZWxvYWRlcihpKSwgdGhpcy51cGxvYWRlci51cGxvYWRCeVVybChpKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgUCBhcyBkZWZhdWx0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@editorjs/image/dist/image.mjs\n\n}");

/***/ }),

/***/ "./node_modules/@editorjs/list/dist/editorjs-list.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@editorjs/list/dist/editorjs-list.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ G)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode('.cdx-list{margin:0;padding:0;outline:none;display:grid;counter-reset:item;gap:var(--spacing-s);padding:var(--spacing-xs);--spacing-s: 8px;--spacing-xs: 6px;--list-counter-type: numeric;--radius-border: 5px;--checkbox-background: #fff;--color-border: #C9C9C9;--color-bg-checked: #369FFF;--line-height: 1.45em;--color-bg-checked-hover: #0059AB;--color-tick: #fff;--size-checkbox: 1.2em}.cdx-list__item{line-height:var(--line-height);display:grid;grid-template-columns:auto 1fr;grid-template-rows:auto auto;grid-template-areas:\"checkbox content\" \". child\"}.cdx-list__item-children{display:grid;grid-area:child;gap:var(--spacing-s);padding-top:var(--spacing-s)}.cdx-list__item [contenteditable]{outline:none}.cdx-list__item-content{word-break:break-word;white-space:pre-wrap;grid-area:content;padding-left:var(--spacing-s)}.cdx-list__item:before{counter-increment:item;white-space:nowrap}.cdx-list-ordered .cdx-list__item:before{content:counters(item,\".\",var(--list-counter-type)) \".\"}.cdx-list-ordered{counter-reset:item}.cdx-list-unordered .cdx-list__item:before{content:\"•\"}.cdx-list-checklist .cdx-list__item:before{content:\"\"}.cdx-list__settings .cdx-settings-button{width:50%}.cdx-list__checkbox{padding-top:calc((var(--line-height) - var(--size-checkbox)) / 2);grid-area:checkbox;width:var(--size-checkbox);height:var(--size-checkbox);display:flex;cursor:pointer}.cdx-list__checkbox svg{opacity:0;height:var(--size-checkbox);width:var(--size-checkbox);left:-1px;top:-1px;position:absolute}@media (hover: hover){.cdx-list__checkbox:not(.cdx-list__checkbox--no-hover):hover .cdx-list__checkbox-check svg{opacity:1}}.cdx-list__checkbox--checked{line-height:var(--line-height)}@media (hover: hover){.cdx-list__checkbox--checked:not(.cdx-list__checkbox--checked--no-hover):hover .cdx-checklist__checkbox-check{background:var(--color-bg-checked-hover);border-color:var(--color-bg-checked-hover)}}.cdx-list__checkbox--checked .cdx-list__checkbox-check{background:var(--color-bg-checked);border-color:var(--color-bg-checked)}.cdx-list__checkbox--checked .cdx-list__checkbox-check svg{opacity:1}.cdx-list__checkbox--checked .cdx-list__checkbox-check svg path{stroke:var(--color-tick)}.cdx-list__checkbox--checked .cdx-list__checkbox-check:before{opacity:0;visibility:visible;transform:scale(2.5)}.cdx-list__checkbox-check{cursor:pointer;display:inline-block;position:relative;margin:0 auto;width:var(--size-checkbox);height:var(--size-checkbox);box-sizing:border-box;border-radius:var(--radius-border);border:1px solid var(--color-border);background:var(--checkbox-background)}.cdx-list__checkbox-check:before{content:\"\";position:absolute;top:0;right:0;bottom:0;left:0;border-radius:100%;background-color:var(--color-bg-checked);visibility:hidden;pointer-events:none;transform:scale(1);transition:transform .4s ease-out,opacity .4s}.cdx-list-start-with-field{background:#F8F8F8;border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:2px;display:grid;grid-template-columns:auto auto 1fr;grid-template-rows:auto}.cdx-list-start-with-field--invalid{background:#FFECED;border:1px solid #E13F3F}.cdx-list-start-with-field--invalid .cdx-list-start-with-field__input{color:#e13f3f}.cdx-list-start-with-field__input{font-size:14px;outline:none;font-weight:500;font-family:inherit;border:0;background:transparent;margin:0;padding:0;line-height:22px;min-width:calc(100% - var(--toolbox-buttons-size) - var(--icon-margin-right))}.cdx-list-start-with-field__input::placeholder{color:var(--grayText);font-weight:500}')),document.head.appendChild(e)}}catch(c){console.error(\"vite-plugin-css-injected-by-js\",c)}})();\nconst Ct = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7 12L10.4884 15.8372C10.5677 15.9245 10.705 15.9245 10.7844 15.8372L17 9\"/></svg>', Ae = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M9.2 12L11.0586 13.8586C11.1367 13.9367 11.2633 13.9367 11.3414 13.8586L14.7 10.5\"/><rect width=\"14\" height=\"14\" x=\"5\" y=\"5\" stroke=\"currentColor\" stroke-width=\"2\" rx=\"4\"/></svg>', $e = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><line x1=\"9\" x2=\"19\" y1=\"7\" y2=\"7\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"9\" x2=\"19\" y1=\"12\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"9\" x2=\"19\" y1=\"17\" y2=\"17\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M5.00001 17H4.99002\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M5.00001 12H4.99002\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M5.00001 7H4.99002\"/></svg>', Be = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><line x1=\"12\" x2=\"19\" y1=\"7\" y2=\"7\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"12\" x2=\"19\" y1=\"12\" y2=\"12\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><line x1=\"12\" x2=\"19\" y1=\"17\" y2=\"17\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M7.79999 14L7.79999 7.2135C7.79999 7.12872 7.7011 7.0824 7.63597 7.13668L4.79999 9.5\"/></svg>', St = '<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10 14.2L10 7.4135C10 7.32872 9.90111 7.28241 9.83598 7.33668L7 9.7\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/><path d=\"M13.2087 14.2H13.2\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/></svg>', Ot = '<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M13.2087 14.2H13.2\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/><path d=\"M10 14.2L10 9.5\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/><path d=\"M10 7.01L10 7\" stroke=\"black\" stroke-width=\"1.8\" stroke-linecap=\"round\"/></svg>', kt = '<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M13.2087 14.2H13.2\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/><path d=\"M10 14.2L10 7.2\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/></svg>', _t = '<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M16.0087 14.2H16\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/><path d=\"M7 14.2L7.78865 12M13 14.2L12.1377 12M7.78865 12C7.78865 12 9.68362 7 10 7C10.3065 7 12.1377 12 12.1377 12M7.78865 12L12.1377 12\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/></svg>', Et = '<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M14.2087 14.2H14.2\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/><path d=\"M11.5 14.5C11.5 14.5 11 13.281 11 12.5M7 9.5C7 9.5 7.5 8.5 9 8.5C10.5 8.5 11 9.5 11 10.5L11 11.5M11 11.5L11 12.5M11 11.5C11 11.5 7 11 7 13C7 15.3031 11 15 11 12.5\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/></svg>', It = '<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M8 14.2L8 7.4135C8 7.32872 7.90111 7.28241 7.83598 7.33668L5 9.7\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\"/><path d=\"M14 13L16.4167 10.7778M16.4167 10.7778L14 8.5M16.4167 10.7778H11.6562\" stroke=\"black\" stroke-width=\"1.6\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>';\nvar A = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction wt(e) {\n  if (e.__esModule)\n    return e;\n  var t = e.default;\n  if (typeof t == \"function\") {\n    var n = function r() {\n      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);\n    };\n    n.prototype = t.prototype;\n  } else\n    n = {};\n  return Object.defineProperty(n, \"__esModule\", { value: !0 }), Object.keys(e).forEach(function(r) {\n    var i = Object.getOwnPropertyDescriptor(e, r);\n    Object.defineProperty(n, r, i.get ? i : {\n      enumerable: !0,\n      get: function() {\n        return e[r];\n      }\n    });\n  }), n;\n}\nvar c = {}, V = {}, Y = {};\nObject.defineProperty(Y, \"__esModule\", { value: !0 });\nY.allInputsSelector = Pt;\nfunction Pt() {\n  var e = [\"text\", \"password\", \"email\", \"number\", \"search\", \"tel\", \"url\"];\n  return \"[contenteditable=true], textarea, input:not([type]), \" + e.map(function(t) {\n    return 'input[type=\"'.concat(t, '\"]');\n  }).join(\", \");\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.allInputsSelector = void 0;\n  var t = Y;\n  Object.defineProperty(e, \"allInputsSelector\", { enumerable: !0, get: function() {\n    return t.allInputsSelector;\n  } });\n})(V);\nvar k = {}, J = {};\nObject.defineProperty(J, \"__esModule\", { value: !0 });\nJ.isNativeInput = jt;\nfunction jt(e) {\n  var t = [\n    \"INPUT\",\n    \"TEXTAREA\"\n  ];\n  return e && e.tagName ? t.includes(e.tagName) : !1;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isNativeInput = void 0;\n  var t = J;\n  Object.defineProperty(e, \"isNativeInput\", { enumerable: !0, get: function() {\n    return t.isNativeInput;\n  } });\n})(k);\nvar Fe = {}, Q = {};\nObject.defineProperty(Q, \"__esModule\", { value: !0 });\nQ.append = Tt;\nfunction Tt(e, t) {\n  Array.isArray(t) ? t.forEach(function(n) {\n    e.appendChild(n);\n  }) : e.appendChild(t);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.append = void 0;\n  var t = Q;\n  Object.defineProperty(e, \"append\", { enumerable: !0, get: function() {\n    return t.append;\n  } });\n})(Fe);\nvar Z = {}, x = {};\nObject.defineProperty(x, \"__esModule\", { value: !0 });\nx.blockElements = Lt;\nfunction Lt() {\n  return [\n    \"address\",\n    \"article\",\n    \"aside\",\n    \"blockquote\",\n    \"canvas\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"li\",\n    \"main\",\n    \"nav\",\n    \"noscript\",\n    \"ol\",\n    \"output\",\n    \"p\",\n    \"pre\",\n    \"ruby\",\n    \"section\",\n    \"table\",\n    \"tbody\",\n    \"thead\",\n    \"tr\",\n    \"tfoot\",\n    \"ul\",\n    \"video\"\n  ];\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.blockElements = void 0;\n  var t = x;\n  Object.defineProperty(e, \"blockElements\", { enumerable: !0, get: function() {\n    return t.blockElements;\n  } });\n})(Z);\nvar Re = {}, ee = {};\nObject.defineProperty(ee, \"__esModule\", { value: !0 });\nee.calculateBaseline = Mt;\nfunction Mt(e) {\n  var t = window.getComputedStyle(e), n = parseFloat(t.fontSize), r = parseFloat(t.lineHeight) || n * 1.2, i = parseFloat(t.paddingTop), a = parseFloat(t.borderTopWidth), l = parseFloat(t.marginTop), s = n * 0.8, o = (r - n) / 2, d = l + a + i + o + s;\n  return d;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.calculateBaseline = void 0;\n  var t = ee;\n  Object.defineProperty(e, \"calculateBaseline\", { enumerable: !0, get: function() {\n    return t.calculateBaseline;\n  } });\n})(Re);\nvar qe = {}, te = {}, ne = {}, re = {};\nObject.defineProperty(re, \"__esModule\", { value: !0 });\nre.isContentEditable = Nt;\nfunction Nt(e) {\n  return e.contentEditable === \"true\";\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isContentEditable = void 0;\n  var t = re;\n  Object.defineProperty(e, \"isContentEditable\", { enumerable: !0, get: function() {\n    return t.isContentEditable;\n  } });\n})(ne);\nObject.defineProperty(te, \"__esModule\", { value: !0 });\nte.canSetCaret = Bt;\nvar At = k, $t = ne;\nfunction Bt(e) {\n  var t = !0;\n  if ((0, At.isNativeInput)(e))\n    switch (e.type) {\n      case \"file\":\n      case \"checkbox\":\n      case \"radio\":\n      case \"hidden\":\n      case \"submit\":\n      case \"button\":\n      case \"image\":\n      case \"reset\":\n        t = !1;\n        break;\n    }\n  else\n    t = (0, $t.isContentEditable)(e);\n  return t;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.canSetCaret = void 0;\n  var t = te;\n  Object.defineProperty(e, \"canSetCaret\", { enumerable: !0, get: function() {\n    return t.canSetCaret;\n  } });\n})(qe);\nvar $ = {}, ie = {};\nfunction Wt(e, t, n) {\n  const r = n.value !== void 0 ? \"value\" : \"get\", i = n[r], a = `#${t}Cache`;\n  if (n[r] = function(...l) {\n    return this[a] === void 0 && (this[a] = i.apply(this, l)), this[a];\n  }, r === \"get\" && n.set) {\n    const l = n.set;\n    n.set = function(s) {\n      delete e[a], l.apply(this, s);\n    };\n  }\n  return n;\n}\nfunction Ue() {\n  const e = {\n    win: !1,\n    mac: !1,\n    x11: !1,\n    linux: !1\n  }, t = Object.keys(e).find((n) => window.navigator.appVersion.toLowerCase().indexOf(n) !== -1);\n  return t !== void 0 && (e[t] = !0), e;\n}\nfunction ae(e) {\n  return e != null && e !== \"\" && (typeof e != \"object\" || Object.keys(e).length > 0);\n}\nfunction Dt(e) {\n  return !ae(e);\n}\nconst Ht = () => typeof window < \"u\" && window.navigator !== null && ae(window.navigator.platform) && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === \"MacIntel\" && window.navigator.maxTouchPoints > 1);\nfunction Ft(e) {\n  const t = Ue();\n  return e = e.replace(/shift/gi, \"⇧\").replace(/backspace/gi, \"⌫\").replace(/enter/gi, \"⏎\").replace(/up/gi, \"↑\").replace(/left/gi, \"→\").replace(/down/gi, \"↓\").replace(/right/gi, \"←\").replace(/escape/gi, \"⎋\").replace(/insert/gi, \"Ins\").replace(/delete/gi, \"␡\").replace(/\\+/gi, \"+\"), t.mac ? e = e.replace(/ctrl|cmd/gi, \"⌘\").replace(/alt/gi, \"⌥\") : e = e.replace(/cmd/gi, \"Ctrl\").replace(/windows/gi, \"WIN\"), e;\n}\nfunction Rt(e) {\n  return e[0].toUpperCase() + e.slice(1);\n}\nfunction qt(e) {\n  const t = document.createElement(\"div\");\n  t.style.position = \"absolute\", t.style.left = \"-999px\", t.style.bottom = \"-999px\", t.innerHTML = e, document.body.appendChild(t);\n  const n = window.getSelection(), r = document.createRange();\n  if (r.selectNode(t), n === null)\n    throw new Error(\"Cannot copy text to clipboard\");\n  n.removeAllRanges(), n.addRange(r), document.execCommand(\"copy\"), document.body.removeChild(t);\n}\nfunction Ut(e, t, n) {\n  let r;\n  return (...i) => {\n    const a = this, l = () => {\n      r = void 0, n !== !0 && e.apply(a, i);\n    }, s = n === !0 && r !== void 0;\n    window.clearTimeout(r), r = window.setTimeout(l, t), s && e.apply(a, i);\n  };\n}\nfunction S(e) {\n  return Object.prototype.toString.call(e).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n}\nfunction Kt(e) {\n  return S(e) === \"boolean\";\n}\nfunction Ke(e) {\n  return S(e) === \"function\" || S(e) === \"asyncfunction\";\n}\nfunction zt(e) {\n  return Ke(e) && /^\\s*class\\s+/.test(e.toString());\n}\nfunction Xt(e) {\n  return S(e) === \"number\";\n}\nfunction M(e) {\n  return S(e) === \"object\";\n}\nfunction Gt(e) {\n  return Promise.resolve(e) === e;\n}\nfunction Vt(e) {\n  return S(e) === \"string\";\n}\nfunction Yt(e) {\n  return S(e) === \"undefined\";\n}\nfunction X(e, ...t) {\n  if (!t.length)\n    return e;\n  const n = t.shift();\n  if (M(e) && M(n))\n    for (const r in n)\n      M(n[r]) ? (e[r] === void 0 && Object.assign(e, { [r]: {} }), X(e[r], n[r])) : Object.assign(e, { [r]: n[r] });\n  return X(e, ...t);\n}\nfunction Jt(e, t, n) {\n  const r = `«${t}» is deprecated and will be removed in the next major release. Please use the «${n}» instead.`;\n  e && console.warn(r);\n}\nfunction Qt(e) {\n  try {\n    return new URL(e).href;\n  } catch {\n  }\n  return e.substring(0, 2) === \"//\" ? window.location.protocol + e : window.location.origin + e;\n}\nfunction Zt(e) {\n  return e > 47 && e < 58 || e === 32 || e === 13 || e === 229 || e > 64 && e < 91 || e > 95 && e < 112 || e > 185 && e < 193 || e > 218 && e < 223;\n}\nconst xt = {\n  BACKSPACE: 8,\n  TAB: 9,\n  ENTER: 13,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  ESC: 27,\n  SPACE: 32,\n  LEFT: 37,\n  UP: 38,\n  DOWN: 40,\n  RIGHT: 39,\n  DELETE: 46,\n  META: 91,\n  SLASH: 191\n}, en = {\n  LEFT: 0,\n  WHEEL: 1,\n  RIGHT: 2,\n  BACKWARD: 3,\n  FORWARD: 4\n};\nclass tn {\n  constructor() {\n    this.completed = Promise.resolve();\n  }\n  /**\n   * Add new promise to queue\n   * @param operation - promise should be added to queue\n   */\n  add(t) {\n    return new Promise((n, r) => {\n      this.completed = this.completed.then(t).then(n).catch(r);\n    });\n  }\n}\nfunction nn(e, t, n = void 0) {\n  let r, i, a, l = null, s = 0;\n  n || (n = {});\n  const o = function() {\n    s = n.leading === !1 ? 0 : Date.now(), l = null, a = e.apply(r, i), l === null && (r = i = null);\n  };\n  return function() {\n    const d = Date.now();\n    !s && n.leading === !1 && (s = d);\n    const u = t - (d - s);\n    return r = this, i = arguments, u <= 0 || u > t ? (l && (clearTimeout(l), l = null), s = d, a = e.apply(r, i), l === null && (r = i = null)) : !l && n.trailing !== !1 && (l = setTimeout(o, u)), a;\n  };\n}\nconst rn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  PromiseQueue: tn,\n  beautifyShortcut: Ft,\n  cacheable: Wt,\n  capitalize: Rt,\n  copyTextToClipboard: qt,\n  debounce: Ut,\n  deepMerge: X,\n  deprecationAssert: Jt,\n  getUserOS: Ue,\n  getValidUrl: Qt,\n  isBoolean: Kt,\n  isClass: zt,\n  isEmpty: Dt,\n  isFunction: Ke,\n  isIosDevice: Ht,\n  isNumber: Xt,\n  isObject: M,\n  isPrintableKey: Zt,\n  isPromise: Gt,\n  isString: Vt,\n  isUndefined: Yt,\n  keyCodes: xt,\n  mouseButtons: en,\n  notEmpty: ae,\n  throttle: nn,\n  typeOf: S\n}, Symbol.toStringTag, { value: \"Module\" })), le = /* @__PURE__ */ wt(rn);\nObject.defineProperty(ie, \"__esModule\", { value: !0 });\nie.containsOnlyInlineElements = sn;\nvar an = le, ln = Z;\nfunction sn(e) {\n  var t;\n  (0, an.isString)(e) ? (t = document.createElement(\"div\"), t.innerHTML = e) : t = e;\n  var n = function(r) {\n    return !(0, ln.blockElements)().includes(r.tagName.toLowerCase()) && Array.from(r.children).every(n);\n  };\n  return Array.from(t.children).every(n);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.containsOnlyInlineElements = void 0;\n  var t = ie;\n  Object.defineProperty(e, \"containsOnlyInlineElements\", { enumerable: !0, get: function() {\n    return t.containsOnlyInlineElements;\n  } });\n})($);\nvar ze = {}, se = {}, B = {}, oe = {};\nObject.defineProperty(oe, \"__esModule\", { value: !0 });\noe.make = on;\nfunction on(e, t, n) {\n  var r;\n  t === void 0 && (t = null), n === void 0 && (n = {});\n  var i = document.createElement(e);\n  if (Array.isArray(t)) {\n    var a = t.filter(function(s) {\n      return s !== void 0;\n    });\n    (r = i.classList).add.apply(r, a);\n  } else\n    t !== null && i.classList.add(t);\n  for (var l in n)\n    Object.prototype.hasOwnProperty.call(n, l) && (i[l] = n[l]);\n  return i;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.make = void 0;\n  var t = oe;\n  Object.defineProperty(e, \"make\", { enumerable: !0, get: function() {\n    return t.make;\n  } });\n})(B);\nObject.defineProperty(se, \"__esModule\", { value: !0 });\nse.fragmentToString = cn;\nvar un = B;\nfunction cn(e) {\n  var t = (0, un.make)(\"div\");\n  return t.appendChild(e), t.innerHTML;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.fragmentToString = void 0;\n  var t = se;\n  Object.defineProperty(e, \"fragmentToString\", { enumerable: !0, get: function() {\n    return t.fragmentToString;\n  } });\n})(ze);\nvar Xe = {}, ue = {};\nObject.defineProperty(ue, \"__esModule\", { value: !0 });\nue.getContentLength = fn;\nvar dn = k;\nfunction fn(e) {\n  var t, n;\n  return (0, dn.isNativeInput)(e) ? e.value.length : e.nodeType === Node.TEXT_NODE ? e.length : (n = (t = e.textContent) === null || t === void 0 ? void 0 : t.length) !== null && n !== void 0 ? n : 0;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.getContentLength = void 0;\n  var t = ue;\n  Object.defineProperty(e, \"getContentLength\", { enumerable: !0, get: function() {\n    return t.getContentLength;\n  } });\n})(Xe);\nvar ce = {}, de = {}, We = A && A.__spreadArray || function(e, t, n) {\n  if (n || arguments.length === 2)\n    for (var r = 0, i = t.length, a; r < i; r++)\n      (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);\n  return e.concat(a || Array.prototype.slice.call(t));\n};\nObject.defineProperty(de, \"__esModule\", { value: !0 });\nde.getDeepestBlockElements = Ge;\nvar pn = $;\nfunction Ge(e) {\n  return (0, pn.containsOnlyInlineElements)(e) ? [e] : Array.from(e.children).reduce(function(t, n) {\n    return We(We([], t, !0), Ge(n), !0);\n  }, []);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.getDeepestBlockElements = void 0;\n  var t = de;\n  Object.defineProperty(e, \"getDeepestBlockElements\", { enumerable: !0, get: function() {\n    return t.getDeepestBlockElements;\n  } });\n})(ce);\nvar Ve = {}, fe = {}, W = {}, pe = {};\nObject.defineProperty(pe, \"__esModule\", { value: !0 });\npe.isLineBreakTag = hn;\nfunction hn(e) {\n  return [\n    \"BR\",\n    \"WBR\"\n  ].includes(e.tagName);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isLineBreakTag = void 0;\n  var t = pe;\n  Object.defineProperty(e, \"isLineBreakTag\", { enumerable: !0, get: function() {\n    return t.isLineBreakTag;\n  } });\n})(W);\nvar D = {}, he = {};\nObject.defineProperty(he, \"__esModule\", { value: !0 });\nhe.isSingleTag = mn;\nfunction mn(e) {\n  return [\n    \"AREA\",\n    \"BASE\",\n    \"BR\",\n    \"COL\",\n    \"COMMAND\",\n    \"EMBED\",\n    \"HR\",\n    \"IMG\",\n    \"INPUT\",\n    \"KEYGEN\",\n    \"LINK\",\n    \"META\",\n    \"PARAM\",\n    \"SOURCE\",\n    \"TRACK\",\n    \"WBR\"\n  ].includes(e.tagName);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isSingleTag = void 0;\n  var t = he;\n  Object.defineProperty(e, \"isSingleTag\", { enumerable: !0, get: function() {\n    return t.isSingleTag;\n  } });\n})(D);\nObject.defineProperty(fe, \"__esModule\", { value: !0 });\nfe.getDeepestNode = Ye;\nvar gn = k, vn = W, bn = D;\nfunction Ye(e, t) {\n  t === void 0 && (t = !1);\n  var n = t ? \"lastChild\" : \"firstChild\", r = t ? \"previousSibling\" : \"nextSibling\";\n  if (e.nodeType === Node.ELEMENT_NODE && e[n]) {\n    var i = e[n];\n    if ((0, bn.isSingleTag)(i) && !(0, gn.isNativeInput)(i) && !(0, vn.isLineBreakTag)(i))\n      if (i[r])\n        i = i[r];\n      else if (i.parentNode !== null && i.parentNode[r])\n        i = i.parentNode[r];\n      else\n        return i.parentNode;\n    return Ye(i, t);\n  }\n  return e;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.getDeepestNode = void 0;\n  var t = fe;\n  Object.defineProperty(e, \"getDeepestNode\", { enumerable: !0, get: function() {\n    return t.getDeepestNode;\n  } });\n})(Ve);\nvar Je = {}, me = {}, T = A && A.__spreadArray || function(e, t, n) {\n  if (n || arguments.length === 2)\n    for (var r = 0, i = t.length, a; r < i; r++)\n      (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);\n  return e.concat(a || Array.prototype.slice.call(t));\n};\nObject.defineProperty(me, \"__esModule\", { value: !0 });\nme.findAllInputs = kn;\nvar yn = $, Cn = ce, Sn = V, On = k;\nfunction kn(e) {\n  return Array.from(e.querySelectorAll((0, Sn.allInputsSelector)())).reduce(function(t, n) {\n    return (0, On.isNativeInput)(n) || (0, yn.containsOnlyInlineElements)(n) ? T(T([], t, !0), [n], !1) : T(T([], t, !0), (0, Cn.getDeepestBlockElements)(n), !0);\n  }, []);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.findAllInputs = void 0;\n  var t = me;\n  Object.defineProperty(e, \"findAllInputs\", { enumerable: !0, get: function() {\n    return t.findAllInputs;\n  } });\n})(Je);\nvar Qe = {}, ge = {};\nObject.defineProperty(ge, \"__esModule\", { value: !0 });\nge.isCollapsedWhitespaces = _n;\nfunction _n(e) {\n  return !/[^\\t\\n\\r ]/.test(e);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isCollapsedWhitespaces = void 0;\n  var t = ge;\n  Object.defineProperty(e, \"isCollapsedWhitespaces\", { enumerable: !0, get: function() {\n    return t.isCollapsedWhitespaces;\n  } });\n})(Qe);\nvar ve = {}, be = {};\nObject.defineProperty(be, \"__esModule\", { value: !0 });\nbe.isElement = In;\nvar En = le;\nfunction In(e) {\n  return (0, En.isNumber)(e) ? !1 : !!e && !!e.nodeType && e.nodeType === Node.ELEMENT_NODE;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isElement = void 0;\n  var t = be;\n  Object.defineProperty(e, \"isElement\", { enumerable: !0, get: function() {\n    return t.isElement;\n  } });\n})(ve);\nvar Ze = {}, ye = {}, Ce = {}, Se = {};\nObject.defineProperty(Se, \"__esModule\", { value: !0 });\nSe.isLeaf = wn;\nfunction wn(e) {\n  return e === null ? !1 : e.childNodes.length === 0;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isLeaf = void 0;\n  var t = Se;\n  Object.defineProperty(e, \"isLeaf\", { enumerable: !0, get: function() {\n    return t.isLeaf;\n  } });\n})(Ce);\nvar Oe = {}, ke = {};\nObject.defineProperty(ke, \"__esModule\", { value: !0 });\nke.isNodeEmpty = Mn;\nvar Pn = W, jn = ve, Tn = k, Ln = D;\nfunction Mn(e, t) {\n  var n = \"\";\n  return (0, Ln.isSingleTag)(e) && !(0, Pn.isLineBreakTag)(e) ? !1 : ((0, jn.isElement)(e) && (0, Tn.isNativeInput)(e) ? n = e.value : e.textContent !== null && (n = e.textContent.replace(\"​\", \"\")), t !== void 0 && (n = n.replace(new RegExp(t, \"g\"), \"\")), n.trim().length === 0);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isNodeEmpty = void 0;\n  var t = ke;\n  Object.defineProperty(e, \"isNodeEmpty\", { enumerable: !0, get: function() {\n    return t.isNodeEmpty;\n  } });\n})(Oe);\nObject.defineProperty(ye, \"__esModule\", { value: !0 });\nye.isEmpty = $n;\nvar Nn = Ce, An = Oe;\nfunction $n(e, t) {\n  e.normalize();\n  for (var n = [e]; n.length > 0; ) {\n    var r = n.shift();\n    if (r) {\n      if (e = r, (0, Nn.isLeaf)(e) && !(0, An.isNodeEmpty)(e, t))\n        return !1;\n      n.push.apply(n, Array.from(e.childNodes));\n    }\n  }\n  return !0;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isEmpty = void 0;\n  var t = ye;\n  Object.defineProperty(e, \"isEmpty\", { enumerable: !0, get: function() {\n    return t.isEmpty;\n  } });\n})(Ze);\nvar xe = {}, _e = {};\nObject.defineProperty(_e, \"__esModule\", { value: !0 });\n_e.isFragment = Wn;\nvar Bn = le;\nfunction Wn(e) {\n  return (0, Bn.isNumber)(e) ? !1 : !!e && !!e.nodeType && e.nodeType === Node.DOCUMENT_FRAGMENT_NODE;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isFragment = void 0;\n  var t = _e;\n  Object.defineProperty(e, \"isFragment\", { enumerable: !0, get: function() {\n    return t.isFragment;\n  } });\n})(xe);\nvar et = {}, Ee = {};\nObject.defineProperty(Ee, \"__esModule\", { value: !0 });\nEe.isHTMLString = Hn;\nvar Dn = B;\nfunction Hn(e) {\n  var t = (0, Dn.make)(\"div\");\n  return t.innerHTML = e, t.childElementCount > 0;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isHTMLString = void 0;\n  var t = Ee;\n  Object.defineProperty(e, \"isHTMLString\", { enumerable: !0, get: function() {\n    return t.isHTMLString;\n  } });\n})(et);\nvar tt = {}, Ie = {};\nObject.defineProperty(Ie, \"__esModule\", { value: !0 });\nIe.offset = Fn;\nfunction Fn(e) {\n  var t = e.getBoundingClientRect(), n = window.pageXOffset || document.documentElement.scrollLeft, r = window.pageYOffset || document.documentElement.scrollTop, i = t.top + r, a = t.left + n;\n  return {\n    top: i,\n    left: a,\n    bottom: i + t.height,\n    right: a + t.width\n  };\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.offset = void 0;\n  var t = Ie;\n  Object.defineProperty(e, \"offset\", { enumerable: !0, get: function() {\n    return t.offset;\n  } });\n})(tt);\nvar nt = {}, we = {};\nObject.defineProperty(we, \"__esModule\", { value: !0 });\nwe.prepend = Rn;\nfunction Rn(e, t) {\n  Array.isArray(t) ? (t = t.reverse(), t.forEach(function(n) {\n    return e.prepend(n);\n  })) : e.prepend(t);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.prepend = void 0;\n  var t = we;\n  Object.defineProperty(e, \"prepend\", { enumerable: !0, get: function() {\n    return t.prepend;\n  } });\n})(nt);\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.prepend = e.offset = e.make = e.isLineBreakTag = e.isSingleTag = e.isNodeEmpty = e.isLeaf = e.isHTMLString = e.isFragment = e.isEmpty = e.isElement = e.isContentEditable = e.isCollapsedWhitespaces = e.findAllInputs = e.isNativeInput = e.allInputsSelector = e.getDeepestNode = e.getDeepestBlockElements = e.getContentLength = e.fragmentToString = e.containsOnlyInlineElements = e.canSetCaret = e.calculateBaseline = e.blockElements = e.append = void 0;\n  var t = V;\n  Object.defineProperty(e, \"allInputsSelector\", { enumerable: !0, get: function() {\n    return t.allInputsSelector;\n  } });\n  var n = k;\n  Object.defineProperty(e, \"isNativeInput\", { enumerable: !0, get: function() {\n    return n.isNativeInput;\n  } });\n  var r = Fe;\n  Object.defineProperty(e, \"append\", { enumerable: !0, get: function() {\n    return r.append;\n  } });\n  var i = Z;\n  Object.defineProperty(e, \"blockElements\", { enumerable: !0, get: function() {\n    return i.blockElements;\n  } });\n  var a = Re;\n  Object.defineProperty(e, \"calculateBaseline\", { enumerable: !0, get: function() {\n    return a.calculateBaseline;\n  } });\n  var l = qe;\n  Object.defineProperty(e, \"canSetCaret\", { enumerable: !0, get: function() {\n    return l.canSetCaret;\n  } });\n  var s = $;\n  Object.defineProperty(e, \"containsOnlyInlineElements\", { enumerable: !0, get: function() {\n    return s.containsOnlyInlineElements;\n  } });\n  var o = ze;\n  Object.defineProperty(e, \"fragmentToString\", { enumerable: !0, get: function() {\n    return o.fragmentToString;\n  } });\n  var d = Xe;\n  Object.defineProperty(e, \"getContentLength\", { enumerable: !0, get: function() {\n    return d.getContentLength;\n  } });\n  var u = ce;\n  Object.defineProperty(e, \"getDeepestBlockElements\", { enumerable: !0, get: function() {\n    return u.getDeepestBlockElements;\n  } });\n  var p = Ve;\n  Object.defineProperty(e, \"getDeepestNode\", { enumerable: !0, get: function() {\n    return p.getDeepestNode;\n  } });\n  var g = Je;\n  Object.defineProperty(e, \"findAllInputs\", { enumerable: !0, get: function() {\n    return g.findAllInputs;\n  } });\n  var w = Qe;\n  Object.defineProperty(e, \"isCollapsedWhitespaces\", { enumerable: !0, get: function() {\n    return w.isCollapsedWhitespaces;\n  } });\n  var _ = ne;\n  Object.defineProperty(e, \"isContentEditable\", { enumerable: !0, get: function() {\n    return _.isContentEditable;\n  } });\n  var ut = ve;\n  Object.defineProperty(e, \"isElement\", { enumerable: !0, get: function() {\n    return ut.isElement;\n  } });\n  var ct = Ze;\n  Object.defineProperty(e, \"isEmpty\", { enumerable: !0, get: function() {\n    return ct.isEmpty;\n  } });\n  var dt = xe;\n  Object.defineProperty(e, \"isFragment\", { enumerable: !0, get: function() {\n    return dt.isFragment;\n  } });\n  var ft = et;\n  Object.defineProperty(e, \"isHTMLString\", { enumerable: !0, get: function() {\n    return ft.isHTMLString;\n  } });\n  var pt = Ce;\n  Object.defineProperty(e, \"isLeaf\", { enumerable: !0, get: function() {\n    return pt.isLeaf;\n  } });\n  var ht = Oe;\n  Object.defineProperty(e, \"isNodeEmpty\", { enumerable: !0, get: function() {\n    return ht.isNodeEmpty;\n  } });\n  var mt = W;\n  Object.defineProperty(e, \"isLineBreakTag\", { enumerable: !0, get: function() {\n    return mt.isLineBreakTag;\n  } });\n  var gt = D;\n  Object.defineProperty(e, \"isSingleTag\", { enumerable: !0, get: function() {\n    return gt.isSingleTag;\n  } });\n  var vt = B;\n  Object.defineProperty(e, \"make\", { enumerable: !0, get: function() {\n    return vt.make;\n  } });\n  var bt = tt;\n  Object.defineProperty(e, \"offset\", { enumerable: !0, get: function() {\n    return bt.offset;\n  } });\n  var yt = nt;\n  Object.defineProperty(e, \"prepend\", { enumerable: !0, get: function() {\n    return yt.prepend;\n  } });\n})(c);\nconst m = \"cdx-list\", h = {\n  wrapper: m,\n  item: `${m}__item`,\n  itemContent: `${m}__item-content`,\n  itemChildren: `${m}__item-children`\n};\nclass v {\n  /**\n   * Getter for all CSS classes used in unordered list rendering\n   */\n  static get CSS() {\n    return {\n      ...h,\n      orderedList: `${m}-ordered`\n    };\n  }\n  /**\n   * Assign passed readonly mode and config to relevant class properties\n   * @param readonly - read-only mode flag\n   * @param config - user config for Tool\n   */\n  constructor(t, n) {\n    this.config = n, this.readOnly = t;\n  }\n  /**\n   * Renders ol wrapper for list\n   * @param isRoot - boolean variable that represents level of the wrappre (root or childList)\n   * @returns - created html ol element\n   */\n  renderWrapper(t) {\n    let n;\n    return t === !0 ? n = c.make(\"ol\", [v.CSS.wrapper, v.CSS.orderedList]) : n = c.make(\"ol\", [v.CSS.orderedList, v.CSS.itemChildren]), n;\n  }\n  /**\n   * Redners list item element\n   * @param content - content used in list item rendering\n   * @param _meta - meta of the list item unused in rendering of the ordered list\n   * @returns - created html list item element\n   */\n  renderItem(t, n) {\n    const r = c.make(\"li\", v.CSS.item), i = c.make(\"div\", v.CSS.itemContent, {\n      innerHTML: t,\n      contentEditable: (!this.readOnly).toString()\n    });\n    return r.appendChild(i), r;\n  }\n  /**\n   * Return the item content\n   * @param item - item wrapper (<li>)\n   * @returns - item content string\n   */\n  getItemContent(t) {\n    const n = t.querySelector(`.${v.CSS.itemContent}`);\n    return !n || c.isEmpty(n) ? \"\" : n.innerHTML;\n  }\n  /**\n   * Returns item meta, for ordered list\n   * @returns item meta object\n   */\n  getItemMeta() {\n    return {};\n  }\n  /**\n   * Returns default item meta used on creation of the new item\n   */\n  composeDefaultMeta() {\n    return {};\n  }\n}\nclass b {\n  /**\n   * Getter for all CSS classes used in unordered list rendering\n   */\n  static get CSS() {\n    return {\n      ...h,\n      unorderedList: `${m}-unordered`\n    };\n  }\n  /**\n   * Assign passed readonly mode and config to relevant class properties\n   * @param readonly - read-only mode flag\n   * @param config - user config for Tool\n   */\n  constructor(t, n) {\n    this.config = n, this.readOnly = t;\n  }\n  /**\n   * Renders ol wrapper for list\n   * @param isRoot - boolean variable that represents level of the wrappre (root or childList)\n   * @returns - created html ul element\n   */\n  renderWrapper(t) {\n    let n;\n    return t === !0 ? n = c.make(\"ul\", [b.CSS.wrapper, b.CSS.unorderedList]) : n = c.make(\"ul\", [b.CSS.unorderedList, b.CSS.itemChildren]), n;\n  }\n  /**\n   * Redners list item element\n   * @param content - content used in list item rendering\n   * @param _meta - meta of the list item unused in rendering of the unordered list\n   * @returns - created html list item element\n   */\n  renderItem(t, n) {\n    const r = c.make(\"li\", b.CSS.item), i = c.make(\"div\", b.CSS.itemContent, {\n      innerHTML: t,\n      contentEditable: (!this.readOnly).toString()\n    });\n    return r.appendChild(i), r;\n  }\n  /**\n   * Return the item content\n   * @param item - item wrapper (<li>)\n   * @returns - item content string\n   */\n  getItemContent(t) {\n    const n = t.querySelector(`.${b.CSS.itemContent}`);\n    return !n || c.isEmpty(n) ? \"\" : n.innerHTML;\n  }\n  /**\n   * Returns item meta, for unordered list\n   * @returns Item meta object\n   */\n  getItemMeta() {\n    return {};\n  }\n  /**\n   * Returns default item meta used on creation of the new item\n   */\n  composeDefaultMeta() {\n    return {};\n  }\n}\nfunction O(e) {\n  return e.nodeType === Node.ELEMENT_NODE;\n}\nvar j = {}, Pe = {}, H = {}, F = {};\nObject.defineProperty(F, \"__esModule\", { value: !0 });\nF.getContenteditableSlice = Un;\nvar qn = c;\nfunction Un(e, t, n, r, i) {\n  var a;\n  i === void 0 && (i = !1);\n  var l = document.createRange();\n  if (r === \"left\" ? (l.setStart(e, 0), l.setEnd(t, n)) : (l.setStart(t, n), l.setEnd(e, e.childNodes.length)), i === !0) {\n    var s = l.extractContents();\n    return (0, qn.fragmentToString)(s);\n  }\n  var o = l.cloneContents(), d = document.createElement(\"div\");\n  d.appendChild(o);\n  var u = (a = d.textContent) !== null && a !== void 0 ? a : \"\";\n  return u;\n}\nObject.defineProperty(H, \"__esModule\", { value: !0 });\nH.checkContenteditableSliceForEmptiness = Xn;\nvar Kn = c, zn = F;\nfunction Xn(e, t, n, r) {\n  var i = (0, zn.getContenteditableSlice)(e, t, n, r);\n  return (0, Kn.isCollapsedWhitespaces)(i);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.checkContenteditableSliceForEmptiness = void 0;\n  var t = H;\n  Object.defineProperty(e, \"checkContenteditableSliceForEmptiness\", { enumerable: !0, get: function() {\n    return t.checkContenteditableSliceForEmptiness;\n  } });\n})(Pe);\nvar rt = {};\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.getContenteditableSlice = void 0;\n  var t = F;\n  Object.defineProperty(e, \"getContenteditableSlice\", { enumerable: !0, get: function() {\n    return t.getContenteditableSlice;\n  } });\n})(rt);\nvar it = {}, je = {};\nObject.defineProperty(je, \"__esModule\", { value: !0 });\nje.focus = Vn;\nvar Gn = c;\nfunction Vn(e, t) {\n  var n, r;\n  if (t === void 0 && (t = !0), (0, Gn.isNativeInput)(e)) {\n    e.focus();\n    var i = t ? 0 : e.value.length;\n    e.setSelectionRange(i, i);\n  } else {\n    var a = document.createRange(), l = window.getSelection();\n    if (!l)\n      return;\n    var s = function(g, w) {\n      w === void 0 && (w = !1);\n      var _ = document.createTextNode(\"\");\n      w ? g.insertBefore(_, g.firstChild) : g.appendChild(_), a.setStart(_, 0), a.setEnd(_, 0);\n    }, o = function(g) {\n      return g != null;\n    }, d = e.childNodes, u = t ? d[0] : d[d.length - 1];\n    if (o(u)) {\n      for (; o(u) && u.nodeType !== Node.TEXT_NODE; )\n        u = t ? u.firstChild : u.lastChild;\n      if (o(u) && u.nodeType === Node.TEXT_NODE) {\n        var p = (r = (n = u.textContent) === null || n === void 0 ? void 0 : n.length) !== null && r !== void 0 ? r : 0, i = t ? 0 : p;\n        a.setStart(u, i), a.setEnd(u, i);\n      } else\n        s(e, t);\n    } else\n      s(e);\n    l.removeAllRanges(), l.addRange(a);\n  }\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.focus = void 0;\n  var t = je;\n  Object.defineProperty(e, \"focus\", { enumerable: !0, get: function() {\n    return t.focus;\n  } });\n})(it);\nvar Te = {}, R = {};\nObject.defineProperty(R, \"__esModule\", { value: !0 });\nR.getCaretNodeAndOffset = Yn;\nfunction Yn() {\n  var e = window.getSelection();\n  if (e === null)\n    return [null, 0];\n  var t = e.focusNode, n = e.focusOffset;\n  return t === null ? [null, 0] : (t.nodeType !== Node.TEXT_NODE && t.childNodes.length > 0 && (t.childNodes[n] !== void 0 ? (t = t.childNodes[n], n = 0) : (t = t.childNodes[n - 1], t.textContent !== null && (n = t.textContent.length))), [t, n]);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.getCaretNodeAndOffset = void 0;\n  var t = R;\n  Object.defineProperty(e, \"getCaretNodeAndOffset\", { enumerable: !0, get: function() {\n    return t.getCaretNodeAndOffset;\n  } });\n})(Te);\nvar at = {}, q = {};\nObject.defineProperty(q, \"__esModule\", { value: !0 });\nq.getRange = Jn;\nfunction Jn() {\n  var e = window.getSelection();\n  return e && e.rangeCount ? e.getRangeAt(0) : null;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.getRange = void 0;\n  var t = q;\n  Object.defineProperty(e, \"getRange\", { enumerable: !0, get: function() {\n    return t.getRange;\n  } });\n})(at);\nvar lt = {}, Le = {};\nObject.defineProperty(Le, \"__esModule\", { value: !0 });\nLe.isCaretAtEndOfInput = xn;\nvar De = c, Qn = Te, Zn = Pe;\nfunction xn(e) {\n  var t = (0, De.getDeepestNode)(e, !0);\n  if (t === null)\n    return !0;\n  if ((0, De.isNativeInput)(t))\n    return t.selectionEnd === t.value.length;\n  var n = (0, Qn.getCaretNodeAndOffset)(), r = n[0], i = n[1];\n  return r === null ? !1 : (0, Zn.checkContenteditableSliceForEmptiness)(e, r, i, \"right\");\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isCaretAtEndOfInput = void 0;\n  var t = Le;\n  Object.defineProperty(e, \"isCaretAtEndOfInput\", { enumerable: !0, get: function() {\n    return t.isCaretAtEndOfInput;\n  } });\n})(lt);\nvar st = {}, Me = {};\nObject.defineProperty(Me, \"__esModule\", { value: !0 });\nMe.isCaretAtStartOfInput = nr;\nvar L = c, er = R, tr = H;\nfunction nr(e) {\n  var t = (0, L.getDeepestNode)(e);\n  if (t === null || (0, L.isEmpty)(e))\n    return !0;\n  if ((0, L.isNativeInput)(t))\n    return t.selectionEnd === 0;\n  if ((0, L.isEmpty)(e))\n    return !0;\n  var n = (0, er.getCaretNodeAndOffset)(), r = n[0], i = n[1];\n  return r === null ? !1 : (0, tr.checkContenteditableSliceForEmptiness)(e, r, i, \"left\");\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isCaretAtStartOfInput = void 0;\n  var t = Me;\n  Object.defineProperty(e, \"isCaretAtStartOfInput\", { enumerable: !0, get: function() {\n    return t.isCaretAtStartOfInput;\n  } });\n})(st);\nvar ot = {}, Ne = {};\nObject.defineProperty(Ne, \"__esModule\", { value: !0 });\nNe.save = ar;\nvar rr = c, ir = q;\nfunction ar() {\n  var e = (0, ir.getRange)(), t = (0, rr.make)(\"span\");\n  if (t.id = \"cursor\", t.hidden = !0, !!e)\n    return e.insertNode(t), function() {\n      var r = window.getSelection();\n      r && (e.setStartAfter(t), e.setEndAfter(t), r.removeAllRanges(), r.addRange(e), setTimeout(function() {\n        t.remove();\n      }, 150));\n    };\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.save = void 0;\n  var t = Ne;\n  Object.defineProperty(e, \"save\", { enumerable: !0, get: function() {\n    return t.save;\n  } });\n})(ot);\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.save = e.isCaretAtStartOfInput = e.isCaretAtEndOfInput = e.getRange = e.getCaretNodeAndOffset = e.focus = e.getContenteditableSlice = e.checkContenteditableSliceForEmptiness = void 0;\n  var t = Pe;\n  Object.defineProperty(e, \"checkContenteditableSliceForEmptiness\", { enumerable: !0, get: function() {\n    return t.checkContenteditableSliceForEmptiness;\n  } });\n  var n = rt;\n  Object.defineProperty(e, \"getContenteditableSlice\", { enumerable: !0, get: function() {\n    return n.getContenteditableSlice;\n  } });\n  var r = it;\n  Object.defineProperty(e, \"focus\", { enumerable: !0, get: function() {\n    return r.focus;\n  } });\n  var i = Te;\n  Object.defineProperty(e, \"getCaretNodeAndOffset\", { enumerable: !0, get: function() {\n    return i.getCaretNodeAndOffset;\n  } });\n  var a = at;\n  Object.defineProperty(e, \"getRange\", { enumerable: !0, get: function() {\n    return a.getRange;\n  } });\n  var l = lt;\n  Object.defineProperty(e, \"isCaretAtEndOfInput\", { enumerable: !0, get: function() {\n    return l.isCaretAtEndOfInput;\n  } });\n  var s = st;\n  Object.defineProperty(e, \"isCaretAtStartOfInput\", { enumerable: !0, get: function() {\n    return s.isCaretAtStartOfInput;\n  } });\n  var o = ot;\n  Object.defineProperty(e, \"save\", { enumerable: !0, get: function() {\n    return o.save;\n  } });\n})(j);\nclass f {\n  /**\n   * Getter for all CSS classes used in unordered list rendering\n   */\n  static get CSS() {\n    return {\n      ...h,\n      checklist: `${m}-checklist`,\n      itemChecked: `${m}__checkbox--checked`,\n      noHover: `${m}__checkbox--no-hover`,\n      checkbox: `${m}__checkbox-check`,\n      checkboxContainer: `${m}__checkbox`\n    };\n  }\n  /**\n   * Assign passed readonly mode and config to relevant class properties\n   * @param readonly - read-only mode flag\n   * @param config - user config for Tool\n   */\n  constructor(t, n) {\n    this.config = n, this.readOnly = t;\n  }\n  /**\n   * Renders ul wrapper for list\n   * @param isRoot - boolean variable that represents level of the wrappre (root or childList)\n   * @returns - created html ul element\n   */\n  renderWrapper(t) {\n    let n;\n    return t === !0 ? (n = c.make(\"ul\", [f.CSS.wrapper, f.CSS.checklist]), n.addEventListener(\"click\", (r) => {\n      const i = r.target;\n      if (i) {\n        const a = i.closest(`.${f.CSS.checkboxContainer}`);\n        a && a.contains(i) && this.toggleCheckbox(a);\n      }\n    })) : n = c.make(\"ul\", [f.CSS.checklist, f.CSS.itemChildren]), n;\n  }\n  /**\n   * Redners list item element\n   * @param content - content used in list item rendering\n   * @param meta - meta of the list item used in rendering of the checklist\n   * @returns - created html list item element\n   */\n  renderItem(t, n) {\n    const r = c.make(\"li\", [f.CSS.item, f.CSS.item]), i = c.make(\"div\", f.CSS.itemContent, {\n      innerHTML: t,\n      contentEditable: (!this.readOnly).toString()\n    }), a = c.make(\"span\", f.CSS.checkbox), l = c.make(\"div\", f.CSS.checkboxContainer);\n    return n.checked === !0 && l.classList.add(f.CSS.itemChecked), a.innerHTML = Ct, l.appendChild(a), r.appendChild(l), r.appendChild(i), r;\n  }\n  /**\n   * Return the item content\n   * @param item - item wrapper (<li>)\n   * @returns - item content string\n   */\n  getItemContent(t) {\n    const n = t.querySelector(`.${f.CSS.itemContent}`);\n    return !n || c.isEmpty(n) ? \"\" : n.innerHTML;\n  }\n  /**\n   * Return meta object of certain element\n   * @param item - will be returned meta information of this item\n   * @returns Item meta object\n   */\n  getItemMeta(t) {\n    const n = t.querySelector(`.${f.CSS.checkboxContainer}`);\n    return {\n      checked: n ? n.classList.contains(f.CSS.itemChecked) : !1\n    };\n  }\n  /**\n   * Returns default item meta used on creation of the new item\n   */\n  composeDefaultMeta() {\n    return { checked: !1 };\n  }\n  /**\n   * Toggle checklist item state\n   * @param checkbox - checkbox element to be toggled\n   */\n  toggleCheckbox(t) {\n    t.classList.toggle(f.CSS.itemChecked), t.classList.add(f.CSS.noHover), t.addEventListener(\"mouseleave\", () => this.removeSpecialHoverBehavior(t), { once: !0 });\n  }\n  /**\n   * Removes class responsible for special hover behavior on an item\n   * @param el - item wrapper\n   */\n  removeSpecialHoverBehavior(t) {\n    t.classList.remove(f.CSS.noHover);\n  }\n}\nfunction U(e, t = \"after\") {\n  const n = [];\n  let r;\n  function i(a) {\n    switch (t) {\n      case \"after\":\n        return a.nextElementSibling;\n      case \"before\":\n        return a.previousElementSibling;\n    }\n  }\n  for (r = i(e); r !== null; )\n    n.push(r), r = i(r);\n  return n.length !== 0 ? n : null;\n}\nfunction y(e, t = !0) {\n  let n = e;\n  return e.classList.contains(h.item) && (n = e.querySelector(`.${h.itemChildren}`)), n === null ? [] : t ? Array.from(n.querySelectorAll(`:scope > .${h.item}`)) : Array.from(n.querySelectorAll(`.${h.item}`));\n}\nfunction lr(e) {\n  return e.nextElementSibling === null;\n}\nfunction sr(e) {\n  return e.querySelector(`.${h.itemChildren}`) !== null;\n}\nfunction C(e) {\n  return e.querySelector(`.${h.itemChildren}`);\n}\nfunction K(e) {\n  let t = e;\n  e.classList.contains(h.item) && (t = C(e)), t !== null && y(t).length === 0 && t.remove();\n}\nfunction N(e) {\n  return e.querySelector(`.${h.itemContent}`);\n}\nfunction E(e, t = !0) {\n  const n = N(e);\n  n && j.focus(n, t);\n}\nclass z {\n  /**\n   * Getter method to get current item\n   * @returns current list item or null if caret position is not undefined\n   */\n  get currentItem() {\n    const t = window.getSelection();\n    if (!t)\n      return null;\n    let n = t.anchorNode;\n    return !n || (O(n) || (n = n.parentNode), !n) || !O(n) ? null : n.closest(`.${h.item}`);\n  }\n  /**\n   * Method that returns nesting level of the current item, null if there is no selection\n   */\n  get currentItemLevel() {\n    const t = this.currentItem;\n    if (t === null)\n      return null;\n    let n = t.parentNode, r = 0;\n    for (; n !== null && n !== this.listWrapper; )\n      O(n) && n.classList.contains(h.item) && (r += 1), n = n.parentNode;\n    return r + 1;\n  }\n  /**\n   * Assign all passed params and renderer to relevant class properties\n   * @param params - tool constructor options\n   * @param params.data - previously saved data\n   * @param params.config - user config for Tool\n   * @param params.api - Editor.js API\n   * @param params.readOnly - read-only mode flag\n   * @param renderer - renderer instance initialized in tool class\n   */\n  constructor({ data: t, config: n, api: r, readOnly: i, block: a }, l) {\n    this.config = n, this.data = t, this.readOnly = i, this.api = r, this.block = a, this.renderer = l;\n  }\n  /**\n   * Function that is responsible for rendering list with contents\n   * @returns Filled with content wrapper element of the list\n   */\n  render() {\n    return this.listWrapper = this.renderer.renderWrapper(!0), this.data.items.length ? this.appendItems(this.data.items, this.listWrapper) : this.appendItems(\n      [\n        {\n          content: \"\",\n          meta: {},\n          items: []\n        }\n      ],\n      this.listWrapper\n    ), this.readOnly || this.listWrapper.addEventListener(\n      \"keydown\",\n      (t) => {\n        switch (t.key) {\n          case \"Enter\":\n            t.shiftKey || this.enterPressed(t);\n            break;\n          case \"Backspace\":\n            this.backspace(t);\n            break;\n          case \"Tab\":\n            t.shiftKey ? this.shiftTab(t) : this.addTab(t);\n            break;\n        }\n      },\n      !1\n    ), \"start\" in this.data.meta && this.data.meta.start !== void 0 && this.changeStartWith(this.data.meta.start), \"counterType\" in this.data.meta && this.data.meta.counterType !== void 0 && this.changeCounters(this.data.meta.counterType), this.listWrapper;\n  }\n  /**\n   * Function that is responsible for list content saving\n   * @param wrapper - optional argument wrapper\n   * @returns whole list saved data if wrapper not passes, otherwise will return data of the passed wrapper\n   */\n  save(t) {\n    const n = t ?? this.listWrapper, r = (l) => y(l).map((o) => {\n      const d = C(o), u = this.renderer.getItemContent(o), p = this.renderer.getItemMeta(o), g = d ? r(d) : [];\n      return {\n        content: u,\n        meta: p,\n        items: g\n      };\n    }), i = n ? r(n) : [];\n    let a = {\n      style: this.data.style,\n      meta: {},\n      items: i\n    };\n    return this.data.style === \"ordered\" && (a.meta = {\n      start: this.data.meta.start,\n      counterType: this.data.meta.counterType\n    }), a;\n  }\n  /**\n   * On paste sanitzation config. Allow only tags that are allowed in the Tool.\n   * @returns - config that determines tags supposted by paste handler\n   * @todo - refactor and move to list instance\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"OL\", \"UL\", \"LI\"]\n    };\n  }\n  /**\n   * Method that specified hot to merge two List blocks.\n   * Called by Editor.js by backspace at the beginning of the Block\n   *\n   * Content of the first item of the next List would be merged with deepest item in current list\n   * Other items of the next List would be appended to the current list without any changes in nesting levels\n   * @param data - data of the second list to be merged with current\n   */\n  merge(t) {\n    const n = this.block.holder.querySelectorAll(`.${h.item}`), r = n[n.length - 1], i = N(r);\n    if (r === null || i === null || (i.insertAdjacentHTML(\"beforeend\", t.items[0].content), this.listWrapper === void 0))\n      return;\n    const a = y(this.listWrapper);\n    if (a.length === 0)\n      return;\n    const l = a[a.length - 1];\n    let s = C(l);\n    const o = t.items.shift();\n    o !== void 0 && (o.items.length !== 0 && (s === null && (s = this.renderer.renderWrapper(!1)), this.appendItems(o.items, s)), t.items.length > 0 && this.appendItems(t.items, this.listWrapper));\n  }\n  /**\n   * On paste callback that is fired from Editor.\n   * @param event - event with pasted data\n   * @todo - refactor and move to list instance\n   */\n  onPaste(t) {\n    const n = t.detail.data;\n    this.data = this.pasteHandler(n);\n    const r = this.listWrapper;\n    r && r.parentNode && r.parentNode.replaceChild(this.render(), r);\n  }\n  /**\n   * Handle UL, OL and LI tags paste and returns List data\n   * @param element - html element that contains whole list\n   * @todo - refactor and move to list instance\n   */\n  pasteHandler(t) {\n    const { tagName: n } = t;\n    let r = \"unordered\", i;\n    switch (n) {\n      case \"OL\":\n        r = \"ordered\", i = \"ol\";\n        break;\n      case \"UL\":\n      case \"LI\":\n        r = \"unordered\", i = \"ul\";\n    }\n    const a = {\n      style: r,\n      meta: {},\n      items: []\n    };\n    r === \"ordered\" && (this.data.meta.counterType = \"numeric\", this.data.meta.start = 1);\n    const l = (s) => Array.from(s.querySelectorAll(\":scope > li\")).map((d) => {\n      const u = d.querySelector(`:scope > ${i}`), p = u ? l(u) : [];\n      return {\n        content: d.innerHTML ?? \"\",\n        meta: {},\n        items: p\n      };\n    });\n    return a.items = l(t), a;\n  }\n  /**\n   * Changes ordered list start property value\n   * @param index - new value of the start property\n   */\n  changeStartWith(t) {\n    this.listWrapper.style.setProperty(\"counter-reset\", `item ${t - 1}`), this.data.meta.start = t;\n  }\n  /**\n   * Changes ordered list counterType property value\n   * @param counterType - new value of the counterType value\n   */\n  changeCounters(t) {\n    this.listWrapper.style.setProperty(\"--list-counter-type\", t), this.data.meta.counterType = t;\n  }\n  /**\n   * Handles Enter keypress\n   * @param event - keydown\n   */\n  enterPressed(t) {\n    var s;\n    const n = this.currentItem;\n    if (t.stopPropagation(), t.preventDefault(), t.isComposing || n === null)\n      return;\n    const r = ((s = this.renderer) == null ? void 0 : s.getItemContent(n).trim().length) === 0, i = n.parentNode === this.listWrapper, a = n.previousElementSibling === null, l = this.api.blocks.getCurrentBlockIndex();\n    if (i && r)\n      if (lr(n) && !sr(n)) {\n        a ? this.convertItemToDefaultBlock(l, !0) : this.convertItemToDefaultBlock();\n        return;\n      } else {\n        this.splitList(n);\n        return;\n      }\n    else if (r) {\n      this.unshiftItem(n);\n      return;\n    } else\n      this.splitItem(n);\n  }\n  /**\n   * Handle backspace\n   * @param event - keydown\n   */\n  backspace(t) {\n    var r;\n    const n = this.currentItem;\n    if (n !== null && j.isCaretAtStartOfInput(n) && ((r = window.getSelection()) == null ? void 0 : r.isCollapsed) !== !1) {\n      if (t.stopPropagation(), n.parentNode === this.listWrapper && n.previousElementSibling === null) {\n        this.convertFirstItemToDefaultBlock();\n        return;\n      }\n      t.preventDefault(), this.mergeItemWithPrevious(n);\n    }\n  }\n  /**\n   * Reduce indentation for current item\n   * @param event - keydown\n   */\n  shiftTab(t) {\n    t.stopPropagation(), t.preventDefault(), this.currentItem !== null && this.unshiftItem(this.currentItem);\n  }\n  /**\n   * Decrease indentation of the passed item\n   * @param item - list item to be unshifted\n   */\n  unshiftItem(t) {\n    if (!t.parentNode || !O(t.parentNode))\n      return;\n    const n = t.parentNode.closest(`.${h.item}`);\n    if (!n)\n      return;\n    let r = C(t);\n    if (t.parentElement === null)\n      return;\n    const i = U(t);\n    i !== null && (r === null && (r = this.renderer.renderWrapper(!1)), i.forEach((a) => {\n      r.appendChild(a);\n    }), t.appendChild(r)), n.after(t), E(t, !1), K(n);\n  }\n  /**\n   * Method that is used for list splitting and moving trailing items to the new separated list\n   * @param item - current item html element\n   */\n  splitList(t) {\n    const n = y(t), r = this.block, i = this.api.blocks.getCurrentBlockIndex();\n    if (n.length !== 0) {\n      const o = n[0];\n      this.unshiftItem(o), E(t, !1);\n    }\n    if (t.previousElementSibling === null && t.parentNode === this.listWrapper) {\n      this.convertItemToDefaultBlock(i);\n      return;\n    }\n    const a = U(t);\n    if (a === null)\n      return;\n    const l = this.renderer.renderWrapper(!0);\n    a.forEach((o) => {\n      l.appendChild(o);\n    });\n    const s = this.save(l);\n    s.meta.start = this.data.style == \"ordered\" ? 1 : void 0, this.api.blocks.insert(r == null ? void 0 : r.name, s, this.config, i + 1), this.convertItemToDefaultBlock(i + 1), l.remove();\n  }\n  /**\n   * Method that is used for splitting item content and moving trailing content to the new sibling item\n   * @param currentItem - current item html element\n   */\n  splitItem(t) {\n    const [n, r] = j.getCaretNodeAndOffset();\n    if (n === null)\n      return;\n    const i = N(t);\n    let a;\n    i === null ? a = \"\" : a = j.getContenteditableSlice(i, n, r, \"right\", !0);\n    const l = C(t), s = this.renderItem(a);\n    t == null || t.after(s), l && s.appendChild(l), E(s);\n  }\n  /**\n   * Method that is used for merging current item with previous one\n   * Content of the current item would be appended to the previous item\n   * Current item children would not change nesting level\n   * @param item - current item html element\n   */\n  mergeItemWithPrevious(t) {\n    const n = t.previousElementSibling, r = t.parentNode;\n    if (r === null || !O(r))\n      return;\n    const i = r.closest(`.${h.item}`);\n    if (!n && !i || n && !O(n))\n      return;\n    let a;\n    if (n) {\n      const p = y(n, !1);\n      p.length !== 0 && p.length !== 0 ? a = p[p.length - 1] : a = n;\n    } else\n      a = i;\n    const l = this.renderer.getItemContent(t);\n    if (!a)\n      return;\n    E(a, !1);\n    const s = N(a);\n    if (s === null)\n      return;\n    s.insertAdjacentHTML(\"beforeend\", l);\n    const o = y(t);\n    if (o.length === 0) {\n      t.remove(), K(a);\n      return;\n    }\n    const d = n || i, u = C(d) ?? this.renderer.renderWrapper(!1);\n    n ? o.forEach((p) => {\n      u.appendChild(p);\n    }) : o.forEach((p) => {\n      u.prepend(p);\n    }), C(d) === null && a.appendChild(u), t.remove();\n  }\n  /**\n   * Add indentation to current item\n   * @param event - keydown\n   */\n  addTab(t) {\n    var a;\n    t.stopPropagation(), t.preventDefault();\n    const n = this.currentItem;\n    if (!n)\n      return;\n    if (((a = this.config) == null ? void 0 : a.maxLevel) !== void 0) {\n      const l = this.currentItemLevel;\n      if (l !== null && l === this.config.maxLevel)\n        return;\n    }\n    const r = n.previousSibling;\n    if (r === null || !O(r))\n      return;\n    const i = C(r);\n    if (i)\n      i.appendChild(n), y(n).forEach((s) => {\n        i.appendChild(s);\n      });\n    else {\n      const l = this.renderer.renderWrapper(!1);\n      l.appendChild(n), y(n).forEach((o) => {\n        l.appendChild(o);\n      }), r.appendChild(l);\n    }\n    K(n), E(n, !1);\n  }\n  /**\n   * Convert current item to default block with passed index\n   * @param newBloxkIndex - optional parameter represents index, where would be inseted default block\n   * @param removeList - optional parameter, that represents condition, if List should be removed\n   */\n  convertItemToDefaultBlock(t, n) {\n    let r;\n    const i = this.currentItem, a = i !== null ? this.renderer.getItemContent(i) : \"\";\n    n === !0 && this.api.blocks.delete(), t !== void 0 ? r = this.api.blocks.insert(void 0, { text: a }, void 0, t) : r = this.api.blocks.insert(), i == null || i.remove(), this.api.caret.setToBlock(r, \"start\");\n  }\n  /**\n   * Convert first item of the list to default block\n   * This method could be called when backspace button pressed at start of the first item of the list\n   * First item of the list would be converted to the paragraph and first item children would be unshifted\n   */\n  convertFirstItemToDefaultBlock() {\n    const t = this.currentItem;\n    if (t === null)\n      return;\n    const n = y(t);\n    if (n.length !== 0) {\n      const l = n[0];\n      this.unshiftItem(l), E(t);\n    }\n    const r = U(t), i = this.api.blocks.getCurrentBlockIndex(), a = r === null;\n    this.convertItemToDefaultBlock(i, a);\n  }\n  /**\n   * Method that calls render function of the renderer with a necessary item meta cast\n   * @param itemContent - content to be rendered in new item\n   * @param meta - meta used in list item rendering\n   * @returns html element of the rendered item\n   */\n  renderItem(t, n) {\n    const r = n ?? this.renderer.composeDefaultMeta();\n    switch (!0) {\n      case this.renderer instanceof v:\n        return this.renderer.renderItem(t, r);\n      case this.renderer instanceof b:\n        return this.renderer.renderItem(t, r);\n      default:\n        return this.renderer.renderItem(t, r);\n    }\n  }\n  /**\n   * Renders children list\n   * @param items - list data used in item rendering\n   * @param parentElement - where to append passed items\n   */\n  appendItems(t, n) {\n    t.forEach((r) => {\n      var a;\n      const i = this.renderItem(r.content, r.meta);\n      if (n.appendChild(i), r.items.length) {\n        const l = (a = this.renderer) == null ? void 0 : a.renderWrapper(!1);\n        this.appendItems(r.items, l), i.appendChild(l);\n      }\n    });\n  }\n}\nconst I = {\n  wrapper: `${m}-start-with-field`,\n  input: `${m}-start-with-field__input`,\n  startWithElementWrapperInvalid: `${m}-start-with-field--invalid`\n};\nfunction or(e, { value: t, placeholder: n, attributes: r, sanitize: i }) {\n  const a = c.make(\"div\", I.wrapper), l = c.make(\"input\", I.input, {\n    placeholder: n,\n    /**\n     * Used to prevent focusing on the input by Tab key\n     * (Popover in the Toolbar lays below the blocks,\n     * so Tab in the last block will focus this hidden input if this property is not set)\n     */\n    tabIndex: -1,\n    /**\n     * Value of the start property, if it is not specified, then it is set to one\n     */\n    value: t\n  });\n  for (const s in r)\n    l.setAttribute(s, r[s]);\n  return a.appendChild(l), l.addEventListener(\"input\", () => {\n    i !== void 0 && (l.value = i(l.value));\n    const s = l.checkValidity();\n    !s && !a.classList.contains(I.startWithElementWrapperInvalid) && a.classList.add(I.startWithElementWrapperInvalid), s && a.classList.contains(I.startWithElementWrapperInvalid) && a.classList.remove(I.startWithElementWrapperInvalid), s && e(l.value);\n  }), a;\n}\nconst P = /* @__PURE__ */ new Map([\n  /**\n   * Value that represents default arabic numbers for counters\n   */\n  [\"Numeric\", \"numeric\"],\n  /**\n   * Value that represents lower roman numbers for counteres\n   */\n  [\"Lower Roman\", \"lower-roman\"],\n  /**\n   * Value that represents upper roman numbers for counters\n   */\n  [\"Upper Roman\", \"upper-roman\"],\n  /**\n   * Value that represents lower alpha characters for counters\n   */\n  [\"Lower Alpha\", \"lower-alpha\"],\n  /**\n   * Value that represents upper alpha characters for counters\n   */\n  [\"Upper Alpha\", \"upper-alpha\"]\n]), He = /* @__PURE__ */ new Map([\n  /**\n   * Value that represents Icon for Numeric counter type\n   */\n  [\"numeric\", St],\n  /**\n   * Value that represents Icon for Lower Roman counter type\n   */\n  [\"lower-roman\", Ot],\n  /**\n   * Value that represents Icon for Upper Roman counter type\n   */\n  [\"upper-roman\", kt],\n  /**\n   * Value that represents Icon for Lower Alpha counter type\n   */\n  [\"lower-alpha\", Et],\n  /**\n   * Value that represents Icon for Upper Alpha counter type\n   */\n  [\"upper-alpha\", _t]\n]);\nfunction ur(e) {\n  return e.replace(/\\D+/g, \"\");\n}\nfunction cr(e) {\n  return typeof e.items[0] == \"string\";\n}\nfunction dr(e) {\n  return !(\"meta\" in e);\n}\nfunction fr(e) {\n  return typeof e.items[0] != \"string\" && \"text\" in e.items[0] && \"checked\" in e.items[0] && typeof e.items[0].text == \"string\" && typeof e.items[0].checked == \"boolean\";\n}\nfunction pr(e) {\n  const t = [];\n  return cr(e) ? (e.items.forEach((n) => {\n    t.push({\n      content: n,\n      meta: {},\n      items: []\n    });\n  }), {\n    style: e.style,\n    meta: {},\n    items: t\n  }) : fr(e) ? (e.items.forEach((n) => {\n    t.push({\n      content: n.text,\n      meta: {\n        checked: n.checked\n      },\n      items: []\n    });\n  }), {\n    style: \"checklist\",\n    meta: {},\n    items: t\n  }) : dr(e) ? {\n    style: e.style,\n    meta: {},\n    items: e.items\n  } : structuredClone(e);\n}\nclass G {\n  /**\n   * Notify core that read-only mode is supported\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Allow to use native Enter behaviour\n   */\n  static get enableLineBreaks() {\n    return !0;\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   */\n  static get toolbox() {\n    return [\n      {\n        icon: $e,\n        title: \"Unordered List\",\n        data: {\n          style: \"unordered\"\n        }\n      },\n      {\n        icon: Be,\n        title: \"Ordered List\",\n        data: {\n          style: \"ordered\"\n        }\n      },\n      {\n        icon: Ae,\n        title: \"Checklist\",\n        data: {\n          style: \"checklist\"\n        }\n      }\n    ];\n  }\n  /**\n   * On paste sanitzation config. Allow only tags that are allowed in the Tool.\n   * @returns - paste config object used in editor\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"OL\", \"UL\", \"LI\"]\n    };\n  }\n  /**\n   * Convert from text to list with import and export list to text\n   */\n  static get conversionConfig() {\n    return {\n      export: (t) => G.joinRecursive(t),\n      import: (t, n) => ({\n        meta: {},\n        items: [\n          {\n            content: t,\n            meta: {},\n            items: []\n          }\n        ],\n        style: (n == null ? void 0 : n.defaultStyle) !== void 0 ? n.defaultStyle : \"unordered\"\n      })\n    };\n  }\n  /**\n   * Get list style name\n   */\n  get listStyle() {\n    return this.data.style || this.defaultListStyle;\n  }\n  /**\n   * Set list style\n   * @param style - new style to set\n   */\n  set listStyle(t) {\n    var r;\n    this.data.style = t, this.changeTabulatorByStyle();\n    const n = this.list.render();\n    (r = this.listElement) == null || r.replaceWith(n), this.listElement = n;\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   * @param params - tool constructor options\n   * @param params.data - previously saved data\n   * @param params.config - user config for Tool\n   * @param params.api - Editor.js API\n   * @param params.readOnly - read-only mode flag\n   */\n  constructor({ data: t, config: n, api: r, readOnly: i, block: a }) {\n    var s;\n    this.api = r, this.readOnly = i, this.config = n, this.block = a, this.defaultListStyle = ((s = this.config) == null ? void 0 : s.defaultStyle) || \"unordered\", this.defaultCounterTypes = this.config.counterTypes || Array.from(P.values());\n    const l = {\n      style: this.defaultListStyle,\n      meta: {},\n      items: []\n    };\n    this.data = Object.keys(t).length ? pr(t) : l, this.listStyle === \"ordered\" && this.data.meta.counterType === void 0 && (this.data.meta.counterType = \"numeric\"), this.changeTabulatorByStyle();\n  }\n  /**\n   * Convert from list to text for conversionConfig\n   * @param data - current data of the list\n   * @returns - string of the recursively merged contents of the items of the list\n   */\n  static joinRecursive(t) {\n    return t.items.map((n) => `${n.content} ${G.joinRecursive(n)}`).join(\"\");\n  }\n  /**\n   * Function that is responsible for content rendering\n   * @returns rendered list wrapper with all contents\n   */\n  render() {\n    return this.listElement = this.list.render(), this.listElement;\n  }\n  /**\n   * Function that is responsible for content saving\n   * @returns formatted content used in editor\n   */\n  save() {\n    return this.data = this.list.save(), this.data;\n  }\n  /**\n   * Function that is responsible for mergind two lists into one\n   * @param data - data of the next standing list, that should be merged with current\n   */\n  merge(t) {\n    this.list.merge(t);\n  }\n  /**\n   * Creates Block Tune allowing to change the list style\n   * @returns array of tune configs\n   */\n  renderSettings() {\n    const t = [\n      {\n        label: this.api.i18n.t(\"Unordered\"),\n        icon: $e,\n        closeOnActivate: !0,\n        isActive: this.listStyle == \"unordered\",\n        onActivate: () => {\n          this.listStyle = \"unordered\";\n        }\n      },\n      {\n        label: this.api.i18n.t(\"Ordered\"),\n        icon: Be,\n        closeOnActivate: !0,\n        isActive: this.listStyle == \"ordered\",\n        onActivate: () => {\n          this.listStyle = \"ordered\";\n        }\n      },\n      {\n        label: this.api.i18n.t(\"Checklist\"),\n        icon: Ae,\n        closeOnActivate: !0,\n        isActive: this.listStyle == \"checklist\",\n        onActivate: () => {\n          this.listStyle = \"checklist\";\n        }\n      }\n    ];\n    if (this.listStyle === \"ordered\") {\n      const n = or(\n        (a) => this.changeStartWith(Number(a)),\n        {\n          value: String(this.data.meta.start ?? 1),\n          placeholder: \"\",\n          attributes: {\n            required: \"true\"\n          },\n          sanitize: (a) => ur(a)\n        }\n      ), r = [\n        {\n          label: this.api.i18n.t(\"Start with\"),\n          icon: It,\n          children: {\n            items: [\n              {\n                element: n,\n                // @ts-expect-error ts(2820) can not use PopoverItem enum from editor.js types\n                type: \"html\"\n              }\n            ]\n          }\n        }\n      ], i = {\n        label: this.api.i18n.t(\"Counter type\"),\n        icon: He.get(this.data.meta.counterType),\n        children: {\n          items: []\n        }\n      };\n      P.forEach((a, l) => {\n        const s = P.get(l);\n        this.defaultCounterTypes.includes(s) && i.children.items.push({\n          title: this.api.i18n.t(l),\n          icon: He.get(s),\n          isActive: this.data.meta.counterType === P.get(l),\n          closeOnActivate: !0,\n          onActivate: () => {\n            this.changeCounters(P.get(l));\n          }\n        });\n      }), i.children.items.length > 1 && r.push(i), t.push({ type: \"separator\" }, ...r);\n    }\n    return t;\n  }\n  /**\n   * On paste callback that is fired from Editor.\n   * @param event - event with pasted data\n   */\n  onPaste(t) {\n    const { tagName: n } = t.detail.data;\n    switch (n) {\n      case \"OL\":\n        this.listStyle = \"ordered\";\n        break;\n      case \"UL\":\n      case \"LI\":\n        this.listStyle = \"unordered\";\n    }\n    this.list.onPaste(t);\n  }\n  /**\n   * Handle UL, OL and LI tags paste and returns List data\n   * @param element - html element that contains whole list\n   */\n  pasteHandler(t) {\n    return this.list.pasteHandler(t);\n  }\n  /**\n   * Changes ordered list counterType property value\n   * @param counterType - new value of the counterType value\n   */\n  changeCounters(t) {\n    var n;\n    (n = this.list) == null || n.changeCounters(t), this.data.meta.counterType = t;\n  }\n  /**\n   * Changes ordered list start property value\n   * @param index - new value of the start property\n   */\n  changeStartWith(t) {\n    var n;\n    (n = this.list) == null || n.changeStartWith(t), this.data.meta.start = t;\n  }\n  /**\n   * This method allows changing tabulator respectfully to passed style\n   */\n  changeTabulatorByStyle() {\n    switch (this.listStyle) {\n      case \"ordered\":\n        this.list = new z(\n          {\n            data: this.data,\n            readOnly: this.readOnly,\n            api: this.api,\n            config: this.config,\n            block: this.block\n          },\n          new v(this.readOnly, this.config)\n        );\n        break;\n      case \"unordered\":\n        this.list = new z(\n          {\n            data: this.data,\n            readOnly: this.readOnly,\n            api: this.api,\n            config: this.config,\n            block: this.block\n          },\n          new b(this.readOnly, this.config)\n        );\n        break;\n      case \"checklist\":\n        this.list = new z(\n          {\n            data: this.data,\n            readOnly: this.readOnly,\n            api: this.api,\n            config: this.config,\n            block: this.block\n          },\n          new f(this.readOnly, this.config)\n        );\n        break;\n    }\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL2xpc3QvZGlzdC9lZGl0b3Jqcy1saXN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsWUFBWSxhQUFhLElBQUksd0JBQXdCLHNDQUFzQyxpREFBaUQsU0FBUyxVQUFVLGFBQWEsYUFBYSxtQkFBbUIscUJBQXFCLDBCQUEwQixpQkFBaUIsa0JBQWtCLDZCQUE2QixxQkFBcUIsNEJBQTRCLHdCQUF3Qiw0QkFBNEIsc0JBQXNCLGtDQUFrQyxtQkFBbUIsdUJBQXVCLGdCQUFnQiwrQkFBK0IsYUFBYSwrQkFBK0IsNkJBQTZCLGlEQUFpRCx5QkFBeUIsYUFBYSxnQkFBZ0IscUJBQXFCLDZCQUE2QixrQ0FBa0MsYUFBYSx3QkFBd0Isc0JBQXNCLHFCQUFxQixrQkFBa0IsOEJBQThCLHVCQUF1Qix1QkFBdUIsbUJBQW1CLHlDQUF5Qyx3REFBd0Qsa0JBQWtCLG1CQUFtQiwyQ0FBMkMsWUFBWSwyQ0FBMkMsV0FBVyx5Q0FBeUMsVUFBVSxvQkFBb0Isa0VBQWtFLG1CQUFtQiwyQkFBMkIsNEJBQTRCLGFBQWEsZUFBZSx3QkFBd0IsVUFBVSw0QkFBNEIsMkJBQTJCLFVBQVUsU0FBUyxrQkFBa0Isc0JBQXNCLDJGQUEyRixXQUFXLDZCQUE2QiwrQkFBK0Isc0JBQXNCLDhHQUE4Ryx5Q0FBeUMsNENBQTRDLHVEQUF1RCxtQ0FBbUMscUNBQXFDLDJEQUEyRCxVQUFVLGdFQUFnRSx5QkFBeUIsOERBQThELFVBQVUsbUJBQW1CLHFCQUFxQiwwQkFBMEIsZUFBZSxxQkFBcUIsa0JBQWtCLGNBQWMsMkJBQTJCLDRCQUE0QixzQkFBc0IsbUNBQW1DLHFDQUFxQyxzQ0FBc0MsaUNBQWlDLFdBQVcsa0JBQWtCLE1BQU0sUUFBUSxTQUFTLE9BQU8sbUJBQW1CLHlDQUF5QyxrQkFBa0Isb0JBQW9CLG1CQUFtQiw4Q0FBOEMsMkJBQTJCLG1CQUFtQixzQ0FBc0Msa0JBQWtCLFlBQVksYUFBYSxvQ0FBb0Msd0JBQXdCLG9DQUFvQyxtQkFBbUIseUJB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QUFDdEQ7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVc7QUFDWCwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLDJDQUEyQztBQUMzQztBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsV0FBVztBQUNYLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVc7QUFDWCwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELFdBQVc7QUFDWCwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3REFBd0Q7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxFQUFFO0FBQzlDO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxNQUFNO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AZWRpdG9yanMvbGlzdC9kaXN0L2VkaXRvcmpzLWxpc3QubWpzP2EzNjkiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dHJ5e2lmKHR5cGVvZiBkb2N1bWVudDxcInVcIil7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO2UuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJy5jZHgtbGlzdHttYXJnaW46MDtwYWRkaW5nOjA7b3V0bGluZTpub25lO2Rpc3BsYXk6Z3JpZDtjb3VudGVyLXJlc2V0Oml0ZW07Z2FwOnZhcigtLXNwYWNpbmctcyk7cGFkZGluZzp2YXIoLS1zcGFjaW5nLXhzKTstLXNwYWNpbmctczogOHB4Oy0tc3BhY2luZy14czogNnB4Oy0tbGlzdC1jb3VudGVyLXR5cGU6IG51bWVyaWM7LS1yYWRpdXMtYm9yZGVyOiA1cHg7LS1jaGVja2JveC1iYWNrZ3JvdW5kOiAjZmZmOy0tY29sb3ItYm9yZGVyOiAjQzlDOUM5Oy0tY29sb3ItYmctY2hlY2tlZDogIzM2OUZGRjstLWxpbmUtaGVpZ2h0OiAxLjQ1ZW07LS1jb2xvci1iZy1jaGVja2VkLWhvdmVyOiAjMDA1OUFCOy0tY29sb3ItdGljazogI2ZmZjstLXNpemUtY2hlY2tib3g6IDEuMmVtfS5jZHgtbGlzdF9faXRlbXtsaW5lLWhlaWdodDp2YXIoLS1saW5lLWhlaWdodCk7ZGlzcGxheTpncmlkO2dyaWQtdGVtcGxhdGUtY29sdW1uczphdXRvIDFmcjtncmlkLXRlbXBsYXRlLXJvd3M6YXV0byBhdXRvO2dyaWQtdGVtcGxhdGUtYXJlYXM6XCJjaGVja2JveCBjb250ZW50XCIgXCIuIGNoaWxkXCJ9LmNkeC1saXN0X19pdGVtLWNoaWxkcmVue2Rpc3BsYXk6Z3JpZDtncmlkLWFyZWE6Y2hpbGQ7Z2FwOnZhcigtLXNwYWNpbmctcyk7cGFkZGluZy10b3A6dmFyKC0tc3BhY2luZy1zKX0uY2R4LWxpc3RfX2l0ZW0gW2NvbnRlbnRlZGl0YWJsZV17b3V0bGluZTpub25lfS5jZHgtbGlzdF9faXRlbS1jb250ZW50e3dvcmQtYnJlYWs6YnJlYWstd29yZDt3aGl0ZS1zcGFjZTpwcmUtd3JhcDtncmlkLWFyZWE6Y29udGVudDtwYWRkaW5nLWxlZnQ6dmFyKC0tc3BhY2luZy1zKX0uY2R4LWxpc3RfX2l0ZW06YmVmb3Jle2NvdW50ZXItaW5jcmVtZW50Oml0ZW07d2hpdGUtc3BhY2U6bm93cmFwfS5jZHgtbGlzdC1vcmRlcmVkIC5jZHgtbGlzdF9faXRlbTpiZWZvcmV7Y29udGVudDpjb3VudGVycyhpdGVtLFwiLlwiLHZhcigtLWxpc3QtY291bnRlci10eXBlKSkgXCIuXCJ9LmNkeC1saXN0LW9yZGVyZWR7Y291bnRlci1yZXNldDppdGVtfS5jZHgtbGlzdC11bm9yZGVyZWQgLmNkeC1saXN0X19pdGVtOmJlZm9yZXtjb250ZW50Olwi4oCiXCJ9LmNkeC1saXN0LWNoZWNrbGlzdCAuY2R4LWxpc3RfX2l0ZW06YmVmb3Jle2NvbnRlbnQ6XCJcIn0uY2R4LWxpc3RfX3NldHRpbmdzIC5jZHgtc2V0dGluZ3MtYnV0dG9ue3dpZHRoOjUwJX0uY2R4LWxpc3RfX2NoZWNrYm94e3BhZGRpbmctdG9wOmNhbGMoKHZhcigtLWxpbmUtaGVpZ2h0KSAtIHZhcigtLXNpemUtY2hlY2tib3gpKSAvIDIpO2dyaWQtYXJlYTpjaGVja2JveDt3aWR0aDp2YXIoLS1zaXplLWNoZWNrYm94KTtoZWlnaHQ6dmFyKC0tc2l6ZS1jaGVja2JveCk7ZGlzcGxheTpmbGV4O2N1cnNvcjpwb2ludGVyfS5jZHgtbGlzdF9fY2hlY2tib3ggc3Zne29wYWNpdHk6MDtoZWlnaHQ6dmFyKC0tc2l6ZS1jaGVja2JveCk7d2lkdGg6dmFyKC0tc2l6ZS1jaGVja2JveCk7bGVmdDotMXB4O3RvcDotMXB4O3Bvc2l0aW9uOmFic29sdXRlfUBtZWRpYSAoaG92ZXI6IGhvdmVyKXsuY2R4LWxpc3RfX2NoZWNrYm94Om5vdCguY2R4LWxpc3RfX2NoZWNrYm94LS1uby1ob3Zlcik6aG92ZXIgLmNkeC1saXN0X19jaGVja2JveC1jaGVjayBzdmd7b3BhY2l0eToxfX0uY2R4LWxpc3RfX2NoZWNrYm94LS1jaGVja2Vke2xpbmUtaGVpZ2h0OnZhcigtLWxpbmUtaGVpZ2h0KX1AbWVkaWEgKGhvdmVyOiBob3Zlcil7LmNkeC1saXN0X19jaGVja2JveC0tY2hlY2tlZDpub3QoLmNkeC1saXN0X19jaGVja2JveC0tY2hlY2tlZC0tbm8taG92ZXIpOmhvdmVyIC5jZHgtY2hlY2tsaXN0X19jaGVja2JveC1jaGVja3tiYWNrZ3JvdW5kOnZhcigtLWNvbG9yLWJnLWNoZWNrZWQtaG92ZXIpO2JvcmRlci1jb2xvcjp2YXIoLS1jb2xvci1iZy1jaGVja2VkLWhvdmVyKX19LmNkeC1saXN0X19jaGVja2JveC0tY2hlY2tlZCAuY2R4LWxpc3RfX2NoZWNrYm94LWNoZWNre2JhY2tncm91bmQ6dmFyKC0tY29sb3ItYmctY2hlY2tlZCk7Ym9yZGVyLWNvbG9yOnZhcigtLWNvbG9yLWJnLWNoZWNrZWQpfS5jZHgtbGlzdF9fY2hlY2tib3gtLWNoZWNrZWQgLmNkeC1saXN0X19jaGVja2JveC1jaGVjayBzdmd7b3BhY2l0eToxfS5jZHgtbGlzdF9fY2hlY2tib3gtLWNoZWNrZWQgLmNkeC1saXN0X19jaGVja2JveC1jaGVjayBzdmcgcGF0aHtzdHJva2U6dmFyKC0tY29sb3ItdGljayl9LmNkeC1saXN0X19jaGVja2JveC0tY2hlY2tlZCAuY2R4LWxpc3RfX2NoZWNrYm94LWNoZWNrOmJlZm9yZXtvcGFjaXR5OjA7dmlzaWJpbGl0eTp2aXNpYmxlO3RyYW5zZm9ybTpzY2FsZSgyLjUpfS5jZHgtbGlzdF9fY2hlY2tib3gtY2hlY2t7Y3Vyc29yOnBvaW50ZXI7ZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luOjAgYXV0bzt3aWR0aDp2YXIoLS1zaXplLWNoZWNrYm94KTtoZWlnaHQ6dmFyKC0tc2l6ZS1jaGVja2JveCk7Ym94LXNpemluZzpib3JkZXItYm94O2JvcmRlci1yYWRpdXM6dmFyKC0tcmFkaXVzLWJvcmRlcik7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1jb2xvci1ib3JkZXIpO2JhY2tncm91bmQ6dmFyKC0tY2hlY2tib3gtYmFja2dyb3VuZCl9LmNkeC1saXN0X19jaGVja2JveC1jaGVjazpiZWZvcmV7Y29udGVudDpcIlwiO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO2JvcmRlci1yYWRpdXM6MTAwJTtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWNvbG9yLWJnLWNoZWNrZWQpO3Zpc2liaWxpdHk6aGlkZGVuO3BvaW50ZXItZXZlbnRzOm5vbmU7dHJhbnNmb3JtOnNjYWxlKDEpO3RyYW5zaXRpb246dHJhbnNmb3JtIC40cyBlYXNlLW91dCxvcGFjaXR5IC40c30uY2R4LWxpc3Qtc3RhcnQtd2l0aC1maWVsZHtiYWNrZ3JvdW5kOiNGOEY4Rjg7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDIyNiwyMjYsMjI5LC4yKTtib3JkZXItcmFkaXVzOjZweDtwYWRkaW5nOjJweDtkaXNwbGF5OmdyaWQ7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOmF1dG8gYXV0byAxZnI7Z3JpZC10ZW1wbGF0ZS1yb3dzOmF1dG99LmNkeC1saXN0LXN0YXJ0LXdpdGgtZmllbGQtLWludmFsaWR7YmFja2dyb3VuZDojRkZFQ0VEO2JvcmRlcjoxcHggc29saWQgI0UxM0YzRn0uY2R4LWxpc3Qtc3RhcnQtd2l0aC1maWVsZC0taW52YWxpZCAuY2R4LWxpc3Qtc3RhcnQtd2l0aC1maWVsZF9faW5wdXR7Y29sb3I6I2UxM2YzZn0uY2R4LWxpc3Qtc3RhcnQtd2l0aC1maWVsZF9faW5wdXR7Zm9udC1zaXplOjE0cHg7b3V0bGluZTpub25lO2ZvbnQtd2VpZ2h0OjUwMDtmb250LWZhbWlseTppbmhlcml0O2JvcmRlcjowO2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7bWFyZ2luOjA7cGFkZGluZzowO2xpbmUtaGVpZ2h0OjIycHg7bWluLXdpZHRoOmNhbGMoMTAwJSAtIHZhcigtLXRvb2xib3gtYnV0dG9ucy1zaXplKSAtIHZhcigtLWljb24tbWFyZ2luLXJpZ2h0KSl9LmNkeC1saXN0LXN0YXJ0LXdpdGgtZmllbGRfX2lucHV0OjpwbGFjZWhvbGRlcntjb2xvcjp2YXIoLS1ncmF5VGV4dCk7Zm9udC13ZWlnaHQ6NTAwfScpKSxkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGUpfX1jYXRjaChjKXtjb25zb2xlLmVycm9yKFwidml0ZS1wbHVnaW4tY3NzLWluamVjdGVkLWJ5LWpzXCIsYyl9fSkoKTtcbmNvbnN0IEN0ID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk03IDEyTDEwLjQ4ODQgMTUuODM3MkMxMC41Njc3IDE1LjkyNDUgMTAuNzA1IDE1LjkyNDUgMTAuNzg0NCAxNS44MzcyTDE3IDlcIi8+PC9zdmc+JywgQWUgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTkuMiAxMkwxMS4wNTg2IDEzLjg1ODZDMTEuMTM2NyAxMy45MzY3IDExLjI2MzMgMTMuOTM2NyAxMS4zNDE0IDEzLjg1ODZMMTQuNyAxMC41XCIvPjxyZWN0IHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiIHg9XCI1XCIgeT1cIjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgcng9XCI0XCIvPjwvc3ZnPicsICRlID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxsaW5lIHgxPVwiOVwiIHgyPVwiMTlcIiB5MT1cIjdcIiB5Mj1cIjdcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48bGluZSB4MT1cIjlcIiB4Mj1cIjE5XCIgeTE9XCIxMlwiIHkyPVwiMTJcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48bGluZSB4MT1cIjlcIiB4Mj1cIjE5XCIgeTE9XCIxN1wiIHkyPVwiMTdcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNS4wMDAwMSAxN0g0Ljk5MDAyXCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk01LjAwMDAxIDEySDQuOTkwMDJcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTUuMDAwMDEgN0g0Ljk5MDAyXCIvPjwvc3ZnPicsIEJlID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxsaW5lIHgxPVwiMTJcIiB4Mj1cIjE5XCIgeTE9XCI3XCIgeTI9XCI3XCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIi8+PGxpbmUgeDE9XCIxMlwiIHgyPVwiMTlcIiB5MT1cIjEyXCIgeTI9XCIxMlwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIvPjxsaW5lIHgxPVwiMTJcIiB4Mj1cIjE5XCIgeTE9XCIxN1wiIHkyPVwiMTdcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiLz48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNNy43OTk5OSAxNEw3Ljc5OTk5IDcuMjEzNUM3Ljc5OTk5IDcuMTI4NzIgNy43MDExIDcuMDgyNCA3LjYzNTk3IDcuMTM2NjhMNC43OTk5OSA5LjVcIi8+PC9zdmc+JywgU3QgPSAnPHN2ZyB3aWR0aD1cIjIwXCIgaGVpZ2h0PVwiMjBcIiB2aWV3Qm94PVwiMCAwIDIwIDIwXCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk0xMCAxNC4yTDEwIDcuNDEzNUMxMCA3LjMyODcyIDkuOTAxMTEgNy4yODI0MSA5LjgzNTk4IDcuMzM2NjhMNyA5LjdcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZS13aWR0aD1cIjEuNlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIi8+PHBhdGggZD1cIk0xMy4yMDg3IDE0LjJIMTMuMlwiIHN0cm9rZT1cImJsYWNrXCIgc3Ryb2tlLXdpZHRoPVwiMS42XCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiLz48L3N2Zz4nLCBPdCA9ICc8c3ZnIHdpZHRoPVwiMjBcIiBoZWlnaHQ9XCIyMFwiIHZpZXdCb3g9XCIwIDAgMjAgMjBcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTEzLjIwODcgMTQuMkgxMy4yXCIgc3Ryb2tlPVwiYmxhY2tcIiBzdHJva2Utd2lkdGg9XCIxLjZcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIvPjxwYXRoIGQ9XCJNMTAgMTQuMkwxMCA5LjVcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZS13aWR0aD1cIjEuNlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIi8+PHBhdGggZD1cIk0xMCA3LjAxTDEwIDdcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZS13aWR0aD1cIjEuOFwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIi8+PC9zdmc+Jywga3QgPSAnPHN2ZyB3aWR0aD1cIjIwXCIgaGVpZ2h0PVwiMjBcIiB2aWV3Qm94PVwiMCAwIDIwIDIwXCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk0xMy4yMDg3IDE0LjJIMTMuMlwiIHN0cm9rZT1cImJsYWNrXCIgc3Ryb2tlLXdpZHRoPVwiMS42XCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiLz48cGF0aCBkPVwiTTEwIDE0LjJMMTAgNy4yXCIgc3Ryb2tlPVwiYmxhY2tcIiBzdHJva2Utd2lkdGg9XCIxLjZcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIvPjwvc3ZnPicsIF90ID0gJzxzdmcgd2lkdGg9XCIyMFwiIGhlaWdodD1cIjIwXCIgdmlld0JveD1cIjAgMCAyMCAyMFwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTYuMDA4NyAxNC4ySDE2XCIgc3Ryb2tlPVwiYmxhY2tcIiBzdHJva2Utd2lkdGg9XCIxLjZcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIvPjxwYXRoIGQ9XCJNNyAxNC4yTDcuNzg4NjUgMTJNMTMgMTQuMkwxMi4xMzc3IDEyTTcuNzg4NjUgMTJDNy43ODg2NSAxMiA5LjY4MzYyIDcgMTAgN0MxMC4zMDY1IDcgMTIuMTM3NyAxMiAxMi4xMzc3IDEyTTcuNzg4NjUgMTJMMTIuMTM3NyAxMlwiIHN0cm9rZT1cImJsYWNrXCIgc3Ryb2tlLXdpZHRoPVwiMS42XCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiLz48L3N2Zz4nLCBFdCA9ICc8c3ZnIHdpZHRoPVwiMjBcIiBoZWlnaHQ9XCIyMFwiIHZpZXdCb3g9XCIwIDAgMjAgMjBcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTE0LjIwODcgMTQuMkgxNC4yXCIgc3Ryb2tlPVwiYmxhY2tcIiBzdHJva2Utd2lkdGg9XCIxLjZcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIvPjxwYXRoIGQ9XCJNMTEuNSAxNC41QzExLjUgMTQuNSAxMSAxMy4yODEgMTEgMTIuNU03IDkuNUM3IDkuNSA3LjUgOC41IDkgOC41QzEwLjUgOC41IDExIDkuNSAxMSAxMC41TDExIDExLjVNMTEgMTEuNUwxMSAxMi41TTExIDExLjVDMTEgMTEuNSA3IDExIDcgMTNDNyAxNS4zMDMxIDExIDE1IDExIDEyLjVcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZS13aWR0aD1cIjEuNlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIi8+PC9zdmc+JywgSXQgPSAnPHN2ZyB3aWR0aD1cIjIwXCIgaGVpZ2h0PVwiMjBcIiB2aWV3Qm94PVwiMCAwIDIwIDIwXCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk04IDE0LjJMOCA3LjQxMzVDOCA3LjMyODcyIDcuOTAxMTEgNy4yODI0MSA3LjgzNTk4IDcuMzM2NjhMNSA5LjdcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZS13aWR0aD1cIjEuNlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIi8+PHBhdGggZD1cIk0xNCAxM0wxNi40MTY3IDEwLjc3NzhNMTYuNDE2NyAxMC43Nzc4TDE0IDguNU0xNi40MTY3IDEwLjc3NzhIMTEuNjU2MlwiIHN0cm9rZT1cImJsYWNrXCIgc3Ryb2tlLXdpZHRoPVwiMS42XCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIvPjwvc3ZnPic7XG52YXIgQSA9IHR5cGVvZiBnbG9iYWxUaGlzIDwgXCJ1XCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyA8IFwidVwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCA8IFwidVwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPCBcInVcIiA/IHNlbGYgOiB7fTtcbmZ1bmN0aW9uIHd0KGUpIHtcbiAgaWYgKGUuX19lc01vZHVsZSlcbiAgICByZXR1cm4gZTtcbiAgdmFyIHQgPSBlLmRlZmF1bHQ7XG4gIGlmICh0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgbiA9IGZ1bmN0aW9uIHIoKSB7XG4gICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIHIgPyBSZWZsZWN0LmNvbnN0cnVjdCh0LCBhcmd1bWVudHMsIHRoaXMuY29uc3RydWN0b3IpIDogdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgbi5wcm90b3R5cGUgPSB0LnByb3RvdHlwZTtcbiAgfSBlbHNlXG4gICAgbiA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgdmFyIGkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCByLCBpLmdldCA/IGkgOiB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBlW3JdO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSwgbjtcbn1cbnZhciBjID0ge30sIFYgPSB7fSwgWSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcblkuYWxsSW5wdXRzU2VsZWN0b3IgPSBQdDtcbmZ1bmN0aW9uIFB0KCkge1xuICB2YXIgZSA9IFtcInRleHRcIiwgXCJwYXNzd29yZFwiLCBcImVtYWlsXCIsIFwibnVtYmVyXCIsIFwic2VhcmNoXCIsIFwidGVsXCIsIFwidXJsXCJdO1xuICByZXR1cm4gXCJbY29udGVudGVkaXRhYmxlPXRydWVdLCB0ZXh0YXJlYSwgaW5wdXQ6bm90KFt0eXBlXSksIFwiICsgZS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHJldHVybiAnaW5wdXRbdHlwZT1cIicuY29uY2F0KHQsICdcIl0nKTtcbiAgfSkuam9pbihcIiwgXCIpO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5hbGxJbnB1dHNTZWxlY3RvciA9IHZvaWQgMDtcbiAgdmFyIHQgPSBZO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJhbGxJbnB1dHNTZWxlY3RvclwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmFsbElucHV0c1NlbGVjdG9yO1xuICB9IH0pO1xufSkoVik7XG52YXIgayA9IHt9LCBKID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuSi5pc05hdGl2ZUlucHV0ID0ganQ7XG5mdW5jdGlvbiBqdChlKSB7XG4gIHZhciB0ID0gW1xuICAgIFwiSU5QVVRcIixcbiAgICBcIlRFWFRBUkVBXCJcbiAgXTtcbiAgcmV0dXJuIGUgJiYgZS50YWdOYW1lID8gdC5pbmNsdWRlcyhlLnRhZ05hbWUpIDogITE7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmlzTmF0aXZlSW5wdXQgPSB2b2lkIDA7XG4gIHZhciB0ID0gSjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNOYXRpdmVJbnB1dFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmlzTmF0aXZlSW5wdXQ7XG4gIH0gfSk7XG59KShrKTtcbnZhciBGZSA9IHt9LCBRID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuUS5hcHBlbmQgPSBUdDtcbmZ1bmN0aW9uIFR0KGUsIHQpIHtcbiAgQXJyYXkuaXNBcnJheSh0KSA/IHQuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgZS5hcHBlbmRDaGlsZChuKTtcbiAgfSkgOiBlLmFwcGVuZENoaWxkKHQpO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5hcHBlbmQgPSB2b2lkIDA7XG4gIHZhciB0ID0gUTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiYXBwZW5kXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuYXBwZW5kO1xuICB9IH0pO1xufSkoRmUpO1xudmFyIFogPSB7fSwgeCA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHgsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnguYmxvY2tFbGVtZW50cyA9IEx0O1xuZnVuY3Rpb24gTHQoKSB7XG4gIHJldHVybiBbXG4gICAgXCJhZGRyZXNzXCIsXG4gICAgXCJhcnRpY2xlXCIsXG4gICAgXCJhc2lkZVwiLFxuICAgIFwiYmxvY2txdW90ZVwiLFxuICAgIFwiY2FudmFzXCIsXG4gICAgXCJkaXZcIixcbiAgICBcImRsXCIsXG4gICAgXCJkdFwiLFxuICAgIFwiZmllbGRzZXRcIixcbiAgICBcImZpZ2NhcHRpb25cIixcbiAgICBcImZpZ3VyZVwiLFxuICAgIFwiZm9vdGVyXCIsXG4gICAgXCJmb3JtXCIsXG4gICAgXCJoMVwiLFxuICAgIFwiaDJcIixcbiAgICBcImgzXCIsXG4gICAgXCJoNFwiLFxuICAgIFwiaDVcIixcbiAgICBcImg2XCIsXG4gICAgXCJoZWFkZXJcIixcbiAgICBcImhncm91cFwiLFxuICAgIFwiaHJcIixcbiAgICBcImxpXCIsXG4gICAgXCJtYWluXCIsXG4gICAgXCJuYXZcIixcbiAgICBcIm5vc2NyaXB0XCIsXG4gICAgXCJvbFwiLFxuICAgIFwib3V0cHV0XCIsXG4gICAgXCJwXCIsXG4gICAgXCJwcmVcIixcbiAgICBcInJ1YnlcIixcbiAgICBcInNlY3Rpb25cIixcbiAgICBcInRhYmxlXCIsXG4gICAgXCJ0Ym9keVwiLFxuICAgIFwidGhlYWRcIixcbiAgICBcInRyXCIsXG4gICAgXCJ0Zm9vdFwiLFxuICAgIFwidWxcIixcbiAgICBcInZpZGVvXCJcbiAgXTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuYmxvY2tFbGVtZW50cyA9IHZvaWQgMDtcbiAgdmFyIHQgPSB4O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJibG9ja0VsZW1lbnRzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuYmxvY2tFbGVtZW50cztcbiAgfSB9KTtcbn0pKFopO1xudmFyIFJlID0ge30sIGVlID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZWUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmVlLmNhbGN1bGF0ZUJhc2VsaW5lID0gTXQ7XG5mdW5jdGlvbiBNdChlKSB7XG4gIHZhciB0ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZSksIG4gPSBwYXJzZUZsb2F0KHQuZm9udFNpemUpLCByID0gcGFyc2VGbG9hdCh0LmxpbmVIZWlnaHQpIHx8IG4gKiAxLjIsIGkgPSBwYXJzZUZsb2F0KHQucGFkZGluZ1RvcCksIGEgPSBwYXJzZUZsb2F0KHQuYm9yZGVyVG9wV2lkdGgpLCBsID0gcGFyc2VGbG9hdCh0Lm1hcmdpblRvcCksIHMgPSBuICogMC44LCBvID0gKHIgLSBuKSAvIDIsIGQgPSBsICsgYSArIGkgKyBvICsgcztcbiAgcmV0dXJuIGQ7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmNhbGN1bGF0ZUJhc2VsaW5lID0gdm9pZCAwO1xuICB2YXIgdCA9IGVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJjYWxjdWxhdGVCYXNlbGluZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmNhbGN1bGF0ZUJhc2VsaW5lO1xuICB9IH0pO1xufSkoUmUpO1xudmFyIHFlID0ge30sIHRlID0ge30sIG5lID0ge30sIHJlID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocmUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnJlLmlzQ29udGVudEVkaXRhYmxlID0gTnQ7XG5mdW5jdGlvbiBOdChlKSB7XG4gIHJldHVybiBlLmNvbnRlbnRFZGl0YWJsZSA9PT0gXCJ0cnVlXCI7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmlzQ29udGVudEVkaXRhYmxlID0gdm9pZCAwO1xuICB2YXIgdCA9IHJlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0NvbnRlbnRFZGl0YWJsZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmlzQ29udGVudEVkaXRhYmxlO1xuICB9IH0pO1xufSkobmUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHRlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG50ZS5jYW5TZXRDYXJldCA9IEJ0O1xudmFyIEF0ID0gaywgJHQgPSBuZTtcbmZ1bmN0aW9uIEJ0KGUpIHtcbiAgdmFyIHQgPSAhMDtcbiAgaWYgKCgwLCBBdC5pc05hdGl2ZUlucHV0KShlKSlcbiAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgY2FzZSBcImZpbGVcIjpcbiAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxuICAgICAgY2FzZSBcInJhZGlvXCI6XG4gICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICBjYXNlIFwic3VibWl0XCI6XG4gICAgICBjYXNlIFwiYnV0dG9uXCI6XG4gICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgIGNhc2UgXCJyZXNldFwiOlxuICAgICAgICB0ID0gITE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgZWxzZVxuICAgIHQgPSAoMCwgJHQuaXNDb250ZW50RWRpdGFibGUpKGUpO1xuICByZXR1cm4gdDtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuY2FuU2V0Q2FyZXQgPSB2b2lkIDA7XG4gIHZhciB0ID0gdGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImNhblNldENhcmV0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuY2FuU2V0Q2FyZXQ7XG4gIH0gfSk7XG59KShxZSk7XG52YXIgJCA9IHt9LCBpZSA9IHt9O1xuZnVuY3Rpb24gV3QoZSwgdCwgbikge1xuICBjb25zdCByID0gbi52YWx1ZSAhPT0gdm9pZCAwID8gXCJ2YWx1ZVwiIDogXCJnZXRcIiwgaSA9IG5bcl0sIGEgPSBgIyR7dH1DYWNoZWA7XG4gIGlmIChuW3JdID0gZnVuY3Rpb24oLi4ubCkge1xuICAgIHJldHVybiB0aGlzW2FdID09PSB2b2lkIDAgJiYgKHRoaXNbYV0gPSBpLmFwcGx5KHRoaXMsIGwpKSwgdGhpc1thXTtcbiAgfSwgciA9PT0gXCJnZXRcIiAmJiBuLnNldCkge1xuICAgIGNvbnN0IGwgPSBuLnNldDtcbiAgICBuLnNldCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIGRlbGV0ZSBlW2FdLCBsLmFwcGx5KHRoaXMsIHMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBVZSgpIHtcbiAgY29uc3QgZSA9IHtcbiAgICB3aW46ICExLFxuICAgIG1hYzogITEsXG4gICAgeDExOiAhMSxcbiAgICBsaW51eDogITFcbiAgfSwgdCA9IE9iamVjdC5rZXlzKGUpLmZpbmQoKG4pID0+IHdpbmRvdy5uYXZpZ2F0b3IuYXBwVmVyc2lvbi50b0xvd2VyQ2FzZSgpLmluZGV4T2YobikgIT09IC0xKTtcbiAgcmV0dXJuIHQgIT09IHZvaWQgMCAmJiAoZVt0XSA9ICEwKSwgZTtcbn1cbmZ1bmN0aW9uIGFlKGUpIHtcbiAgcmV0dXJuIGUgIT0gbnVsbCAmJiBlICE9PSBcIlwiICYmICh0eXBlb2YgZSAhPSBcIm9iamVjdFwiIHx8IE9iamVjdC5rZXlzKGUpLmxlbmd0aCA+IDApO1xufVxuZnVuY3Rpb24gRHQoZSkge1xuICByZXR1cm4gIWFlKGUpO1xufVxuY29uc3QgSHQgPSAoKSA9PiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgd2luZG93Lm5hdmlnYXRvciAhPT0gbnVsbCAmJiBhZSh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSAmJiAoL2lQKGFkfGhvbmV8b2QpLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0pIHx8IHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0gPT09IFwiTWFjSW50ZWxcIiAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMSk7XG5mdW5jdGlvbiBGdChlKSB7XG4gIGNvbnN0IHQgPSBVZSgpO1xuICByZXR1cm4gZSA9IGUucmVwbGFjZSgvc2hpZnQvZ2ksIFwi4oenXCIpLnJlcGxhY2UoL2JhY2tzcGFjZS9naSwgXCLijKtcIikucmVwbGFjZSgvZW50ZXIvZ2ksIFwi4o+OXCIpLnJlcGxhY2UoL3VwL2dpLCBcIuKGkVwiKS5yZXBsYWNlKC9sZWZ0L2dpLCBcIuKGklwiKS5yZXBsYWNlKC9kb3duL2dpLCBcIuKGk1wiKS5yZXBsYWNlKC9yaWdodC9naSwgXCLihpBcIikucmVwbGFjZSgvZXNjYXBlL2dpLCBcIuKOi1wiKS5yZXBsYWNlKC9pbnNlcnQvZ2ksIFwiSW5zXCIpLnJlcGxhY2UoL2RlbGV0ZS9naSwgXCLikKFcIikucmVwbGFjZSgvXFwrL2dpLCBcIitcIiksIHQubWFjID8gZSA9IGUucmVwbGFjZSgvY3RybHxjbWQvZ2ksIFwi4oyYXCIpLnJlcGxhY2UoL2FsdC9naSwgXCLijKVcIikgOiBlID0gZS5yZXBsYWNlKC9jbWQvZ2ksIFwiQ3RybFwiKS5yZXBsYWNlKC93aW5kb3dzL2dpLCBcIldJTlwiKSwgZTtcbn1cbmZ1bmN0aW9uIFJ0KGUpIHtcbiAgcmV0dXJuIGVbMF0udG9VcHBlckNhc2UoKSArIGUuc2xpY2UoMSk7XG59XG5mdW5jdGlvbiBxdChlKSB7XG4gIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB0LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiLCB0LnN0eWxlLmxlZnQgPSBcIi05OTlweFwiLCB0LnN0eWxlLmJvdHRvbSA9IFwiLTk5OXB4XCIsIHQuaW5uZXJIVE1MID0gZSwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0KTtcbiAgY29uc3QgbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgciA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGlmIChyLnNlbGVjdE5vZGUodCksIG4gPT09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvcHkgdGV4dCB0byBjbGlwYm9hcmRcIik7XG4gIG4ucmVtb3ZlQWxsUmFuZ2VzKCksIG4uYWRkUmFuZ2UociksIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiY29weVwiKSwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0KTtcbn1cbmZ1bmN0aW9uIFV0KGUsIHQsIG4pIHtcbiAgbGV0IHI7XG4gIHJldHVybiAoLi4uaSkgPT4ge1xuICAgIGNvbnN0IGEgPSB0aGlzLCBsID0gKCkgPT4ge1xuICAgICAgciA9IHZvaWQgMCwgbiAhPT0gITAgJiYgZS5hcHBseShhLCBpKTtcbiAgICB9LCBzID0gbiA9PT0gITAgJiYgciAhPT0gdm9pZCAwO1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQociksIHIgPSB3aW5kb3cuc2V0VGltZW91dChsLCB0KSwgcyAmJiBlLmFwcGx5KGEsIGkpO1xuICB9O1xufVxuZnVuY3Rpb24gUyhlKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkubWF0Y2goL1xccyhbYS16QS1aXSspLylbMV0udG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIEt0KGUpIHtcbiAgcmV0dXJuIFMoZSkgPT09IFwiYm9vbGVhblwiO1xufVxuZnVuY3Rpb24gS2UoZSkge1xuICByZXR1cm4gUyhlKSA9PT0gXCJmdW5jdGlvblwiIHx8IFMoZSkgPT09IFwiYXN5bmNmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24genQoZSkge1xuICByZXR1cm4gS2UoZSkgJiYgL15cXHMqY2xhc3NcXHMrLy50ZXN0KGUudG9TdHJpbmcoKSk7XG59XG5mdW5jdGlvbiBYdChlKSB7XG4gIHJldHVybiBTKGUpID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gTShlKSB7XG4gIHJldHVybiBTKGUpID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gR3QoZSkge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUpID09PSBlO1xufVxuZnVuY3Rpb24gVnQoZSkge1xuICByZXR1cm4gUyhlKSA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIFl0KGUpIHtcbiAgcmV0dXJuIFMoZSkgPT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBYKGUsIC4uLnQpIHtcbiAgaWYgKCF0Lmxlbmd0aClcbiAgICByZXR1cm4gZTtcbiAgY29uc3QgbiA9IHQuc2hpZnQoKTtcbiAgaWYgKE0oZSkgJiYgTShuKSlcbiAgICBmb3IgKGNvbnN0IHIgaW4gbilcbiAgICAgIE0obltyXSkgPyAoZVtyXSA9PT0gdm9pZCAwICYmIE9iamVjdC5hc3NpZ24oZSwgeyBbcl06IHt9IH0pLCBYKGVbcl0sIG5bcl0pKSA6IE9iamVjdC5hc3NpZ24oZSwgeyBbcl06IG5bcl0gfSk7XG4gIHJldHVybiBYKGUsIC4uLnQpO1xufVxuZnVuY3Rpb24gSnQoZSwgdCwgbikge1xuICBjb25zdCByID0gYMKrJHt0fcK7IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBQbGVhc2UgdXNlIHRoZSDCqyR7bn3CuyBpbnN0ZWFkLmA7XG4gIGUgJiYgY29uc29sZS53YXJuKHIpO1xufVxuZnVuY3Rpb24gUXQoZSkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgVVJMKGUpLmhyZWY7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBlLnN1YnN0cmluZygwLCAyKSA9PT0gXCIvL1wiID8gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgZSA6IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyBlO1xufVxuZnVuY3Rpb24gWnQoZSkge1xuICByZXR1cm4gZSA+IDQ3ICYmIGUgPCA1OCB8fCBlID09PSAzMiB8fCBlID09PSAxMyB8fCBlID09PSAyMjkgfHwgZSA+IDY0ICYmIGUgPCA5MSB8fCBlID4gOTUgJiYgZSA8IDExMiB8fCBlID4gMTg1ICYmIGUgPCAxOTMgfHwgZSA+IDIxOCAmJiBlIDwgMjIzO1xufVxuY29uc3QgeHQgPSB7XG4gIEJBQ0tTUEFDRTogOCxcbiAgVEFCOiA5LFxuICBFTlRFUjogMTMsXG4gIFNISUZUOiAxNixcbiAgQ1RSTDogMTcsXG4gIEFMVDogMTgsXG4gIEVTQzogMjcsXG4gIFNQQUNFOiAzMixcbiAgTEVGVDogMzcsXG4gIFVQOiAzOCxcbiAgRE9XTjogNDAsXG4gIFJJR0hUOiAzOSxcbiAgREVMRVRFOiA0NixcbiAgTUVUQTogOTEsXG4gIFNMQVNIOiAxOTFcbn0sIGVuID0ge1xuICBMRUZUOiAwLFxuICBXSEVFTDogMSxcbiAgUklHSFQ6IDIsXG4gIEJBQ0tXQVJEOiAzLFxuICBGT1JXQVJEOiA0XG59O1xuY2xhc3MgdG4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbXBsZXRlZCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgbmV3IHByb21pc2UgdG8gcXVldWVcbiAgICogQHBhcmFtIG9wZXJhdGlvbiAtIHByb21pc2Ugc2hvdWxkIGJlIGFkZGVkIHRvIHF1ZXVlXG4gICAqL1xuICBhZGQodCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgobiwgcikgPT4ge1xuICAgICAgdGhpcy5jb21wbGV0ZWQgPSB0aGlzLmNvbXBsZXRlZC50aGVuKHQpLnRoZW4obikuY2F0Y2gocik7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5uKGUsIHQsIG4gPSB2b2lkIDApIHtcbiAgbGV0IHIsIGksIGEsIGwgPSBudWxsLCBzID0gMDtcbiAgbiB8fCAobiA9IHt9KTtcbiAgY29uc3QgbyA9IGZ1bmN0aW9uKCkge1xuICAgIHMgPSBuLmxlYWRpbmcgPT09ICExID8gMCA6IERhdGUubm93KCksIGwgPSBudWxsLCBhID0gZS5hcHBseShyLCBpKSwgbCA9PT0gbnVsbCAmJiAociA9IGkgPSBudWxsKTtcbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGQgPSBEYXRlLm5vdygpO1xuICAgICFzICYmIG4ubGVhZGluZyA9PT0gITEgJiYgKHMgPSBkKTtcbiAgICBjb25zdCB1ID0gdCAtIChkIC0gcyk7XG4gICAgcmV0dXJuIHIgPSB0aGlzLCBpID0gYXJndW1lbnRzLCB1IDw9IDAgfHwgdSA+IHQgPyAobCAmJiAoY2xlYXJUaW1lb3V0KGwpLCBsID0gbnVsbCksIHMgPSBkLCBhID0gZS5hcHBseShyLCBpKSwgbCA9PT0gbnVsbCAmJiAociA9IGkgPSBudWxsKSkgOiAhbCAmJiBuLnRyYWlsaW5nICE9PSAhMSAmJiAobCA9IHNldFRpbWVvdXQobywgdSkpLCBhO1xuICB9O1xufVxuY29uc3Qgcm4gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBQcm9taXNlUXVldWU6IHRuLFxuICBiZWF1dGlmeVNob3J0Y3V0OiBGdCxcbiAgY2FjaGVhYmxlOiBXdCxcbiAgY2FwaXRhbGl6ZTogUnQsXG4gIGNvcHlUZXh0VG9DbGlwYm9hcmQ6IHF0LFxuICBkZWJvdW5jZTogVXQsXG4gIGRlZXBNZXJnZTogWCxcbiAgZGVwcmVjYXRpb25Bc3NlcnQ6IEp0LFxuICBnZXRVc2VyT1M6IFVlLFxuICBnZXRWYWxpZFVybDogUXQsXG4gIGlzQm9vbGVhbjogS3QsXG4gIGlzQ2xhc3M6IHp0LFxuICBpc0VtcHR5OiBEdCxcbiAgaXNGdW5jdGlvbjogS2UsXG4gIGlzSW9zRGV2aWNlOiBIdCxcbiAgaXNOdW1iZXI6IFh0LFxuICBpc09iamVjdDogTSxcbiAgaXNQcmludGFibGVLZXk6IFp0LFxuICBpc1Byb21pc2U6IEd0LFxuICBpc1N0cmluZzogVnQsXG4gIGlzVW5kZWZpbmVkOiBZdCxcbiAga2V5Q29kZXM6IHh0LFxuICBtb3VzZUJ1dHRvbnM6IGVuLFxuICBub3RFbXB0eTogYWUsXG4gIHRocm90dGxlOiBubixcbiAgdHlwZU9mOiBTXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBsZSA9IC8qIEBfX1BVUkVfXyAqLyB3dChybik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaWUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmllLmNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzID0gc247XG52YXIgYW4gPSBsZSwgbG4gPSBaO1xuZnVuY3Rpb24gc24oZSkge1xuICB2YXIgdDtcbiAgKDAsIGFuLmlzU3RyaW5nKShlKSA/ICh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgdC5pbm5lckhUTUwgPSBlKSA6IHQgPSBlO1xuICB2YXIgbiA9IGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gISgwLCBsbi5ibG9ja0VsZW1lbnRzKSgpLmluY2x1ZGVzKHIudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSAmJiBBcnJheS5mcm9tKHIuY2hpbGRyZW4pLmV2ZXJ5KG4pO1xuICB9O1xuICByZXR1cm4gQXJyYXkuZnJvbSh0LmNoaWxkcmVuKS5ldmVyeShuKTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHMgPSB2b2lkIDA7XG4gIHZhciB0ID0gaWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHM7XG4gIH0gfSk7XG59KSgkKTtcbnZhciB6ZSA9IHt9LCBzZSA9IHt9LCBCID0ge30sIG9lID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkob2UsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbm9lLm1ha2UgPSBvbjtcbmZ1bmN0aW9uIG9uKGUsIHQsIG4pIHtcbiAgdmFyIHI7XG4gIHQgPT09IHZvaWQgMCAmJiAodCA9IG51bGwpLCBuID09PSB2b2lkIDAgJiYgKG4gPSB7fSk7XG4gIHZhciBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICB2YXIgYSA9IHQuZmlsdGVyKGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBzICE9PSB2b2lkIDA7XG4gICAgfSk7XG4gICAgKHIgPSBpLmNsYXNzTGlzdCkuYWRkLmFwcGx5KHIsIGEpO1xuICB9IGVsc2VcbiAgICB0ICE9PSBudWxsICYmIGkuY2xhc3NMaXN0LmFkZCh0KTtcbiAgZm9yICh2YXIgbCBpbiBuKVxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCBsKSAmJiAoaVtsXSA9IG5bbF0pO1xuICByZXR1cm4gaTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUubWFrZSA9IHZvaWQgMDtcbiAgdmFyIHQgPSBvZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwibWFrZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0Lm1ha2U7XG4gIH0gfSk7XG59KShCKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuc2UuZnJhZ21lbnRUb1N0cmluZyA9IGNuO1xudmFyIHVuID0gQjtcbmZ1bmN0aW9uIGNuKGUpIHtcbiAgdmFyIHQgPSAoMCwgdW4ubWFrZSkoXCJkaXZcIik7XG4gIHJldHVybiB0LmFwcGVuZENoaWxkKGUpLCB0LmlubmVySFRNTDtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuZnJhZ21lbnRUb1N0cmluZyA9IHZvaWQgMDtcbiAgdmFyIHQgPSBzZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiZnJhZ21lbnRUb1N0cmluZ1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmZyYWdtZW50VG9TdHJpbmc7XG4gIH0gfSk7XG59KSh6ZSk7XG52YXIgWGUgPSB7fSwgdWUgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1ZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudWUuZ2V0Q29udGVudExlbmd0aCA9IGZuO1xudmFyIGRuID0gaztcbmZ1bmN0aW9uIGZuKGUpIHtcbiAgdmFyIHQsIG47XG4gIHJldHVybiAoMCwgZG4uaXNOYXRpdmVJbnB1dCkoZSkgPyBlLnZhbHVlLmxlbmd0aCA6IGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gZS5sZW5ndGggOiAobiA9ICh0ID0gZS50ZXh0Q29udGVudCkgPT09IG51bGwgfHwgdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdC5sZW5ndGgpICE9PSBudWxsICYmIG4gIT09IHZvaWQgMCA/IG4gOiAwO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5nZXRDb250ZW50TGVuZ3RoID0gdm9pZCAwO1xuICB2YXIgdCA9IHVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJnZXRDb250ZW50TGVuZ3RoXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuZ2V0Q29udGVudExlbmd0aDtcbiAgfSB9KTtcbn0pKFhlKTtcbnZhciBjZSA9IHt9LCBkZSA9IHt9LCBXZSA9IEEgJiYgQS5fX3NwcmVhZEFycmF5IHx8IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgaWYgKG4gfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICBmb3IgKHZhciByID0gMCwgaSA9IHQubGVuZ3RoLCBhOyByIDwgaTsgcisrKVxuICAgICAgKGEgfHwgIShyIGluIHQpKSAmJiAoYSB8fCAoYSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQsIDAsIHIpKSwgYVtyXSA9IHRbcl0pO1xuICByZXR1cm4gZS5jb25jYXQoYSB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0KSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5kZS5nZXREZWVwZXN0QmxvY2tFbGVtZW50cyA9IEdlO1xudmFyIHBuID0gJDtcbmZ1bmN0aW9uIEdlKGUpIHtcbiAgcmV0dXJuICgwLCBwbi5jb250YWluc09ubHlJbmxpbmVFbGVtZW50cykoZSkgPyBbZV0gOiBBcnJheS5mcm9tKGUuY2hpbGRyZW4pLnJlZHVjZShmdW5jdGlvbih0LCBuKSB7XG4gICAgcmV0dXJuIFdlKFdlKFtdLCB0LCAhMCksIEdlKG4pLCAhMCk7XG4gIH0sIFtdKTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuZ2V0RGVlcGVzdEJsb2NrRWxlbWVudHMgPSB2b2lkIDA7XG4gIHZhciB0ID0gZGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImdldERlZXBlc3RCbG9ja0VsZW1lbnRzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuZ2V0RGVlcGVzdEJsb2NrRWxlbWVudHM7XG4gIH0gfSk7XG59KShjZSk7XG52YXIgVmUgPSB7fSwgZmUgPSB7fSwgVyA9IHt9LCBwZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHBlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5wZS5pc0xpbmVCcmVha1RhZyA9IGhuO1xuZnVuY3Rpb24gaG4oZSkge1xuICByZXR1cm4gW1xuICAgIFwiQlJcIixcbiAgICBcIldCUlwiXG4gIF0uaW5jbHVkZXMoZS50YWdOYW1lKTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuaXNMaW5lQnJlYWtUYWcgPSB2b2lkIDA7XG4gIHZhciB0ID0gcGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzTGluZUJyZWFrVGFnXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuaXNMaW5lQnJlYWtUYWc7XG4gIH0gfSk7XG59KShXKTtcbnZhciBEID0ge30sIGhlID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmhlLmlzU2luZ2xlVGFnID0gbW47XG5mdW5jdGlvbiBtbihlKSB7XG4gIHJldHVybiBbXG4gICAgXCJBUkVBXCIsXG4gICAgXCJCQVNFXCIsXG4gICAgXCJCUlwiLFxuICAgIFwiQ09MXCIsXG4gICAgXCJDT01NQU5EXCIsXG4gICAgXCJFTUJFRFwiLFxuICAgIFwiSFJcIixcbiAgICBcIklNR1wiLFxuICAgIFwiSU5QVVRcIixcbiAgICBcIktFWUdFTlwiLFxuICAgIFwiTElOS1wiLFxuICAgIFwiTUVUQVwiLFxuICAgIFwiUEFSQU1cIixcbiAgICBcIlNPVVJDRVwiLFxuICAgIFwiVFJBQ0tcIixcbiAgICBcIldCUlwiXG4gIF0uaW5jbHVkZXMoZS50YWdOYW1lKTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuaXNTaW5nbGVUYWcgPSB2b2lkIDA7XG4gIHZhciB0ID0gaGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzU2luZ2xlVGFnXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuaXNTaW5nbGVUYWc7XG4gIH0gfSk7XG59KShEKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShmZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuZmUuZ2V0RGVlcGVzdE5vZGUgPSBZZTtcbnZhciBnbiA9IGssIHZuID0gVywgYm4gPSBEO1xuZnVuY3Rpb24gWWUoZSwgdCkge1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSAhMSk7XG4gIHZhciBuID0gdCA/IFwibGFzdENoaWxkXCIgOiBcImZpcnN0Q2hpbGRcIiwgciA9IHQgPyBcInByZXZpb3VzU2libGluZ1wiIDogXCJuZXh0U2libGluZ1wiO1xuICBpZiAoZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgZVtuXSkge1xuICAgIHZhciBpID0gZVtuXTtcbiAgICBpZiAoKDAsIGJuLmlzU2luZ2xlVGFnKShpKSAmJiAhKDAsIGduLmlzTmF0aXZlSW5wdXQpKGkpICYmICEoMCwgdm4uaXNMaW5lQnJlYWtUYWcpKGkpKVxuICAgICAgaWYgKGlbcl0pXG4gICAgICAgIGkgPSBpW3JdO1xuICAgICAgZWxzZSBpZiAoaS5wYXJlbnROb2RlICE9PSBudWxsICYmIGkucGFyZW50Tm9kZVtyXSlcbiAgICAgICAgaSA9IGkucGFyZW50Tm9kZVtyXTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGkucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gWWUoaSwgdCk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmdldERlZXBlc3ROb2RlID0gdm9pZCAwO1xuICB2YXIgdCA9IGZlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJnZXREZWVwZXN0Tm9kZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmdldERlZXBlc3ROb2RlO1xuICB9IH0pO1xufSkoVmUpO1xudmFyIEplID0ge30sIG1lID0ge30sIFQgPSBBICYmIEEuX19zcHJlYWRBcnJheSB8fCBmdW5jdGlvbihlLCB0LCBuKSB7XG4gIGlmIChuIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgZm9yICh2YXIgciA9IDAsIGkgPSB0Lmxlbmd0aCwgYTsgciA8IGk7IHIrKylcbiAgICAgIChhIHx8ICEociBpbiB0KSkgJiYgKGEgfHwgKGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LCAwLCByKSksIGFbcl0gPSB0W3JdKTtcbiAgcmV0dXJuIGUuY29uY2F0KGEgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodCkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xubWUuZmluZEFsbElucHV0cyA9IGtuO1xudmFyIHluID0gJCwgQ24gPSBjZSwgU24gPSBWLCBPbiA9IGs7XG5mdW5jdGlvbiBrbihlKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGUucXVlcnlTZWxlY3RvckFsbCgoMCwgU24uYWxsSW5wdXRzU2VsZWN0b3IpKCkpKS5yZWR1Y2UoZnVuY3Rpb24odCwgbikge1xuICAgIHJldHVybiAoMCwgT24uaXNOYXRpdmVJbnB1dCkobikgfHwgKDAsIHluLmNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzKShuKSA/IFQoVChbXSwgdCwgITApLCBbbl0sICExKSA6IFQoVChbXSwgdCwgITApLCAoMCwgQ24uZ2V0RGVlcGVzdEJsb2NrRWxlbWVudHMpKG4pLCAhMCk7XG4gIH0sIFtdKTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuZmluZEFsbElucHV0cyA9IHZvaWQgMDtcbiAgdmFyIHQgPSBtZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiZmluZEFsbElucHV0c1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmZpbmRBbGxJbnB1dHM7XG4gIH0gfSk7XG59KShKZSk7XG52YXIgUWUgPSB7fSwgZ2UgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShnZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuZ2UuaXNDb2xsYXBzZWRXaGl0ZXNwYWNlcyA9IF9uO1xuZnVuY3Rpb24gX24oZSkge1xuICByZXR1cm4gIS9bXlxcdFxcblxcciBdLy50ZXN0KGUpO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5pc0NvbGxhcHNlZFdoaXRlc3BhY2VzID0gdm9pZCAwO1xuICB2YXIgdCA9IGdlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0NvbGxhcHNlZFdoaXRlc3BhY2VzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuaXNDb2xsYXBzZWRXaGl0ZXNwYWNlcztcbiAgfSB9KTtcbn0pKFFlKTtcbnZhciB2ZSA9IHt9LCBiZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGJlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5iZS5pc0VsZW1lbnQgPSBJbjtcbnZhciBFbiA9IGxlO1xuZnVuY3Rpb24gSW4oZSkge1xuICByZXR1cm4gKDAsIEVuLmlzTnVtYmVyKShlKSA/ICExIDogISFlICYmICEhZS5ub2RlVHlwZSAmJiBlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuaXNFbGVtZW50ID0gdm9pZCAwO1xuICB2YXIgdCA9IGJlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0VsZW1lbnRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5pc0VsZW1lbnQ7XG4gIH0gfSk7XG59KSh2ZSk7XG52YXIgWmUgPSB7fSwgeWUgPSB7fSwgQ2UgPSB7fSwgU2UgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuU2UuaXNMZWFmID0gd247XG5mdW5jdGlvbiB3bihlKSB7XG4gIHJldHVybiBlID09PSBudWxsID8gITEgOiBlLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5pc0xlYWYgPSB2b2lkIDA7XG4gIHZhciB0ID0gU2U7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzTGVhZlwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmlzTGVhZjtcbiAgfSB9KTtcbn0pKENlKTtcbnZhciBPZSA9IHt9LCBrZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGtlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5rZS5pc05vZGVFbXB0eSA9IE1uO1xudmFyIFBuID0gVywgam4gPSB2ZSwgVG4gPSBrLCBMbiA9IEQ7XG5mdW5jdGlvbiBNbihlLCB0KSB7XG4gIHZhciBuID0gXCJcIjtcbiAgcmV0dXJuICgwLCBMbi5pc1NpbmdsZVRhZykoZSkgJiYgISgwLCBQbi5pc0xpbmVCcmVha1RhZykoZSkgPyAhMSA6ICgoMCwgam4uaXNFbGVtZW50KShlKSAmJiAoMCwgVG4uaXNOYXRpdmVJbnB1dCkoZSkgPyBuID0gZS52YWx1ZSA6IGUudGV4dENvbnRlbnQgIT09IG51bGwgJiYgKG4gPSBlLnRleHRDb250ZW50LnJlcGxhY2UoXCLigItcIiwgXCJcIikpLCB0ICE9PSB2b2lkIDAgJiYgKG4gPSBuLnJlcGxhY2UobmV3IFJlZ0V4cCh0LCBcImdcIiksIFwiXCIpKSwgbi50cmltKCkubGVuZ3RoID09PSAwKTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuaXNOb2RlRW1wdHkgPSB2b2lkIDA7XG4gIHZhciB0ID0ga2U7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzTm9kZUVtcHR5XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuaXNOb2RlRW1wdHk7XG4gIH0gfSk7XG59KShPZSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoeWUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnllLmlzRW1wdHkgPSAkbjtcbnZhciBObiA9IENlLCBBbiA9IE9lO1xuZnVuY3Rpb24gJG4oZSwgdCkge1xuICBlLm5vcm1hbGl6ZSgpO1xuICBmb3IgKHZhciBuID0gW2VdOyBuLmxlbmd0aCA+IDA7ICkge1xuICAgIHZhciByID0gbi5zaGlmdCgpO1xuICAgIGlmIChyKSB7XG4gICAgICBpZiAoZSA9IHIsICgwLCBObi5pc0xlYWYpKGUpICYmICEoMCwgQW4uaXNOb2RlRW1wdHkpKGUsIHQpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBuLnB1c2guYXBwbHkobiwgQXJyYXkuZnJvbShlLmNoaWxkTm9kZXMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICEwO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5pc0VtcHR5ID0gdm9pZCAwO1xuICB2YXIgdCA9IHllO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0VtcHR5XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuaXNFbXB0eTtcbiAgfSB9KTtcbn0pKFplKTtcbnZhciB4ZSA9IHt9LCBfZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9lLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5fZS5pc0ZyYWdtZW50ID0gV247XG52YXIgQm4gPSBsZTtcbmZ1bmN0aW9uIFduKGUpIHtcbiAgcmV0dXJuICgwLCBCbi5pc051bWJlcikoZSkgPyAhMSA6ICEhZSAmJiAhIWUubm9kZVR5cGUgJiYgZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5pc0ZyYWdtZW50ID0gdm9pZCAwO1xuICB2YXIgdCA9IF9lO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0ZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuaXNGcmFnbWVudDtcbiAgfSB9KTtcbn0pKHhlKTtcbnZhciBldCA9IHt9LCBFZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5FZS5pc0hUTUxTdHJpbmcgPSBIbjtcbnZhciBEbiA9IEI7XG5mdW5jdGlvbiBIbihlKSB7XG4gIHZhciB0ID0gKDAsIERuLm1ha2UpKFwiZGl2XCIpO1xuICByZXR1cm4gdC5pbm5lckhUTUwgPSBlLCB0LmNoaWxkRWxlbWVudENvdW50ID4gMDtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuaXNIVE1MU3RyaW5nID0gdm9pZCAwO1xuICB2YXIgdCA9IEVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0hUTUxTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5pc0hUTUxTdHJpbmc7XG4gIH0gfSk7XG59KShldCk7XG52YXIgdHQgPSB7fSwgSWUgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuSWUub2Zmc2V0ID0gRm47XG5mdW5jdGlvbiBGbihlKSB7XG4gIHZhciB0ID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbiA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCwgciA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wLCBpID0gdC50b3AgKyByLCBhID0gdC5sZWZ0ICsgbjtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IGksXG4gICAgbGVmdDogYSxcbiAgICBib3R0b206IGkgKyB0LmhlaWdodCxcbiAgICByaWdodDogYSArIHQud2lkdGhcbiAgfTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUub2Zmc2V0ID0gdm9pZCAwO1xuICB2YXIgdCA9IEllO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJvZmZzZXRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5vZmZzZXQ7XG4gIH0gfSk7XG59KSh0dCk7XG52YXIgbnQgPSB7fSwgd2UgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3ZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xud2UucHJlcGVuZCA9IFJuO1xuZnVuY3Rpb24gUm4oZSwgdCkge1xuICBBcnJheS5pc0FycmF5KHQpID8gKHQgPSB0LnJldmVyc2UoKSwgdC5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gZS5wcmVwZW5kKG4pO1xuICB9KSkgOiBlLnByZXBlbmQodCk7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLnByZXBlbmQgPSB2b2lkIDA7XG4gIHZhciB0ID0gd2U7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByZXBlbmRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5wcmVwZW5kO1xuICB9IH0pO1xufSkobnQpO1xuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5wcmVwZW5kID0gZS5vZmZzZXQgPSBlLm1ha2UgPSBlLmlzTGluZUJyZWFrVGFnID0gZS5pc1NpbmdsZVRhZyA9IGUuaXNOb2RlRW1wdHkgPSBlLmlzTGVhZiA9IGUuaXNIVE1MU3RyaW5nID0gZS5pc0ZyYWdtZW50ID0gZS5pc0VtcHR5ID0gZS5pc0VsZW1lbnQgPSBlLmlzQ29udGVudEVkaXRhYmxlID0gZS5pc0NvbGxhcHNlZFdoaXRlc3BhY2VzID0gZS5maW5kQWxsSW5wdXRzID0gZS5pc05hdGl2ZUlucHV0ID0gZS5hbGxJbnB1dHNTZWxlY3RvciA9IGUuZ2V0RGVlcGVzdE5vZGUgPSBlLmdldERlZXBlc3RCbG9ja0VsZW1lbnRzID0gZS5nZXRDb250ZW50TGVuZ3RoID0gZS5mcmFnbWVudFRvU3RyaW5nID0gZS5jb250YWluc09ubHlJbmxpbmVFbGVtZW50cyA9IGUuY2FuU2V0Q2FyZXQgPSBlLmNhbGN1bGF0ZUJhc2VsaW5lID0gZS5ibG9ja0VsZW1lbnRzID0gZS5hcHBlbmQgPSB2b2lkIDA7XG4gIHZhciB0ID0gVjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiYWxsSW5wdXRzU2VsZWN0b3JcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5hbGxJbnB1dHNTZWxlY3RvcjtcbiAgfSB9KTtcbiAgdmFyIG4gPSBrO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc05hdGl2ZUlucHV0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG4uaXNOYXRpdmVJbnB1dDtcbiAgfSB9KTtcbiAgdmFyIHIgPSBGZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiYXBwZW5kXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHIuYXBwZW5kO1xuICB9IH0pO1xuICB2YXIgaSA9IFo7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImJsb2NrRWxlbWVudHNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaS5ibG9ja0VsZW1lbnRzO1xuICB9IH0pO1xuICB2YXIgYSA9IFJlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJjYWxjdWxhdGVCYXNlbGluZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhLmNhbGN1bGF0ZUJhc2VsaW5lO1xuICB9IH0pO1xuICB2YXIgbCA9IHFlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJjYW5TZXRDYXJldFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsLmNhblNldENhcmV0O1xuICB9IH0pO1xuICB2YXIgcyA9ICQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHMuY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHM7XG4gIH0gfSk7XG4gIHZhciBvID0gemU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImZyYWdtZW50VG9TdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gby5mcmFnbWVudFRvU3RyaW5nO1xuICB9IH0pO1xuICB2YXIgZCA9IFhlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJnZXRDb250ZW50TGVuZ3RoXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQuZ2V0Q29udGVudExlbmd0aDtcbiAgfSB9KTtcbiAgdmFyIHUgPSBjZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiZ2V0RGVlcGVzdEJsb2NrRWxlbWVudHNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdS5nZXREZWVwZXN0QmxvY2tFbGVtZW50cztcbiAgfSB9KTtcbiAgdmFyIHAgPSBWZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiZ2V0RGVlcGVzdE5vZGVcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcC5nZXREZWVwZXN0Tm9kZTtcbiAgfSB9KTtcbiAgdmFyIGcgPSBKZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiZmluZEFsbElucHV0c1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnLmZpbmRBbGxJbnB1dHM7XG4gIH0gfSk7XG4gIHZhciB3ID0gUWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzQ29sbGFwc2VkV2hpdGVzcGFjZXNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdy5pc0NvbGxhcHNlZFdoaXRlc3BhY2VzO1xuICB9IH0pO1xuICB2YXIgXyA9IG5lO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0NvbnRlbnRFZGl0YWJsZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLmlzQ29udGVudEVkaXRhYmxlO1xuICB9IH0pO1xuICB2YXIgdXQgPSB2ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNFbGVtZW50XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHV0LmlzRWxlbWVudDtcbiAgfSB9KTtcbiAgdmFyIGN0ID0gWmU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzRW1wdHlcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY3QuaXNFbXB0eTtcbiAgfSB9KTtcbiAgdmFyIGR0ID0geGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzRnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZHQuaXNGcmFnbWVudDtcbiAgfSB9KTtcbiAgdmFyIGZ0ID0gZXQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzSFRNTFN0cmluZ1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdC5pc0hUTUxTdHJpbmc7XG4gIH0gfSk7XG4gIHZhciBwdCA9IENlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0xlYWZcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcHQuaXNMZWFmO1xuICB9IH0pO1xuICB2YXIgaHQgPSBPZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNOb2RlRW1wdHlcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaHQuaXNOb2RlRW1wdHk7XG4gIH0gfSk7XG4gIHZhciBtdCA9IFc7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzTGluZUJyZWFrVGFnXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG10LmlzTGluZUJyZWFrVGFnO1xuICB9IH0pO1xuICB2YXIgZ3QgPSBEO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc1NpbmdsZVRhZ1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBndC5pc1NpbmdsZVRhZztcbiAgfSB9KTtcbiAgdmFyIHZ0ID0gQjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwibWFrZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2dC5tYWtlO1xuICB9IH0pO1xuICB2YXIgYnQgPSB0dDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwib2Zmc2V0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGJ0Lm9mZnNldDtcbiAgfSB9KTtcbiAgdmFyIHl0ID0gbnQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByZXBlbmRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geXQucHJlcGVuZDtcbiAgfSB9KTtcbn0pKGMpO1xuY29uc3QgbSA9IFwiY2R4LWxpc3RcIiwgaCA9IHtcbiAgd3JhcHBlcjogbSxcbiAgaXRlbTogYCR7bX1fX2l0ZW1gLFxuICBpdGVtQ29udGVudDogYCR7bX1fX2l0ZW0tY29udGVudGAsXG4gIGl0ZW1DaGlsZHJlbjogYCR7bX1fX2l0ZW0tY2hpbGRyZW5gXG59O1xuY2xhc3MgdiB7XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIGFsbCBDU1MgY2xhc3NlcyB1c2VkIGluIHVub3JkZXJlZCBsaXN0IHJlbmRlcmluZ1xuICAgKi9cbiAgc3RhdGljIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmgsXG4gICAgICBvcmRlcmVkTGlzdDogYCR7bX0tb3JkZXJlZGBcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBc3NpZ24gcGFzc2VkIHJlYWRvbmx5IG1vZGUgYW5kIGNvbmZpZyB0byByZWxldmFudCBjbGFzcyBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSByZWFkb25seSAtIHJlYWQtb25seSBtb2RlIGZsYWdcbiAgICogQHBhcmFtIGNvbmZpZyAtIHVzZXIgY29uZmlnIGZvciBUb29sXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgdGhpcy5jb25maWcgPSBuLCB0aGlzLnJlYWRPbmx5ID0gdDtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyBvbCB3cmFwcGVyIGZvciBsaXN0XG4gICAqIEBwYXJhbSBpc1Jvb3QgLSBib29sZWFuIHZhcmlhYmxlIHRoYXQgcmVwcmVzZW50cyBsZXZlbCBvZiB0aGUgd3JhcHByZSAocm9vdCBvciBjaGlsZExpc3QpXG4gICAqIEByZXR1cm5zIC0gY3JlYXRlZCBodG1sIG9sIGVsZW1lbnRcbiAgICovXG4gIHJlbmRlcldyYXBwZXIodCkge1xuICAgIGxldCBuO1xuICAgIHJldHVybiB0ID09PSAhMCA/IG4gPSBjLm1ha2UoXCJvbFwiLCBbdi5DU1Mud3JhcHBlciwgdi5DU1Mub3JkZXJlZExpc3RdKSA6IG4gPSBjLm1ha2UoXCJvbFwiLCBbdi5DU1Mub3JkZXJlZExpc3QsIHYuQ1NTLml0ZW1DaGlsZHJlbl0pLCBuO1xuICB9XG4gIC8qKlxuICAgKiBSZWRuZXJzIGxpc3QgaXRlbSBlbGVtZW50XG4gICAqIEBwYXJhbSBjb250ZW50IC0gY29udGVudCB1c2VkIGluIGxpc3QgaXRlbSByZW5kZXJpbmdcbiAgICogQHBhcmFtIF9tZXRhIC0gbWV0YSBvZiB0aGUgbGlzdCBpdGVtIHVudXNlZCBpbiByZW5kZXJpbmcgb2YgdGhlIG9yZGVyZWQgbGlzdFxuICAgKiBAcmV0dXJucyAtIGNyZWF0ZWQgaHRtbCBsaXN0IGl0ZW0gZWxlbWVudFxuICAgKi9cbiAgcmVuZGVySXRlbSh0LCBuKSB7XG4gICAgY29uc3QgciA9IGMubWFrZShcImxpXCIsIHYuQ1NTLml0ZW0pLCBpID0gYy5tYWtlKFwiZGl2XCIsIHYuQ1NTLml0ZW1Db250ZW50LCB7XG4gICAgICBpbm5lckhUTUw6IHQsXG4gICAgICBjb250ZW50RWRpdGFibGU6ICghdGhpcy5yZWFkT25seSkudG9TdHJpbmcoKVxuICAgIH0pO1xuICAgIHJldHVybiByLmFwcGVuZENoaWxkKGkpLCByO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGl0ZW0gY29udGVudFxuICAgKiBAcGFyYW0gaXRlbSAtIGl0ZW0gd3JhcHBlciAoPGxpPilcbiAgICogQHJldHVybnMgLSBpdGVtIGNvbnRlbnQgc3RyaW5nXG4gICAqL1xuICBnZXRJdGVtQ29udGVudCh0KSB7XG4gICAgY29uc3QgbiA9IHQucXVlcnlTZWxlY3RvcihgLiR7di5DU1MuaXRlbUNvbnRlbnR9YCk7XG4gICAgcmV0dXJuICFuIHx8IGMuaXNFbXB0eShuKSA/IFwiXCIgOiBuLmlubmVySFRNTDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBpdGVtIG1ldGEsIGZvciBvcmRlcmVkIGxpc3RcbiAgICogQHJldHVybnMgaXRlbSBtZXRhIG9iamVjdFxuICAgKi9cbiAgZ2V0SXRlbU1ldGEoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGRlZmF1bHQgaXRlbSBtZXRhIHVzZWQgb24gY3JlYXRpb24gb2YgdGhlIG5ldyBpdGVtXG4gICAqL1xuICBjb21wb3NlRGVmYXVsdE1ldGEoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5jbGFzcyBiIHtcbiAgLyoqXG4gICAqIEdldHRlciBmb3IgYWxsIENTUyBjbGFzc2VzIHVzZWQgaW4gdW5vcmRlcmVkIGxpc3QgcmVuZGVyaW5nXG4gICAqL1xuICBzdGF0aWMgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaCxcbiAgICAgIHVub3JkZXJlZExpc3Q6IGAke219LXVub3JkZXJlZGBcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBc3NpZ24gcGFzc2VkIHJlYWRvbmx5IG1vZGUgYW5kIGNvbmZpZyB0byByZWxldmFudCBjbGFzcyBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSByZWFkb25seSAtIHJlYWQtb25seSBtb2RlIGZsYWdcbiAgICogQHBhcmFtIGNvbmZpZyAtIHVzZXIgY29uZmlnIGZvciBUb29sXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0LCBuKSB7XG4gICAgdGhpcy5jb25maWcgPSBuLCB0aGlzLnJlYWRPbmx5ID0gdDtcbiAgfVxuICAvKipcbiAgICogUmVuZGVycyBvbCB3cmFwcGVyIGZvciBsaXN0XG4gICAqIEBwYXJhbSBpc1Jvb3QgLSBib29sZWFuIHZhcmlhYmxlIHRoYXQgcmVwcmVzZW50cyBsZXZlbCBvZiB0aGUgd3JhcHByZSAocm9vdCBvciBjaGlsZExpc3QpXG4gICAqIEByZXR1cm5zIC0gY3JlYXRlZCBodG1sIHVsIGVsZW1lbnRcbiAgICovXG4gIHJlbmRlcldyYXBwZXIodCkge1xuICAgIGxldCBuO1xuICAgIHJldHVybiB0ID09PSAhMCA/IG4gPSBjLm1ha2UoXCJ1bFwiLCBbYi5DU1Mud3JhcHBlciwgYi5DU1MudW5vcmRlcmVkTGlzdF0pIDogbiA9IGMubWFrZShcInVsXCIsIFtiLkNTUy51bm9yZGVyZWRMaXN0LCBiLkNTUy5pdGVtQ2hpbGRyZW5dKSwgbjtcbiAgfVxuICAvKipcbiAgICogUmVkbmVycyBsaXN0IGl0ZW0gZWxlbWVudFxuICAgKiBAcGFyYW0gY29udGVudCAtIGNvbnRlbnQgdXNlZCBpbiBsaXN0IGl0ZW0gcmVuZGVyaW5nXG4gICAqIEBwYXJhbSBfbWV0YSAtIG1ldGEgb2YgdGhlIGxpc3QgaXRlbSB1bnVzZWQgaW4gcmVuZGVyaW5nIG9mIHRoZSB1bm9yZGVyZWQgbGlzdFxuICAgKiBAcmV0dXJucyAtIGNyZWF0ZWQgaHRtbCBsaXN0IGl0ZW0gZWxlbWVudFxuICAgKi9cbiAgcmVuZGVySXRlbSh0LCBuKSB7XG4gICAgY29uc3QgciA9IGMubWFrZShcImxpXCIsIGIuQ1NTLml0ZW0pLCBpID0gYy5tYWtlKFwiZGl2XCIsIGIuQ1NTLml0ZW1Db250ZW50LCB7XG4gICAgICBpbm5lckhUTUw6IHQsXG4gICAgICBjb250ZW50RWRpdGFibGU6ICghdGhpcy5yZWFkT25seSkudG9TdHJpbmcoKVxuICAgIH0pO1xuICAgIHJldHVybiByLmFwcGVuZENoaWxkKGkpLCByO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGl0ZW0gY29udGVudFxuICAgKiBAcGFyYW0gaXRlbSAtIGl0ZW0gd3JhcHBlciAoPGxpPilcbiAgICogQHJldHVybnMgLSBpdGVtIGNvbnRlbnQgc3RyaW5nXG4gICAqL1xuICBnZXRJdGVtQ29udGVudCh0KSB7XG4gICAgY29uc3QgbiA9IHQucXVlcnlTZWxlY3RvcihgLiR7Yi5DU1MuaXRlbUNvbnRlbnR9YCk7XG4gICAgcmV0dXJuICFuIHx8IGMuaXNFbXB0eShuKSA/IFwiXCIgOiBuLmlubmVySFRNTDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBpdGVtIG1ldGEsIGZvciB1bm9yZGVyZWQgbGlzdFxuICAgKiBAcmV0dXJucyBJdGVtIG1ldGEgb2JqZWN0XG4gICAqL1xuICBnZXRJdGVtTWV0YSgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgZGVmYXVsdCBpdGVtIG1ldGEgdXNlZCBvbiBjcmVhdGlvbiBvZiB0aGUgbmV3IGl0ZW1cbiAgICovXG4gIGNvbXBvc2VEZWZhdWx0TWV0YSgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cbmZ1bmN0aW9uIE8oZSkge1xuICByZXR1cm4gZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG59XG52YXIgaiA9IHt9LCBQZSA9IHt9LCBIID0ge30sIEYgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShGLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5GLmdldENvbnRlbnRlZGl0YWJsZVNsaWNlID0gVW47XG52YXIgcW4gPSBjO1xuZnVuY3Rpb24gVW4oZSwgdCwgbiwgciwgaSkge1xuICB2YXIgYTtcbiAgaSA9PT0gdm9pZCAwICYmIChpID0gITEpO1xuICB2YXIgbCA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGlmIChyID09PSBcImxlZnRcIiA/IChsLnNldFN0YXJ0KGUsIDApLCBsLnNldEVuZCh0LCBuKSkgOiAobC5zZXRTdGFydCh0LCBuKSwgbC5zZXRFbmQoZSwgZS5jaGlsZE5vZGVzLmxlbmd0aCkpLCBpID09PSAhMCkge1xuICAgIHZhciBzID0gbC5leHRyYWN0Q29udGVudHMoKTtcbiAgICByZXR1cm4gKDAsIHFuLmZyYWdtZW50VG9TdHJpbmcpKHMpO1xuICB9XG4gIHZhciBvID0gbC5jbG9uZUNvbnRlbnRzKCksIGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBkLmFwcGVuZENoaWxkKG8pO1xuICB2YXIgdSA9IChhID0gZC50ZXh0Q29udGVudCkgIT09IG51bGwgJiYgYSAhPT0gdm9pZCAwID8gYSA6IFwiXCI7XG4gIHJldHVybiB1O1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEgsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbkguY2hlY2tDb250ZW50ZWRpdGFibGVTbGljZUZvckVtcHRpbmVzcyA9IFhuO1xudmFyIEtuID0gYywgem4gPSBGO1xuZnVuY3Rpb24gWG4oZSwgdCwgbiwgcikge1xuICB2YXIgaSA9ICgwLCB6bi5nZXRDb250ZW50ZWRpdGFibGVTbGljZSkoZSwgdCwgbiwgcik7XG4gIHJldHVybiAoMCwgS24uaXNDb2xsYXBzZWRXaGl0ZXNwYWNlcykoaSk7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmNoZWNrQ29udGVudGVkaXRhYmxlU2xpY2VGb3JFbXB0aW5lc3MgPSB2b2lkIDA7XG4gIHZhciB0ID0gSDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiY2hlY2tDb250ZW50ZWRpdGFibGVTbGljZUZvckVtcHRpbmVzc1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmNoZWNrQ29udGVudGVkaXRhYmxlU2xpY2VGb3JFbXB0aW5lc3M7XG4gIH0gfSk7XG59KShQZSk7XG52YXIgcnQgPSB7fTtcbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuZ2V0Q29udGVudGVkaXRhYmxlU2xpY2UgPSB2b2lkIDA7XG4gIHZhciB0ID0gRjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiZ2V0Q29udGVudGVkaXRhYmxlU2xpY2VcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5nZXRDb250ZW50ZWRpdGFibGVTbGljZTtcbiAgfSB9KTtcbn0pKHJ0KTtcbnZhciBpdCA9IHt9LCBqZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGplLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5qZS5mb2N1cyA9IFZuO1xudmFyIEduID0gYztcbmZ1bmN0aW9uIFZuKGUsIHQpIHtcbiAgdmFyIG4sIHI7XG4gIGlmICh0ID09PSB2b2lkIDAgJiYgKHQgPSAhMCksICgwLCBHbi5pc05hdGl2ZUlucHV0KShlKSkge1xuICAgIGUuZm9jdXMoKTtcbiAgICB2YXIgaSA9IHQgPyAwIDogZS52YWx1ZS5sZW5ndGg7XG4gICAgZS5zZXRTZWxlY3Rpb25SYW5nZShpLCBpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCksIGwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFsKVxuICAgICAgcmV0dXJuO1xuICAgIHZhciBzID0gZnVuY3Rpb24oZywgdykge1xuICAgICAgdyA9PT0gdm9pZCAwICYmICh3ID0gITEpO1xuICAgICAgdmFyIF8gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtcbiAgICAgIHcgPyBnLmluc2VydEJlZm9yZShfLCBnLmZpcnN0Q2hpbGQpIDogZy5hcHBlbmRDaGlsZChfKSwgYS5zZXRTdGFydChfLCAwKSwgYS5zZXRFbmQoXywgMCk7XG4gICAgfSwgbyA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgIHJldHVybiBnICE9IG51bGw7XG4gICAgfSwgZCA9IGUuY2hpbGROb2RlcywgdSA9IHQgPyBkWzBdIDogZFtkLmxlbmd0aCAtIDFdO1xuICAgIGlmIChvKHUpKSB7XG4gICAgICBmb3IgKDsgbyh1KSAmJiB1Lm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERTsgKVxuICAgICAgICB1ID0gdCA/IHUuZmlyc3RDaGlsZCA6IHUubGFzdENoaWxkO1xuICAgICAgaWYgKG8odSkgJiYgdS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgdmFyIHAgPSAociA9IChuID0gdS50ZXh0Q29udGVudCkgPT09IG51bGwgfHwgbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbi5sZW5ndGgpICE9PSBudWxsICYmIHIgIT09IHZvaWQgMCA/IHIgOiAwLCBpID0gdCA/IDAgOiBwO1xuICAgICAgICBhLnNldFN0YXJ0KHUsIGkpLCBhLnNldEVuZCh1LCBpKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBzKGUsIHQpO1xuICAgIH0gZWxzZVxuICAgICAgcyhlKTtcbiAgICBsLnJlbW92ZUFsbFJhbmdlcygpLCBsLmFkZFJhbmdlKGEpO1xuICB9XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmZvY3VzID0gdm9pZCAwO1xuICB2YXIgdCA9IGplO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJmb2N1c1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmZvY3VzO1xuICB9IH0pO1xufSkoaXQpO1xudmFyIFRlID0ge30sIFIgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5SLmdldENhcmV0Tm9kZUFuZE9mZnNldCA9IFluO1xuZnVuY3Rpb24gWW4oKSB7XG4gIHZhciBlID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICBpZiAoZSA9PT0gbnVsbClcbiAgICByZXR1cm4gW251bGwsIDBdO1xuICB2YXIgdCA9IGUuZm9jdXNOb2RlLCBuID0gZS5mb2N1c09mZnNldDtcbiAgcmV0dXJuIHQgPT09IG51bGwgPyBbbnVsbCwgMF0gOiAodC5ub2RlVHlwZSAhPT0gTm9kZS5URVhUX05PREUgJiYgdC5jaGlsZE5vZGVzLmxlbmd0aCA+IDAgJiYgKHQuY2hpbGROb2Rlc1tuXSAhPT0gdm9pZCAwID8gKHQgPSB0LmNoaWxkTm9kZXNbbl0sIG4gPSAwKSA6ICh0ID0gdC5jaGlsZE5vZGVzW24gLSAxXSwgdC50ZXh0Q29udGVudCAhPT0gbnVsbCAmJiAobiA9IHQudGV4dENvbnRlbnQubGVuZ3RoKSkpLCBbdCwgbl0pO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5nZXRDYXJldE5vZGVBbmRPZmZzZXQgPSB2b2lkIDA7XG4gIHZhciB0ID0gUjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiZ2V0Q2FyZXROb2RlQW5kT2Zmc2V0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuZ2V0Q2FyZXROb2RlQW5kT2Zmc2V0O1xuICB9IH0pO1xufSkoVGUpO1xudmFyIGF0ID0ge30sIHEgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShxLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5xLmdldFJhbmdlID0gSm47XG5mdW5jdGlvbiBKbigpIHtcbiAgdmFyIGUgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHJldHVybiBlICYmIGUucmFuZ2VDb3VudCA/IGUuZ2V0UmFuZ2VBdCgwKSA6IG51bGw7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmdldFJhbmdlID0gdm9pZCAwO1xuICB2YXIgdCA9IHE7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImdldFJhbmdlXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuZ2V0UmFuZ2U7XG4gIH0gfSk7XG59KShhdCk7XG52YXIgbHQgPSB7fSwgTGUgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuTGUuaXNDYXJldEF0RW5kT2ZJbnB1dCA9IHhuO1xudmFyIERlID0gYywgUW4gPSBUZSwgWm4gPSBQZTtcbmZ1bmN0aW9uIHhuKGUpIHtcbiAgdmFyIHQgPSAoMCwgRGUuZ2V0RGVlcGVzdE5vZGUpKGUsICEwKTtcbiAgaWYgKHQgPT09IG51bGwpXG4gICAgcmV0dXJuICEwO1xuICBpZiAoKDAsIERlLmlzTmF0aXZlSW5wdXQpKHQpKVxuICAgIHJldHVybiB0LnNlbGVjdGlvbkVuZCA9PT0gdC52YWx1ZS5sZW5ndGg7XG4gIHZhciBuID0gKDAsIFFuLmdldENhcmV0Tm9kZUFuZE9mZnNldCkoKSwgciA9IG5bMF0sIGkgPSBuWzFdO1xuICByZXR1cm4gciA9PT0gbnVsbCA/ICExIDogKDAsIFpuLmNoZWNrQ29udGVudGVkaXRhYmxlU2xpY2VGb3JFbXB0aW5lc3MpKGUsIHIsIGksIFwicmlnaHRcIik7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmlzQ2FyZXRBdEVuZE9mSW5wdXQgPSB2b2lkIDA7XG4gIHZhciB0ID0gTGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzQ2FyZXRBdEVuZE9mSW5wdXRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5pc0NhcmV0QXRFbmRPZklucHV0O1xuICB9IH0pO1xufSkobHQpO1xudmFyIHN0ID0ge30sIE1lID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbk1lLmlzQ2FyZXRBdFN0YXJ0T2ZJbnB1dCA9IG5yO1xudmFyIEwgPSBjLCBlciA9IFIsIHRyID0gSDtcbmZ1bmN0aW9uIG5yKGUpIHtcbiAgdmFyIHQgPSAoMCwgTC5nZXREZWVwZXN0Tm9kZSkoZSk7XG4gIGlmICh0ID09PSBudWxsIHx8ICgwLCBMLmlzRW1wdHkpKGUpKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKCgwLCBMLmlzTmF0aXZlSW5wdXQpKHQpKVxuICAgIHJldHVybiB0LnNlbGVjdGlvbkVuZCA9PT0gMDtcbiAgaWYgKCgwLCBMLmlzRW1wdHkpKGUpKVxuICAgIHJldHVybiAhMDtcbiAgdmFyIG4gPSAoMCwgZXIuZ2V0Q2FyZXROb2RlQW5kT2Zmc2V0KSgpLCByID0gblswXSwgaSA9IG5bMV07XG4gIHJldHVybiByID09PSBudWxsID8gITEgOiAoMCwgdHIuY2hlY2tDb250ZW50ZWRpdGFibGVTbGljZUZvckVtcHRpbmVzcykoZSwgciwgaSwgXCJsZWZ0XCIpO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5pc0NhcmV0QXRTdGFydE9mSW5wdXQgPSB2b2lkIDA7XG4gIHZhciB0ID0gTWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzQ2FyZXRBdFN0YXJ0T2ZJbnB1dFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmlzQ2FyZXRBdFN0YXJ0T2ZJbnB1dDtcbiAgfSB9KTtcbn0pKHN0KTtcbnZhciBvdCA9IHt9LCBOZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE5lLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5OZS5zYXZlID0gYXI7XG52YXIgcnIgPSBjLCBpciA9IHE7XG5mdW5jdGlvbiBhcigpIHtcbiAgdmFyIGUgPSAoMCwgaXIuZ2V0UmFuZ2UpKCksIHQgPSAoMCwgcnIubWFrZSkoXCJzcGFuXCIpO1xuICBpZiAodC5pZCA9IFwiY3Vyc29yXCIsIHQuaGlkZGVuID0gITAsICEhZSlcbiAgICByZXR1cm4gZS5pbnNlcnROb2RlKHQpLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgciAmJiAoZS5zZXRTdGFydEFmdGVyKHQpLCBlLnNldEVuZEFmdGVyKHQpLCByLnJlbW92ZUFsbFJhbmdlcygpLCByLmFkZFJhbmdlKGUpLCBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0LnJlbW92ZSgpO1xuICAgICAgfSwgMTUwKSk7XG4gICAgfTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuc2F2ZSA9IHZvaWQgMDtcbiAgdmFyIHQgPSBOZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwic2F2ZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LnNhdmU7XG4gIH0gfSk7XG59KShvdCk7XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLnNhdmUgPSBlLmlzQ2FyZXRBdFN0YXJ0T2ZJbnB1dCA9IGUuaXNDYXJldEF0RW5kT2ZJbnB1dCA9IGUuZ2V0UmFuZ2UgPSBlLmdldENhcmV0Tm9kZUFuZE9mZnNldCA9IGUuZm9jdXMgPSBlLmdldENvbnRlbnRlZGl0YWJsZVNsaWNlID0gZS5jaGVja0NvbnRlbnRlZGl0YWJsZVNsaWNlRm9yRW1wdGluZXNzID0gdm9pZCAwO1xuICB2YXIgdCA9IFBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJjaGVja0NvbnRlbnRlZGl0YWJsZVNsaWNlRm9yRW1wdGluZXNzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuY2hlY2tDb250ZW50ZWRpdGFibGVTbGljZUZvckVtcHRpbmVzcztcbiAgfSB9KTtcbiAgdmFyIG4gPSBydDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiZ2V0Q29udGVudGVkaXRhYmxlU2xpY2VcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbi5nZXRDb250ZW50ZWRpdGFibGVTbGljZTtcbiAgfSB9KTtcbiAgdmFyIHIgPSBpdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiZm9jdXNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gci5mb2N1cztcbiAgfSB9KTtcbiAgdmFyIGkgPSBUZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiZ2V0Q2FyZXROb2RlQW5kT2Zmc2V0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGkuZ2V0Q2FyZXROb2RlQW5kT2Zmc2V0O1xuICB9IH0pO1xuICB2YXIgYSA9IGF0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJnZXRSYW5nZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhLmdldFJhbmdlO1xuICB9IH0pO1xuICB2YXIgbCA9IGx0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0NhcmV0QXRFbmRPZklucHV0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGwuaXNDYXJldEF0RW5kT2ZJbnB1dDtcbiAgfSB9KTtcbiAgdmFyIHMgPSBzdDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNDYXJldEF0U3RhcnRPZklucHV0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHMuaXNDYXJldEF0U3RhcnRPZklucHV0O1xuICB9IH0pO1xuICB2YXIgbyA9IG90O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJzYXZlXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG8uc2F2ZTtcbiAgfSB9KTtcbn0pKGopO1xuY2xhc3MgZiB7XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIGFsbCBDU1MgY2xhc3NlcyB1c2VkIGluIHVub3JkZXJlZCBsaXN0IHJlbmRlcmluZ1xuICAgKi9cbiAgc3RhdGljIGdldCBDU1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmgsXG4gICAgICBjaGVja2xpc3Q6IGAke219LWNoZWNrbGlzdGAsXG4gICAgICBpdGVtQ2hlY2tlZDogYCR7bX1fX2NoZWNrYm94LS1jaGVja2VkYCxcbiAgICAgIG5vSG92ZXI6IGAke219X19jaGVja2JveC0tbm8taG92ZXJgLFxuICAgICAgY2hlY2tib3g6IGAke219X19jaGVja2JveC1jaGVja2AsXG4gICAgICBjaGVja2JveENvbnRhaW5lcjogYCR7bX1fX2NoZWNrYm94YFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEFzc2lnbiBwYXNzZWQgcmVhZG9ubHkgbW9kZSBhbmQgY29uZmlnIHRvIHJlbGV2YW50IGNsYXNzIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHJlYWRvbmx5IC0gcmVhZC1vbmx5IG1vZGUgZmxhZ1xuICAgKiBAcGFyYW0gY29uZmlnIC0gdXNlciBjb25maWcgZm9yIFRvb2xcbiAgICovXG4gIGNvbnN0cnVjdG9yKHQsIG4pIHtcbiAgICB0aGlzLmNvbmZpZyA9IG4sIHRoaXMucmVhZE9ubHkgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXJzIHVsIHdyYXBwZXIgZm9yIGxpc3RcbiAgICogQHBhcmFtIGlzUm9vdCAtIGJvb2xlYW4gdmFyaWFibGUgdGhhdCByZXByZXNlbnRzIGxldmVsIG9mIHRoZSB3cmFwcHJlIChyb290IG9yIGNoaWxkTGlzdClcbiAgICogQHJldHVybnMgLSBjcmVhdGVkIGh0bWwgdWwgZWxlbWVudFxuICAgKi9cbiAgcmVuZGVyV3JhcHBlcih0KSB7XG4gICAgbGV0IG47XG4gICAgcmV0dXJuIHQgPT09ICEwID8gKG4gPSBjLm1ha2UoXCJ1bFwiLCBbZi5DU1Mud3JhcHBlciwgZi5DU1MuY2hlY2tsaXN0XSksIG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChyKSA9PiB7XG4gICAgICBjb25zdCBpID0gci50YXJnZXQ7XG4gICAgICBpZiAoaSkge1xuICAgICAgICBjb25zdCBhID0gaS5jbG9zZXN0KGAuJHtmLkNTUy5jaGVja2JveENvbnRhaW5lcn1gKTtcbiAgICAgICAgYSAmJiBhLmNvbnRhaW5zKGkpICYmIHRoaXMudG9nZ2xlQ2hlY2tib3goYSk7XG4gICAgICB9XG4gICAgfSkpIDogbiA9IGMubWFrZShcInVsXCIsIFtmLkNTUy5jaGVja2xpc3QsIGYuQ1NTLml0ZW1DaGlsZHJlbl0pLCBuO1xuICB9XG4gIC8qKlxuICAgKiBSZWRuZXJzIGxpc3QgaXRlbSBlbGVtZW50XG4gICAqIEBwYXJhbSBjb250ZW50IC0gY29udGVudCB1c2VkIGluIGxpc3QgaXRlbSByZW5kZXJpbmdcbiAgICogQHBhcmFtIG1ldGEgLSBtZXRhIG9mIHRoZSBsaXN0IGl0ZW0gdXNlZCBpbiByZW5kZXJpbmcgb2YgdGhlIGNoZWNrbGlzdFxuICAgKiBAcmV0dXJucyAtIGNyZWF0ZWQgaHRtbCBsaXN0IGl0ZW0gZWxlbWVudFxuICAgKi9cbiAgcmVuZGVySXRlbSh0LCBuKSB7XG4gICAgY29uc3QgciA9IGMubWFrZShcImxpXCIsIFtmLkNTUy5pdGVtLCBmLkNTUy5pdGVtXSksIGkgPSBjLm1ha2UoXCJkaXZcIiwgZi5DU1MuaXRlbUNvbnRlbnQsIHtcbiAgICAgIGlubmVySFRNTDogdCxcbiAgICAgIGNvbnRlbnRFZGl0YWJsZTogKCF0aGlzLnJlYWRPbmx5KS50b1N0cmluZygpXG4gICAgfSksIGEgPSBjLm1ha2UoXCJzcGFuXCIsIGYuQ1NTLmNoZWNrYm94KSwgbCA9IGMubWFrZShcImRpdlwiLCBmLkNTUy5jaGVja2JveENvbnRhaW5lcik7XG4gICAgcmV0dXJuIG4uY2hlY2tlZCA9PT0gITAgJiYgbC5jbGFzc0xpc3QuYWRkKGYuQ1NTLml0ZW1DaGVja2VkKSwgYS5pbm5lckhUTUwgPSBDdCwgbC5hcHBlbmRDaGlsZChhKSwgci5hcHBlbmRDaGlsZChsKSwgci5hcHBlbmRDaGlsZChpKSwgcjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBpdGVtIGNvbnRlbnRcbiAgICogQHBhcmFtIGl0ZW0gLSBpdGVtIHdyYXBwZXIgKDxsaT4pXG4gICAqIEByZXR1cm5zIC0gaXRlbSBjb250ZW50IHN0cmluZ1xuICAgKi9cbiAgZ2V0SXRlbUNvbnRlbnQodCkge1xuICAgIGNvbnN0IG4gPSB0LnF1ZXJ5U2VsZWN0b3IoYC4ke2YuQ1NTLml0ZW1Db250ZW50fWApO1xuICAgIHJldHVybiAhbiB8fCBjLmlzRW1wdHkobikgPyBcIlwiIDogbi5pbm5lckhUTUw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBtZXRhIG9iamVjdCBvZiBjZXJ0YWluIGVsZW1lbnRcbiAgICogQHBhcmFtIGl0ZW0gLSB3aWxsIGJlIHJldHVybmVkIG1ldGEgaW5mb3JtYXRpb24gb2YgdGhpcyBpdGVtXG4gICAqIEByZXR1cm5zIEl0ZW0gbWV0YSBvYmplY3RcbiAgICovXG4gIGdldEl0ZW1NZXRhKHQpIHtcbiAgICBjb25zdCBuID0gdC5xdWVyeVNlbGVjdG9yKGAuJHtmLkNTUy5jaGVja2JveENvbnRhaW5lcn1gKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2hlY2tlZDogbiA/IG4uY2xhc3NMaXN0LmNvbnRhaW5zKGYuQ1NTLml0ZW1DaGVja2VkKSA6ICExXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBkZWZhdWx0IGl0ZW0gbWV0YSB1c2VkIG9uIGNyZWF0aW9uIG9mIHRoZSBuZXcgaXRlbVxuICAgKi9cbiAgY29tcG9zZURlZmF1bHRNZXRhKCkge1xuICAgIHJldHVybiB7IGNoZWNrZWQ6ICExIH07XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZSBjaGVja2xpc3QgaXRlbSBzdGF0ZVxuICAgKiBAcGFyYW0gY2hlY2tib3ggLSBjaGVja2JveCBlbGVtZW50IHRvIGJlIHRvZ2dsZWRcbiAgICovXG4gIHRvZ2dsZUNoZWNrYm94KHQpIHtcbiAgICB0LmNsYXNzTGlzdC50b2dnbGUoZi5DU1MuaXRlbUNoZWNrZWQpLCB0LmNsYXNzTGlzdC5hZGQoZi5DU1Mubm9Ib3ZlciksIHQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgKCkgPT4gdGhpcy5yZW1vdmVTcGVjaWFsSG92ZXJCZWhhdmlvcih0KSwgeyBvbmNlOiAhMCB9KTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBjbGFzcyByZXNwb25zaWJsZSBmb3Igc3BlY2lhbCBob3ZlciBiZWhhdmlvciBvbiBhbiBpdGVtXG4gICAqIEBwYXJhbSBlbCAtIGl0ZW0gd3JhcHBlclxuICAgKi9cbiAgcmVtb3ZlU3BlY2lhbEhvdmVyQmVoYXZpb3IodCkge1xuICAgIHQuY2xhc3NMaXN0LnJlbW92ZShmLkNTUy5ub0hvdmVyKTtcbiAgfVxufVxuZnVuY3Rpb24gVShlLCB0ID0gXCJhZnRlclwiKSB7XG4gIGNvbnN0IG4gPSBbXTtcbiAgbGV0IHI7XG4gIGZ1bmN0aW9uIGkoYSkge1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSBcImFmdGVyXCI6XG4gICAgICAgIHJldHVybiBhLm5leHRFbGVtZW50U2libGluZztcbiAgICAgIGNhc2UgXCJiZWZvcmVcIjpcbiAgICAgICAgcmV0dXJuIGEucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICB9XG4gIH1cbiAgZm9yIChyID0gaShlKTsgciAhPT0gbnVsbDsgKVxuICAgIG4ucHVzaChyKSwgciA9IGkocik7XG4gIHJldHVybiBuLmxlbmd0aCAhPT0gMCA/IG4gOiBudWxsO1xufVxuZnVuY3Rpb24geShlLCB0ID0gITApIHtcbiAgbGV0IG4gPSBlO1xuICByZXR1cm4gZS5jbGFzc0xpc3QuY29udGFpbnMoaC5pdGVtKSAmJiAobiA9IGUucXVlcnlTZWxlY3RvcihgLiR7aC5pdGVtQ2hpbGRyZW59YCkpLCBuID09PSBudWxsID8gW10gOiB0ID8gQXJyYXkuZnJvbShuLnF1ZXJ5U2VsZWN0b3JBbGwoYDpzY29wZSA+IC4ke2guaXRlbX1gKSkgOiBBcnJheS5mcm9tKG4ucXVlcnlTZWxlY3RvckFsbChgLiR7aC5pdGVtfWApKTtcbn1cbmZ1bmN0aW9uIGxyKGUpIHtcbiAgcmV0dXJuIGUubmV4dEVsZW1lbnRTaWJsaW5nID09PSBudWxsO1xufVxuZnVuY3Rpb24gc3IoZSkge1xuICByZXR1cm4gZS5xdWVyeVNlbGVjdG9yKGAuJHtoLml0ZW1DaGlsZHJlbn1gKSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIEMoZSkge1xuICByZXR1cm4gZS5xdWVyeVNlbGVjdG9yKGAuJHtoLml0ZW1DaGlsZHJlbn1gKTtcbn1cbmZ1bmN0aW9uIEsoZSkge1xuICBsZXQgdCA9IGU7XG4gIGUuY2xhc3NMaXN0LmNvbnRhaW5zKGguaXRlbSkgJiYgKHQgPSBDKGUpKSwgdCAhPT0gbnVsbCAmJiB5KHQpLmxlbmd0aCA9PT0gMCAmJiB0LnJlbW92ZSgpO1xufVxuZnVuY3Rpb24gTihlKSB7XG4gIHJldHVybiBlLnF1ZXJ5U2VsZWN0b3IoYC4ke2guaXRlbUNvbnRlbnR9YCk7XG59XG5mdW5jdGlvbiBFKGUsIHQgPSAhMCkge1xuICBjb25zdCBuID0gTihlKTtcbiAgbiAmJiBqLmZvY3VzKG4sIHQpO1xufVxuY2xhc3MgeiB7XG4gIC8qKlxuICAgKiBHZXR0ZXIgbWV0aG9kIHRvIGdldCBjdXJyZW50IGl0ZW1cbiAgICogQHJldHVybnMgY3VycmVudCBsaXN0IGl0ZW0gb3IgbnVsbCBpZiBjYXJldCBwb3NpdGlvbiBpcyBub3QgdW5kZWZpbmVkXG4gICAqL1xuICBnZXQgY3VycmVudEl0ZW0oKSB7XG4gICAgY29uc3QgdCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbiA9IHQuYW5jaG9yTm9kZTtcbiAgICByZXR1cm4gIW4gfHwgKE8obikgfHwgKG4gPSBuLnBhcmVudE5vZGUpLCAhbikgfHwgIU8obikgPyBudWxsIDogbi5jbG9zZXN0KGAuJHtoLml0ZW19YCk7XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZCB0aGF0IHJldHVybnMgbmVzdGluZyBsZXZlbCBvZiB0aGUgY3VycmVudCBpdGVtLCBudWxsIGlmIHRoZXJlIGlzIG5vIHNlbGVjdGlvblxuICAgKi9cbiAgZ2V0IGN1cnJlbnRJdGVtTGV2ZWwoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY3VycmVudEl0ZW07XG4gICAgaWYgKHQgPT09IG51bGwpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbiA9IHQucGFyZW50Tm9kZSwgciA9IDA7XG4gICAgZm9yICg7IG4gIT09IG51bGwgJiYgbiAhPT0gdGhpcy5saXN0V3JhcHBlcjsgKVxuICAgICAgTyhuKSAmJiBuLmNsYXNzTGlzdC5jb250YWlucyhoLml0ZW0pICYmIChyICs9IDEpLCBuID0gbi5wYXJlbnROb2RlO1xuICAgIHJldHVybiByICsgMTtcbiAgfVxuICAvKipcbiAgICogQXNzaWduIGFsbCBwYXNzZWQgcGFyYW1zIGFuZCByZW5kZXJlciB0byByZWxldmFudCBjbGFzcyBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSBwYXJhbXMgLSB0b29sIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhIC0gcHJldmlvdXNseSBzYXZlZCBkYXRhXG4gICAqIEBwYXJhbSBwYXJhbXMuY29uZmlnIC0gdXNlciBjb25maWcgZm9yIFRvb2xcbiAgICogQHBhcmFtIHBhcmFtcy5hcGkgLSBFZGl0b3IuanMgQVBJXG4gICAqIEBwYXJhbSBwYXJhbXMucmVhZE9ubHkgLSByZWFkLW9ubHkgbW9kZSBmbGFnXG4gICAqIEBwYXJhbSByZW5kZXJlciAtIHJlbmRlcmVyIGluc3RhbmNlIGluaXRpYWxpemVkIGluIHRvb2wgY2xhc3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgZGF0YTogdCwgY29uZmlnOiBuLCBhcGk6IHIsIHJlYWRPbmx5OiBpLCBibG9jazogYSB9LCBsKSB7XG4gICAgdGhpcy5jb25maWcgPSBuLCB0aGlzLmRhdGEgPSB0LCB0aGlzLnJlYWRPbmx5ID0gaSwgdGhpcy5hcGkgPSByLCB0aGlzLmJsb2NrID0gYSwgdGhpcy5yZW5kZXJlciA9IGw7XG4gIH1cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIHJlbmRlcmluZyBsaXN0IHdpdGggY29udGVudHNcbiAgICogQHJldHVybnMgRmlsbGVkIHdpdGggY29udGVudCB3cmFwcGVyIGVsZW1lbnQgb2YgdGhlIGxpc3RcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0V3JhcHBlciA9IHRoaXMucmVuZGVyZXIucmVuZGVyV3JhcHBlcighMCksIHRoaXMuZGF0YS5pdGVtcy5sZW5ndGggPyB0aGlzLmFwcGVuZEl0ZW1zKHRoaXMuZGF0YS5pdGVtcywgdGhpcy5saXN0V3JhcHBlcikgOiB0aGlzLmFwcGVuZEl0ZW1zKFxuICAgICAgW1xuICAgICAgICB7XG4gICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICBtZXRhOiB7fSxcbiAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHRoaXMubGlzdFdyYXBwZXJcbiAgICApLCB0aGlzLnJlYWRPbmx5IHx8IHRoaXMubGlzdFdyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgKHQpID0+IHtcbiAgICAgICAgc3dpdGNoICh0LmtleSkge1xuICAgICAgICAgIGNhc2UgXCJFbnRlclwiOlxuICAgICAgICAgICAgdC5zaGlmdEtleSB8fCB0aGlzLmVudGVyUHJlc3NlZCh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJCYWNrc3BhY2VcIjpcbiAgICAgICAgICAgIHRoaXMuYmFja3NwYWNlKHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIlRhYlwiOlxuICAgICAgICAgICAgdC5zaGlmdEtleSA/IHRoaXMuc2hpZnRUYWIodCkgOiB0aGlzLmFkZFRhYih0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgITFcbiAgICApLCBcInN0YXJ0XCIgaW4gdGhpcy5kYXRhLm1ldGEgJiYgdGhpcy5kYXRhLm1ldGEuc3RhcnQgIT09IHZvaWQgMCAmJiB0aGlzLmNoYW5nZVN0YXJ0V2l0aCh0aGlzLmRhdGEubWV0YS5zdGFydCksIFwiY291bnRlclR5cGVcIiBpbiB0aGlzLmRhdGEubWV0YSAmJiB0aGlzLmRhdGEubWV0YS5jb3VudGVyVHlwZSAhPT0gdm9pZCAwICYmIHRoaXMuY2hhbmdlQ291bnRlcnModGhpcy5kYXRhLm1ldGEuY291bnRlclR5cGUpLCB0aGlzLmxpc3RXcmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBsaXN0IGNvbnRlbnQgc2F2aW5nXG4gICAqIEBwYXJhbSB3cmFwcGVyIC0gb3B0aW9uYWwgYXJndW1lbnQgd3JhcHBlclxuICAgKiBAcmV0dXJucyB3aG9sZSBsaXN0IHNhdmVkIGRhdGEgaWYgd3JhcHBlciBub3QgcGFzc2VzLCBvdGhlcndpc2Ugd2lsbCByZXR1cm4gZGF0YSBvZiB0aGUgcGFzc2VkIHdyYXBwZXJcbiAgICovXG4gIHNhdmUodCkge1xuICAgIGNvbnN0IG4gPSB0ID8/IHRoaXMubGlzdFdyYXBwZXIsIHIgPSAobCkgPT4geShsKS5tYXAoKG8pID0+IHtcbiAgICAgIGNvbnN0IGQgPSBDKG8pLCB1ID0gdGhpcy5yZW5kZXJlci5nZXRJdGVtQ29udGVudChvKSwgcCA9IHRoaXMucmVuZGVyZXIuZ2V0SXRlbU1ldGEobyksIGcgPSBkID8gcihkKSA6IFtdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudDogdSxcbiAgICAgICAgbWV0YTogcCxcbiAgICAgICAgaXRlbXM6IGdcbiAgICAgIH07XG4gICAgfSksIGkgPSBuID8gcihuKSA6IFtdO1xuICAgIGxldCBhID0ge1xuICAgICAgc3R5bGU6IHRoaXMuZGF0YS5zdHlsZSxcbiAgICAgIG1ldGE6IHt9LFxuICAgICAgaXRlbXM6IGlcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmRhdGEuc3R5bGUgPT09IFwib3JkZXJlZFwiICYmIChhLm1ldGEgPSB7XG4gICAgICBzdGFydDogdGhpcy5kYXRhLm1ldGEuc3RhcnQsXG4gICAgICBjb3VudGVyVHlwZTogdGhpcy5kYXRhLm1ldGEuY291bnRlclR5cGVcbiAgICB9KSwgYTtcbiAgfVxuICAvKipcbiAgICogT24gcGFzdGUgc2FuaXR6YXRpb24gY29uZmlnLiBBbGxvdyBvbmx5IHRhZ3MgdGhhdCBhcmUgYWxsb3dlZCBpbiB0aGUgVG9vbC5cbiAgICogQHJldHVybnMgLSBjb25maWcgdGhhdCBkZXRlcm1pbmVzIHRhZ3Mgc3VwcG9zdGVkIGJ5IHBhc3RlIGhhbmRsZXJcbiAgICogQHRvZG8gLSByZWZhY3RvciBhbmQgbW92ZSB0byBsaXN0IGluc3RhbmNlXG4gICAqL1xuICBzdGF0aWMgZ2V0IHBhc3RlQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWdzOiBbXCJPTFwiLCBcIlVMXCIsIFwiTElcIl1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgdGhhdCBzcGVjaWZpZWQgaG90IHRvIG1lcmdlIHR3byBMaXN0IGJsb2Nrcy5cbiAgICogQ2FsbGVkIGJ5IEVkaXRvci5qcyBieSBiYWNrc3BhY2UgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgQmxvY2tcbiAgICpcbiAgICogQ29udGVudCBvZiB0aGUgZmlyc3QgaXRlbSBvZiB0aGUgbmV4dCBMaXN0IHdvdWxkIGJlIG1lcmdlZCB3aXRoIGRlZXBlc3QgaXRlbSBpbiBjdXJyZW50IGxpc3RcbiAgICogT3RoZXIgaXRlbXMgb2YgdGhlIG5leHQgTGlzdCB3b3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgY3VycmVudCBsaXN0IHdpdGhvdXQgYW55IGNoYW5nZXMgaW4gbmVzdGluZyBsZXZlbHNcbiAgICogQHBhcmFtIGRhdGEgLSBkYXRhIG9mIHRoZSBzZWNvbmQgbGlzdCB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50XG4gICAqL1xuICBtZXJnZSh0KSB7XG4gICAgY29uc3QgbiA9IHRoaXMuYmxvY2suaG9sZGVyLnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke2guaXRlbX1gKSwgciA9IG5bbi5sZW5ndGggLSAxXSwgaSA9IE4ocik7XG4gICAgaWYgKHIgPT09IG51bGwgfHwgaSA9PT0gbnVsbCB8fCAoaS5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgdC5pdGVtc1swXS5jb250ZW50KSwgdGhpcy5saXN0V3JhcHBlciA9PT0gdm9pZCAwKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhID0geSh0aGlzLmxpc3RXcmFwcGVyKTtcbiAgICBpZiAoYS5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbCA9IGFbYS5sZW5ndGggLSAxXTtcbiAgICBsZXQgcyA9IEMobCk7XG4gICAgY29uc3QgbyA9IHQuaXRlbXMuc2hpZnQoKTtcbiAgICBvICE9PSB2b2lkIDAgJiYgKG8uaXRlbXMubGVuZ3RoICE9PSAwICYmIChzID09PSBudWxsICYmIChzID0gdGhpcy5yZW5kZXJlci5yZW5kZXJXcmFwcGVyKCExKSksIHRoaXMuYXBwZW5kSXRlbXMoby5pdGVtcywgcykpLCB0Lml0ZW1zLmxlbmd0aCA+IDAgJiYgdGhpcy5hcHBlbmRJdGVtcyh0Lml0ZW1zLCB0aGlzLmxpc3RXcmFwcGVyKSk7XG4gIH1cbiAgLyoqXG4gICAqIE9uIHBhc3RlIGNhbGxiYWNrIHRoYXQgaXMgZmlyZWQgZnJvbSBFZGl0b3IuXG4gICAqIEBwYXJhbSBldmVudCAtIGV2ZW50IHdpdGggcGFzdGVkIGRhdGFcbiAgICogQHRvZG8gLSByZWZhY3RvciBhbmQgbW92ZSB0byBsaXN0IGluc3RhbmNlXG4gICAqL1xuICBvblBhc3RlKHQpIHtcbiAgICBjb25zdCBuID0gdC5kZXRhaWwuZGF0YTtcbiAgICB0aGlzLmRhdGEgPSB0aGlzLnBhc3RlSGFuZGxlcihuKTtcbiAgICBjb25zdCByID0gdGhpcy5saXN0V3JhcHBlcjtcbiAgICByICYmIHIucGFyZW50Tm9kZSAmJiByLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRoaXMucmVuZGVyKCksIHIpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGUgVUwsIE9MIGFuZCBMSSB0YWdzIHBhc3RlIGFuZCByZXR1cm5zIExpc3QgZGF0YVxuICAgKiBAcGFyYW0gZWxlbWVudCAtIGh0bWwgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHdob2xlIGxpc3RcbiAgICogQHRvZG8gLSByZWZhY3RvciBhbmQgbW92ZSB0byBsaXN0IGluc3RhbmNlXG4gICAqL1xuICBwYXN0ZUhhbmRsZXIodCkge1xuICAgIGNvbnN0IHsgdGFnTmFtZTogbiB9ID0gdDtcbiAgICBsZXQgciA9IFwidW5vcmRlcmVkXCIsIGk7XG4gICAgc3dpdGNoIChuKSB7XG4gICAgICBjYXNlIFwiT0xcIjpcbiAgICAgICAgciA9IFwib3JkZXJlZFwiLCBpID0gXCJvbFwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJVTFwiOlxuICAgICAgY2FzZSBcIkxJXCI6XG4gICAgICAgIHIgPSBcInVub3JkZXJlZFwiLCBpID0gXCJ1bFwiO1xuICAgIH1cbiAgICBjb25zdCBhID0ge1xuICAgICAgc3R5bGU6IHIsXG4gICAgICBtZXRhOiB7fSxcbiAgICAgIGl0ZW1zOiBbXVxuICAgIH07XG4gICAgciA9PT0gXCJvcmRlcmVkXCIgJiYgKHRoaXMuZGF0YS5tZXRhLmNvdW50ZXJUeXBlID0gXCJudW1lcmljXCIsIHRoaXMuZGF0YS5tZXRhLnN0YXJ0ID0gMSk7XG4gICAgY29uc3QgbCA9IChzKSA9PiBBcnJheS5mcm9tKHMucXVlcnlTZWxlY3RvckFsbChcIjpzY29wZSA+IGxpXCIpKS5tYXAoKGQpID0+IHtcbiAgICAgIGNvbnN0IHUgPSBkLnF1ZXJ5U2VsZWN0b3IoYDpzY29wZSA+ICR7aX1gKSwgcCA9IHUgPyBsKHUpIDogW107XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50OiBkLmlubmVySFRNTCA/PyBcIlwiLFxuICAgICAgICBtZXRhOiB7fSxcbiAgICAgICAgaXRlbXM6IHBcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGEuaXRlbXMgPSBsKHQpLCBhO1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2VzIG9yZGVyZWQgbGlzdCBzdGFydCBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcGFyYW0gaW5kZXggLSBuZXcgdmFsdWUgb2YgdGhlIHN0YXJ0IHByb3BlcnR5XG4gICAqL1xuICBjaGFuZ2VTdGFydFdpdGgodCkge1xuICAgIHRoaXMubGlzdFdyYXBwZXIuc3R5bGUuc2V0UHJvcGVydHkoXCJjb3VudGVyLXJlc2V0XCIsIGBpdGVtICR7dCAtIDF9YCksIHRoaXMuZGF0YS5tZXRhLnN0YXJ0ID0gdDtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyBvcmRlcmVkIGxpc3QgY291bnRlclR5cGUgcHJvcGVydHkgdmFsdWVcbiAgICogQHBhcmFtIGNvdW50ZXJUeXBlIC0gbmV3IHZhbHVlIG9mIHRoZSBjb3VudGVyVHlwZSB2YWx1ZVxuICAgKi9cbiAgY2hhbmdlQ291bnRlcnModCkge1xuICAgIHRoaXMubGlzdFdyYXBwZXIuc3R5bGUuc2V0UHJvcGVydHkoXCItLWxpc3QtY291bnRlci10eXBlXCIsIHQpLCB0aGlzLmRhdGEubWV0YS5jb3VudGVyVHlwZSA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgRW50ZXIga2V5cHJlc3NcbiAgICogQHBhcmFtIGV2ZW50IC0ga2V5ZG93blxuICAgKi9cbiAgZW50ZXJQcmVzc2VkKHQpIHtcbiAgICB2YXIgcztcbiAgICBjb25zdCBuID0gdGhpcy5jdXJyZW50SXRlbTtcbiAgICBpZiAodC5zdG9wUHJvcGFnYXRpb24oKSwgdC5wcmV2ZW50RGVmYXVsdCgpLCB0LmlzQ29tcG9zaW5nIHx8IG4gPT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9ICgocyA9IHRoaXMucmVuZGVyZXIpID09IG51bGwgPyB2b2lkIDAgOiBzLmdldEl0ZW1Db250ZW50KG4pLnRyaW0oKS5sZW5ndGgpID09PSAwLCBpID0gbi5wYXJlbnROb2RlID09PSB0aGlzLmxpc3RXcmFwcGVyLCBhID0gbi5wcmV2aW91c0VsZW1lbnRTaWJsaW5nID09PSBudWxsLCBsID0gdGhpcy5hcGkuYmxvY2tzLmdldEN1cnJlbnRCbG9ja0luZGV4KCk7XG4gICAgaWYgKGkgJiYgcilcbiAgICAgIGlmIChscihuKSAmJiAhc3IobikpIHtcbiAgICAgICAgYSA/IHRoaXMuY29udmVydEl0ZW1Ub0RlZmF1bHRCbG9jayhsLCAhMCkgOiB0aGlzLmNvbnZlcnRJdGVtVG9EZWZhdWx0QmxvY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zcGxpdExpc3Qobik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBlbHNlIGlmIChyKSB7XG4gICAgICB0aGlzLnVuc2hpZnRJdGVtKG4pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5zcGxpdEl0ZW0obik7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBiYWNrc3BhY2VcbiAgICogQHBhcmFtIGV2ZW50IC0ga2V5ZG93blxuICAgKi9cbiAgYmFja3NwYWNlKHQpIHtcbiAgICB2YXIgcjtcbiAgICBjb25zdCBuID0gdGhpcy5jdXJyZW50SXRlbTtcbiAgICBpZiAobiAhPT0gbnVsbCAmJiBqLmlzQ2FyZXRBdFN0YXJ0T2ZJbnB1dChuKSAmJiAoKHIgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkpID09IG51bGwgPyB2b2lkIDAgOiByLmlzQ29sbGFwc2VkKSAhPT0gITEpIHtcbiAgICAgIGlmICh0LnN0b3BQcm9wYWdhdGlvbigpLCBuLnBhcmVudE5vZGUgPT09IHRoaXMubGlzdFdyYXBwZXIgJiYgbi5wcmV2aW91c0VsZW1lbnRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY29udmVydEZpcnN0SXRlbVRvRGVmYXVsdEJsb2NrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5tZXJnZUl0ZW1XaXRoUHJldmlvdXMobik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZWR1Y2UgaW5kZW50YXRpb24gZm9yIGN1cnJlbnQgaXRlbVxuICAgKiBAcGFyYW0gZXZlbnQgLSBrZXlkb3duXG4gICAqL1xuICBzaGlmdFRhYih0KSB7XG4gICAgdC5zdG9wUHJvcGFnYXRpb24oKSwgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLmN1cnJlbnRJdGVtICE9PSBudWxsICYmIHRoaXMudW5zaGlmdEl0ZW0odGhpcy5jdXJyZW50SXRlbSk7XG4gIH1cbiAgLyoqXG4gICAqIERlY3JlYXNlIGluZGVudGF0aW9uIG9mIHRoZSBwYXNzZWQgaXRlbVxuICAgKiBAcGFyYW0gaXRlbSAtIGxpc3QgaXRlbSB0byBiZSB1bnNoaWZ0ZWRcbiAgICovXG4gIHVuc2hpZnRJdGVtKHQpIHtcbiAgICBpZiAoIXQucGFyZW50Tm9kZSB8fCAhTyh0LnBhcmVudE5vZGUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG4gPSB0LnBhcmVudE5vZGUuY2xvc2VzdChgLiR7aC5pdGVtfWApO1xuICAgIGlmICghbilcbiAgICAgIHJldHVybjtcbiAgICBsZXQgciA9IEModCk7XG4gICAgaWYgKHQucGFyZW50RWxlbWVudCA9PT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gVSh0KTtcbiAgICBpICE9PSBudWxsICYmIChyID09PSBudWxsICYmIChyID0gdGhpcy5yZW5kZXJlci5yZW5kZXJXcmFwcGVyKCExKSksIGkuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgci5hcHBlbmRDaGlsZChhKTtcbiAgICB9KSwgdC5hcHBlbmRDaGlsZChyKSksIG4uYWZ0ZXIodCksIEUodCwgITEpLCBLKG4pO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgdGhhdCBpcyB1c2VkIGZvciBsaXN0IHNwbGl0dGluZyBhbmQgbW92aW5nIHRyYWlsaW5nIGl0ZW1zIHRvIHRoZSBuZXcgc2VwYXJhdGVkIGxpc3RcbiAgICogQHBhcmFtIGl0ZW0gLSBjdXJyZW50IGl0ZW0gaHRtbCBlbGVtZW50XG4gICAqL1xuICBzcGxpdExpc3QodCkge1xuICAgIGNvbnN0IG4gPSB5KHQpLCByID0gdGhpcy5ibG9jaywgaSA9IHRoaXMuYXBpLmJsb2Nrcy5nZXRDdXJyZW50QmxvY2tJbmRleCgpO1xuICAgIGlmIChuLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29uc3QgbyA9IG5bMF07XG4gICAgICB0aGlzLnVuc2hpZnRJdGVtKG8pLCBFKHQsICExKTtcbiAgICB9XG4gICAgaWYgKHQucHJldmlvdXNFbGVtZW50U2libGluZyA9PT0gbnVsbCAmJiB0LnBhcmVudE5vZGUgPT09IHRoaXMubGlzdFdyYXBwZXIpIHtcbiAgICAgIHRoaXMuY29udmVydEl0ZW1Ub0RlZmF1bHRCbG9jayhpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYSA9IFUodCk7XG4gICAgaWYgKGEgPT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbCA9IHRoaXMucmVuZGVyZXIucmVuZGVyV3JhcHBlcighMCk7XG4gICAgYS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICBsLmFwcGVuZENoaWxkKG8pO1xuICAgIH0pO1xuICAgIGNvbnN0IHMgPSB0aGlzLnNhdmUobCk7XG4gICAgcy5tZXRhLnN0YXJ0ID0gdGhpcy5kYXRhLnN0eWxlID09IFwib3JkZXJlZFwiID8gMSA6IHZvaWQgMCwgdGhpcy5hcGkuYmxvY2tzLmluc2VydChyID09IG51bGwgPyB2b2lkIDAgOiByLm5hbWUsIHMsIHRoaXMuY29uZmlnLCBpICsgMSksIHRoaXMuY29udmVydEl0ZW1Ub0RlZmF1bHRCbG9jayhpICsgMSksIGwucmVtb3ZlKCk7XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZCB0aGF0IGlzIHVzZWQgZm9yIHNwbGl0dGluZyBpdGVtIGNvbnRlbnQgYW5kIG1vdmluZyB0cmFpbGluZyBjb250ZW50IHRvIHRoZSBuZXcgc2libGluZyBpdGVtXG4gICAqIEBwYXJhbSBjdXJyZW50SXRlbSAtIGN1cnJlbnQgaXRlbSBodG1sIGVsZW1lbnRcbiAgICovXG4gIHNwbGl0SXRlbSh0KSB7XG4gICAgY29uc3QgW24sIHJdID0gai5nZXRDYXJldE5vZGVBbmRPZmZzZXQoKTtcbiAgICBpZiAobiA9PT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gTih0KTtcbiAgICBsZXQgYTtcbiAgICBpID09PSBudWxsID8gYSA9IFwiXCIgOiBhID0gai5nZXRDb250ZW50ZWRpdGFibGVTbGljZShpLCBuLCByLCBcInJpZ2h0XCIsICEwKTtcbiAgICBjb25zdCBsID0gQyh0KSwgcyA9IHRoaXMucmVuZGVySXRlbShhKTtcbiAgICB0ID09IG51bGwgfHwgdC5hZnRlcihzKSwgbCAmJiBzLmFwcGVuZENoaWxkKGwpLCBFKHMpO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgdGhhdCBpcyB1c2VkIGZvciBtZXJnaW5nIGN1cnJlbnQgaXRlbSB3aXRoIHByZXZpb3VzIG9uZVxuICAgKiBDb250ZW50IG9mIHRoZSBjdXJyZW50IGl0ZW0gd291bGQgYmUgYXBwZW5kZWQgdG8gdGhlIHByZXZpb3VzIGl0ZW1cbiAgICogQ3VycmVudCBpdGVtIGNoaWxkcmVuIHdvdWxkIG5vdCBjaGFuZ2UgbmVzdGluZyBsZXZlbFxuICAgKiBAcGFyYW0gaXRlbSAtIGN1cnJlbnQgaXRlbSBodG1sIGVsZW1lbnRcbiAgICovXG4gIG1lcmdlSXRlbVdpdGhQcmV2aW91cyh0KSB7XG4gICAgY29uc3QgbiA9IHQucHJldmlvdXNFbGVtZW50U2libGluZywgciA9IHQucGFyZW50Tm9kZTtcbiAgICBpZiAociA9PT0gbnVsbCB8fCAhTyhyKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gci5jbG9zZXN0KGAuJHtoLml0ZW19YCk7XG4gICAgaWYgKCFuICYmICFpIHx8IG4gJiYgIU8obikpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGE7XG4gICAgaWYgKG4pIHtcbiAgICAgIGNvbnN0IHAgPSB5KG4sICExKTtcbiAgICAgIHAubGVuZ3RoICE9PSAwICYmIHAubGVuZ3RoICE9PSAwID8gYSA9IHBbcC5sZW5ndGggLSAxXSA6IGEgPSBuO1xuICAgIH0gZWxzZVxuICAgICAgYSA9IGk7XG4gICAgY29uc3QgbCA9IHRoaXMucmVuZGVyZXIuZ2V0SXRlbUNvbnRlbnQodCk7XG4gICAgaWYgKCFhKVxuICAgICAgcmV0dXJuO1xuICAgIEUoYSwgITEpO1xuICAgIGNvbnN0IHMgPSBOKGEpO1xuICAgIGlmIChzID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIHMuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIGwpO1xuICAgIGNvbnN0IG8gPSB5KHQpO1xuICAgIGlmIChvLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdC5yZW1vdmUoKSwgSyhhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZCA9IG4gfHwgaSwgdSA9IEMoZCkgPz8gdGhpcy5yZW5kZXJlci5yZW5kZXJXcmFwcGVyKCExKTtcbiAgICBuID8gby5mb3JFYWNoKChwKSA9PiB7XG4gICAgICB1LmFwcGVuZENoaWxkKHApO1xuICAgIH0pIDogby5mb3JFYWNoKChwKSA9PiB7XG4gICAgICB1LnByZXBlbmQocCk7XG4gICAgfSksIEMoZCkgPT09IG51bGwgJiYgYS5hcHBlbmRDaGlsZCh1KSwgdC5yZW1vdmUoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGluZGVudGF0aW9uIHRvIGN1cnJlbnQgaXRlbVxuICAgKiBAcGFyYW0gZXZlbnQgLSBrZXlkb3duXG4gICAqL1xuICBhZGRUYWIodCkge1xuICAgIHZhciBhO1xuICAgIHQuc3RvcFByb3BhZ2F0aW9uKCksIHQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBuID0gdGhpcy5jdXJyZW50SXRlbTtcbiAgICBpZiAoIW4pXG4gICAgICByZXR1cm47XG4gICAgaWYgKCgoYSA9IHRoaXMuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogYS5tYXhMZXZlbCkgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgbCA9IHRoaXMuY3VycmVudEl0ZW1MZXZlbDtcbiAgICAgIGlmIChsICE9PSBudWxsICYmIGwgPT09IHRoaXMuY29uZmlnLm1heExldmVsKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHIgPSBuLnByZXZpb3VzU2libGluZztcbiAgICBpZiAociA9PT0gbnVsbCB8fCAhTyhyKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gQyhyKTtcbiAgICBpZiAoaSlcbiAgICAgIGkuYXBwZW5kQ2hpbGQobiksIHkobikuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICBpLmFwcGVuZENoaWxkKHMpO1xuICAgICAgfSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBsID0gdGhpcy5yZW5kZXJlci5yZW5kZXJXcmFwcGVyKCExKTtcbiAgICAgIGwuYXBwZW5kQ2hpbGQobiksIHkobikuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBsLmFwcGVuZENoaWxkKG8pO1xuICAgICAgfSksIHIuYXBwZW5kQ2hpbGQobCk7XG4gICAgfVxuICAgIEsobiksIEUobiwgITEpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IGN1cnJlbnQgaXRlbSB0byBkZWZhdWx0IGJsb2NrIHdpdGggcGFzc2VkIGluZGV4XG4gICAqIEBwYXJhbSBuZXdCbG94a0luZGV4IC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudHMgaW5kZXgsIHdoZXJlIHdvdWxkIGJlIGluc2V0ZWQgZGVmYXVsdCBibG9ja1xuICAgKiBAcGFyYW0gcmVtb3ZlTGlzdCAtIG9wdGlvbmFsIHBhcmFtZXRlciwgdGhhdCByZXByZXNlbnRzIGNvbmRpdGlvbiwgaWYgTGlzdCBzaG91bGQgYmUgcmVtb3ZlZFxuICAgKi9cbiAgY29udmVydEl0ZW1Ub0RlZmF1bHRCbG9jayh0LCBuKSB7XG4gICAgbGV0IHI7XG4gICAgY29uc3QgaSA9IHRoaXMuY3VycmVudEl0ZW0sIGEgPSBpICE9PSBudWxsID8gdGhpcy5yZW5kZXJlci5nZXRJdGVtQ29udGVudChpKSA6IFwiXCI7XG4gICAgbiA9PT0gITAgJiYgdGhpcy5hcGkuYmxvY2tzLmRlbGV0ZSgpLCB0ICE9PSB2b2lkIDAgPyByID0gdGhpcy5hcGkuYmxvY2tzLmluc2VydCh2b2lkIDAsIHsgdGV4dDogYSB9LCB2b2lkIDAsIHQpIDogciA9IHRoaXMuYXBpLmJsb2Nrcy5pbnNlcnQoKSwgaSA9PSBudWxsIHx8IGkucmVtb3ZlKCksIHRoaXMuYXBpLmNhcmV0LnNldFRvQmxvY2sociwgXCJzdGFydFwiKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCBmaXJzdCBpdGVtIG9mIHRoZSBsaXN0IHRvIGRlZmF1bHQgYmxvY2tcbiAgICogVGhpcyBtZXRob2QgY291bGQgYmUgY2FsbGVkIHdoZW4gYmFja3NwYWNlIGJ1dHRvbiBwcmVzc2VkIGF0IHN0YXJ0IG9mIHRoZSBmaXJzdCBpdGVtIG9mIHRoZSBsaXN0XG4gICAqIEZpcnN0IGl0ZW0gb2YgdGhlIGxpc3Qgd291bGQgYmUgY29udmVydGVkIHRvIHRoZSBwYXJhZ3JhcGggYW5kIGZpcnN0IGl0ZW0gY2hpbGRyZW4gd291bGQgYmUgdW5zaGlmdGVkXG4gICAqL1xuICBjb252ZXJ0Rmlyc3RJdGVtVG9EZWZhdWx0QmxvY2soKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY3VycmVudEl0ZW07XG4gICAgaWYgKHQgPT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbiA9IHkodCk7XG4gICAgaWYgKG4ubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBsID0gblswXTtcbiAgICAgIHRoaXMudW5zaGlmdEl0ZW0obCksIEUodCk7XG4gICAgfVxuICAgIGNvbnN0IHIgPSBVKHQpLCBpID0gdGhpcy5hcGkuYmxvY2tzLmdldEN1cnJlbnRCbG9ja0luZGV4KCksIGEgPSByID09PSBudWxsO1xuICAgIHRoaXMuY29udmVydEl0ZW1Ub0RlZmF1bHRCbG9jayhpLCBhKTtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kIHRoYXQgY2FsbHMgcmVuZGVyIGZ1bmN0aW9uIG9mIHRoZSByZW5kZXJlciB3aXRoIGEgbmVjZXNzYXJ5IGl0ZW0gbWV0YSBjYXN0XG4gICAqIEBwYXJhbSBpdGVtQ29udGVudCAtIGNvbnRlbnQgdG8gYmUgcmVuZGVyZWQgaW4gbmV3IGl0ZW1cbiAgICogQHBhcmFtIG1ldGEgLSBtZXRhIHVzZWQgaW4gbGlzdCBpdGVtIHJlbmRlcmluZ1xuICAgKiBAcmV0dXJucyBodG1sIGVsZW1lbnQgb2YgdGhlIHJlbmRlcmVkIGl0ZW1cbiAgICovXG4gIHJlbmRlckl0ZW0odCwgbikge1xuICAgIGNvbnN0IHIgPSBuID8/IHRoaXMucmVuZGVyZXIuY29tcG9zZURlZmF1bHRNZXRhKCk7XG4gICAgc3dpdGNoICghMCkge1xuICAgICAgY2FzZSB0aGlzLnJlbmRlcmVyIGluc3RhbmNlb2YgdjpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVuZGVySXRlbSh0LCByKTtcbiAgICAgIGNhc2UgdGhpcy5yZW5kZXJlciBpbnN0YW5jZW9mIGI6XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlbmRlckl0ZW0odCwgcik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZW5kZXJJdGVtKHQsIHIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVuZGVycyBjaGlsZHJlbiBsaXN0XG4gICAqIEBwYXJhbSBpdGVtcyAtIGxpc3QgZGF0YSB1c2VkIGluIGl0ZW0gcmVuZGVyaW5nXG4gICAqIEBwYXJhbSBwYXJlbnRFbGVtZW50IC0gd2hlcmUgdG8gYXBwZW5kIHBhc3NlZCBpdGVtc1xuICAgKi9cbiAgYXBwZW5kSXRlbXModCwgbikge1xuICAgIHQuZm9yRWFjaCgocikgPT4ge1xuICAgICAgdmFyIGE7XG4gICAgICBjb25zdCBpID0gdGhpcy5yZW5kZXJJdGVtKHIuY29udGVudCwgci5tZXRhKTtcbiAgICAgIGlmIChuLmFwcGVuZENoaWxkKGkpLCByLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBsID0gKGEgPSB0aGlzLnJlbmRlcmVyKSA9PSBudWxsID8gdm9pZCAwIDogYS5yZW5kZXJXcmFwcGVyKCExKTtcbiAgICAgICAgdGhpcy5hcHBlbmRJdGVtcyhyLml0ZW1zLCBsKSwgaS5hcHBlbmRDaGlsZChsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgSSA9IHtcbiAgd3JhcHBlcjogYCR7bX0tc3RhcnQtd2l0aC1maWVsZGAsXG4gIGlucHV0OiBgJHttfS1zdGFydC13aXRoLWZpZWxkX19pbnB1dGAsXG4gIHN0YXJ0V2l0aEVsZW1lbnRXcmFwcGVySW52YWxpZDogYCR7bX0tc3RhcnQtd2l0aC1maWVsZC0taW52YWxpZGBcbn07XG5mdW5jdGlvbiBvcihlLCB7IHZhbHVlOiB0LCBwbGFjZWhvbGRlcjogbiwgYXR0cmlidXRlczogciwgc2FuaXRpemU6IGkgfSkge1xuICBjb25zdCBhID0gYy5tYWtlKFwiZGl2XCIsIEkud3JhcHBlciksIGwgPSBjLm1ha2UoXCJpbnB1dFwiLCBJLmlucHV0LCB7XG4gICAgcGxhY2Vob2xkZXI6IG4sXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBwcmV2ZW50IGZvY3VzaW5nIG9uIHRoZSBpbnB1dCBieSBUYWIga2V5XG4gICAgICogKFBvcG92ZXIgaW4gdGhlIFRvb2xiYXIgbGF5cyBiZWxvdyB0aGUgYmxvY2tzLFxuICAgICAqIHNvIFRhYiBpbiB0aGUgbGFzdCBibG9jayB3aWxsIGZvY3VzIHRoaXMgaGlkZGVuIGlucHV0IGlmIHRoaXMgcHJvcGVydHkgaXMgbm90IHNldClcbiAgICAgKi9cbiAgICB0YWJJbmRleDogLTEsXG4gICAgLyoqXG4gICAgICogVmFsdWUgb2YgdGhlIHN0YXJ0IHByb3BlcnR5LCBpZiBpdCBpcyBub3Qgc3BlY2lmaWVkLCB0aGVuIGl0IGlzIHNldCB0byBvbmVcbiAgICAgKi9cbiAgICB2YWx1ZTogdFxuICB9KTtcbiAgZm9yIChjb25zdCBzIGluIHIpXG4gICAgbC5zZXRBdHRyaWJ1dGUocywgcltzXSk7XG4gIHJldHVybiBhLmFwcGVuZENoaWxkKGwpLCBsLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoKSA9PiB7XG4gICAgaSAhPT0gdm9pZCAwICYmIChsLnZhbHVlID0gaShsLnZhbHVlKSk7XG4gICAgY29uc3QgcyA9IGwuY2hlY2tWYWxpZGl0eSgpO1xuICAgICFzICYmICFhLmNsYXNzTGlzdC5jb250YWlucyhJLnN0YXJ0V2l0aEVsZW1lbnRXcmFwcGVySW52YWxpZCkgJiYgYS5jbGFzc0xpc3QuYWRkKEkuc3RhcnRXaXRoRWxlbWVudFdyYXBwZXJJbnZhbGlkKSwgcyAmJiBhLmNsYXNzTGlzdC5jb250YWlucyhJLnN0YXJ0V2l0aEVsZW1lbnRXcmFwcGVySW52YWxpZCkgJiYgYS5jbGFzc0xpc3QucmVtb3ZlKEkuc3RhcnRXaXRoRWxlbWVudFdyYXBwZXJJbnZhbGlkKSwgcyAmJiBlKGwudmFsdWUpO1xuICB9KSwgYTtcbn1cbmNvbnN0IFAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIC8qKlxuICAgKiBWYWx1ZSB0aGF0IHJlcHJlc2VudHMgZGVmYXVsdCBhcmFiaWMgbnVtYmVycyBmb3IgY291bnRlcnNcbiAgICovXG4gIFtcIk51bWVyaWNcIiwgXCJudW1lcmljXCJdLFxuICAvKipcbiAgICogVmFsdWUgdGhhdCByZXByZXNlbnRzIGxvd2VyIHJvbWFuIG51bWJlcnMgZm9yIGNvdW50ZXJlc1xuICAgKi9cbiAgW1wiTG93ZXIgUm9tYW5cIiwgXCJsb3dlci1yb21hblwiXSxcbiAgLyoqXG4gICAqIFZhbHVlIHRoYXQgcmVwcmVzZW50cyB1cHBlciByb21hbiBudW1iZXJzIGZvciBjb3VudGVyc1xuICAgKi9cbiAgW1wiVXBwZXIgUm9tYW5cIiwgXCJ1cHBlci1yb21hblwiXSxcbiAgLyoqXG4gICAqIFZhbHVlIHRoYXQgcmVwcmVzZW50cyBsb3dlciBhbHBoYSBjaGFyYWN0ZXJzIGZvciBjb3VudGVyc1xuICAgKi9cbiAgW1wiTG93ZXIgQWxwaGFcIiwgXCJsb3dlci1hbHBoYVwiXSxcbiAgLyoqXG4gICAqIFZhbHVlIHRoYXQgcmVwcmVzZW50cyB1cHBlciBhbHBoYSBjaGFyYWN0ZXJzIGZvciBjb3VudGVyc1xuICAgKi9cbiAgW1wiVXBwZXIgQWxwaGFcIiwgXCJ1cHBlci1hbHBoYVwiXVxuXSksIEhlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAvKipcbiAgICogVmFsdWUgdGhhdCByZXByZXNlbnRzIEljb24gZm9yIE51bWVyaWMgY291bnRlciB0eXBlXG4gICAqL1xuICBbXCJudW1lcmljXCIsIFN0XSxcbiAgLyoqXG4gICAqIFZhbHVlIHRoYXQgcmVwcmVzZW50cyBJY29uIGZvciBMb3dlciBSb21hbiBjb3VudGVyIHR5cGVcbiAgICovXG4gIFtcImxvd2VyLXJvbWFuXCIsIE90XSxcbiAgLyoqXG4gICAqIFZhbHVlIHRoYXQgcmVwcmVzZW50cyBJY29uIGZvciBVcHBlciBSb21hbiBjb3VudGVyIHR5cGVcbiAgICovXG4gIFtcInVwcGVyLXJvbWFuXCIsIGt0XSxcbiAgLyoqXG4gICAqIFZhbHVlIHRoYXQgcmVwcmVzZW50cyBJY29uIGZvciBMb3dlciBBbHBoYSBjb3VudGVyIHR5cGVcbiAgICovXG4gIFtcImxvd2VyLWFscGhhXCIsIEV0XSxcbiAgLyoqXG4gICAqIFZhbHVlIHRoYXQgcmVwcmVzZW50cyBJY29uIGZvciBVcHBlciBBbHBoYSBjb3VudGVyIHR5cGVcbiAgICovXG4gIFtcInVwcGVyLWFscGhhXCIsIF90XVxuXSk7XG5mdW5jdGlvbiB1cihlKSB7XG4gIHJldHVybiBlLnJlcGxhY2UoL1xcRCsvZywgXCJcIik7XG59XG5mdW5jdGlvbiBjcihlKSB7XG4gIHJldHVybiB0eXBlb2YgZS5pdGVtc1swXSA9PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gZHIoZSkge1xuICByZXR1cm4gIShcIm1ldGFcIiBpbiBlKTtcbn1cbmZ1bmN0aW9uIGZyKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlLml0ZW1zWzBdICE9IFwic3RyaW5nXCIgJiYgXCJ0ZXh0XCIgaW4gZS5pdGVtc1swXSAmJiBcImNoZWNrZWRcIiBpbiBlLml0ZW1zWzBdICYmIHR5cGVvZiBlLml0ZW1zWzBdLnRleHQgPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZS5pdGVtc1swXS5jaGVja2VkID09IFwiYm9vbGVhblwiO1xufVxuZnVuY3Rpb24gcHIoZSkge1xuICBjb25zdCB0ID0gW107XG4gIHJldHVybiBjcihlKSA/IChlLml0ZW1zLmZvckVhY2goKG4pID0+IHtcbiAgICB0LnB1c2goe1xuICAgICAgY29udGVudDogbixcbiAgICAgIG1ldGE6IHt9LFxuICAgICAgaXRlbXM6IFtdXG4gICAgfSk7XG4gIH0pLCB7XG4gICAgc3R5bGU6IGUuc3R5bGUsXG4gICAgbWV0YToge30sXG4gICAgaXRlbXM6IHRcbiAgfSkgOiBmcihlKSA/IChlLml0ZW1zLmZvckVhY2goKG4pID0+IHtcbiAgICB0LnB1c2goe1xuICAgICAgY29udGVudDogbi50ZXh0LFxuICAgICAgbWV0YToge1xuICAgICAgICBjaGVja2VkOiBuLmNoZWNrZWRcbiAgICAgIH0sXG4gICAgICBpdGVtczogW11cbiAgICB9KTtcbiAgfSksIHtcbiAgICBzdHlsZTogXCJjaGVja2xpc3RcIixcbiAgICBtZXRhOiB7fSxcbiAgICBpdGVtczogdFxuICB9KSA6IGRyKGUpID8ge1xuICAgIHN0eWxlOiBlLnN0eWxlLFxuICAgIG1ldGE6IHt9LFxuICAgIGl0ZW1zOiBlLml0ZW1zXG4gIH0gOiBzdHJ1Y3R1cmVkQ2xvbmUoZSk7XG59XG5jbGFzcyBHIHtcbiAgLyoqXG4gICAqIE5vdGlmeSBjb3JlIHRoYXQgcmVhZC1vbmx5IG1vZGUgaXMgc3VwcG9ydGVkXG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzUmVhZE9ubHlTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvdyB0byB1c2UgbmF0aXZlIEVudGVyIGJlaGF2aW91clxuICAgKi9cbiAgc3RhdGljIGdldCBlbmFibGVMaW5lQnJlYWtzKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgICogR2V0IFRvb2wgdG9vbGJveCBzZXR0aW5nc1xuICAgKiBpY29uIC0gVG9vbCBpY29uJ3MgU1ZHXG4gICAqIHRpdGxlIC0gdGl0bGUgdG8gc2hvdyBpbiB0b29sYm94XG4gICAqL1xuICBzdGF0aWMgZ2V0IHRvb2xib3goKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgaWNvbjogJGUsXG4gICAgICAgIHRpdGxlOiBcIlVub3JkZXJlZCBMaXN0XCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzdHlsZTogXCJ1bm9yZGVyZWRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpY29uOiBCZSxcbiAgICAgICAgdGl0bGU6IFwiT3JkZXJlZCBMaXN0XCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzdHlsZTogXCJvcmRlcmVkXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWNvbjogQWUsXG4gICAgICAgIHRpdGxlOiBcIkNoZWNrbGlzdFwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc3R5bGU6IFwiY2hlY2tsaXN0XCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgLyoqXG4gICAqIE9uIHBhc3RlIHNhbml0emF0aW9uIGNvbmZpZy4gQWxsb3cgb25seSB0YWdzIHRoYXQgYXJlIGFsbG93ZWQgaW4gdGhlIFRvb2wuXG4gICAqIEByZXR1cm5zIC0gcGFzdGUgY29uZmlnIG9iamVjdCB1c2VkIGluIGVkaXRvclxuICAgKi9cbiAgc3RhdGljIGdldCBwYXN0ZUNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFnczogW1wiT0xcIiwgXCJVTFwiLCBcIkxJXCJdXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCBmcm9tIHRleHQgdG8gbGlzdCB3aXRoIGltcG9ydCBhbmQgZXhwb3J0IGxpc3QgdG8gdGV4dFxuICAgKi9cbiAgc3RhdGljIGdldCBjb252ZXJzaW9uQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICBleHBvcnQ6ICh0KSA9PiBHLmpvaW5SZWN1cnNpdmUodCksXG4gICAgICBpbXBvcnQ6ICh0LCBuKSA9PiAoe1xuICAgICAgICBtZXRhOiB7fSxcbiAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb250ZW50OiB0LFxuICAgICAgICAgICAgbWV0YToge30sXG4gICAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHN0eWxlOiAobiA9PSBudWxsID8gdm9pZCAwIDogbi5kZWZhdWx0U3R5bGUpICE9PSB2b2lkIDAgPyBuLmRlZmF1bHRTdHlsZSA6IFwidW5vcmRlcmVkXCJcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0IGxpc3Qgc3R5bGUgbmFtZVxuICAgKi9cbiAgZ2V0IGxpc3RTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnN0eWxlIHx8IHRoaXMuZGVmYXVsdExpc3RTdHlsZTtcbiAgfVxuICAvKipcbiAgICogU2V0IGxpc3Qgc3R5bGVcbiAgICogQHBhcmFtIHN0eWxlIC0gbmV3IHN0eWxlIHRvIHNldFxuICAgKi9cbiAgc2V0IGxpc3RTdHlsZSh0KSB7XG4gICAgdmFyIHI7XG4gICAgdGhpcy5kYXRhLnN0eWxlID0gdCwgdGhpcy5jaGFuZ2VUYWJ1bGF0b3JCeVN0eWxlKCk7XG4gICAgY29uc3QgbiA9IHRoaXMubGlzdC5yZW5kZXIoKTtcbiAgICAociA9IHRoaXMubGlzdEVsZW1lbnQpID09IG51bGwgfHwgci5yZXBsYWNlV2l0aChuKSwgdGhpcy5saXN0RWxlbWVudCA9IG47XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciBwbHVnaW5gcyBtYWluIEVsZW1lbnQgYW5kIGZpbGwgaXQgd2l0aCBzYXZlZCBkYXRhXG4gICAqIEBwYXJhbSBwYXJhbXMgLSB0b29sIGNvbnN0cnVjdG9yIG9wdGlvbnNcbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhIC0gcHJldmlvdXNseSBzYXZlZCBkYXRhXG4gICAqIEBwYXJhbSBwYXJhbXMuY29uZmlnIC0gdXNlciBjb25maWcgZm9yIFRvb2xcbiAgICogQHBhcmFtIHBhcmFtcy5hcGkgLSBFZGl0b3IuanMgQVBJXG4gICAqIEBwYXJhbSBwYXJhbXMucmVhZE9ubHkgLSByZWFkLW9ubHkgbW9kZSBmbGFnXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGRhdGE6IHQsIGNvbmZpZzogbiwgYXBpOiByLCByZWFkT25seTogaSwgYmxvY2s6IGEgfSkge1xuICAgIHZhciBzO1xuICAgIHRoaXMuYXBpID0gciwgdGhpcy5yZWFkT25seSA9IGksIHRoaXMuY29uZmlnID0gbiwgdGhpcy5ibG9jayA9IGEsIHRoaXMuZGVmYXVsdExpc3RTdHlsZSA9ICgocyA9IHRoaXMuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogcy5kZWZhdWx0U3R5bGUpIHx8IFwidW5vcmRlcmVkXCIsIHRoaXMuZGVmYXVsdENvdW50ZXJUeXBlcyA9IHRoaXMuY29uZmlnLmNvdW50ZXJUeXBlcyB8fCBBcnJheS5mcm9tKFAudmFsdWVzKCkpO1xuICAgIGNvbnN0IGwgPSB7XG4gICAgICBzdHlsZTogdGhpcy5kZWZhdWx0TGlzdFN0eWxlLFxuICAgICAgbWV0YToge30sXG4gICAgICBpdGVtczogW11cbiAgICB9O1xuICAgIHRoaXMuZGF0YSA9IE9iamVjdC5rZXlzKHQpLmxlbmd0aCA/IHByKHQpIDogbCwgdGhpcy5saXN0U3R5bGUgPT09IFwib3JkZXJlZFwiICYmIHRoaXMuZGF0YS5tZXRhLmNvdW50ZXJUeXBlID09PSB2b2lkIDAgJiYgKHRoaXMuZGF0YS5tZXRhLmNvdW50ZXJUeXBlID0gXCJudW1lcmljXCIpLCB0aGlzLmNoYW5nZVRhYnVsYXRvckJ5U3R5bGUoKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCBmcm9tIGxpc3QgdG8gdGV4dCBmb3IgY29udmVyc2lvbkNvbmZpZ1xuICAgKiBAcGFyYW0gZGF0YSAtIGN1cnJlbnQgZGF0YSBvZiB0aGUgbGlzdFxuICAgKiBAcmV0dXJucyAtIHN0cmluZyBvZiB0aGUgcmVjdXJzaXZlbHkgbWVyZ2VkIGNvbnRlbnRzIG9mIHRoZSBpdGVtcyBvZiB0aGUgbGlzdFxuICAgKi9cbiAgc3RhdGljIGpvaW5SZWN1cnNpdmUodCkge1xuICAgIHJldHVybiB0Lml0ZW1zLm1hcCgobikgPT4gYCR7bi5jb250ZW50fSAke0cuam9pblJlY3Vyc2l2ZShuKX1gKS5qb2luKFwiXCIpO1xuICB9XG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBjb250ZW50IHJlbmRlcmluZ1xuICAgKiBAcmV0dXJucyByZW5kZXJlZCBsaXN0IHdyYXBwZXIgd2l0aCBhbGwgY29udGVudHNcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0RWxlbWVudCA9IHRoaXMubGlzdC5yZW5kZXIoKSwgdGhpcy5saXN0RWxlbWVudDtcbiAgfVxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgY29udGVudCBzYXZpbmdcbiAgICogQHJldHVybnMgZm9ybWF0dGVkIGNvbnRlbnQgdXNlZCBpbiBlZGl0b3JcbiAgICovXG4gIHNhdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YSA9IHRoaXMubGlzdC5zYXZlKCksIHRoaXMuZGF0YTtcbiAgfVxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgbWVyZ2luZCB0d28gbGlzdHMgaW50byBvbmVcbiAgICogQHBhcmFtIGRhdGEgLSBkYXRhIG9mIHRoZSBuZXh0IHN0YW5kaW5nIGxpc3QsIHRoYXQgc2hvdWxkIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnRcbiAgICovXG4gIG1lcmdlKHQpIHtcbiAgICB0aGlzLmxpc3QubWVyZ2UodCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgQmxvY2sgVHVuZSBhbGxvd2luZyB0byBjaGFuZ2UgdGhlIGxpc3Qgc3R5bGVcbiAgICogQHJldHVybnMgYXJyYXkgb2YgdHVuZSBjb25maWdzXG4gICAqL1xuICByZW5kZXJTZXR0aW5ncygpIHtcbiAgICBjb25zdCB0ID0gW1xuICAgICAge1xuICAgICAgICBsYWJlbDogdGhpcy5hcGkuaTE4bi50KFwiVW5vcmRlcmVkXCIpLFxuICAgICAgICBpY29uOiAkZSxcbiAgICAgICAgY2xvc2VPbkFjdGl2YXRlOiAhMCxcbiAgICAgICAgaXNBY3RpdmU6IHRoaXMubGlzdFN0eWxlID09IFwidW5vcmRlcmVkXCIsXG4gICAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmxpc3RTdHlsZSA9IFwidW5vcmRlcmVkXCI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoXCJPcmRlcmVkXCIpLFxuICAgICAgICBpY29uOiBCZSxcbiAgICAgICAgY2xvc2VPbkFjdGl2YXRlOiAhMCxcbiAgICAgICAgaXNBY3RpdmU6IHRoaXMubGlzdFN0eWxlID09IFwib3JkZXJlZFwiLFxuICAgICAgICBvbkFjdGl2YXRlOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5saXN0U3R5bGUgPSBcIm9yZGVyZWRcIjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbGFiZWw6IHRoaXMuYXBpLmkxOG4udChcIkNoZWNrbGlzdFwiKSxcbiAgICAgICAgaWNvbjogQWUsXG4gICAgICAgIGNsb3NlT25BY3RpdmF0ZTogITAsXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmxpc3RTdHlsZSA9PSBcImNoZWNrbGlzdFwiLFxuICAgICAgICBvbkFjdGl2YXRlOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5saXN0U3R5bGUgPSBcImNoZWNrbGlzdFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXTtcbiAgICBpZiAodGhpcy5saXN0U3R5bGUgPT09IFwib3JkZXJlZFwiKSB7XG4gICAgICBjb25zdCBuID0gb3IoXG4gICAgICAgIChhKSA9PiB0aGlzLmNoYW5nZVN0YXJ0V2l0aChOdW1iZXIoYSkpLFxuICAgICAgICB7XG4gICAgICAgICAgdmFsdWU6IFN0cmluZyh0aGlzLmRhdGEubWV0YS5zdGFydCA/PyAxKSxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogXCJcIixcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICByZXF1aXJlZDogXCJ0cnVlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNhbml0aXplOiAoYSkgPT4gdXIoYSlcbiAgICAgICAgfVxuICAgICAgKSwgciA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoXCJTdGFydCB3aXRoXCIpLFxuICAgICAgICAgIGljb246IEl0LFxuICAgICAgICAgIGNoaWxkcmVuOiB7XG4gICAgICAgICAgICBpdGVtczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogbixcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRzKDI4MjApIGNhbiBub3QgdXNlIFBvcG92ZXJJdGVtIGVudW0gZnJvbSBlZGl0b3IuanMgdHlwZXNcbiAgICAgICAgICAgICAgICB0eXBlOiBcImh0bWxcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdLCBpID0ge1xuICAgICAgICBsYWJlbDogdGhpcy5hcGkuaTE4bi50KFwiQ291bnRlciB0eXBlXCIpLFxuICAgICAgICBpY29uOiBIZS5nZXQodGhpcy5kYXRhLm1ldGEuY291bnRlclR5cGUpLFxuICAgICAgICBjaGlsZHJlbjoge1xuICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgUC5mb3JFYWNoKChhLCBsKSA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSBQLmdldChsKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0Q291bnRlclR5cGVzLmluY2x1ZGVzKHMpICYmIGkuY2hpbGRyZW4uaXRlbXMucHVzaCh7XG4gICAgICAgICAgdGl0bGU6IHRoaXMuYXBpLmkxOG4udChsKSxcbiAgICAgICAgICBpY29uOiBIZS5nZXQocyksXG4gICAgICAgICAgaXNBY3RpdmU6IHRoaXMuZGF0YS5tZXRhLmNvdW50ZXJUeXBlID09PSBQLmdldChsKSxcbiAgICAgICAgICBjbG9zZU9uQWN0aXZhdGU6ICEwLFxuICAgICAgICAgIG9uQWN0aXZhdGU6ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlQ291bnRlcnMoUC5nZXQobCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KSwgaS5jaGlsZHJlbi5pdGVtcy5sZW5ndGggPiAxICYmIHIucHVzaChpKSwgdC5wdXNoKHsgdHlwZTogXCJzZXBhcmF0b3JcIiB9LCAuLi5yKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgLyoqXG4gICAqIE9uIHBhc3RlIGNhbGxiYWNrIHRoYXQgaXMgZmlyZWQgZnJvbSBFZGl0b3IuXG4gICAqIEBwYXJhbSBldmVudCAtIGV2ZW50IHdpdGggcGFzdGVkIGRhdGFcbiAgICovXG4gIG9uUGFzdGUodCkge1xuICAgIGNvbnN0IHsgdGFnTmFtZTogbiB9ID0gdC5kZXRhaWwuZGF0YTtcbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgIGNhc2UgXCJPTFwiOlxuICAgICAgICB0aGlzLmxpc3RTdHlsZSA9IFwib3JkZXJlZFwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJVTFwiOlxuICAgICAgY2FzZSBcIkxJXCI6XG4gICAgICAgIHRoaXMubGlzdFN0eWxlID0gXCJ1bm9yZGVyZWRcIjtcbiAgICB9XG4gICAgdGhpcy5saXN0Lm9uUGFzdGUodCk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZSBVTCwgT0wgYW5kIExJIHRhZ3MgcGFzdGUgYW5kIHJldHVybnMgTGlzdCBkYXRhXG4gICAqIEBwYXJhbSBlbGVtZW50IC0gaHRtbCBlbGVtZW50IHRoYXQgY29udGFpbnMgd2hvbGUgbGlzdFxuICAgKi9cbiAgcGFzdGVIYW5kbGVyKHQpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0LnBhc3RlSGFuZGxlcih0KTtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyBvcmRlcmVkIGxpc3QgY291bnRlclR5cGUgcHJvcGVydHkgdmFsdWVcbiAgICogQHBhcmFtIGNvdW50ZXJUeXBlIC0gbmV3IHZhbHVlIG9mIHRoZSBjb3VudGVyVHlwZSB2YWx1ZVxuICAgKi9cbiAgY2hhbmdlQ291bnRlcnModCkge1xuICAgIHZhciBuO1xuICAgIChuID0gdGhpcy5saXN0KSA9PSBudWxsIHx8IG4uY2hhbmdlQ291bnRlcnModCksIHRoaXMuZGF0YS5tZXRhLmNvdW50ZXJUeXBlID0gdDtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlcyBvcmRlcmVkIGxpc3Qgc3RhcnQgcHJvcGVydHkgdmFsdWVcbiAgICogQHBhcmFtIGluZGV4IC0gbmV3IHZhbHVlIG9mIHRoZSBzdGFydCBwcm9wZXJ0eVxuICAgKi9cbiAgY2hhbmdlU3RhcnRXaXRoKHQpIHtcbiAgICB2YXIgbjtcbiAgICAobiA9IHRoaXMubGlzdCkgPT0gbnVsbCB8fCBuLmNoYW5nZVN0YXJ0V2l0aCh0KSwgdGhpcy5kYXRhLm1ldGEuc3RhcnQgPSB0O1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgY2hhbmdpbmcgdGFidWxhdG9yIHJlc3BlY3RmdWxseSB0byBwYXNzZWQgc3R5bGVcbiAgICovXG4gIGNoYW5nZVRhYnVsYXRvckJ5U3R5bGUoKSB7XG4gICAgc3dpdGNoICh0aGlzLmxpc3RTdHlsZSkge1xuICAgICAgY2FzZSBcIm9yZGVyZWRcIjpcbiAgICAgICAgdGhpcy5saXN0ID0gbmV3IHooXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgcmVhZE9ubHk6IHRoaXMucmVhZE9ubHksXG4gICAgICAgICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIGJsb2NrOiB0aGlzLmJsb2NrXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuZXcgdih0aGlzLnJlYWRPbmx5LCB0aGlzLmNvbmZpZylcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidW5vcmRlcmVkXCI6XG4gICAgICAgIHRoaXMubGlzdCA9IG5ldyB6KFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIHJlYWRPbmx5OiB0aGlzLnJlYWRPbmx5LFxuICAgICAgICAgICAgYXBpOiB0aGlzLmFwaSxcbiAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgICAgICBibG9jazogdGhpcy5ibG9ja1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbmV3IGIodGhpcy5yZWFkT25seSwgdGhpcy5jb25maWcpXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNoZWNrbGlzdFwiOlxuICAgICAgICB0aGlzLmxpc3QgPSBuZXcgeihcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgICByZWFkT25seTogdGhpcy5yZWFkT25seSxcbiAgICAgICAgICAgIGFwaTogdGhpcy5hcGksXG4gICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICAgICAgYmxvY2s6IHRoaXMuYmxvY2tcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5ldyBmKHRoaXMucmVhZE9ubHksIHRoaXMuY29uZmlnKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEcgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@editorjs/list/dist/editorjs-list.mjs\n\n}");

/***/ }),

/***/ "./node_modules/@editorjs/paragraph/dist/paragraph.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@editorjs/paragraph/dist/paragraph.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ n)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(\".ce-paragraph{line-height:1.6em;outline:none}.ce-block:only-of-type .ce-paragraph[data-placeholder-active]:empty:before,.ce-block:only-of-type .ce-paragraph[data-placeholder-active][data-empty=true]:before{content:attr(data-placeholder-active)}.ce-paragraph p:first-of-type{margin-top:0}.ce-paragraph p:last-of-type{margin-bottom:0}\")),document.head.appendChild(e)}}catch(a){console.error(\"vite-plugin-css-injected-by-js\",a)}})();\nconst a = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M8 9V7.2C8 7.08954 8.08954 7 8.2 7L12 7M16 9V7.2C16 7.08954 15.9105 7 15.8 7L12 7M12 7L12 17M12 17H10M12 17H14\"/></svg>';\nfunction l(r) {\n  const t = document.createElement(\"div\");\n  t.innerHTML = r.trim();\n  const e = document.createDocumentFragment();\n  return e.append(...Array.from(t.childNodes)), e;\n}\n/**\n * Base Paragraph Block for the Editor.js.\n * Represents a regular text block\n *\n * @author CodeX (team@codex.so)\n * @copyright CodeX 2018\n * @license The MIT License (MIT)\n */\nclass n {\n  /**\n   * Default placeholder for Paragraph Tool\n   *\n   * @returns {string}\n   * @class\n   */\n  static get DEFAULT_PLACEHOLDER() {\n    return \"\";\n  }\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   *\n   * @param {object} params - constructor params\n   * @param {ParagraphData} params.data - previously saved data\n   * @param {ParagraphConfig} params.config - user config for Tool\n   * @param {object} params.api - editor.js api\n   * @param {boolean} readOnly - read only mode flag\n   */\n  constructor({ data: t, config: e, api: i, readOnly: s }) {\n    this.api = i, this.readOnly = s, this._CSS = {\n      block: this.api.styles.block,\n      wrapper: \"ce-paragraph\"\n    }, this.readOnly || (this.onKeyUp = this.onKeyUp.bind(this)), this._placeholder = e.placeholder ? e.placeholder : n.DEFAULT_PLACEHOLDER, this._data = t ?? {}, this._element = null, this._preserveBlank = e.preserveBlank ?? !1;\n  }\n  /**\n   * Check if text content is empty and set empty string to inner html.\n   * We need this because some browsers (e.g. Safari) insert <br> into empty contenteditanle elements\n   *\n   * @param {KeyboardEvent} e - key up event\n   */\n  onKeyUp(t) {\n    if (t.code !== \"Backspace\" && t.code !== \"Delete\" || !this._element)\n      return;\n    const { textContent: e } = this._element;\n    e === \"\" && (this._element.innerHTML = \"\");\n  }\n  /**\n   * Create Tool's view\n   *\n   * @returns {HTMLDivElement}\n   * @private\n   */\n  drawView() {\n    const t = document.createElement(\"DIV\");\n    return t.classList.add(this._CSS.wrapper, this._CSS.block), t.contentEditable = \"false\", t.dataset.placeholderActive = this.api.i18n.t(this._placeholder), this._data.text && (t.innerHTML = this._data.text), this.readOnly || (t.contentEditable = \"true\", t.addEventListener(\"keyup\", this.onKeyUp)), t;\n  }\n  /**\n   * Return Tool's view\n   *\n   * @returns {HTMLDivElement}\n   */\n  render() {\n    return this._element = this.drawView(), this._element;\n  }\n  /**\n   * Method that specified how to merge two Text blocks.\n   * Called by Editor.js by backspace at the beginning of the Block\n   *\n   * @param {ParagraphData} data\n   * @public\n   */\n  merge(t) {\n    if (!this._element)\n      return;\n    this._data.text += t.text;\n    const e = l(t.text);\n    this._element.appendChild(e), this._element.normalize();\n  }\n  /**\n   * Validate Paragraph block data:\n   * - check for emptiness\n   *\n   * @param {ParagraphData} savedData — data received after saving\n   * @returns {boolean} false if saved data is not correct, otherwise true\n   * @public\n   */\n  validate(t) {\n    return !(t.text.trim() === \"\" && !this._preserveBlank);\n  }\n  /**\n   * Extract Tool's data from the view\n   *\n   * @param {HTMLDivElement} toolsContent - Paragraph tools rendered view\n   * @returns {ParagraphData} - saved data\n   * @public\n   */\n  save(t) {\n    return {\n      text: t.innerHTML\n    };\n  }\n  /**\n   * On paste callback fired from Editor.\n   *\n   * @param {HTMLPasteEvent} event - event with pasted data\n   */\n  onPaste(t) {\n    const e = {\n      text: t.detail.data.innerHTML\n    };\n    this._data = e, window.requestAnimationFrame(() => {\n      this._element && (this._element.innerHTML = this._data.text || \"\");\n    });\n  }\n  /**\n   * Enable Conversion Toolbar. Paragraph can be converted to/from other tools\n   * @returns {ConversionConfig}\n   */\n  static get conversionConfig() {\n    return {\n      export: \"text\",\n      // to convert Paragraph to other block, use 'text' property of saved data\n      import: \"text\"\n      // to covert other block's exported string to Paragraph, fill 'text' property of tool data\n    };\n  }\n  /**\n   * Sanitizer rules\n   * @returns {SanitizerConfig} - Edtior.js sanitizer config\n   */\n  static get sanitize() {\n    return {\n      text: {\n        br: !0\n      }\n    };\n  }\n  /**\n   * Returns true to notify the core that read-only mode is supported\n   *\n   * @returns {boolean}\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Used by Editor paste handling API.\n   * Provides configuration to handle P tags.\n   *\n   * @returns {PasteConfig} - Paragraph Paste Setting\n   */\n  static get pasteConfig() {\n    return {\n      tags: [\"P\"]\n    };\n  }\n  /**\n   * Icon and title for displaying at the Toolbox\n   *\n   * @returns {ToolboxConfig} - Paragraph Toolbox Setting\n   */\n  static get toolbox() {\n    return {\n      icon: a,\n      title: \"Text\"\n    };\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL3BhcmFncmFwaC9kaXN0L3BhcmFncmFwaC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFlBQVksYUFBYSxJQUFJLHdCQUF3QixzQ0FBc0MscURBQXFELGtCQUFrQixhQUFhLGlLQUFpSyxzQ0FBc0MsOEJBQThCLGFBQWEsNkJBQTZCLGdCQUFnQixrQ0FBa0MsU0FBUyxtREFBbUQ7QUFDNWlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxlQUFlO0FBQzVCLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxnQkFBZ0IseUNBQXlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEtBQUssNEpBQTRKO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL3BhcmFncmFwaC9kaXN0L3BhcmFncmFwaC5tanM/MmI2OSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt0cnl7aWYodHlwZW9mIGRvY3VtZW50PFwidVwiKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7ZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIi5jZS1wYXJhZ3JhcGh7bGluZS1oZWlnaHQ6MS42ZW07b3V0bGluZTpub25lfS5jZS1ibG9jazpvbmx5LW9mLXR5cGUgLmNlLXBhcmFncmFwaFtkYXRhLXBsYWNlaG9sZGVyLWFjdGl2ZV06ZW1wdHk6YmVmb3JlLC5jZS1ibG9jazpvbmx5LW9mLXR5cGUgLmNlLXBhcmFncmFwaFtkYXRhLXBsYWNlaG9sZGVyLWFjdGl2ZV1bZGF0YS1lbXB0eT10cnVlXTpiZWZvcmV7Y29udGVudDphdHRyKGRhdGEtcGxhY2Vob2xkZXItYWN0aXZlKX0uY2UtcGFyYWdyYXBoIHA6Zmlyc3Qtb2YtdHlwZXttYXJnaW4tdG9wOjB9LmNlLXBhcmFncmFwaCBwOmxhc3Qtb2YtdHlwZXttYXJnaW4tYm90dG9tOjB9XCIpKSxkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGUpfX1jYXRjaChhKXtjb25zb2xlLmVycm9yKFwidml0ZS1wbHVnaW4tY3NzLWluamVjdGVkLWJ5LWpzXCIsYSl9fSkoKTtcbmNvbnN0IGEgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTggOVY3LjJDOCA3LjA4OTU0IDguMDg5NTQgNyA4LjIgN0wxMiA3TTE2IDlWNy4yQzE2IDcuMDg5NTQgMTUuOTEwNSA3IDE1LjggN0wxMiA3TTEyIDdMMTIgMTdNMTIgMTdIMTBNMTIgMTdIMTRcIi8+PC9zdmc+JztcbmZ1bmN0aW9uIGwocikge1xuICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgdC5pbm5lckhUTUwgPSByLnRyaW0oKTtcbiAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgcmV0dXJuIGUuYXBwZW5kKC4uLkFycmF5LmZyb20odC5jaGlsZE5vZGVzKSksIGU7XG59XG4vKipcbiAqIEJhc2UgUGFyYWdyYXBoIEJsb2NrIGZvciB0aGUgRWRpdG9yLmpzLlxuICogUmVwcmVzZW50cyBhIHJlZ3VsYXIgdGV4dCBibG9ja1xuICpcbiAqIEBhdXRob3IgQ29kZVggKHRlYW1AY29kZXguc28pXG4gKiBAY29weXJpZ2h0IENvZGVYIDIwMThcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICovXG5jbGFzcyBuIHtcbiAgLyoqXG4gICAqIERlZmF1bHQgcGxhY2Vob2xkZXIgZm9yIFBhcmFncmFwaCBUb29sXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqIEBjbGFzc1xuICAgKi9cbiAgc3RhdGljIGdldCBERUZBVUxUX1BMQUNFSE9MREVSKCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIC8qKlxuICAgKiBSZW5kZXIgcGx1Z2luYHMgbWFpbiBFbGVtZW50IGFuZCBmaWxsIGl0IHdpdGggc2F2ZWQgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gY29uc3RydWN0b3IgcGFyYW1zXG4gICAqIEBwYXJhbSB7UGFyYWdyYXBoRGF0YX0gcGFyYW1zLmRhdGEgLSBwcmV2aW91c2x5IHNhdmVkIGRhdGFcbiAgICogQHBhcmFtIHtQYXJhZ3JhcGhDb25maWd9IHBhcmFtcy5jb25maWcgLSB1c2VyIGNvbmZpZyBmb3IgVG9vbFxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmFwaSAtIGVkaXRvci5qcyBhcGlcbiAgICogQHBhcmFtIHtib29sZWFufSByZWFkT25seSAtIHJlYWQgb25seSBtb2RlIGZsYWdcbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgZGF0YTogdCwgY29uZmlnOiBlLCBhcGk6IGksIHJlYWRPbmx5OiBzIH0pIHtcbiAgICB0aGlzLmFwaSA9IGksIHRoaXMucmVhZE9ubHkgPSBzLCB0aGlzLl9DU1MgPSB7XG4gICAgICBibG9jazogdGhpcy5hcGkuc3R5bGVzLmJsb2NrLFxuICAgICAgd3JhcHBlcjogXCJjZS1wYXJhZ3JhcGhcIlxuICAgIH0sIHRoaXMucmVhZE9ubHkgfHwgKHRoaXMub25LZXlVcCA9IHRoaXMub25LZXlVcC5iaW5kKHRoaXMpKSwgdGhpcy5fcGxhY2Vob2xkZXIgPSBlLnBsYWNlaG9sZGVyID8gZS5wbGFjZWhvbGRlciA6IG4uREVGQVVMVF9QTEFDRUhPTERFUiwgdGhpcy5fZGF0YSA9IHQgPz8ge30sIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9wcmVzZXJ2ZUJsYW5rID0gZS5wcmVzZXJ2ZUJsYW5rID8/ICExO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0ZXh0IGNvbnRlbnQgaXMgZW1wdHkgYW5kIHNldCBlbXB0eSBzdHJpbmcgdG8gaW5uZXIgaHRtbC5cbiAgICogV2UgbmVlZCB0aGlzIGJlY2F1c2Ugc29tZSBicm93c2VycyAoZS5nLiBTYWZhcmkpIGluc2VydCA8YnI+IGludG8gZW1wdHkgY29udGVudGVkaXRhbmxlIGVsZW1lbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZSAtIGtleSB1cCBldmVudFxuICAgKi9cbiAgb25LZXlVcCh0KSB7XG4gICAgaWYgKHQuY29kZSAhPT0gXCJCYWNrc3BhY2VcIiAmJiB0LmNvZGUgIT09IFwiRGVsZXRlXCIgfHwgIXRoaXMuX2VsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyB0ZXh0Q29udGVudDogZSB9ID0gdGhpcy5fZWxlbWVudDtcbiAgICBlID09PSBcIlwiICYmICh0aGlzLl9lbGVtZW50LmlubmVySFRNTCA9IFwiXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgVG9vbCdzIHZpZXdcbiAgICpcbiAgICogQHJldHVybnMge0hUTUxEaXZFbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZHJhd1ZpZXcoKSB7XG4gICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XG4gICAgcmV0dXJuIHQuY2xhc3NMaXN0LmFkZCh0aGlzLl9DU1Mud3JhcHBlciwgdGhpcy5fQ1NTLmJsb2NrKSwgdC5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCIsIHQuZGF0YXNldC5wbGFjZWhvbGRlckFjdGl2ZSA9IHRoaXMuYXBpLmkxOG4udCh0aGlzLl9wbGFjZWhvbGRlciksIHRoaXMuX2RhdGEudGV4dCAmJiAodC5pbm5lckhUTUwgPSB0aGlzLl9kYXRhLnRleHQpLCB0aGlzLnJlYWRPbmx5IHx8ICh0LmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiLCB0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLm9uS2V5VXApKSwgdDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIFRvb2wncyB2aWV3XG4gICAqXG4gICAqIEByZXR1cm5zIHtIVE1MRGl2RWxlbWVudH1cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudCA9IHRoaXMuZHJhd1ZpZXcoKSwgdGhpcy5fZWxlbWVudDtcbiAgfVxuICAvKipcbiAgICogTWV0aG9kIHRoYXQgc3BlY2lmaWVkIGhvdyB0byBtZXJnZSB0d28gVGV4dCBibG9ja3MuXG4gICAqIENhbGxlZCBieSBFZGl0b3IuanMgYnkgYmFja3NwYWNlIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIEJsb2NrXG4gICAqXG4gICAqIEBwYXJhbSB7UGFyYWdyYXBoRGF0YX0gZGF0YVxuICAgKiBAcHVibGljXG4gICAqL1xuICBtZXJnZSh0KSB7XG4gICAgaWYgKCF0aGlzLl9lbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2RhdGEudGV4dCArPSB0LnRleHQ7XG4gICAgY29uc3QgZSA9IGwodC50ZXh0KTtcbiAgICB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKGUpLCB0aGlzLl9lbGVtZW50Lm5vcm1hbGl6ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBQYXJhZ3JhcGggYmxvY2sgZGF0YTpcbiAgICogLSBjaGVjayBmb3IgZW1wdGluZXNzXG4gICAqXG4gICAqIEBwYXJhbSB7UGFyYWdyYXBoRGF0YX0gc2F2ZWREYXRhIOKAlCBkYXRhIHJlY2VpdmVkIGFmdGVyIHNhdmluZ1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWYgc2F2ZWQgZGF0YSBpcyBub3QgY29ycmVjdCwgb3RoZXJ3aXNlIHRydWVcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdmFsaWRhdGUodCkge1xuICAgIHJldHVybiAhKHQudGV4dC50cmltKCkgPT09IFwiXCIgJiYgIXRoaXMuX3ByZXNlcnZlQmxhbmspO1xuICB9XG4gIC8qKlxuICAgKiBFeHRyYWN0IFRvb2wncyBkYXRhIGZyb20gdGhlIHZpZXdcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudH0gdG9vbHNDb250ZW50IC0gUGFyYWdyYXBoIHRvb2xzIHJlbmRlcmVkIHZpZXdcbiAgICogQHJldHVybnMge1BhcmFncmFwaERhdGF9IC0gc2F2ZWQgZGF0YVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzYXZlKHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogdC5pbm5lckhUTUxcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBPbiBwYXN0ZSBjYWxsYmFjayBmaXJlZCBmcm9tIEVkaXRvci5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MUGFzdGVFdmVudH0gZXZlbnQgLSBldmVudCB3aXRoIHBhc3RlZCBkYXRhXG4gICAqL1xuICBvblBhc3RlKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgdGV4dDogdC5kZXRhaWwuZGF0YS5pbm5lckhUTUxcbiAgICB9O1xuICAgIHRoaXMuX2RhdGEgPSBlLCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQgJiYgKHRoaXMuX2VsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5fZGF0YS50ZXh0IHx8IFwiXCIpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGUgQ29udmVyc2lvbiBUb29sYmFyLiBQYXJhZ3JhcGggY2FuIGJlIGNvbnZlcnRlZCB0by9mcm9tIG90aGVyIHRvb2xzXG4gICAqIEByZXR1cm5zIHtDb252ZXJzaW9uQ29uZmlnfVxuICAgKi9cbiAgc3RhdGljIGdldCBjb252ZXJzaW9uQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICBleHBvcnQ6IFwidGV4dFwiLFxuICAgICAgLy8gdG8gY29udmVydCBQYXJhZ3JhcGggdG8gb3RoZXIgYmxvY2ssIHVzZSAndGV4dCcgcHJvcGVydHkgb2Ygc2F2ZWQgZGF0YVxuICAgICAgaW1wb3J0OiBcInRleHRcIlxuICAgICAgLy8gdG8gY292ZXJ0IG90aGVyIGJsb2NrJ3MgZXhwb3J0ZWQgc3RyaW5nIHRvIFBhcmFncmFwaCwgZmlsbCAndGV4dCcgcHJvcGVydHkgb2YgdG9vbCBkYXRhXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2FuaXRpemVyIHJ1bGVzXG4gICAqIEByZXR1cm5zIHtTYW5pdGl6ZXJDb25maWd9IC0gRWR0aW9yLmpzIHNhbml0aXplciBjb25maWdcbiAgICovXG4gIHN0YXRpYyBnZXQgc2FuaXRpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHtcbiAgICAgICAgYnI6ICEwXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIHRvIG5vdGlmeSB0aGUgY29yZSB0aGF0IHJlYWQtb25seSBtb2RlIGlzIHN1cHBvcnRlZFxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBnZXQgaXNSZWFkT25seVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIFVzZWQgYnkgRWRpdG9yIHBhc3RlIGhhbmRsaW5nIEFQSS5cbiAgICogUHJvdmlkZXMgY29uZmlndXJhdGlvbiB0byBoYW5kbGUgUCB0YWdzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UGFzdGVDb25maWd9IC0gUGFyYWdyYXBoIFBhc3RlIFNldHRpbmdcbiAgICovXG4gIHN0YXRpYyBnZXQgcGFzdGVDb25maWcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZ3M6IFtcIlBcIl1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBJY29uIGFuZCB0aXRsZSBmb3IgZGlzcGxheWluZyBhdCB0aGUgVG9vbGJveFxuICAgKlxuICAgKiBAcmV0dXJucyB7VG9vbGJveENvbmZpZ30gLSBQYXJhZ3JhcGggVG9vbGJveCBTZXR0aW5nXG4gICAqL1xuICBzdGF0aWMgZ2V0IHRvb2xib3goKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGljb246IGEsXG4gICAgICB0aXRsZTogXCJUZXh0XCJcbiAgICB9O1xuICB9XG59XG5leHBvcnQge1xuICBuIGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@editorjs/paragraph/dist/paragraph.mjs\n\n}");

/***/ }),

/***/ "./node_modules/@editorjs/quote/dist/quote.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@editorjs/quote/dist/quote.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ m)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var t=document.createElement(\"style\");t.appendChild(document.createTextNode(\".cdx-quote-icon svg{transform:rotate(180deg)}.cdx-quote{margin:0}.cdx-quote__text{min-height:158px;margin-bottom:10px}.cdx-quote [contentEditable=true][data-placeholder]:before{position:absolute;content:attr(data-placeholder);color:#707684;font-weight:400;opacity:0}.cdx-quote [contentEditable=true][data-placeholder]:empty:before{opacity:1}.cdx-quote [contentEditable=true][data-placeholder]:empty:focus:before{opacity:0}.cdx-quote-settings{display:flex}.cdx-quote-settings .cdx-settings-button{width:50%}\")),document.head.appendChild(t)}}catch(e){console.error(\"vite-plugin-css-injected-by-js\",e)}})();\nconst De = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M18 7L6 7\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M18 17H6\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M16 12L8 12\"/></svg>', He = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M17 7L5 7\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M17 17H5\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-width=\"2\" d=\"M13 12L5 12\"/></svg>', Re = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M10 10.8182L9 10.8182C8.80222 10.8182 8.60888 10.7649 8.44443 10.665C8.27998 10.5651 8.15181 10.4231 8.07612 10.257C8.00043 10.0909 7.98063 9.90808 8.01922 9.73174C8.0578 9.55539 8.15304 9.39341 8.29289 9.26627C8.43275 9.13913 8.61093 9.05255 8.80491 9.01747C8.99889 8.98239 9.19996 9.00039 9.38268 9.0692C9.56541 9.13801 9.72159 9.25453 9.83147 9.40403C9.94135 9.55353 10 9.72929 10 9.90909L10 12.1818C10 12.664 9.78929 13.1265 9.41421 13.4675C9.03914 13.8084 8.53043 14 8 14\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M16 10.8182L15 10.8182C14.8022 10.8182 14.6089 10.7649 14.4444 10.665C14.28 10.5651 14.1518 10.4231 14.0761 10.257C14.0004 10.0909 13.9806 9.90808 14.0192 9.73174C14.0578 9.55539 14.153 9.39341 14.2929 9.26627C14.4327 9.13913 14.6109 9.05255 14.8049 9.01747C14.9989 8.98239 15.2 9.00039 15.3827 9.0692C15.5654 9.13801 15.7216 9.25453 15.8315 9.40403C15.9414 9.55353 16 9.72929 16 9.90909L16 12.1818C16 12.664 15.7893 13.1265 15.4142 13.4675C15.0391 13.8084 14.5304 14 14 14\"/></svg>';\nvar b = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction Fe(e) {\n  if (e.__esModule)\n    return e;\n  var t = e.default;\n  if (typeof t == \"function\") {\n    var n = function r() {\n      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);\n    };\n    n.prototype = t.prototype;\n  } else\n    n = {};\n  return Object.defineProperty(n, \"__esModule\", { value: !0 }), Object.keys(e).forEach(function(r) {\n    var i = Object.getOwnPropertyDescriptor(e, r);\n    Object.defineProperty(n, r, i.get ? i : {\n      enumerable: !0,\n      get: function() {\n        return e[r];\n      }\n    });\n  }), n;\n}\nvar v = {}, P = {}, j = {};\nObject.defineProperty(j, \"__esModule\", { value: !0 });\nj.allInputsSelector = We;\nfunction We() {\n  var e = [\"text\", \"password\", \"email\", \"number\", \"search\", \"tel\", \"url\"];\n  return \"[contenteditable=true], textarea, input:not([type]), \" + e.map(function(t) {\n    return 'input[type=\"'.concat(t, '\"]');\n  }).join(\", \");\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.allInputsSelector = void 0;\n  var t = j;\n  Object.defineProperty(e, \"allInputsSelector\", { enumerable: !0, get: function() {\n    return t.allInputsSelector;\n  } });\n})(P);\nvar c = {}, T = {};\nObject.defineProperty(T, \"__esModule\", { value: !0 });\nT.isNativeInput = Ue;\nfunction Ue(e) {\n  var t = [\n    \"INPUT\",\n    \"TEXTAREA\"\n  ];\n  return e && e.tagName ? t.includes(e.tagName) : !1;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isNativeInput = void 0;\n  var t = T;\n  Object.defineProperty(e, \"isNativeInput\", { enumerable: !0, get: function() {\n    return t.isNativeInput;\n  } });\n})(c);\nvar ie = {}, C = {};\nObject.defineProperty(C, \"__esModule\", { value: !0 });\nC.append = qe;\nfunction qe(e, t) {\n  Array.isArray(t) ? t.forEach(function(n) {\n    e.appendChild(n);\n  }) : e.appendChild(t);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.append = void 0;\n  var t = C;\n  Object.defineProperty(e, \"append\", { enumerable: !0, get: function() {\n    return t.append;\n  } });\n})(ie);\nvar L = {}, S = {};\nObject.defineProperty(S, \"__esModule\", { value: !0 });\nS.blockElements = ze;\nfunction ze() {\n  return [\n    \"address\",\n    \"article\",\n    \"aside\",\n    \"blockquote\",\n    \"canvas\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"li\",\n    \"main\",\n    \"nav\",\n    \"noscript\",\n    \"ol\",\n    \"output\",\n    \"p\",\n    \"pre\",\n    \"ruby\",\n    \"section\",\n    \"table\",\n    \"tbody\",\n    \"thead\",\n    \"tr\",\n    \"tfoot\",\n    \"ul\",\n    \"video\"\n  ];\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.blockElements = void 0;\n  var t = S;\n  Object.defineProperty(e, \"blockElements\", { enumerable: !0, get: function() {\n    return t.blockElements;\n  } });\n})(L);\nvar ae = {}, M = {};\nObject.defineProperty(M, \"__esModule\", { value: !0 });\nM.calculateBaseline = Ge;\nfunction Ge(e) {\n  var t = window.getComputedStyle(e), n = parseFloat(t.fontSize), r = parseFloat(t.lineHeight) || n * 1.2, i = parseFloat(t.paddingTop), a = parseFloat(t.borderTopWidth), l = parseFloat(t.marginTop), u = n * 0.8, d = (r - n) / 2, s = l + a + i + d + u;\n  return s;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.calculateBaseline = void 0;\n  var t = M;\n  Object.defineProperty(e, \"calculateBaseline\", { enumerable: !0, get: function() {\n    return t.calculateBaseline;\n  } });\n})(ae);\nvar le = {}, k = {}, w = {}, N = {};\nObject.defineProperty(N, \"__esModule\", { value: !0 });\nN.isContentEditable = Ke;\nfunction Ke(e) {\n  return e.contentEditable === \"true\";\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isContentEditable = void 0;\n  var t = N;\n  Object.defineProperty(e, \"isContentEditable\", { enumerable: !0, get: function() {\n    return t.isContentEditable;\n  } });\n})(w);\nObject.defineProperty(k, \"__esModule\", { value: !0 });\nk.canSetCaret = Qe;\nvar Xe = c, Ye = w;\nfunction Qe(e) {\n  var t = !0;\n  if ((0, Xe.isNativeInput)(e))\n    switch (e.type) {\n      case \"file\":\n      case \"checkbox\":\n      case \"radio\":\n      case \"hidden\":\n      case \"submit\":\n      case \"button\":\n      case \"image\":\n      case \"reset\":\n        t = !1;\n        break;\n    }\n  else\n    t = (0, Ye.isContentEditable)(e);\n  return t;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.canSetCaret = void 0;\n  var t = k;\n  Object.defineProperty(e, \"canSetCaret\", { enumerable: !0, get: function() {\n    return t.canSetCaret;\n  } });\n})(le);\nvar y = {}, I = {};\nfunction Ve(e, t, n) {\n  const r = n.value !== void 0 ? \"value\" : \"get\", i = n[r], a = `#${t}Cache`;\n  if (n[r] = function(...l) {\n    return this[a] === void 0 && (this[a] = i.apply(this, l)), this[a];\n  }, r === \"get\" && n.set) {\n    const l = n.set;\n    n.set = function(u) {\n      delete e[a], l.apply(this, u);\n    };\n  }\n  return n;\n}\nfunction ue() {\n  const e = {\n    win: !1,\n    mac: !1,\n    x11: !1,\n    linux: !1\n  }, t = Object.keys(e).find((n) => window.navigator.appVersion.toLowerCase().indexOf(n) !== -1);\n  return t !== void 0 && (e[t] = !0), e;\n}\nfunction A(e) {\n  return e != null && e !== \"\" && (typeof e != \"object\" || Object.keys(e).length > 0);\n}\nfunction Ze(e) {\n  return !A(e);\n}\nconst Je = () => typeof window < \"u\" && window.navigator !== null && A(window.navigator.platform) && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === \"MacIntel\" && window.navigator.maxTouchPoints > 1);\nfunction xe(e) {\n  const t = ue();\n  return e = e.replace(/shift/gi, \"⇧\").replace(/backspace/gi, \"⌫\").replace(/enter/gi, \"⏎\").replace(/up/gi, \"↑\").replace(/left/gi, \"→\").replace(/down/gi, \"↓\").replace(/right/gi, \"←\").replace(/escape/gi, \"⎋\").replace(/insert/gi, \"Ins\").replace(/delete/gi, \"␡\").replace(/\\+/gi, \"+\"), t.mac ? e = e.replace(/ctrl|cmd/gi, \"⌘\").replace(/alt/gi, \"⌥\") : e = e.replace(/cmd/gi, \"Ctrl\").replace(/windows/gi, \"WIN\"), e;\n}\nfunction et(e) {\n  return e[0].toUpperCase() + e.slice(1);\n}\nfunction tt(e) {\n  const t = document.createElement(\"div\");\n  t.style.position = \"absolute\", t.style.left = \"-999px\", t.style.bottom = \"-999px\", t.innerHTML = e, document.body.appendChild(t);\n  const n = window.getSelection(), r = document.createRange();\n  if (r.selectNode(t), n === null)\n    throw new Error(\"Cannot copy text to clipboard\");\n  n.removeAllRanges(), n.addRange(r), document.execCommand(\"copy\"), document.body.removeChild(t);\n}\nfunction nt(e, t, n) {\n  let r;\n  return (...i) => {\n    const a = this, l = () => {\n      r = void 0, n !== !0 && e.apply(a, i);\n    }, u = n === !0 && r !== void 0;\n    window.clearTimeout(r), r = window.setTimeout(l, t), u && e.apply(a, i);\n  };\n}\nfunction o(e) {\n  return Object.prototype.toString.call(e).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n}\nfunction rt(e) {\n  return o(e) === \"boolean\";\n}\nfunction oe(e) {\n  return o(e) === \"function\" || o(e) === \"asyncfunction\";\n}\nfunction it(e) {\n  return oe(e) && /^\\s*class\\s+/.test(e.toString());\n}\nfunction at(e) {\n  return o(e) === \"number\";\n}\nfunction g(e) {\n  return o(e) === \"object\";\n}\nfunction lt(e) {\n  return Promise.resolve(e) === e;\n}\nfunction ut(e) {\n  return o(e) === \"string\";\n}\nfunction ot(e) {\n  return o(e) === \"undefined\";\n}\nfunction O(e, ...t) {\n  if (!t.length)\n    return e;\n  const n = t.shift();\n  if (g(e) && g(n))\n    for (const r in n)\n      g(n[r]) ? (e[r] === void 0 && Object.assign(e, { [r]: {} }), O(e[r], n[r])) : Object.assign(e, { [r]: n[r] });\n  return O(e, ...t);\n}\nfunction st(e, t, n) {\n  const r = `«${t}» is deprecated and will be removed in the next major release. Please use the «${n}» instead.`;\n  e && console.warn(r);\n}\nfunction ct(e) {\n  try {\n    return new URL(e).href;\n  } catch {\n  }\n  return e.substring(0, 2) === \"//\" ? window.location.protocol + e : window.location.origin + e;\n}\nfunction dt(e) {\n  return e > 47 && e < 58 || e === 32 || e === 13 || e === 229 || e > 64 && e < 91 || e > 95 && e < 112 || e > 185 && e < 193 || e > 218 && e < 223;\n}\nconst ft = {\n  BACKSPACE: 8,\n  TAB: 9,\n  ENTER: 13,\n  SHIFT: 16,\n  CTRL: 17,\n  ALT: 18,\n  ESC: 27,\n  SPACE: 32,\n  LEFT: 37,\n  UP: 38,\n  DOWN: 40,\n  RIGHT: 39,\n  DELETE: 46,\n  META: 91,\n  SLASH: 191\n}, pt = {\n  LEFT: 0,\n  WHEEL: 1,\n  RIGHT: 2,\n  BACKWARD: 3,\n  FORWARD: 4\n};\nclass vt {\n  constructor() {\n    this.completed = Promise.resolve();\n  }\n  /**\n   * Add new promise to queue\n   * @param operation - promise should be added to queue\n   */\n  add(t) {\n    return new Promise((n, r) => {\n      this.completed = this.completed.then(t).then(n).catch(r);\n    });\n  }\n}\nfunction gt(e, t, n = void 0) {\n  let r, i, a, l = null, u = 0;\n  n || (n = {});\n  const d = function() {\n    u = n.leading === !1 ? 0 : Date.now(), l = null, a = e.apply(r, i), l === null && (r = i = null);\n  };\n  return function() {\n    const s = Date.now();\n    !u && n.leading === !1 && (u = s);\n    const f = t - (s - u);\n    return r = this, i = arguments, f <= 0 || f > t ? (l && (clearTimeout(l), l = null), u = s, a = e.apply(r, i), l === null && (r = i = null)) : !l && n.trailing !== !1 && (l = setTimeout(d, f)), a;\n  };\n}\nconst mt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  PromiseQueue: vt,\n  beautifyShortcut: xe,\n  cacheable: Ve,\n  capitalize: et,\n  copyTextToClipboard: tt,\n  debounce: nt,\n  deepMerge: O,\n  deprecationAssert: st,\n  getUserOS: ue,\n  getValidUrl: ct,\n  isBoolean: rt,\n  isClass: it,\n  isEmpty: Ze,\n  isFunction: oe,\n  isIosDevice: Je,\n  isNumber: at,\n  isObject: g,\n  isPrintableKey: dt,\n  isPromise: lt,\n  isString: ut,\n  isUndefined: ot,\n  keyCodes: ft,\n  mouseButtons: pt,\n  notEmpty: A,\n  throttle: gt,\n  typeOf: o\n}, Symbol.toStringTag, { value: \"Module\" })), $ = /* @__PURE__ */ Fe(mt);\nObject.defineProperty(I, \"__esModule\", { value: !0 });\nI.containsOnlyInlineElements = _t;\nvar bt = $, yt = L;\nfunction _t(e) {\n  var t;\n  (0, bt.isString)(e) ? (t = document.createElement(\"div\"), t.innerHTML = e) : t = e;\n  var n = function(r) {\n    return !(0, yt.blockElements)().includes(r.tagName.toLowerCase()) && Array.from(r.children).every(n);\n  };\n  return Array.from(t.children).every(n);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.containsOnlyInlineElements = void 0;\n  var t = I;\n  Object.defineProperty(e, \"containsOnlyInlineElements\", { enumerable: !0, get: function() {\n    return t.containsOnlyInlineElements;\n  } });\n})(y);\nvar se = {}, B = {}, _ = {}, D = {};\nObject.defineProperty(D, \"__esModule\", { value: !0 });\nD.make = ht;\nfunction ht(e, t, n) {\n  var r;\n  t === void 0 && (t = null), n === void 0 && (n = {});\n  var i = document.createElement(e);\n  if (Array.isArray(t)) {\n    var a = t.filter(function(u) {\n      return u !== void 0;\n    });\n    (r = i.classList).add.apply(r, a);\n  } else\n    t !== null && i.classList.add(t);\n  for (var l in n)\n    Object.prototype.hasOwnProperty.call(n, l) && (i[l] = n[l]);\n  return i;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.make = void 0;\n  var t = D;\n  Object.defineProperty(e, \"make\", { enumerable: !0, get: function() {\n    return t.make;\n  } });\n})(_);\nObject.defineProperty(B, \"__esModule\", { value: !0 });\nB.fragmentToString = Ot;\nvar Et = _;\nfunction Ot(e) {\n  var t = (0, Et.make)(\"div\");\n  return t.appendChild(e), t.innerHTML;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.fragmentToString = void 0;\n  var t = B;\n  Object.defineProperty(e, \"fragmentToString\", { enumerable: !0, get: function() {\n    return t.fragmentToString;\n  } });\n})(se);\nvar ce = {}, H = {};\nObject.defineProperty(H, \"__esModule\", { value: !0 });\nH.getContentLength = jt;\nvar Pt = c;\nfunction jt(e) {\n  var t, n;\n  return (0, Pt.isNativeInput)(e) ? e.value.length : e.nodeType === Node.TEXT_NODE ? e.length : (n = (t = e.textContent) === null || t === void 0 ? void 0 : t.length) !== null && n !== void 0 ? n : 0;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.getContentLength = void 0;\n  var t = H;\n  Object.defineProperty(e, \"getContentLength\", { enumerable: !0, get: function() {\n    return t.getContentLength;\n  } });\n})(ce);\nvar R = {}, F = {}, re = b && b.__spreadArray || function(e, t, n) {\n  if (n || arguments.length === 2)\n    for (var r = 0, i = t.length, a; r < i; r++)\n      (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);\n  return e.concat(a || Array.prototype.slice.call(t));\n};\nObject.defineProperty(F, \"__esModule\", { value: !0 });\nF.getDeepestBlockElements = de;\nvar Tt = y;\nfunction de(e) {\n  return (0, Tt.containsOnlyInlineElements)(e) ? [e] : Array.from(e.children).reduce(function(t, n) {\n    return re(re([], t, !0), de(n), !0);\n  }, []);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.getDeepestBlockElements = void 0;\n  var t = F;\n  Object.defineProperty(e, \"getDeepestBlockElements\", { enumerable: !0, get: function() {\n    return t.getDeepestBlockElements;\n  } });\n})(R);\nvar fe = {}, W = {}, h = {}, U = {};\nObject.defineProperty(U, \"__esModule\", { value: !0 });\nU.isLineBreakTag = Ct;\nfunction Ct(e) {\n  return [\n    \"BR\",\n    \"WBR\"\n  ].includes(e.tagName);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isLineBreakTag = void 0;\n  var t = U;\n  Object.defineProperty(e, \"isLineBreakTag\", { enumerable: !0, get: function() {\n    return t.isLineBreakTag;\n  } });\n})(h);\nvar E = {}, q = {};\nObject.defineProperty(q, \"__esModule\", { value: !0 });\nq.isSingleTag = Lt;\nfunction Lt(e) {\n  return [\n    \"AREA\",\n    \"BASE\",\n    \"BR\",\n    \"COL\",\n    \"COMMAND\",\n    \"EMBED\",\n    \"HR\",\n    \"IMG\",\n    \"INPUT\",\n    \"KEYGEN\",\n    \"LINK\",\n    \"META\",\n    \"PARAM\",\n    \"SOURCE\",\n    \"TRACK\",\n    \"WBR\"\n  ].includes(e.tagName);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isSingleTag = void 0;\n  var t = q;\n  Object.defineProperty(e, \"isSingleTag\", { enumerable: !0, get: function() {\n    return t.isSingleTag;\n  } });\n})(E);\nObject.defineProperty(W, \"__esModule\", { value: !0 });\nW.getDeepestNode = pe;\nvar St = c, Mt = h, kt = E;\nfunction pe(e, t) {\n  t === void 0 && (t = !1);\n  var n = t ? \"lastChild\" : \"firstChild\", r = t ? \"previousSibling\" : \"nextSibling\";\n  if (e.nodeType === Node.ELEMENT_NODE && e[n]) {\n    var i = e[n];\n    if ((0, kt.isSingleTag)(i) && !(0, St.isNativeInput)(i) && !(0, Mt.isLineBreakTag)(i))\n      if (i[r])\n        i = i[r];\n      else if (i.parentNode !== null && i.parentNode[r])\n        i = i.parentNode[r];\n      else\n        return i.parentNode;\n    return pe(i, t);\n  }\n  return e;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.getDeepestNode = void 0;\n  var t = W;\n  Object.defineProperty(e, \"getDeepestNode\", { enumerable: !0, get: function() {\n    return t.getDeepestNode;\n  } });\n})(fe);\nvar ve = {}, z = {}, p = b && b.__spreadArray || function(e, t, n) {\n  if (n || arguments.length === 2)\n    for (var r = 0, i = t.length, a; r < i; r++)\n      (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);\n  return e.concat(a || Array.prototype.slice.call(t));\n};\nObject.defineProperty(z, \"__esModule\", { value: !0 });\nz.findAllInputs = $t;\nvar wt = y, Nt = R, It = P, At = c;\nfunction $t(e) {\n  return Array.from(e.querySelectorAll((0, It.allInputsSelector)())).reduce(function(t, n) {\n    return (0, At.isNativeInput)(n) || (0, wt.containsOnlyInlineElements)(n) ? p(p([], t, !0), [n], !1) : p(p([], t, !0), (0, Nt.getDeepestBlockElements)(n), !0);\n  }, []);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.findAllInputs = void 0;\n  var t = z;\n  Object.defineProperty(e, \"findAllInputs\", { enumerable: !0, get: function() {\n    return t.findAllInputs;\n  } });\n})(ve);\nvar ge = {}, G = {};\nObject.defineProperty(G, \"__esModule\", { value: !0 });\nG.isCollapsedWhitespaces = Bt;\nfunction Bt(e) {\n  return !/[^\\t\\n\\r ]/.test(e);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isCollapsedWhitespaces = void 0;\n  var t = G;\n  Object.defineProperty(e, \"isCollapsedWhitespaces\", { enumerable: !0, get: function() {\n    return t.isCollapsedWhitespaces;\n  } });\n})(ge);\nvar K = {}, X = {};\nObject.defineProperty(X, \"__esModule\", { value: !0 });\nX.isElement = Ht;\nvar Dt = $;\nfunction Ht(e) {\n  return (0, Dt.isNumber)(e) ? !1 : !!e && !!e.nodeType && e.nodeType === Node.ELEMENT_NODE;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isElement = void 0;\n  var t = X;\n  Object.defineProperty(e, \"isElement\", { enumerable: !0, get: function() {\n    return t.isElement;\n  } });\n})(K);\nvar me = {}, Y = {}, Q = {}, V = {};\nObject.defineProperty(V, \"__esModule\", { value: !0 });\nV.isLeaf = Rt;\nfunction Rt(e) {\n  return e === null ? !1 : e.childNodes.length === 0;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isLeaf = void 0;\n  var t = V;\n  Object.defineProperty(e, \"isLeaf\", { enumerable: !0, get: function() {\n    return t.isLeaf;\n  } });\n})(Q);\nvar Z = {}, J = {};\nObject.defineProperty(J, \"__esModule\", { value: !0 });\nJ.isNodeEmpty = zt;\nvar Ft = h, Wt = K, Ut = c, qt = E;\nfunction zt(e, t) {\n  var n = \"\";\n  return (0, qt.isSingleTag)(e) && !(0, Ft.isLineBreakTag)(e) ? !1 : ((0, Wt.isElement)(e) && (0, Ut.isNativeInput)(e) ? n = e.value : e.textContent !== null && (n = e.textContent.replace(\"​\", \"\")), t !== void 0 && (n = n.replace(new RegExp(t, \"g\"), \"\")), n.trim().length === 0);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isNodeEmpty = void 0;\n  var t = J;\n  Object.defineProperty(e, \"isNodeEmpty\", { enumerable: !0, get: function() {\n    return t.isNodeEmpty;\n  } });\n})(Z);\nObject.defineProperty(Y, \"__esModule\", { value: !0 });\nY.isEmpty = Xt;\nvar Gt = Q, Kt = Z;\nfunction Xt(e, t) {\n  e.normalize();\n  for (var n = [e]; n.length > 0; ) {\n    var r = n.shift();\n    if (r) {\n      if (e = r, (0, Gt.isLeaf)(e) && !(0, Kt.isNodeEmpty)(e, t))\n        return !1;\n      n.push.apply(n, Array.from(e.childNodes));\n    }\n  }\n  return !0;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isEmpty = void 0;\n  var t = Y;\n  Object.defineProperty(e, \"isEmpty\", { enumerable: !0, get: function() {\n    return t.isEmpty;\n  } });\n})(me);\nvar be = {}, x = {};\nObject.defineProperty(x, \"__esModule\", { value: !0 });\nx.isFragment = Qt;\nvar Yt = $;\nfunction Qt(e) {\n  return (0, Yt.isNumber)(e) ? !1 : !!e && !!e.nodeType && e.nodeType === Node.DOCUMENT_FRAGMENT_NODE;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isFragment = void 0;\n  var t = x;\n  Object.defineProperty(e, \"isFragment\", { enumerable: !0, get: function() {\n    return t.isFragment;\n  } });\n})(be);\nvar ye = {}, ee = {};\nObject.defineProperty(ee, \"__esModule\", { value: !0 });\nee.isHTMLString = Zt;\nvar Vt = _;\nfunction Zt(e) {\n  var t = (0, Vt.make)(\"div\");\n  return t.innerHTML = e, t.childElementCount > 0;\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.isHTMLString = void 0;\n  var t = ee;\n  Object.defineProperty(e, \"isHTMLString\", { enumerable: !0, get: function() {\n    return t.isHTMLString;\n  } });\n})(ye);\nvar _e = {}, te = {};\nObject.defineProperty(te, \"__esModule\", { value: !0 });\nte.offset = Jt;\nfunction Jt(e) {\n  var t = e.getBoundingClientRect(), n = window.pageXOffset || document.documentElement.scrollLeft, r = window.pageYOffset || document.documentElement.scrollTop, i = t.top + r, a = t.left + n;\n  return {\n    top: i,\n    left: a,\n    bottom: i + t.height,\n    right: a + t.width\n  };\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.offset = void 0;\n  var t = te;\n  Object.defineProperty(e, \"offset\", { enumerable: !0, get: function() {\n    return t.offset;\n  } });\n})(_e);\nvar he = {}, ne = {};\nObject.defineProperty(ne, \"__esModule\", { value: !0 });\nne.prepend = xt;\nfunction xt(e, t) {\n  Array.isArray(t) ? (t = t.reverse(), t.forEach(function(n) {\n    return e.prepend(n);\n  })) : e.prepend(t);\n}\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.prepend = void 0;\n  var t = ne;\n  Object.defineProperty(e, \"prepend\", { enumerable: !0, get: function() {\n    return t.prepend;\n  } });\n})(he);\n(function(e) {\n  Object.defineProperty(e, \"__esModule\", { value: !0 }), e.prepend = e.offset = e.make = e.isLineBreakTag = e.isSingleTag = e.isNodeEmpty = e.isLeaf = e.isHTMLString = e.isFragment = e.isEmpty = e.isElement = e.isContentEditable = e.isCollapsedWhitespaces = e.findAllInputs = e.isNativeInput = e.allInputsSelector = e.getDeepestNode = e.getDeepestBlockElements = e.getContentLength = e.fragmentToString = e.containsOnlyInlineElements = e.canSetCaret = e.calculateBaseline = e.blockElements = e.append = void 0;\n  var t = P;\n  Object.defineProperty(e, \"allInputsSelector\", { enumerable: !0, get: function() {\n    return t.allInputsSelector;\n  } });\n  var n = c;\n  Object.defineProperty(e, \"isNativeInput\", { enumerable: !0, get: function() {\n    return n.isNativeInput;\n  } });\n  var r = ie;\n  Object.defineProperty(e, \"append\", { enumerable: !0, get: function() {\n    return r.append;\n  } });\n  var i = L;\n  Object.defineProperty(e, \"blockElements\", { enumerable: !0, get: function() {\n    return i.blockElements;\n  } });\n  var a = ae;\n  Object.defineProperty(e, \"calculateBaseline\", { enumerable: !0, get: function() {\n    return a.calculateBaseline;\n  } });\n  var l = le;\n  Object.defineProperty(e, \"canSetCaret\", { enumerable: !0, get: function() {\n    return l.canSetCaret;\n  } });\n  var u = y;\n  Object.defineProperty(e, \"containsOnlyInlineElements\", { enumerable: !0, get: function() {\n    return u.containsOnlyInlineElements;\n  } });\n  var d = se;\n  Object.defineProperty(e, \"fragmentToString\", { enumerable: !0, get: function() {\n    return d.fragmentToString;\n  } });\n  var s = ce;\n  Object.defineProperty(e, \"getContentLength\", { enumerable: !0, get: function() {\n    return s.getContentLength;\n  } });\n  var f = R;\n  Object.defineProperty(e, \"getDeepestBlockElements\", { enumerable: !0, get: function() {\n    return f.getDeepestBlockElements;\n  } });\n  var Oe = fe;\n  Object.defineProperty(e, \"getDeepestNode\", { enumerable: !0, get: function() {\n    return Oe.getDeepestNode;\n  } });\n  var Pe = ve;\n  Object.defineProperty(e, \"findAllInputs\", { enumerable: !0, get: function() {\n    return Pe.findAllInputs;\n  } });\n  var je = ge;\n  Object.defineProperty(e, \"isCollapsedWhitespaces\", { enumerable: !0, get: function() {\n    return je.isCollapsedWhitespaces;\n  } });\n  var Te = w;\n  Object.defineProperty(e, \"isContentEditable\", { enumerable: !0, get: function() {\n    return Te.isContentEditable;\n  } });\n  var Ce = K;\n  Object.defineProperty(e, \"isElement\", { enumerable: !0, get: function() {\n    return Ce.isElement;\n  } });\n  var Le = me;\n  Object.defineProperty(e, \"isEmpty\", { enumerable: !0, get: function() {\n    return Le.isEmpty;\n  } });\n  var Se = be;\n  Object.defineProperty(e, \"isFragment\", { enumerable: !0, get: function() {\n    return Se.isFragment;\n  } });\n  var Me = ye;\n  Object.defineProperty(e, \"isHTMLString\", { enumerable: !0, get: function() {\n    return Me.isHTMLString;\n  } });\n  var ke = Q;\n  Object.defineProperty(e, \"isLeaf\", { enumerable: !0, get: function() {\n    return ke.isLeaf;\n  } });\n  var we = Z;\n  Object.defineProperty(e, \"isNodeEmpty\", { enumerable: !0, get: function() {\n    return we.isNodeEmpty;\n  } });\n  var Ne = h;\n  Object.defineProperty(e, \"isLineBreakTag\", { enumerable: !0, get: function() {\n    return Ne.isLineBreakTag;\n  } });\n  var Ie = E;\n  Object.defineProperty(e, \"isSingleTag\", { enumerable: !0, get: function() {\n    return Ie.isSingleTag;\n  } });\n  var Ae = _;\n  Object.defineProperty(e, \"make\", { enumerable: !0, get: function() {\n    return Ae.make;\n  } });\n  var $e = _e;\n  Object.defineProperty(e, \"offset\", { enumerable: !0, get: function() {\n    return $e.offset;\n  } });\n  var Be = he;\n  Object.defineProperty(e, \"prepend\", { enumerable: !0, get: function() {\n    return Be.prepend;\n  } });\n})(v);\nvar Ee = /* @__PURE__ */ ((e) => (e.Left = \"left\", e.Center = \"center\", e))(Ee || {});\nclass m {\n  /**\n   * Render plugin`s main Element and fill it with saved data\n   * @param params - Quote Tool constructor params\n   * @param params.data - previously saved data\n   * @param params.config - user config for Tool\n   * @param params.api - editor.js api\n   * @param params.readOnly - read only mode flag\n   */\n  constructor({ data: t, config: n, api: r, readOnly: i, block: a }) {\n    const { DEFAULT_ALIGNMENT: l } = m;\n    this.api = r, this.readOnly = i, this.quotePlaceholder = r.i18n.t((n == null ? void 0 : n.quotePlaceholder) ?? m.DEFAULT_QUOTE_PLACEHOLDER), this.captionPlaceholder = r.i18n.t((n == null ? void 0 : n.captionPlaceholder) ?? m.DEFAULT_CAPTION_PLACEHOLDER), this.data = {\n      text: t.text || \"\",\n      caption: t.caption || \"\",\n      alignment: Object.values(Ee).includes(t.alignment) ? t.alignment : (n == null ? void 0 : n.defaultAlignment) ?? l\n    }, this.css = {\n      baseClass: this.api.styles.block,\n      wrapper: \"cdx-quote\",\n      text: \"cdx-quote__text\",\n      input: this.api.styles.input,\n      caption: \"cdx-quote__caption\"\n    }, this.block = a;\n  }\n  /**\n   * Notify core that read-only mode is supported\n   * @returns true\n   */\n  static get isReadOnlySupported() {\n    return !0;\n  }\n  /**\n   * Get Tool toolbox settings\n   * icon - Tool icon's SVG\n   * title - title to show in toolbox\n   * @returns icon and title of the toolbox\n   */\n  static get toolbox() {\n    return {\n      icon: Re,\n      title: \"Quote\"\n    };\n  }\n  /**\n   * Empty Quote is not empty Block\n   * @returns true\n   */\n  static get contentless() {\n    return !0;\n  }\n  /**\n   * Allow to press Enter inside the Quote\n   * @returns true\n   */\n  static get enableLineBreaks() {\n    return !0;\n  }\n  /**\n   * Default placeholder for quote text\n   * @returns 'Enter a quote'\n   */\n  static get DEFAULT_QUOTE_PLACEHOLDER() {\n    return \"Enter a quote\";\n  }\n  /**\n   * Default placeholder for quote caption\n   * @returns 'Enter a caption'\n   */\n  static get DEFAULT_CAPTION_PLACEHOLDER() {\n    return \"Enter a caption\";\n  }\n  /**\n   * Default quote alignment\n   * @returns Alignment.Left\n   */\n  static get DEFAULT_ALIGNMENT() {\n    return \"left\";\n  }\n  /**\n   * Allow Quote to be converted to/from other blocks\n   * @returns conversion config object\n   */\n  static get conversionConfig() {\n    return {\n      /**\n       * To create Quote data from string, simple fill 'text' property\n       */\n      import: \"text\",\n      /**\n       * To create string from Quote data, concatenate text and caption\n       * @param quoteData - Quote data object\n       * @returns string\n       */\n      export: function(t) {\n        return t.caption ? `${t.text} — ${t.caption}` : t.text;\n      }\n    };\n  }\n  /**\n   * Tool`s styles\n   * @returns CSS classes names\n   */\n  get CSS() {\n    return {\n      baseClass: this.api.styles.block,\n      wrapper: \"cdx-quote\",\n      text: \"cdx-quote__text\",\n      input: this.api.styles.input,\n      caption: \"cdx-quote__caption\"\n    };\n  }\n  /**\n   * Tool`s settings properties\n   * @returns settings properties\n   */\n  get settings() {\n    return [\n      {\n        name: \"left\",\n        icon: He\n      },\n      {\n        name: \"center\",\n        icon: De\n      }\n    ];\n  }\n  /**\n   * Create Quote Tool container with inputs\n   * @returns blockquote DOM element - Quote Tool container\n   */\n  render() {\n    const t = v.make(\"blockquote\", [\n      this.css.baseClass,\n      this.css.wrapper\n    ]), n = v.make(\"div\", [this.css.input, this.css.text], {\n      contentEditable: !this.readOnly,\n      innerHTML: this.data.text\n    }), r = v.make(\"div\", [this.css.input, this.css.caption], {\n      contentEditable: !this.readOnly,\n      innerHTML: this.data.caption\n    });\n    return n.dataset.placeholder = this.quotePlaceholder, r.dataset.placeholder = this.captionPlaceholder, t.appendChild(n), t.appendChild(r), t;\n  }\n  /**\n   * Extract Quote data from Quote Tool element\n   * @param quoteElement - Quote DOM element to save\n   * @returns Quote data object\n   */\n  save(t) {\n    const n = t.querySelector(`.${this.css.text}`), r = t.querySelector(`.${this.css.caption}`);\n    return Object.assign(this.data, {\n      text: (n == null ? void 0 : n.innerHTML) ?? \"\",\n      caption: (r == null ? void 0 : r.innerHTML) ?? \"\"\n    });\n  }\n  /**\n   * Sanitizer rules\n   * @returns sanitizer rules\n   */\n  static get sanitize() {\n    return {\n      text: {\n        br: !0\n      },\n      caption: {\n        br: !0\n      },\n      alignment: {}\n    };\n  }\n  /**\n   * Create wrapper for Tool`s settings buttons:\n   * 1. Left alignment\n   * 2. Center alignment\n   * @returns settings menu\n   */\n  renderSettings() {\n    const t = (n) => n && n[0].toUpperCase() + n.slice(1);\n    return this.settings.map((n) => ({\n      icon: n.icon,\n      label: this.api.i18n.t(`Align ${t(n.name)}`),\n      onActivate: () => this._toggleTune(n.name),\n      isActive: this.data.alignment === n.name,\n      closeOnActivate: !0\n    }));\n  }\n  /**\n   * Toggle quote`s alignment\n   * @param tune - alignment\n   */\n  _toggleTune(t) {\n    this.data.alignment = t, this.block.dispatchChange();\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL3F1b3RlL2Rpc3QvcXVvdGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxZQUFZLGFBQWEsSUFBSSx3QkFBd0Isc0NBQXNDLDJEQUEyRCx5QkFBeUIsV0FBVyxTQUFTLGlCQUFpQixpQkFBaUIsbUJBQW1CLDJEQUEyRCxrQkFBa0IsK0JBQStCLGNBQWMsZ0JBQWdCLFVBQVUsaUVBQWlFLFVBQVUsdUVBQXVFLFVBQVUsb0JBQW9CLGFBQWEseUNBQXlDLFVBQVUsa0NBQWtDLFNBQVMsbURBQW1EO0FBQzF0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLFVBQVUsUUFBUTtBQUNsQix5Q0FBeUMsV0FBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0QsVUFBVTtBQUNWLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCxXQUFXO0FBQ1gseUNBQXlDLFdBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCxVQUFVO0FBQ1YseUNBQXlDLFdBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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d2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL3F1b3RlL2Rpc3QvcXVvdGUubWpzPzY1MTIiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dHJ5e2lmKHR5cGVvZiBkb2N1bWVudDxcInVcIil7dmFyIHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO3QuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIuY2R4LXF1b3RlLWljb24gc3Zne3RyYW5zZm9ybTpyb3RhdGUoMTgwZGVnKX0uY2R4LXF1b3Rle21hcmdpbjowfS5jZHgtcXVvdGVfX3RleHR7bWluLWhlaWdodDoxNThweDttYXJnaW4tYm90dG9tOjEwcHh9LmNkeC1xdW90ZSBbY29udGVudEVkaXRhYmxlPXRydWVdW2RhdGEtcGxhY2Vob2xkZXJdOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTtjb250ZW50OmF0dHIoZGF0YS1wbGFjZWhvbGRlcik7Y29sb3I6IzcwNzY4NDtmb250LXdlaWdodDo0MDA7b3BhY2l0eTowfS5jZHgtcXVvdGUgW2NvbnRlbnRFZGl0YWJsZT10cnVlXVtkYXRhLXBsYWNlaG9sZGVyXTplbXB0eTpiZWZvcmV7b3BhY2l0eToxfS5jZHgtcXVvdGUgW2NvbnRlbnRFZGl0YWJsZT10cnVlXVtkYXRhLXBsYWNlaG9sZGVyXTplbXB0eTpmb2N1czpiZWZvcmV7b3BhY2l0eTowfS5jZHgtcXVvdGUtc2V0dGluZ3N7ZGlzcGxheTpmbGV4fS5jZHgtcXVvdGUtc2V0dGluZ3MgLmNkeC1zZXR0aW5ncy1idXR0b257d2lkdGg6NTAlfVwiKSksZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0KX19Y2F0Y2goZSl7Y29uc29sZS5lcnJvcihcInZpdGUtcGx1Z2luLWNzcy1pbmplY3RlZC1ieS1qc1wiLGUpfX0pKCk7XG5jb25zdCBEZSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTggN0w2IDdcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE4IDE3SDZcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE2IDEyTDggMTJcIi8+PC9zdmc+JywgSGUgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTE3IDdMNSA3XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xNyAxN0g1XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xMyAxMkw1IDEyXCIvPjwvc3ZnPicsIFJlID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTEwIDEwLjgxODJMOSAxMC44MTgyQzguODAyMjIgMTAuODE4MiA4LjYwODg4IDEwLjc2NDkgOC40NDQ0MyAxMC42NjVDOC4yNzk5OCAxMC41NjUxIDguMTUxODEgMTAuNDIzMSA4LjA3NjEyIDEwLjI1N0M4LjAwMDQzIDEwLjA5MDkgNy45ODA2MyA5LjkwODA4IDguMDE5MjIgOS43MzE3NEM4LjA1NzggOS41NTUzOSA4LjE1MzA0IDkuMzkzNDEgOC4yOTI4OSA5LjI2NjI3QzguNDMyNzUgOS4xMzkxMyA4LjYxMDkzIDkuMDUyNTUgOC44MDQ5MSA5LjAxNzQ3QzguOTk4ODkgOC45ODIzOSA5LjE5OTk2IDkuMDAwMzkgOS4zODI2OCA5LjA2OTJDOS41NjU0MSA5LjEzODAxIDkuNzIxNTkgOS4yNTQ1MyA5LjgzMTQ3IDkuNDA0MDNDOS45NDEzNSA5LjU1MzUzIDEwIDkuNzI5MjkgMTAgOS45MDkwOUwxMCAxMi4xODE4QzEwIDEyLjY2NCA5Ljc4OTI5IDEzLjEyNjUgOS40MTQyMSAxMy40Njc1QzkuMDM5MTQgMTMuODA4NCA4LjUzMDQzIDE0IDggMTRcIi8+PHBhdGggc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGQ9XCJNMTYgMTAuODE4MkwxNSAxMC44MTgyQzE0LjgwMjIgMTAuODE4MiAxNC42MDg5IDEwLjc2NDkgMTQuNDQ0NCAxMC42NjVDMTQuMjggMTAuNTY1MSAxNC4xNTE4IDEwLjQyMzEgMTQuMDc2MSAxMC4yNTdDMTQuMDAwNCAxMC4wOTA5IDEzLjk4MDYgOS45MDgwOCAxNC4wMTkyIDkuNzMxNzRDMTQuMDU3OCA5LjU1NTM5IDE0LjE1MyA5LjM5MzQxIDE0LjI5MjkgOS4yNjYyN0MxNC40MzI3IDkuMTM5MTMgMTQuNjEwOSA5LjA1MjU1IDE0LjgwNDkgOS4wMTc0N0MxNC45OTg5IDguOTgyMzkgMTUuMiA5LjAwMDM5IDE1LjM4MjcgOS4wNjkyQzE1LjU2NTQgOS4xMzgwMSAxNS43MjE2IDkuMjU0NTMgMTUuODMxNSA5LjQwNDAzQzE1Ljk0MTQgOS41NTM1MyAxNiA5LjcyOTI5IDE2IDkuOTA5MDlMMTYgMTIuMTgxOEMxNiAxMi42NjQgMTUuNzg5MyAxMy4xMjY1IDE1LjQxNDIgMTMuNDY3NUMxNS4wMzkxIDEzLjgwODQgMTQuNTMwNCAxNCAxNCAxNFwiLz48L3N2Zz4nO1xudmFyIGIgPSB0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgPCBcInVcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmIDwgXCJ1XCIgPyBzZWxmIDoge307XG5mdW5jdGlvbiBGZShlKSB7XG4gIGlmIChlLl9fZXNNb2R1bGUpXG4gICAgcmV0dXJuIGU7XG4gIHZhciB0ID0gZS5kZWZhdWx0O1xuICBpZiAodHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIG4gPSBmdW5jdGlvbiByKCkge1xuICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiByID8gUmVmbGVjdC5jb25zdHJ1Y3QodCwgYXJndW1lbnRzLCB0aGlzLmNvbnN0cnVjdG9yKSA6IHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIG4ucHJvdG90eXBlID0gdC5wcm90b3R5cGU7XG4gIH0gZWxzZVxuICAgIG4gPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgIHZhciBpID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgciwgaS5nZXQgPyBpIDoge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZVtyXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSksIG47XG59XG52YXIgdiA9IHt9LCBQID0ge30sIGogPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShqLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5qLmFsbElucHV0c1NlbGVjdG9yID0gV2U7XG5mdW5jdGlvbiBXZSgpIHtcbiAgdmFyIGUgPSBbXCJ0ZXh0XCIsIFwicGFzc3dvcmRcIiwgXCJlbWFpbFwiLCBcIm51bWJlclwiLCBcInNlYXJjaFwiLCBcInRlbFwiLCBcInVybFwiXTtcbiAgcmV0dXJuIFwiW2NvbnRlbnRlZGl0YWJsZT10cnVlXSwgdGV4dGFyZWEsIGlucHV0Om5vdChbdHlwZV0pLCBcIiArIGUubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gJ2lucHV0W3R5cGU9XCInLmNvbmNhdCh0LCAnXCJdJyk7XG4gIH0pLmpvaW4oXCIsIFwiKTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuYWxsSW5wdXRzU2VsZWN0b3IgPSB2b2lkIDA7XG4gIHZhciB0ID0gajtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiYWxsSW5wdXRzU2VsZWN0b3JcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5hbGxJbnB1dHNTZWxlY3RvcjtcbiAgfSB9KTtcbn0pKFApO1xudmFyIGMgPSB7fSwgVCA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcblQuaXNOYXRpdmVJbnB1dCA9IFVlO1xuZnVuY3Rpb24gVWUoZSkge1xuICB2YXIgdCA9IFtcbiAgICBcIklOUFVUXCIsXG4gICAgXCJURVhUQVJFQVwiXG4gIF07XG4gIHJldHVybiBlICYmIGUudGFnTmFtZSA/IHQuaW5jbHVkZXMoZS50YWdOYW1lKSA6ICExO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5pc05hdGl2ZUlucHV0ID0gdm9pZCAwO1xuICB2YXIgdCA9IFQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzTmF0aXZlSW5wdXRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5pc05hdGl2ZUlucHV0O1xuICB9IH0pO1xufSkoYyk7XG52YXIgaWUgPSB7fSwgQyA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbkMuYXBwZW5kID0gcWU7XG5mdW5jdGlvbiBxZShlLCB0KSB7XG4gIEFycmF5LmlzQXJyYXkodCkgPyB0LmZvckVhY2goZnVuY3Rpb24obikge1xuICAgIGUuYXBwZW5kQ2hpbGQobik7XG4gIH0pIDogZS5hcHBlbmRDaGlsZCh0KTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuYXBwZW5kID0gdm9pZCAwO1xuICB2YXIgdCA9IEM7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImFwcGVuZFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmFwcGVuZDtcbiAgfSB9KTtcbn0pKGllKTtcbnZhciBMID0ge30sIFMgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5TLmJsb2NrRWxlbWVudHMgPSB6ZTtcbmZ1bmN0aW9uIHplKCkge1xuICByZXR1cm4gW1xuICAgIFwiYWRkcmVzc1wiLFxuICAgIFwiYXJ0aWNsZVwiLFxuICAgIFwiYXNpZGVcIixcbiAgICBcImJsb2NrcXVvdGVcIixcbiAgICBcImNhbnZhc1wiLFxuICAgIFwiZGl2XCIsXG4gICAgXCJkbFwiLFxuICAgIFwiZHRcIixcbiAgICBcImZpZWxkc2V0XCIsXG4gICAgXCJmaWdjYXB0aW9uXCIsXG4gICAgXCJmaWd1cmVcIixcbiAgICBcImZvb3RlclwiLFxuICAgIFwiZm9ybVwiLFxuICAgIFwiaDFcIixcbiAgICBcImgyXCIsXG4gICAgXCJoM1wiLFxuICAgIFwiaDRcIixcbiAgICBcImg1XCIsXG4gICAgXCJoNlwiLFxuICAgIFwiaGVhZGVyXCIsXG4gICAgXCJoZ3JvdXBcIixcbiAgICBcImhyXCIsXG4gICAgXCJsaVwiLFxuICAgIFwibWFpblwiLFxuICAgIFwibmF2XCIsXG4gICAgXCJub3NjcmlwdFwiLFxuICAgIFwib2xcIixcbiAgICBcIm91dHB1dFwiLFxuICAgIFwicFwiLFxuICAgIFwicHJlXCIsXG4gICAgXCJydWJ5XCIsXG4gICAgXCJzZWN0aW9uXCIsXG4gICAgXCJ0YWJsZVwiLFxuICAgIFwidGJvZHlcIixcbiAgICBcInRoZWFkXCIsXG4gICAgXCJ0clwiLFxuICAgIFwidGZvb3RcIixcbiAgICBcInVsXCIsXG4gICAgXCJ2aWRlb1wiXG4gIF07XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmJsb2NrRWxlbWVudHMgPSB2b2lkIDA7XG4gIHZhciB0ID0gUztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiYmxvY2tFbGVtZW50c1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmJsb2NrRWxlbWVudHM7XG4gIH0gfSk7XG59KShMKTtcbnZhciBhZSA9IHt9LCBNID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuTS5jYWxjdWxhdGVCYXNlbGluZSA9IEdlO1xuZnVuY3Rpb24gR2UoZSkge1xuICB2YXIgdCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUpLCBuID0gcGFyc2VGbG9hdCh0LmZvbnRTaXplKSwgciA9IHBhcnNlRmxvYXQodC5saW5lSGVpZ2h0KSB8fCBuICogMS4yLCBpID0gcGFyc2VGbG9hdCh0LnBhZGRpbmdUb3ApLCBhID0gcGFyc2VGbG9hdCh0LmJvcmRlclRvcFdpZHRoKSwgbCA9IHBhcnNlRmxvYXQodC5tYXJnaW5Ub3ApLCB1ID0gbiAqIDAuOCwgZCA9IChyIC0gbikgLyAyLCBzID0gbCArIGEgKyBpICsgZCArIHU7XG4gIHJldHVybiBzO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5jYWxjdWxhdGVCYXNlbGluZSA9IHZvaWQgMDtcbiAgdmFyIHQgPSBNO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJjYWxjdWxhdGVCYXNlbGluZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmNhbGN1bGF0ZUJhc2VsaW5lO1xuICB9IH0pO1xufSkoYWUpO1xudmFyIGxlID0ge30sIGsgPSB7fSwgdyA9IHt9LCBOID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuTi5pc0NvbnRlbnRFZGl0YWJsZSA9IEtlO1xuZnVuY3Rpb24gS2UoZSkge1xuICByZXR1cm4gZS5jb250ZW50RWRpdGFibGUgPT09IFwidHJ1ZVwiO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5pc0NvbnRlbnRFZGl0YWJsZSA9IHZvaWQgMDtcbiAgdmFyIHQgPSBOO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0NvbnRlbnRFZGl0YWJsZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmlzQ29udGVudEVkaXRhYmxlO1xuICB9IH0pO1xufSkodyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuay5jYW5TZXRDYXJldCA9IFFlO1xudmFyIFhlID0gYywgWWUgPSB3O1xuZnVuY3Rpb24gUWUoZSkge1xuICB2YXIgdCA9ICEwO1xuICBpZiAoKDAsIFhlLmlzTmF0aXZlSW5wdXQpKGUpKVxuICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICBjYXNlIFwicmFkaW9cIjpcbiAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgIGNhc2UgXCJzdWJtaXRcIjpcbiAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgY2FzZSBcInJlc2V0XCI6XG4gICAgICAgIHQgPSAhMTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICBlbHNlXG4gICAgdCA9ICgwLCBZZS5pc0NvbnRlbnRFZGl0YWJsZSkoZSk7XG4gIHJldHVybiB0O1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5jYW5TZXRDYXJldCA9IHZvaWQgMDtcbiAgdmFyIHQgPSBrO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJjYW5TZXRDYXJldFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmNhblNldENhcmV0O1xuICB9IH0pO1xufSkobGUpO1xudmFyIHkgPSB7fSwgSSA9IHt9O1xuZnVuY3Rpb24gVmUoZSwgdCwgbikge1xuICBjb25zdCByID0gbi52YWx1ZSAhPT0gdm9pZCAwID8gXCJ2YWx1ZVwiIDogXCJnZXRcIiwgaSA9IG5bcl0sIGEgPSBgIyR7dH1DYWNoZWA7XG4gIGlmIChuW3JdID0gZnVuY3Rpb24oLi4ubCkge1xuICAgIHJldHVybiB0aGlzW2FdID09PSB2b2lkIDAgJiYgKHRoaXNbYV0gPSBpLmFwcGx5KHRoaXMsIGwpKSwgdGhpc1thXTtcbiAgfSwgciA9PT0gXCJnZXRcIiAmJiBuLnNldCkge1xuICAgIGNvbnN0IGwgPSBuLnNldDtcbiAgICBuLnNldCA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgIGRlbGV0ZSBlW2FdLCBsLmFwcGx5KHRoaXMsIHUpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiB1ZSgpIHtcbiAgY29uc3QgZSA9IHtcbiAgICB3aW46ICExLFxuICAgIG1hYzogITEsXG4gICAgeDExOiAhMSxcbiAgICBsaW51eDogITFcbiAgfSwgdCA9IE9iamVjdC5rZXlzKGUpLmZpbmQoKG4pID0+IHdpbmRvdy5uYXZpZ2F0b3IuYXBwVmVyc2lvbi50b0xvd2VyQ2FzZSgpLmluZGV4T2YobikgIT09IC0xKTtcbiAgcmV0dXJuIHQgIT09IHZvaWQgMCAmJiAoZVt0XSA9ICEwKSwgZTtcbn1cbmZ1bmN0aW9uIEEoZSkge1xuICByZXR1cm4gZSAhPSBudWxsICYmIGUgIT09IFwiXCIgJiYgKHR5cGVvZiBlICE9IFwib2JqZWN0XCIgfHwgT2JqZWN0LmtleXMoZSkubGVuZ3RoID4gMCk7XG59XG5mdW5jdGlvbiBaZShlKSB7XG4gIHJldHVybiAhQShlKTtcbn1cbmNvbnN0IEplID0gKCkgPT4gdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5uYXZpZ2F0b3IgIT09IG51bGwgJiYgQSh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSAmJiAoL2lQKGFkfGhvbmV8b2QpLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0pIHx8IHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0gPT09IFwiTWFjSW50ZWxcIiAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMSk7XG5mdW5jdGlvbiB4ZShlKSB7XG4gIGNvbnN0IHQgPSB1ZSgpO1xuICByZXR1cm4gZSA9IGUucmVwbGFjZSgvc2hpZnQvZ2ksIFwi4oenXCIpLnJlcGxhY2UoL2JhY2tzcGFjZS9naSwgXCLijKtcIikucmVwbGFjZSgvZW50ZXIvZ2ksIFwi4o+OXCIpLnJlcGxhY2UoL3VwL2dpLCBcIuKGkVwiKS5yZXBsYWNlKC9sZWZ0L2dpLCBcIuKGklwiKS5yZXBsYWNlKC9kb3duL2dpLCBcIuKGk1wiKS5yZXBsYWNlKC9yaWdodC9naSwgXCLihpBcIikucmVwbGFjZSgvZXNjYXBlL2dpLCBcIuKOi1wiKS5yZXBsYWNlKC9pbnNlcnQvZ2ksIFwiSW5zXCIpLnJlcGxhY2UoL2RlbGV0ZS9naSwgXCLikKFcIikucmVwbGFjZSgvXFwrL2dpLCBcIitcIiksIHQubWFjID8gZSA9IGUucmVwbGFjZSgvY3RybHxjbWQvZ2ksIFwi4oyYXCIpLnJlcGxhY2UoL2FsdC9naSwgXCLijKVcIikgOiBlID0gZS5yZXBsYWNlKC9jbWQvZ2ksIFwiQ3RybFwiKS5yZXBsYWNlKC93aW5kb3dzL2dpLCBcIldJTlwiKSwgZTtcbn1cbmZ1bmN0aW9uIGV0KGUpIHtcbiAgcmV0dXJuIGVbMF0udG9VcHBlckNhc2UoKSArIGUuc2xpY2UoMSk7XG59XG5mdW5jdGlvbiB0dChlKSB7XG4gIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICB0LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiLCB0LnN0eWxlLmxlZnQgPSBcIi05OTlweFwiLCB0LnN0eWxlLmJvdHRvbSA9IFwiLTk5OXB4XCIsIHQuaW5uZXJIVE1MID0gZSwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0KTtcbiAgY29uc3QgbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgciA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGlmIChyLnNlbGVjdE5vZGUodCksIG4gPT09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvcHkgdGV4dCB0byBjbGlwYm9hcmRcIik7XG4gIG4ucmVtb3ZlQWxsUmFuZ2VzKCksIG4uYWRkUmFuZ2UociksIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiY29weVwiKSwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0KTtcbn1cbmZ1bmN0aW9uIG50KGUsIHQsIG4pIHtcbiAgbGV0IHI7XG4gIHJldHVybiAoLi4uaSkgPT4ge1xuICAgIGNvbnN0IGEgPSB0aGlzLCBsID0gKCkgPT4ge1xuICAgICAgciA9IHZvaWQgMCwgbiAhPT0gITAgJiYgZS5hcHBseShhLCBpKTtcbiAgICB9LCB1ID0gbiA9PT0gITAgJiYgciAhPT0gdm9pZCAwO1xuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQociksIHIgPSB3aW5kb3cuc2V0VGltZW91dChsLCB0KSwgdSAmJiBlLmFwcGx5KGEsIGkpO1xuICB9O1xufVxuZnVuY3Rpb24gbyhlKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkubWF0Y2goL1xccyhbYS16QS1aXSspLylbMV0udG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHJ0KGUpIHtcbiAgcmV0dXJuIG8oZSkgPT09IFwiYm9vbGVhblwiO1xufVxuZnVuY3Rpb24gb2UoZSkge1xuICByZXR1cm4gbyhlKSA9PT0gXCJmdW5jdGlvblwiIHx8IG8oZSkgPT09IFwiYXN5bmNmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXQoZSkge1xuICByZXR1cm4gb2UoZSkgJiYgL15cXHMqY2xhc3NcXHMrLy50ZXN0KGUudG9TdHJpbmcoKSk7XG59XG5mdW5jdGlvbiBhdChlKSB7XG4gIHJldHVybiBvKGUpID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gZyhlKSB7XG4gIHJldHVybiBvKGUpID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gbHQoZSkge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGUpID09PSBlO1xufVxuZnVuY3Rpb24gdXQoZSkge1xuICByZXR1cm4gbyhlKSA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIG90KGUpIHtcbiAgcmV0dXJuIG8oZSkgPT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBPKGUsIC4uLnQpIHtcbiAgaWYgKCF0Lmxlbmd0aClcbiAgICByZXR1cm4gZTtcbiAgY29uc3QgbiA9IHQuc2hpZnQoKTtcbiAgaWYgKGcoZSkgJiYgZyhuKSlcbiAgICBmb3IgKGNvbnN0IHIgaW4gbilcbiAgICAgIGcobltyXSkgPyAoZVtyXSA9PT0gdm9pZCAwICYmIE9iamVjdC5hc3NpZ24oZSwgeyBbcl06IHt9IH0pLCBPKGVbcl0sIG5bcl0pKSA6IE9iamVjdC5hc3NpZ24oZSwgeyBbcl06IG5bcl0gfSk7XG4gIHJldHVybiBPKGUsIC4uLnQpO1xufVxuZnVuY3Rpb24gc3QoZSwgdCwgbikge1xuICBjb25zdCByID0gYMKrJHt0fcK7IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBQbGVhc2UgdXNlIHRoZSDCqyR7bn3CuyBpbnN0ZWFkLmA7XG4gIGUgJiYgY29uc29sZS53YXJuKHIpO1xufVxuZnVuY3Rpb24gY3QoZSkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgVVJMKGUpLmhyZWY7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBlLnN1YnN0cmluZygwLCAyKSA9PT0gXCIvL1wiID8gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgZSA6IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyBlO1xufVxuZnVuY3Rpb24gZHQoZSkge1xuICByZXR1cm4gZSA+IDQ3ICYmIGUgPCA1OCB8fCBlID09PSAzMiB8fCBlID09PSAxMyB8fCBlID09PSAyMjkgfHwgZSA+IDY0ICYmIGUgPCA5MSB8fCBlID4gOTUgJiYgZSA8IDExMiB8fCBlID4gMTg1ICYmIGUgPCAxOTMgfHwgZSA+IDIxOCAmJiBlIDwgMjIzO1xufVxuY29uc3QgZnQgPSB7XG4gIEJBQ0tTUEFDRTogOCxcbiAgVEFCOiA5LFxuICBFTlRFUjogMTMsXG4gIFNISUZUOiAxNixcbiAgQ1RSTDogMTcsXG4gIEFMVDogMTgsXG4gIEVTQzogMjcsXG4gIFNQQUNFOiAzMixcbiAgTEVGVDogMzcsXG4gIFVQOiAzOCxcbiAgRE9XTjogNDAsXG4gIFJJR0hUOiAzOSxcbiAgREVMRVRFOiA0NixcbiAgTUVUQTogOTEsXG4gIFNMQVNIOiAxOTFcbn0sIHB0ID0ge1xuICBMRUZUOiAwLFxuICBXSEVFTDogMSxcbiAgUklHSFQ6IDIsXG4gIEJBQ0tXQVJEOiAzLFxuICBGT1JXQVJEOiA0XG59O1xuY2xhc3MgdnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbXBsZXRlZCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgbmV3IHByb21pc2UgdG8gcXVldWVcbiAgICogQHBhcmFtIG9wZXJhdGlvbiAtIHByb21pc2Ugc2hvdWxkIGJlIGFkZGVkIHRvIHF1ZXVlXG4gICAqL1xuICBhZGQodCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgobiwgcikgPT4ge1xuICAgICAgdGhpcy5jb21wbGV0ZWQgPSB0aGlzLmNvbXBsZXRlZC50aGVuKHQpLnRoZW4obikuY2F0Y2gocik7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGd0KGUsIHQsIG4gPSB2b2lkIDApIHtcbiAgbGV0IHIsIGksIGEsIGwgPSBudWxsLCB1ID0gMDtcbiAgbiB8fCAobiA9IHt9KTtcbiAgY29uc3QgZCA9IGZ1bmN0aW9uKCkge1xuICAgIHUgPSBuLmxlYWRpbmcgPT09ICExID8gMCA6IERhdGUubm93KCksIGwgPSBudWxsLCBhID0gZS5hcHBseShyLCBpKSwgbCA9PT0gbnVsbCAmJiAociA9IGkgPSBudWxsKTtcbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHMgPSBEYXRlLm5vdygpO1xuICAgICF1ICYmIG4ubGVhZGluZyA9PT0gITEgJiYgKHUgPSBzKTtcbiAgICBjb25zdCBmID0gdCAtIChzIC0gdSk7XG4gICAgcmV0dXJuIHIgPSB0aGlzLCBpID0gYXJndW1lbnRzLCBmIDw9IDAgfHwgZiA+IHQgPyAobCAmJiAoY2xlYXJUaW1lb3V0KGwpLCBsID0gbnVsbCksIHUgPSBzLCBhID0gZS5hcHBseShyLCBpKSwgbCA9PT0gbnVsbCAmJiAociA9IGkgPSBudWxsKSkgOiAhbCAmJiBuLnRyYWlsaW5nICE9PSAhMSAmJiAobCA9IHNldFRpbWVvdXQoZCwgZikpLCBhO1xuICB9O1xufVxuY29uc3QgbXQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBQcm9taXNlUXVldWU6IHZ0LFxuICBiZWF1dGlmeVNob3J0Y3V0OiB4ZSxcbiAgY2FjaGVhYmxlOiBWZSxcbiAgY2FwaXRhbGl6ZTogZXQsXG4gIGNvcHlUZXh0VG9DbGlwYm9hcmQ6IHR0LFxuICBkZWJvdW5jZTogbnQsXG4gIGRlZXBNZXJnZTogTyxcbiAgZGVwcmVjYXRpb25Bc3NlcnQ6IHN0LFxuICBnZXRVc2VyT1M6IHVlLFxuICBnZXRWYWxpZFVybDogY3QsXG4gIGlzQm9vbGVhbjogcnQsXG4gIGlzQ2xhc3M6IGl0LFxuICBpc0VtcHR5OiBaZSxcbiAgaXNGdW5jdGlvbjogb2UsXG4gIGlzSW9zRGV2aWNlOiBKZSxcbiAgaXNOdW1iZXI6IGF0LFxuICBpc09iamVjdDogZyxcbiAgaXNQcmludGFibGVLZXk6IGR0LFxuICBpc1Byb21pc2U6IGx0LFxuICBpc1N0cmluZzogdXQsXG4gIGlzVW5kZWZpbmVkOiBvdCxcbiAga2V5Q29kZXM6IGZ0LFxuICBtb3VzZUJ1dHRvbnM6IHB0LFxuICBub3RFbXB0eTogQSxcbiAgdGhyb3R0bGU6IGd0LFxuICB0eXBlT2Y6IG9cbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksICQgPSAvKiBAX19QVVJFX18gKi8gRmUobXQpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEksIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbkkuY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHMgPSBfdDtcbnZhciBidCA9ICQsIHl0ID0gTDtcbmZ1bmN0aW9uIF90KGUpIHtcbiAgdmFyIHQ7XG4gICgwLCBidC5pc1N0cmluZykoZSkgPyAodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHQuaW5uZXJIVE1MID0gZSkgOiB0ID0gZTtcbiAgdmFyIG4gPSBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuICEoMCwgeXQuYmxvY2tFbGVtZW50cykoKS5pbmNsdWRlcyhyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkgJiYgQXJyYXkuZnJvbShyLmNoaWxkcmVuKS5ldmVyeShuKTtcbiAgfTtcbiAgcmV0dXJuIEFycmF5LmZyb20odC5jaGlsZHJlbikuZXZlcnkobik7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzID0gdm9pZCAwO1xuICB2YXIgdCA9IEk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHM7XG4gIH0gfSk7XG59KSh5KTtcbnZhciBzZSA9IHt9LCBCID0ge30sIF8gPSB7fSwgRCA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbkQubWFrZSA9IGh0O1xuZnVuY3Rpb24gaHQoZSwgdCwgbikge1xuICB2YXIgcjtcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0gbnVsbCksIG4gPT09IHZvaWQgMCAmJiAobiA9IHt9KTtcbiAgdmFyIGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGUpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgIHZhciBhID0gdC5maWx0ZXIoZnVuY3Rpb24odSkge1xuICAgICAgcmV0dXJuIHUgIT09IHZvaWQgMDtcbiAgICB9KTtcbiAgICAociA9IGkuY2xhc3NMaXN0KS5hZGQuYXBwbHkociwgYSk7XG4gIH0gZWxzZVxuICAgIHQgIT09IG51bGwgJiYgaS5jbGFzc0xpc3QuYWRkKHQpO1xuICBmb3IgKHZhciBsIGluIG4pXG4gICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIGwpICYmIChpW2xdID0gbltsXSk7XG4gIHJldHVybiBpO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5tYWtlID0gdm9pZCAwO1xuICB2YXIgdCA9IEQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIm1ha2VcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5tYWtlO1xuICB9IH0pO1xufSkoXyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuQi5mcmFnbWVudFRvU3RyaW5nID0gT3Q7XG52YXIgRXQgPSBfO1xuZnVuY3Rpb24gT3QoZSkge1xuICB2YXIgdCA9ICgwLCBFdC5tYWtlKShcImRpdlwiKTtcbiAgcmV0dXJuIHQuYXBwZW5kQ2hpbGQoZSksIHQuaW5uZXJIVE1MO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5mcmFnbWVudFRvU3RyaW5nID0gdm9pZCAwO1xuICB2YXIgdCA9IEI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImZyYWdtZW50VG9TdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5mcmFnbWVudFRvU3RyaW5nO1xuICB9IH0pO1xufSkoc2UpO1xudmFyIGNlID0ge30sIEggPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShILCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5ILmdldENvbnRlbnRMZW5ndGggPSBqdDtcbnZhciBQdCA9IGM7XG5mdW5jdGlvbiBqdChlKSB7XG4gIHZhciB0LCBuO1xuICByZXR1cm4gKDAsIFB0LmlzTmF0aXZlSW5wdXQpKGUpID8gZS52YWx1ZS5sZW5ndGggOiBlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/IGUubGVuZ3RoIDogKG4gPSAodCA9IGUudGV4dENvbnRlbnQpID09PSBudWxsIHx8IHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHQubGVuZ3RoKSAhPT0gbnVsbCAmJiBuICE9PSB2b2lkIDAgPyBuIDogMDtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuZ2V0Q29udGVudExlbmd0aCA9IHZvaWQgMDtcbiAgdmFyIHQgPSBIO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJnZXRDb250ZW50TGVuZ3RoXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuZ2V0Q29udGVudExlbmd0aDtcbiAgfSB9KTtcbn0pKGNlKTtcbnZhciBSID0ge30sIEYgPSB7fSwgcmUgPSBiICYmIGIuX19zcHJlYWRBcnJheSB8fCBmdW5jdGlvbihlLCB0LCBuKSB7XG4gIGlmIChuIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgZm9yICh2YXIgciA9IDAsIGkgPSB0Lmxlbmd0aCwgYTsgciA8IGk7IHIrKylcbiAgICAgIChhIHx8ICEociBpbiB0KSkgJiYgKGEgfHwgKGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LCAwLCByKSksIGFbcl0gPSB0W3JdKTtcbiAgcmV0dXJuIGUuY29uY2F0KGEgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodCkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShGLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5GLmdldERlZXBlc3RCbG9ja0VsZW1lbnRzID0gZGU7XG52YXIgVHQgPSB5O1xuZnVuY3Rpb24gZGUoZSkge1xuICByZXR1cm4gKDAsIFR0LmNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzKShlKSA/IFtlXSA6IEFycmF5LmZyb20oZS5jaGlsZHJlbikucmVkdWNlKGZ1bmN0aW9uKHQsIG4pIHtcbiAgICByZXR1cm4gcmUocmUoW10sIHQsICEwKSwgZGUobiksICEwKTtcbiAgfSwgW10pO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5nZXREZWVwZXN0QmxvY2tFbGVtZW50cyA9IHZvaWQgMDtcbiAgdmFyIHQgPSBGO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJnZXREZWVwZXN0QmxvY2tFbGVtZW50c1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmdldERlZXBlc3RCbG9ja0VsZW1lbnRzO1xuICB9IH0pO1xufSkoUik7XG52YXIgZmUgPSB7fSwgVyA9IHt9LCBoID0ge30sIFUgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5VLmlzTGluZUJyZWFrVGFnID0gQ3Q7XG5mdW5jdGlvbiBDdChlKSB7XG4gIHJldHVybiBbXG4gICAgXCJCUlwiLFxuICAgIFwiV0JSXCJcbiAgXS5pbmNsdWRlcyhlLnRhZ05hbWUpO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5pc0xpbmVCcmVha1RhZyA9IHZvaWQgMDtcbiAgdmFyIHQgPSBVO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0xpbmVCcmVha1RhZ1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmlzTGluZUJyZWFrVGFnO1xuICB9IH0pO1xufSkoaCk7XG52YXIgRSA9IHt9LCBxID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xucS5pc1NpbmdsZVRhZyA9IEx0O1xuZnVuY3Rpb24gTHQoZSkge1xuICByZXR1cm4gW1xuICAgIFwiQVJFQVwiLFxuICAgIFwiQkFTRVwiLFxuICAgIFwiQlJcIixcbiAgICBcIkNPTFwiLFxuICAgIFwiQ09NTUFORFwiLFxuICAgIFwiRU1CRURcIixcbiAgICBcIkhSXCIsXG4gICAgXCJJTUdcIixcbiAgICBcIklOUFVUXCIsXG4gICAgXCJLRVlHRU5cIixcbiAgICBcIkxJTktcIixcbiAgICBcIk1FVEFcIixcbiAgICBcIlBBUkFNXCIsXG4gICAgXCJTT1VSQ0VcIixcbiAgICBcIlRSQUNLXCIsXG4gICAgXCJXQlJcIlxuICBdLmluY2x1ZGVzKGUudGFnTmFtZSk7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmlzU2luZ2xlVGFnID0gdm9pZCAwO1xuICB2YXIgdCA9IHE7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzU2luZ2xlVGFnXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuaXNTaW5nbGVUYWc7XG4gIH0gfSk7XG59KShFKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5XLmdldERlZXBlc3ROb2RlID0gcGU7XG52YXIgU3QgPSBjLCBNdCA9IGgsIGt0ID0gRTtcbmZ1bmN0aW9uIHBlKGUsIHQpIHtcbiAgdCA9PT0gdm9pZCAwICYmICh0ID0gITEpO1xuICB2YXIgbiA9IHQgPyBcImxhc3RDaGlsZFwiIDogXCJmaXJzdENoaWxkXCIsIHIgPSB0ID8gXCJwcmV2aW91c1NpYmxpbmdcIiA6IFwibmV4dFNpYmxpbmdcIjtcbiAgaWYgKGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIGVbbl0pIHtcbiAgICB2YXIgaSA9IGVbbl07XG4gICAgaWYgKCgwLCBrdC5pc1NpbmdsZVRhZykoaSkgJiYgISgwLCBTdC5pc05hdGl2ZUlucHV0KShpKSAmJiAhKDAsIE10LmlzTGluZUJyZWFrVGFnKShpKSlcbiAgICAgIGlmIChpW3JdKVxuICAgICAgICBpID0gaVtyXTtcbiAgICAgIGVsc2UgaWYgKGkucGFyZW50Tm9kZSAhPT0gbnVsbCAmJiBpLnBhcmVudE5vZGVbcl0pXG4gICAgICAgIGkgPSBpLnBhcmVudE5vZGVbcl07XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBpLnBhcmVudE5vZGU7XG4gICAgcmV0dXJuIHBlKGksIHQpO1xuICB9XG4gIHJldHVybiBlO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5nZXREZWVwZXN0Tm9kZSA9IHZvaWQgMDtcbiAgdmFyIHQgPSBXO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJnZXREZWVwZXN0Tm9kZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmdldERlZXBlc3ROb2RlO1xuICB9IH0pO1xufSkoZmUpO1xudmFyIHZlID0ge30sIHogPSB7fSwgcCA9IGIgJiYgYi5fX3NwcmVhZEFycmF5IHx8IGZ1bmN0aW9uKGUsIHQsIG4pIHtcbiAgaWYgKG4gfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICBmb3IgKHZhciByID0gMCwgaSA9IHQubGVuZ3RoLCBhOyByIDwgaTsgcisrKVxuICAgICAgKGEgfHwgIShyIGluIHQpKSAmJiAoYSB8fCAoYSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQsIDAsIHIpKSwgYVtyXSA9IHRbcl0pO1xuICByZXR1cm4gZS5jb25jYXQoYSB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0KSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHosIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnouZmluZEFsbElucHV0cyA9ICR0O1xudmFyIHd0ID0geSwgTnQgPSBSLCBJdCA9IFAsIEF0ID0gYztcbmZ1bmN0aW9uICR0KGUpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZS5xdWVyeVNlbGVjdG9yQWxsKCgwLCBJdC5hbGxJbnB1dHNTZWxlY3RvcikoKSkpLnJlZHVjZShmdW5jdGlvbih0LCBuKSB7XG4gICAgcmV0dXJuICgwLCBBdC5pc05hdGl2ZUlucHV0KShuKSB8fCAoMCwgd3QuY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHMpKG4pID8gcChwKFtdLCB0LCAhMCksIFtuXSwgITEpIDogcChwKFtdLCB0LCAhMCksICgwLCBOdC5nZXREZWVwZXN0QmxvY2tFbGVtZW50cykobiksICEwKTtcbiAgfSwgW10pO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5maW5kQWxsSW5wdXRzID0gdm9pZCAwO1xuICB2YXIgdCA9IHo7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImZpbmRBbGxJbnB1dHNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5maW5kQWxsSW5wdXRzO1xuICB9IH0pO1xufSkodmUpO1xudmFyIGdlID0ge30sIEcgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShHLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5HLmlzQ29sbGFwc2VkV2hpdGVzcGFjZXMgPSBCdDtcbmZ1bmN0aW9uIEJ0KGUpIHtcbiAgcmV0dXJuICEvW15cXHRcXG5cXHIgXS8udGVzdChlKTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUuaXNDb2xsYXBzZWRXaGl0ZXNwYWNlcyA9IHZvaWQgMDtcbiAgdmFyIHQgPSBHO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0NvbGxhcHNlZFdoaXRlc3BhY2VzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuaXNDb2xsYXBzZWRXaGl0ZXNwYWNlcztcbiAgfSB9KTtcbn0pKGdlKTtcbnZhciBLID0ge30sIFggPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShYLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5YLmlzRWxlbWVudCA9IEh0O1xudmFyIER0ID0gJDtcbmZ1bmN0aW9uIEh0KGUpIHtcbiAgcmV0dXJuICgwLCBEdC5pc051bWJlcikoZSkgPyAhMSA6ICEhZSAmJiAhIWUubm9kZVR5cGUgJiYgZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmlzRWxlbWVudCA9IHZvaWQgMDtcbiAgdmFyIHQgPSBYO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0VsZW1lbnRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5pc0VsZW1lbnQ7XG4gIH0gfSk7XG59KShLKTtcbnZhciBtZSA9IHt9LCBZID0ge30sIFEgPSB7fSwgViA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFYsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcblYuaXNMZWFmID0gUnQ7XG5mdW5jdGlvbiBSdChlKSB7XG4gIHJldHVybiBlID09PSBudWxsID8gITEgOiBlLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5pc0xlYWYgPSB2b2lkIDA7XG4gIHZhciB0ID0gVjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNMZWFmXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuaXNMZWFmO1xuICB9IH0pO1xufSkoUSk7XG52YXIgWiA9IHt9LCBKID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuSi5pc05vZGVFbXB0eSA9IHp0O1xudmFyIEZ0ID0gaCwgV3QgPSBLLCBVdCA9IGMsIHF0ID0gRTtcbmZ1bmN0aW9uIHp0KGUsIHQpIHtcbiAgdmFyIG4gPSBcIlwiO1xuICByZXR1cm4gKDAsIHF0LmlzU2luZ2xlVGFnKShlKSAmJiAhKDAsIEZ0LmlzTGluZUJyZWFrVGFnKShlKSA/ICExIDogKCgwLCBXdC5pc0VsZW1lbnQpKGUpICYmICgwLCBVdC5pc05hdGl2ZUlucHV0KShlKSA/IG4gPSBlLnZhbHVlIDogZS50ZXh0Q29udGVudCAhPT0gbnVsbCAmJiAobiA9IGUudGV4dENvbnRlbnQucmVwbGFjZShcIuKAi1wiLCBcIlwiKSksIHQgIT09IHZvaWQgMCAmJiAobiA9IG4ucmVwbGFjZShuZXcgUmVnRXhwKHQsIFwiZ1wiKSwgXCJcIikpLCBuLnRyaW0oKS5sZW5ndGggPT09IDApO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5pc05vZGVFbXB0eSA9IHZvaWQgMDtcbiAgdmFyIHQgPSBKO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc05vZGVFbXB0eVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmlzTm9kZUVtcHR5O1xuICB9IH0pO1xufSkoWik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoWSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuWS5pc0VtcHR5ID0gWHQ7XG52YXIgR3QgPSBRLCBLdCA9IFo7XG5mdW5jdGlvbiBYdChlLCB0KSB7XG4gIGUubm9ybWFsaXplKCk7XG4gIGZvciAodmFyIG4gPSBbZV07IG4ubGVuZ3RoID4gMDsgKSB7XG4gICAgdmFyIHIgPSBuLnNoaWZ0KCk7XG4gICAgaWYgKHIpIHtcbiAgICAgIGlmIChlID0gciwgKDAsIEd0LmlzTGVhZikoZSkgJiYgISgwLCBLdC5pc05vZGVFbXB0eSkoZSwgdCkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIG4ucHVzaC5hcHBseShuLCBBcnJheS5mcm9tKGUuY2hpbGROb2RlcykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gITA7XG59XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLmlzRW1wdHkgPSB2b2lkIDA7XG4gIHZhciB0ID0gWTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNFbXB0eVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmlzRW1wdHk7XG4gIH0gfSk7XG59KShtZSk7XG52YXIgYmUgPSB7fSwgeCA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHgsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnguaXNGcmFnbWVudCA9IFF0O1xudmFyIFl0ID0gJDtcbmZ1bmN0aW9uIFF0KGUpIHtcbiAgcmV0dXJuICgwLCBZdC5pc051bWJlcikoZSkgPyAhMSA6ICEhZSAmJiAhIWUubm9kZVR5cGUgJiYgZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5pc0ZyYWdtZW50ID0gdm9pZCAwO1xuICB2YXIgdCA9IHg7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzRnJhZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5pc0ZyYWdtZW50O1xuICB9IH0pO1xufSkoYmUpO1xudmFyIHllID0ge30sIGVlID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZWUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmVlLmlzSFRNTFN0cmluZyA9IFp0O1xudmFyIFZ0ID0gXztcbmZ1bmN0aW9uIFp0KGUpIHtcbiAgdmFyIHQgPSAoMCwgVnQubWFrZSkoXCJkaXZcIik7XG4gIHJldHVybiB0LmlubmVySFRNTCA9IGUsIHQuY2hpbGRFbGVtZW50Q291bnQgPiAwO1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5pc0hUTUxTdHJpbmcgPSB2b2lkIDA7XG4gIHZhciB0ID0gZWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzSFRNTFN0cmluZ1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmlzSFRNTFN0cmluZztcbiAgfSB9KTtcbn0pKHllKTtcbnZhciBfZSA9IHt9LCB0ZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHRlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG50ZS5vZmZzZXQgPSBKdDtcbmZ1bmN0aW9uIEp0KGUpIHtcbiAgdmFyIHQgPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBuID0gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LCByID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsIGkgPSB0LnRvcCArIHIsIGEgPSB0LmxlZnQgKyBuO1xuICByZXR1cm4ge1xuICAgIHRvcDogaSxcbiAgICBsZWZ0OiBhLFxuICAgIGJvdHRvbTogaSArIHQuaGVpZ2h0LFxuICAgIHJpZ2h0OiBhICsgdC53aWR0aFxuICB9O1xufVxuKGZ1bmN0aW9uKGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZS5vZmZzZXQgPSB2b2lkIDA7XG4gIHZhciB0ID0gdGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIm9mZnNldFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0Lm9mZnNldDtcbiAgfSB9KTtcbn0pKF9lKTtcbnZhciBoZSA9IHt9LCBuZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KG5lLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5uZS5wcmVwZW5kID0geHQ7XG5mdW5jdGlvbiB4dChlLCB0KSB7XG4gIEFycmF5LmlzQXJyYXkodCkgPyAodCA9IHQucmV2ZXJzZSgpLCB0LmZvckVhY2goZnVuY3Rpb24obikge1xuICAgIHJldHVybiBlLnByZXBlbmQobik7XG4gIH0pKSA6IGUucHJlcGVuZCh0KTtcbn1cbihmdW5jdGlvbihlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGUucHJlcGVuZCA9IHZvaWQgMDtcbiAgdmFyIHQgPSBuZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJlcGVuZFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LnByZXBlbmQ7XG4gIH0gfSk7XG59KShoZSk7XG4oZnVuY3Rpb24oZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBlLnByZXBlbmQgPSBlLm9mZnNldCA9IGUubWFrZSA9IGUuaXNMaW5lQnJlYWtUYWcgPSBlLmlzU2luZ2xlVGFnID0gZS5pc05vZGVFbXB0eSA9IGUuaXNMZWFmID0gZS5pc0hUTUxTdHJpbmcgPSBlLmlzRnJhZ21lbnQgPSBlLmlzRW1wdHkgPSBlLmlzRWxlbWVudCA9IGUuaXNDb250ZW50RWRpdGFibGUgPSBlLmlzQ29sbGFwc2VkV2hpdGVzcGFjZXMgPSBlLmZpbmRBbGxJbnB1dHMgPSBlLmlzTmF0aXZlSW5wdXQgPSBlLmFsbElucHV0c1NlbGVjdG9yID0gZS5nZXREZWVwZXN0Tm9kZSA9IGUuZ2V0RGVlcGVzdEJsb2NrRWxlbWVudHMgPSBlLmdldENvbnRlbnRMZW5ndGggPSBlLmZyYWdtZW50VG9TdHJpbmcgPSBlLmNvbnRhaW5zT25seUlubGluZUVsZW1lbnRzID0gZS5jYW5TZXRDYXJldCA9IGUuY2FsY3VsYXRlQmFzZWxpbmUgPSBlLmJsb2NrRWxlbWVudHMgPSBlLmFwcGVuZCA9IHZvaWQgMDtcbiAgdmFyIHQgPSBQO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJhbGxJbnB1dHNTZWxlY3RvclwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0LmFsbElucHV0c1NlbGVjdG9yO1xuICB9IH0pO1xuICB2YXIgbiA9IGM7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzTmF0aXZlSW5wdXRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbi5pc05hdGl2ZUlucHV0O1xuICB9IH0pO1xuICB2YXIgciA9IGllO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJhcHBlbmRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gci5hcHBlbmQ7XG4gIH0gfSk7XG4gIHZhciBpID0gTDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiYmxvY2tFbGVtZW50c1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpLmJsb2NrRWxlbWVudHM7XG4gIH0gfSk7XG4gIHZhciBhID0gYWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImNhbGN1bGF0ZUJhc2VsaW5lXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGEuY2FsY3VsYXRlQmFzZWxpbmU7XG4gIH0gfSk7XG4gIHZhciBsID0gbGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImNhblNldENhcmV0XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGwuY2FuU2V0Q2FyZXQ7XG4gIH0gfSk7XG4gIHZhciB1ID0geTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiY29udGFpbnNPbmx5SW5saW5lRWxlbWVudHNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdS5jb250YWluc09ubHlJbmxpbmVFbGVtZW50cztcbiAgfSB9KTtcbiAgdmFyIGQgPSBzZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiZnJhZ21lbnRUb1N0cmluZ1wiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkLmZyYWdtZW50VG9TdHJpbmc7XG4gIH0gfSk7XG4gIHZhciBzID0gY2U7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImdldENvbnRlbnRMZW5ndGhcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcy5nZXRDb250ZW50TGVuZ3RoO1xuICB9IH0pO1xuICB2YXIgZiA9IFI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImdldERlZXBlc3RCbG9ja0VsZW1lbnRzXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGYuZ2V0RGVlcGVzdEJsb2NrRWxlbWVudHM7XG4gIH0gfSk7XG4gIHZhciBPZSA9IGZlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJnZXREZWVwZXN0Tm9kZVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBPZS5nZXREZWVwZXN0Tm9kZTtcbiAgfSB9KTtcbiAgdmFyIFBlID0gdmU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImZpbmRBbGxJbnB1dHNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUGUuZmluZEFsbElucHV0cztcbiAgfSB9KTtcbiAgdmFyIGplID0gZ2U7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzQ29sbGFwc2VkV2hpdGVzcGFjZXNcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gamUuaXNDb2xsYXBzZWRXaGl0ZXNwYWNlcztcbiAgfSB9KTtcbiAgdmFyIFRlID0gdztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNDb250ZW50RWRpdGFibGVcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gVGUuaXNDb250ZW50RWRpdGFibGU7XG4gIH0gfSk7XG4gIHZhciBDZSA9IEs7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzRWxlbWVudFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBDZS5pc0VsZW1lbnQ7XG4gIH0gfSk7XG4gIHZhciBMZSA9IG1lO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0VtcHR5XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIExlLmlzRW1wdHk7XG4gIH0gfSk7XG4gIHZhciBTZSA9IGJlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0ZyYWdtZW50XCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFNlLmlzRnJhZ21lbnQ7XG4gIH0gfSk7XG4gIHZhciBNZSA9IHllO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0hUTUxTdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTWUuaXNIVE1MU3RyaW5nO1xuICB9IH0pO1xuICB2YXIga2UgPSBRO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc0xlYWZcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ga2UuaXNMZWFmO1xuICB9IH0pO1xuICB2YXIgd2UgPSBaO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJpc05vZGVFbXB0eVwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB3ZS5pc05vZGVFbXB0eTtcbiAgfSB9KTtcbiAgdmFyIE5lID0gaDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiaXNMaW5lQnJlYWtUYWdcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTmUuaXNMaW5lQnJlYWtUYWc7XG4gIH0gfSk7XG4gIHZhciBJZSA9IEU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImlzU2luZ2xlVGFnXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEllLmlzU2luZ2xlVGFnO1xuICB9IH0pO1xuICB2YXIgQWUgPSBfO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJtYWtlXCIsIHsgZW51bWVyYWJsZTogITAsIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEFlLm1ha2U7XG4gIH0gfSk7XG4gIHZhciAkZSA9IF9lO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJvZmZzZXRcIiwgeyBlbnVtZXJhYmxlOiAhMCwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJGUub2Zmc2V0O1xuICB9IH0pO1xuICB2YXIgQmUgPSBoZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJlcGVuZFwiLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBCZS5wcmVwZW5kO1xuICB9IH0pO1xufSkodik7XG52YXIgRWUgPSAvKiBAX19QVVJFX18gKi8gKChlKSA9PiAoZS5MZWZ0ID0gXCJsZWZ0XCIsIGUuQ2VudGVyID0gXCJjZW50ZXJcIiwgZSkpKEVlIHx8IHt9KTtcbmNsYXNzIG0ge1xuICAvKipcbiAgICogUmVuZGVyIHBsdWdpbmBzIG1haW4gRWxlbWVudCBhbmQgZmlsbCBpdCB3aXRoIHNhdmVkIGRhdGFcbiAgICogQHBhcmFtIHBhcmFtcyAtIFF1b3RlIFRvb2wgY29uc3RydWN0b3IgcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YSAtIHByZXZpb3VzbHkgc2F2ZWQgZGF0YVxuICAgKiBAcGFyYW0gcGFyYW1zLmNvbmZpZyAtIHVzZXIgY29uZmlnIGZvciBUb29sXG4gICAqIEBwYXJhbSBwYXJhbXMuYXBpIC0gZWRpdG9yLmpzIGFwaVxuICAgKiBAcGFyYW0gcGFyYW1zLnJlYWRPbmx5IC0gcmVhZCBvbmx5IG1vZGUgZmxhZ1xuICAgKi9cbiAgY29uc3RydWN0b3IoeyBkYXRhOiB0LCBjb25maWc6IG4sIGFwaTogciwgcmVhZE9ubHk6IGksIGJsb2NrOiBhIH0pIHtcbiAgICBjb25zdCB7IERFRkFVTFRfQUxJR05NRU5UOiBsIH0gPSBtO1xuICAgIHRoaXMuYXBpID0gciwgdGhpcy5yZWFkT25seSA9IGksIHRoaXMucXVvdGVQbGFjZWhvbGRlciA9IHIuaTE4bi50KChuID09IG51bGwgPyB2b2lkIDAgOiBuLnF1b3RlUGxhY2Vob2xkZXIpID8/IG0uREVGQVVMVF9RVU9URV9QTEFDRUhPTERFUiksIHRoaXMuY2FwdGlvblBsYWNlaG9sZGVyID0gci5pMThuLnQoKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uY2FwdGlvblBsYWNlaG9sZGVyKSA/PyBtLkRFRkFVTFRfQ0FQVElPTl9QTEFDRUhPTERFUiksIHRoaXMuZGF0YSA9IHtcbiAgICAgIHRleHQ6IHQudGV4dCB8fCBcIlwiLFxuICAgICAgY2FwdGlvbjogdC5jYXB0aW9uIHx8IFwiXCIsXG4gICAgICBhbGlnbm1lbnQ6IE9iamVjdC52YWx1ZXMoRWUpLmluY2x1ZGVzKHQuYWxpZ25tZW50KSA/IHQuYWxpZ25tZW50IDogKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uZGVmYXVsdEFsaWdubWVudCkgPz8gbFxuICAgIH0sIHRoaXMuY3NzID0ge1xuICAgICAgYmFzZUNsYXNzOiB0aGlzLmFwaS5zdHlsZXMuYmxvY2ssXG4gICAgICB3cmFwcGVyOiBcImNkeC1xdW90ZVwiLFxuICAgICAgdGV4dDogXCJjZHgtcXVvdGVfX3RleHRcIixcbiAgICAgIGlucHV0OiB0aGlzLmFwaS5zdHlsZXMuaW5wdXQsXG4gICAgICBjYXB0aW9uOiBcImNkeC1xdW90ZV9fY2FwdGlvblwiXG4gICAgfSwgdGhpcy5ibG9jayA9IGE7XG4gIH1cbiAgLyoqXG4gICAqIE5vdGlmeSBjb3JlIHRoYXQgcmVhZC1vbmx5IG1vZGUgaXMgc3VwcG9ydGVkXG4gICAqIEByZXR1cm5zIHRydWVcbiAgICovXG4gIHN0YXRpYyBnZXQgaXNSZWFkT25seVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBUb29sIHRvb2xib3ggc2V0dGluZ3NcbiAgICogaWNvbiAtIFRvb2wgaWNvbidzIFNWR1xuICAgKiB0aXRsZSAtIHRpdGxlIHRvIHNob3cgaW4gdG9vbGJveFxuICAgKiBAcmV0dXJucyBpY29uIGFuZCB0aXRsZSBvZiB0aGUgdG9vbGJveFxuICAgKi9cbiAgc3RhdGljIGdldCB0b29sYm94KCkge1xuICAgIHJldHVybiB7XG4gICAgICBpY29uOiBSZSxcbiAgICAgIHRpdGxlOiBcIlF1b3RlXCJcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFbXB0eSBRdW90ZSBpcyBub3QgZW1wdHkgQmxvY2tcbiAgICogQHJldHVybnMgdHJ1ZVxuICAgKi9cbiAgc3RhdGljIGdldCBjb250ZW50bGVzcygpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93IHRvIHByZXNzIEVudGVyIGluc2lkZSB0aGUgUXVvdGVcbiAgICogQHJldHVybnMgdHJ1ZVxuICAgKi9cbiAgc3RhdGljIGdldCBlbmFibGVMaW5lQnJlYWtzKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgICogRGVmYXVsdCBwbGFjZWhvbGRlciBmb3IgcXVvdGUgdGV4dFxuICAgKiBAcmV0dXJucyAnRW50ZXIgYSBxdW90ZSdcbiAgICovXG4gIHN0YXRpYyBnZXQgREVGQVVMVF9RVU9URV9QTEFDRUhPTERFUigpIHtcbiAgICByZXR1cm4gXCJFbnRlciBhIHF1b3RlXCI7XG4gIH1cbiAgLyoqXG4gICAqIERlZmF1bHQgcGxhY2Vob2xkZXIgZm9yIHF1b3RlIGNhcHRpb25cbiAgICogQHJldHVybnMgJ0VudGVyIGEgY2FwdGlvbidcbiAgICovXG4gIHN0YXRpYyBnZXQgREVGQVVMVF9DQVBUSU9OX1BMQUNFSE9MREVSKCkge1xuICAgIHJldHVybiBcIkVudGVyIGEgY2FwdGlvblwiO1xuICB9XG4gIC8qKlxuICAgKiBEZWZhdWx0IHF1b3RlIGFsaWdubWVudFxuICAgKiBAcmV0dXJucyBBbGlnbm1lbnQuTGVmdFxuICAgKi9cbiAgc3RhdGljIGdldCBERUZBVUxUX0FMSUdOTUVOVCgpIHtcbiAgICByZXR1cm4gXCJsZWZ0XCI7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93IFF1b3RlIHRvIGJlIGNvbnZlcnRlZCB0by9mcm9tIG90aGVyIGJsb2Nrc1xuICAgKiBAcmV0dXJucyBjb252ZXJzaW9uIGNvbmZpZyBvYmplY3RcbiAgICovXG4gIHN0YXRpYyBnZXQgY29udmVyc2lvbkNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBUbyBjcmVhdGUgUXVvdGUgZGF0YSBmcm9tIHN0cmluZywgc2ltcGxlIGZpbGwgJ3RleHQnIHByb3BlcnR5XG4gICAgICAgKi9cbiAgICAgIGltcG9ydDogXCJ0ZXh0XCIsXG4gICAgICAvKipcbiAgICAgICAqIFRvIGNyZWF0ZSBzdHJpbmcgZnJvbSBRdW90ZSBkYXRhLCBjb25jYXRlbmF0ZSB0ZXh0IGFuZCBjYXB0aW9uXG4gICAgICAgKiBAcGFyYW0gcXVvdGVEYXRhIC0gUXVvdGUgZGF0YSBvYmplY3RcbiAgICAgICAqIEByZXR1cm5zIHN0cmluZ1xuICAgICAgICovXG4gICAgICBleHBvcnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQuY2FwdGlvbiA/IGAke3QudGV4dH0g4oCUICR7dC5jYXB0aW9ufWAgOiB0LnRleHQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVG9vbGBzIHN0eWxlc1xuICAgKiBAcmV0dXJucyBDU1MgY2xhc3NlcyBuYW1lc1xuICAgKi9cbiAgZ2V0IENTUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmFzZUNsYXNzOiB0aGlzLmFwaS5zdHlsZXMuYmxvY2ssXG4gICAgICB3cmFwcGVyOiBcImNkeC1xdW90ZVwiLFxuICAgICAgdGV4dDogXCJjZHgtcXVvdGVfX3RleHRcIixcbiAgICAgIGlucHV0OiB0aGlzLmFwaS5zdHlsZXMuaW5wdXQsXG4gICAgICBjYXB0aW9uOiBcImNkeC1xdW90ZV9fY2FwdGlvblwiXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVG9vbGBzIHNldHRpbmdzIHByb3BlcnRpZXNcbiAgICogQHJldHVybnMgc2V0dGluZ3MgcHJvcGVydGllc1xuICAgKi9cbiAgZ2V0IHNldHRpbmdzKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwibGVmdFwiLFxuICAgICAgICBpY29uOiBIZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJjZW50ZXJcIixcbiAgICAgICAgaWNvbjogRGVcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgUXVvdGUgVG9vbCBjb250YWluZXIgd2l0aCBpbnB1dHNcbiAgICogQHJldHVybnMgYmxvY2txdW90ZSBET00gZWxlbWVudCAtIFF1b3RlIFRvb2wgY29udGFpbmVyXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgdCA9IHYubWFrZShcImJsb2NrcXVvdGVcIiwgW1xuICAgICAgdGhpcy5jc3MuYmFzZUNsYXNzLFxuICAgICAgdGhpcy5jc3Mud3JhcHBlclxuICAgIF0pLCBuID0gdi5tYWtlKFwiZGl2XCIsIFt0aGlzLmNzcy5pbnB1dCwgdGhpcy5jc3MudGV4dF0sIHtcbiAgICAgIGNvbnRlbnRFZGl0YWJsZTogIXRoaXMucmVhZE9ubHksXG4gICAgICBpbm5lckhUTUw6IHRoaXMuZGF0YS50ZXh0XG4gICAgfSksIHIgPSB2Lm1ha2UoXCJkaXZcIiwgW3RoaXMuY3NzLmlucHV0LCB0aGlzLmNzcy5jYXB0aW9uXSwge1xuICAgICAgY29udGVudEVkaXRhYmxlOiAhdGhpcy5yZWFkT25seSxcbiAgICAgIGlubmVySFRNTDogdGhpcy5kYXRhLmNhcHRpb25cbiAgICB9KTtcbiAgICByZXR1cm4gbi5kYXRhc2V0LnBsYWNlaG9sZGVyID0gdGhpcy5xdW90ZVBsYWNlaG9sZGVyLCByLmRhdGFzZXQucGxhY2Vob2xkZXIgPSB0aGlzLmNhcHRpb25QbGFjZWhvbGRlciwgdC5hcHBlbmRDaGlsZChuKSwgdC5hcHBlbmRDaGlsZChyKSwgdDtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdCBRdW90ZSBkYXRhIGZyb20gUXVvdGUgVG9vbCBlbGVtZW50XG4gICAqIEBwYXJhbSBxdW90ZUVsZW1lbnQgLSBRdW90ZSBET00gZWxlbWVudCB0byBzYXZlXG4gICAqIEByZXR1cm5zIFF1b3RlIGRhdGEgb2JqZWN0XG4gICAqL1xuICBzYXZlKHQpIHtcbiAgICBjb25zdCBuID0gdC5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLmNzcy50ZXh0fWApLCByID0gdC5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLmNzcy5jYXB0aW9ufWApO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHRoaXMuZGF0YSwge1xuICAgICAgdGV4dDogKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uaW5uZXJIVE1MKSA/PyBcIlwiLFxuICAgICAgY2FwdGlvbjogKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuaW5uZXJIVE1MKSA/PyBcIlwiXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNhbml0aXplciBydWxlc1xuICAgKiBAcmV0dXJucyBzYW5pdGl6ZXIgcnVsZXNcbiAgICovXG4gIHN0YXRpYyBnZXQgc2FuaXRpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHtcbiAgICAgICAgYnI6ICEwXG4gICAgICB9LFxuICAgICAgY2FwdGlvbjoge1xuICAgICAgICBicjogITBcbiAgICAgIH0sXG4gICAgICBhbGlnbm1lbnQ6IHt9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIHdyYXBwZXIgZm9yIFRvb2xgcyBzZXR0aW5ncyBidXR0b25zOlxuICAgKiAxLiBMZWZ0IGFsaWdubWVudFxuICAgKiAyLiBDZW50ZXIgYWxpZ25tZW50XG4gICAqIEByZXR1cm5zIHNldHRpbmdzIG1lbnVcbiAgICovXG4gIHJlbmRlclNldHRpbmdzKCkge1xuICAgIGNvbnN0IHQgPSAobikgPT4gbiAmJiBuWzBdLnRvVXBwZXJDYXNlKCkgKyBuLnNsaWNlKDEpO1xuICAgIHJldHVybiB0aGlzLnNldHRpbmdzLm1hcCgobikgPT4gKHtcbiAgICAgIGljb246IG4uaWNvbixcbiAgICAgIGxhYmVsOiB0aGlzLmFwaS5pMThuLnQoYEFsaWduICR7dChuLm5hbWUpfWApLFxuICAgICAgb25BY3RpdmF0ZTogKCkgPT4gdGhpcy5fdG9nZ2xlVHVuZShuLm5hbWUpLFxuICAgICAgaXNBY3RpdmU6IHRoaXMuZGF0YS5hbGlnbm1lbnQgPT09IG4ubmFtZSxcbiAgICAgIGNsb3NlT25BY3RpdmF0ZTogITBcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZSBxdW90ZWBzIGFsaWdubWVudFxuICAgKiBAcGFyYW0gdHVuZSAtIGFsaWdubWVudFxuICAgKi9cbiAgX3RvZ2dsZVR1bmUodCkge1xuICAgIHRoaXMuZGF0YS5hbGlnbm1lbnQgPSB0LCB0aGlzLmJsb2NrLmRpc3BhdGNoQ2hhbmdlKCk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIG0gYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@editorjs/quote/dist/quote.mjs\n\n}");

/***/ }),

/***/ "./node_modules/@editorjs/underline/dist/underline.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@editorjs/underline/dist/underline.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ a)\n/* harmony export */ });\n(function(){\"use strict\";try{if(typeof document<\"u\"){var e=document.createElement(\"style\");e.appendChild(document.createTextNode(\".cdx-underline{text-decoration:underline}\")),document.head.appendChild(e)}}catch(n){console.error(\"vite-plugin-css-injected-by-js\",n)}})();\nconst r = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"none\" viewBox=\"0 0 24 24\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 7.5V11.5C9 12.2956 9.31607 13.0587 9.87868 13.6213C10.4413 14.1839 11.2044 14.5 12 14.5C12.7956 14.5 13.5587 14.1839 14.1213 13.6213C14.6839 13.0587 15 12.2956 15 11.5V7.5\"/><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M7.71429 18H16.2857\"/></svg>', s = class s {\n  /**\n   * @param options InlineToolConstructorOptions\n   */\n  constructor(e) {\n    this.tag = \"U\", this.api = e.api, this.iconClasses = {\n      base: this.api.styles.inlineToolButton,\n      active: this.api.styles.inlineToolButtonActive\n    };\n  }\n  /**\n   * Class name for term-tag\n   *\n   * @type {string}\n   */\n  static get CSS() {\n    return \"cdx-underline\";\n  }\n  /**\n   * Create button element for Toolbar\n   *\n   * @returns {HTMLElement}\n   */\n  render() {\n    return this.button = document.createElement(\"button\"), this.button.type = \"button\", this.button.classList.add(this.iconClasses.base), this.button.innerHTML = this.toolboxIcon, this.button;\n  }\n  /**\n   * Wrap/Unwrap selected fragment\n   *\n   * @param {Range} range - selected fragment\n   */\n  surround(e) {\n    if (!e)\n      return;\n    const t = this.api.selection.findParentTag(this.tag, s.CSS);\n    t ? this.unwrap(t) : this.wrap(e);\n  }\n  /**\n   * Wrap selection with term-tag\n   *\n   * @param {Range} range - selected fragment\n   */\n  wrap(e) {\n    const t = document.createElement(this.tag);\n    t.classList.add(s.CSS), t.appendChild(e.extractContents()), e.insertNode(t), this.api.selection.expandToTag(t);\n  }\n  /**\n   * Unwrap term-tag\n   *\n   * @param {HTMLElement} termWrapper - term wrapper tag\n   */\n  unwrap(e) {\n    var o;\n    this.api.selection.expandToTag(e);\n    const t = window.getSelection();\n    if (!t)\n      return;\n    const n = t.getRangeAt(0);\n    if (!n)\n      return;\n    const i = n.extractContents();\n    i && ((o = e.parentNode) == null || o.removeChild(e), n.insertNode(i), t.removeAllRanges(), t.addRange(n));\n  }\n  /**\n   * Check and change Term's state for current selection\n   */\n  checkState() {\n    var t;\n    const e = this.api.selection.findParentTag(this.tag, s.CSS);\n    return (t = this.button) == null || t.classList.toggle(this.iconClasses.active, !!e), !!e;\n  }\n  /**\n   * Get Tool icon's SVG\n   *\n   * @returns {string}\n   */\n  get toolboxIcon() {\n    return r;\n  }\n  /**\n   * Sanitizer rule\n   *\n   * @returns {{u: {class: string}}}\n   */\n  static get sanitize() {\n    return {\n      u: {\n        class: s.CSS\n      }\n    };\n  }\n};\ns.isInline = !0;\nlet a = s;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVkaXRvcmpzL3VuZGVybGluZS9kaXN0L3VuZGVybGluZS5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLFlBQVksYUFBYSxJQUFJLHdCQUF3QixzQ0FBc0Msc0RBQXNELDBCQUEwQixrQ0FBa0MsU0FBUyxtREFBbUQ7QUFDelE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vbm9kZV9tb2R1bGVzL0BlZGl0b3Jqcy91bmRlcmxpbmUvZGlzdC91bmRlcmxpbmUubWpzP2RkNmUiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dHJ5e2lmKHR5cGVvZiBkb2N1bWVudDxcInVcIil7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO2UuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIuY2R4LXVuZGVybGluZXt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lfVwiKSksZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChlKX19Y2F0Y2gobil7Y29uc29sZS5lcnJvcihcInZpdGUtcGx1Z2luLWNzcy1pbmplY3RlZC1ieS1qc1wiLG4pfX0pKCk7XG5jb25zdCByID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTkgNy41VjExLjVDOSAxMi4yOTU2IDkuMzE2MDcgMTMuMDU4NyA5Ljg3ODY4IDEzLjYyMTNDMTAuNDQxMyAxNC4xODM5IDExLjIwNDQgMTQuNSAxMiAxNC41QzEyLjc5NTYgMTQuNSAxMy41NTg3IDE0LjE4MzkgMTQuMTIxMyAxMy42MjEzQzE0LjY4MzkgMTMuMDU4NyAxNSAxMi4yOTU2IDE1IDExLjVWNy41XCIvPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTcuNzE0MjkgMThIMTYuMjg1N1wiLz48L3N2Zz4nLCBzID0gY2xhc3MgcyB7XG4gIC8qKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBJbmxpbmVUb29sQ29uc3RydWN0b3JPcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy50YWcgPSBcIlVcIiwgdGhpcy5hcGkgPSBlLmFwaSwgdGhpcy5pY29uQ2xhc3NlcyA9IHtcbiAgICAgIGJhc2U6IHRoaXMuYXBpLnN0eWxlcy5pbmxpbmVUb29sQnV0dG9uLFxuICAgICAgYWN0aXZlOiB0aGlzLmFwaS5zdHlsZXMuaW5saW5lVG9vbEJ1dHRvbkFjdGl2ZVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENsYXNzIG5hbWUgZm9yIHRlcm0tdGFnXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IENTUygpIHtcbiAgICByZXR1cm4gXCJjZHgtdW5kZXJsaW5lXCI7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBidXR0b24gZWxlbWVudCBmb3IgVG9vbGJhclxuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSwgdGhpcy5idXR0b24udHlwZSA9IFwiYnV0dG9uXCIsIHRoaXMuYnV0dG9uLmNsYXNzTGlzdC5hZGQodGhpcy5pY29uQ2xhc3Nlcy5iYXNlKSwgdGhpcy5idXR0b24uaW5uZXJIVE1MID0gdGhpcy50b29sYm94SWNvbiwgdGhpcy5idXR0b247XG4gIH1cbiAgLyoqXG4gICAqIFdyYXAvVW53cmFwIHNlbGVjdGVkIGZyYWdtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlIC0gc2VsZWN0ZWQgZnJhZ21lbnRcbiAgICovXG4gIHN1cnJvdW5kKGUpIHtcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMuYXBpLnNlbGVjdGlvbi5maW5kUGFyZW50VGFnKHRoaXMudGFnLCBzLkNTUyk7XG4gICAgdCA/IHRoaXMudW53cmFwKHQpIDogdGhpcy53cmFwKGUpO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwIHNlbGVjdGlvbiB3aXRoIHRlcm0tdGFnXG4gICAqXG4gICAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlIC0gc2VsZWN0ZWQgZnJhZ21lbnRcbiAgICovXG4gIHdyYXAoZSkge1xuICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnKTtcbiAgICB0LmNsYXNzTGlzdC5hZGQocy5DU1MpLCB0LmFwcGVuZENoaWxkKGUuZXh0cmFjdENvbnRlbnRzKCkpLCBlLmluc2VydE5vZGUodCksIHRoaXMuYXBpLnNlbGVjdGlvbi5leHBhbmRUb1RhZyh0KTtcbiAgfVxuICAvKipcbiAgICogVW53cmFwIHRlcm0tdGFnXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRlcm1XcmFwcGVyIC0gdGVybSB3cmFwcGVyIHRhZ1xuICAgKi9cbiAgdW53cmFwKGUpIHtcbiAgICB2YXIgbztcbiAgICB0aGlzLmFwaS5zZWxlY3Rpb24uZXhwYW5kVG9UYWcoZSk7XG4gICAgY29uc3QgdCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbiA9IHQuZ2V0UmFuZ2VBdCgwKTtcbiAgICBpZiAoIW4pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IG4uZXh0cmFjdENvbnRlbnRzKCk7XG4gICAgaSAmJiAoKG8gPSBlLnBhcmVudE5vZGUpID09IG51bGwgfHwgby5yZW1vdmVDaGlsZChlKSwgbi5pbnNlcnROb2RlKGkpLCB0LnJlbW92ZUFsbFJhbmdlcygpLCB0LmFkZFJhbmdlKG4pKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgYW5kIGNoYW5nZSBUZXJtJ3Mgc3RhdGUgZm9yIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAqL1xuICBjaGVja1N0YXRlKCkge1xuICAgIHZhciB0O1xuICAgIGNvbnN0IGUgPSB0aGlzLmFwaS5zZWxlY3Rpb24uZmluZFBhcmVudFRhZyh0aGlzLnRhZywgcy5DU1MpO1xuICAgIHJldHVybiAodCA9IHRoaXMuYnV0dG9uKSA9PSBudWxsIHx8IHQuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLmljb25DbGFzc2VzLmFjdGl2ZSwgISFlKSwgISFlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgVG9vbCBpY29uJ3MgU1ZHXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgdG9vbGJveEljb24oKSB7XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgLyoqXG4gICAqIFNhbml0aXplciBydWxlXG4gICAqXG4gICAqIEByZXR1cm5zIHt7dToge2NsYXNzOiBzdHJpbmd9fX1cbiAgICovXG4gIHN0YXRpYyBnZXQgc2FuaXRpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHU6IHtcbiAgICAgICAgY2xhc3M6IHMuQ1NTXG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbnMuaXNJbmxpbmUgPSAhMDtcbmxldCBhID0gcztcbmV4cG9ydCB7XG4gIGEgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@editorjs/underline/dist/underline.mjs\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/createPopper.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/createPopper.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPopper: () => (/* binding */ createPopper),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   popperGenerator: () => (/* binding */ popperGenerator)\n/* harmony export */ });\n/* harmony import */ var _dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-utils/getCompositeRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js\");\n/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-utils/getLayoutRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\");\n/* harmony import */ var _dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom-utils/listScrollParents.js */ \"./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js\");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom-utils/getOffsetParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\");\n/* harmony import */ var _utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/orderModifiers.js */ \"./node_modules/@popperjs/core/lib/utils/orderModifiers.js\");\n/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/debounce.js */ \"./node_modules/@popperjs/core/lib/utils/debounce.js\");\n/* harmony import */ var _utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/mergeByName.js */ \"./node_modules/@popperjs/core/lib/utils/mergeByName.js\");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/detectOverflow.js */ \"./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dom-utils/instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\n\n\n\n\n\n\n\n\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: (0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_8__.isElement)(reference) ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(reference) : reference.contextElement ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(reference.contextElement) : [],\n          popper: (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = (0,_utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((0,_utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        });\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: (0,_dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(reference, (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(popper), state.options.strategy === 'fixed'),\n          popper: (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: (0,_utils_debounce_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref) {\n        var name = _ref.name,\n            _ref$options = _ref.options,\n            options = _ref$options === void 0 ? {} : _ref$options,\n            effect = _ref.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nvar createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBK0Q7QUFDTjtBQUNRO0FBQ0o7QUFDTjtBQUNaO0FBQ007QUFDTTtBQUNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzRUFBc0UsYUFBYTtBQUNuRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxxQkFBcUIsbUVBQVMsY0FBYywyRUFBaUIseUNBQXlDLDJFQUFpQjtBQUN2SCxrQkFBa0IsMkVBQWlCO0FBQ25DLFdBQVc7QUFDWDs7QUFFQSwrQkFBK0Isb0VBQWMsQ0FBQyxpRUFBVyx5REFBeUQ7O0FBRWxIO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQSxxQkFBcUIsMEVBQWdCLFlBQVkseUVBQWU7QUFDaEUsa0JBQWtCLHVFQUFhO0FBQy9CLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7O0FBRWxEO0FBQ0Esc0VBQXNFO0FBQ3RFLFNBQVM7O0FBRVQsNEJBQTRCLHVDQUF1QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsY0FBYyw4REFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPLG1EQUFtRCIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcz81MDkwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRDb21wb3NpdGVSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gXCIuL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgb3JkZXJNb2RpZmllcnMgZnJvbSBcIi4vdXRpbHMvb3JkZXJNb2RpZmllcnMuanNcIjtcbmltcG9ydCBkZWJvdW5jZSBmcm9tIFwiLi91dGlscy9kZWJvdW5jZS5qc1wiO1xuaW1wb3J0IG1lcmdlQnlOYW1lIGZyb20gXCIuL3V0aWxzL21lcmdlQnlOYW1lLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICBtb2RpZmllcnM6IFtdLFxuICBzdHJhdGVneTogJ2Fic29sdXRlJ1xufTtcblxuZnVuY3Rpb24gYXJlVmFsaWRFbGVtZW50cygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiAhYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuICEoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcHBlckdlbmVyYXRvcihnZW5lcmF0b3JPcHRpb25zKSB7XG4gIGlmIChnZW5lcmF0b3JPcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBnZW5lcmF0b3JPcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX2dlbmVyYXRvck9wdGlvbnMgPSBnZW5lcmF0b3JPcHRpb25zLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE1vZGlmaWVycyxcbiAgICAgIGRlZmF1bHRNb2RpZmllcnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPT09IHZvaWQgMCA/IFtdIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRPcHRpb25zLFxuICAgICAgZGVmYXVsdE9wdGlvbnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID09PSB2b2lkIDAgPyBERUZBVUxUX09QVElPTlMgOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgZGVmYXVsdE9wdGlvbnMpLFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2U6IHJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyOiBwb3BwZXJcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9O1xuICAgIHZhciBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgdmFyIGlzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgdmFyIGluc3RhbmNlID0ge1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyhzZXRPcHRpb25zQWN0aW9uKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHNldE9wdGlvbnNBY3Rpb24gPT09ICdmdW5jdGlvbicgPyBzZXRPcHRpb25zQWN0aW9uKHN0YXRlLm9wdGlvbnMpIDogc2V0T3B0aW9uc0FjdGlvbjtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBzdGF0ZS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIHN0YXRlLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogaXNFbGVtZW50KHJlZmVyZW5jZSkgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UpIDogcmVmZXJlbmNlLmNvbnRleHRFbGVtZW50ID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKVxuICAgICAgICB9OyAvLyBPcmRlcnMgdGhlIG1vZGlmaWVycyBiYXNlZCBvbiB0aGVpciBkZXBlbmRlbmNpZXMgYW5kIGBwaGFzZWBcbiAgICAgICAgLy8gcHJvcGVydGllc1xuXG4gICAgICAgIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnMobWVyZ2VCeU5hbWUoW10uY29uY2F0KGRlZmF1bHRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSkpOyAvLyBTdHJpcCBvdXQgZGlzYWJsZWQgbW9kaWZpZXJzXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uZW5hYmxlZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJ1bk1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9LFxuICAgICAgLy8gU3luYyB1cGRhdGUg4oCTIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcbiAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcbiAgICAgIC8vIGxvZ2ljLlxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xuICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxuICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICBpZiAoaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0YXRlJGVsZW1lbnRzID0gc3RhdGUuZWxlbWVudHMsXG4gICAgICAgICAgICByZWZlcmVuY2UgPSBfc3RhdGUkZWxlbWVudHMucmVmZXJlbmNlLFxuICAgICAgICAgICAgcG9wcGVyID0gX3N0YXRlJGVsZW1lbnRzLnBvcHBlcjsgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXG4gICAgICAgIC8vIGFueW1vcmVcblxuICAgICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xuXG5cbiAgICAgICAgc3RhdGUucmVjdHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBnZXRDb21wb3NpdGVSZWN0KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KHBvcHBlciksIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCcpLFxuICAgICAgICAgIHBvcHBlcjogZ2V0TGF5b3V0UmVjdChwb3BwZXIpXG4gICAgICAgIH07IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIHJlc2V0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZS4gVGhlXG4gICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXG4gICAgICAgIC8vIHBsYWNlbWVudCwgd2hpY2ggdGhlbiBuZWVkcyB0byByZS1ydW4gYWxsIHRoZSBtb2RpZmllcnMsIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIGxvZ2ljIHdhcyBwcmV2aW91c2x5IHJhbiBmb3IgdGhlIHByZXZpb3VzIHBsYWNlbWVudCBhbmQgaXMgdGhlcmVmb3JlXG4gICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxuXG4gICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50OyAvLyBPbiBlYWNoIHVwZGF0ZSBjeWNsZSwgdGhlIGBtb2RpZmllcnNEYXRhYCBwcm9wZXJ0eSBmb3IgZWFjaCBtb2RpZmllclxuICAgICAgICAvLyBpcyBmaWxsZWQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhIHNwZWNpZmllZCBieSB0aGUgbW9kaWZpZXIuIFRoaXMgbWVhbnNcbiAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0IGFuZCBpcyBmcmVzaCBvbiBlYWNoIHVwZGF0ZS5cbiAgICAgICAgLy8gVG8gZW5zdXJlIHBlcnNpc3RlbnQgZGF0YSwgdXNlIGAke25hbWV9I3BlcnNpc3RlbnRgXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5tb2RpZmllcnNEYXRhW21vZGlmaWVyLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kaWZpZXIuZGF0YSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGlmIChzdGF0ZS5yZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3N0YXRlJG9yZGVyZWRNb2RpZmllID0gc3RhdGUub3JkZXJlZE1vZGlmaWVyc1tpbmRleF0sXG4gICAgICAgICAgICAgIGZuID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLmZuLFxuICAgICAgICAgICAgICBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm9wdGlvbnMsXG4gICAgICAgICAgICAgIF9vcHRpb25zID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9PT0gdm9pZCAwID8ge30gOiBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyLFxuICAgICAgICAgICAgICBuYW1lID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm5hbWU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGZuKHtcbiAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICBvcHRpb25zOiBfb3B0aW9ucyxcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlXG4gICAgICAgICAgICB9KSB8fCBzdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBc3luYyBhbmQgb3B0aW1pc3RpY2FsbHkgb3B0aW1pemVkIHVwZGF0ZSDigJMgaXQgd2lsbCBub3QgYmUgZXhlY3V0ZWQgaWZcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxuICAgICAgdXBkYXRlOiBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgcmVzb2x2ZShzdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIGlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmICghaXNEZXN0cm95ZWQgJiYgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIG9wdGlvbnMub25GaXJzdFVwZGF0ZShzdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgYmVmb3JlIHRoZSBmaXJzdFxuICAgIC8vIHVwZGF0ZSBjeWNsZSBydW5zLiBUaGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHVwZGF0ZVxuICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XG4gICAgLy8gb3RoZXIgbW9kaWZpZXJzIG5lZWQgdG8gdXNlLCBidXQgdGhlIG1vZGlmaWVyIGlzIHJ1biBhZnRlciB0aGUgZGVwZW5kZW50XG4gICAgLy8gb25lLlxuXG4gICAgZnVuY3Rpb24gcnVuTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICAgICAgX3JlZiRvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9ucyA9IF9yZWYkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJG9wdGlvbnMsXG4gICAgICAgICAgICBlZmZlY3QgPSBfcmVmLmVmZmVjdDtcblxuICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjbGVhbnVwRm4gPSBlZmZlY3Qoe1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBub29wRm4gPSBmdW5jdGlvbiBub29wRm4oKSB7fTtcblxuICAgICAgICAgIGVmZmVjdENsZWFudXBGbnMucHVzaChjbGVhbnVwRm4gfHwgbm9vcEZuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9KTtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59XG5leHBvcnQgdmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBkZXRlY3RPdmVyZmxvdyB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/createPopper.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/contains.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/contains.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ contains)\n/* harmony export */ });\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\nfunction contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(rootNode)) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n  return false;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQztBQUNoQztBQUNmLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBLElBQUk7QUFDSix1QkFBdUIsNERBQVk7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQSxRQUFRO0FBQ1IsTUFBTTs7O0FBR047QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcz9hMjExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgICAgdmFyIG5leHQgPSBjaGlsZDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cblxuXG4gICAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgICAgfSB3aGlsZSAobmV4dCk7XG4gICAgfSAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG5cblxuICByZXR1cm4gZmFsc2U7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/contains.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getBoundingClientRect)\n/* harmony export */ });\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math.js */ \"./node_modules/@popperjs/core/lib/utils/math.js\");\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isLayoutViewport.js */ \"./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js\");\n\n\n\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  var clientRect = element.getBoundingClientRect();\n  var scaleX = 1;\n  var scaleY = 1;\n\n  if (includeScale && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n    scaleX = element.offsetWidth > 0 ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  var _ref = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element) : window,\n      visualViewport = _ref.visualViewport;\n\n  var addVisualOffsets = !(0,_isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])() && isFixedStrategy;\n  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n  var width = clientRect.width / scaleX;\n  var height = clientRect.height / scaleY;\n  return {\n    width: width,\n    height: height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x: x,\n    y: y\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkQ7QUFDbEI7QUFDRjtBQUNjO0FBQ3RDO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDZEQUFhO0FBQ25DLHVDQUF1QyxxREFBSztBQUM1Qyx3Q0FBd0MscURBQUs7QUFDN0M7O0FBRUEsYUFBYSx5REFBUyxZQUFZLHlEQUFTO0FBQzNDOztBQUVBLDBCQUEwQixnRUFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcz9mY2M2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNMYXlvdXRWaWV3cG9ydCBmcm9tIFwiLi9pc0xheW91dFZpZXdwb3J0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3kpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuXG4gIGlmIChpbmNsdWRlU2NhbGUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHNjYWxlWCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggPiAwID8gcm91bmQoY2xpZW50UmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEgOiAxO1xuICAgIHNjYWxlWSA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ID4gMCA/IHJvdW5kKGNsaWVudFJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEgOiAxO1xuICB9XG5cbiAgdmFyIF9yZWYgPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3csXG4gICAgICB2aXN1YWxWaWV3cG9ydCA9IF9yZWYudmlzdWFsVmlld3BvcnQ7XG5cbiAgdmFyIGFkZFZpc3VhbE9mZnNldHMgPSAhaXNMYXlvdXRWaWV3cG9ydCgpICYmIGlzRml4ZWRTdHJhdGVneTtcbiAgdmFyIHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0IDogMCkpIC8gc2NhbGVYO1xuICB2YXIgeSA9IChjbGllbnRSZWN0LnRvcCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wIDogMCkpIC8gc2NhbGVZO1xuICB2YXIgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGVYO1xuICB2YXIgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICBsZWZ0OiB4LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getClippingRect)\n/* harmony export */ });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _getViewportRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getViewportRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js\");\n/* harmony import */ var _getDocumentRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js\");\n/* harmony import */ var _listScrollParents_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./listScrollParents.js */ \"./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js\");\n/* harmony import */ var _getOffsetParent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getOffsetParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getComputedStyle.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getBoundingClientRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\");\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getParentNode.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\");\n/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./contains.js */ \"./node_modules/@popperjs/core/lib/dom-utils/contains.js\");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./getNodeName.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utils/rectToClientRect.js */ \"./node_modules/@popperjs/core/lib/utils/rectToClientRect.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/math.js */ \"./node_modules/@popperjs/core/lib/utils/math.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(element, false, strategy === 'fixed');\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n\nfunction getClientRectFromMixedType(element, clippingParent, strategy) {\n  return clippingParent === _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport ? (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"])((0,_getViewportRect_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element, strategy)) : (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__.isElement)(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"])((0,_getDocumentRect_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = (0,_listScrollParents_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(element));\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(element).position) >= 0;\n  var clipperElement = canEscapeClipping && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__.isHTMLElement)(element) ? (0,_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(element) : element;\n\n  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__.isElement)(clipperElement)) {\n    return [];\n  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_7__.isElement)(clippingParent) && (0,_contains_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(clippingParent, clipperElement) && (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(clippingParent) !== 'body';\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nfunction getClippingRect(element, boundary, rootBoundary, strategy) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n    accRect.top = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.top, accRect.top);\n    accRect.right = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.right, accRect.right);\n    accRect.bottom = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.bottom, accRect.bottom);\n    accRect.left = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVDO0FBQ1k7QUFDQTtBQUNJO0FBQ0o7QUFDTTtBQUNKO0FBQ007QUFDSTtBQUNoQjtBQUNWO0FBQ007QUFDaUI7QUFDaEI7O0FBRTVDO0FBQ0EsYUFBYSxxRUFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsK0NBQVEsR0FBRyx1RUFBZ0IsQ0FBQywrREFBZSx1QkFBdUIseURBQVMsMEVBQTBFLHVFQUFnQixDQUFDLCtEQUFlLENBQUMsa0VBQWtCO0FBQ3BPLEVBQUU7QUFDRjtBQUNBOzs7QUFHQTtBQUNBLHdCQUF3QixpRUFBaUIsQ0FBQyw2REFBYTtBQUN2RCx3REFBd0QsZ0VBQWdCO0FBQ3hFLDRDQUE0Qyw2REFBYSxZQUFZLCtEQUFlOztBQUVwRixPQUFPLHlEQUFTO0FBQ2hCO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSxXQUFXLHlEQUFTLG9CQUFvQix5REFBUSxvQ0FBb0MsNERBQVc7QUFDL0YsR0FBRztBQUNILEVBQUU7QUFDRjs7O0FBR2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9EQUFHO0FBQ3JCLG9CQUFvQixvREFBRztBQUN2QixxQkFBcUIsb0RBQUc7QUFDeEIsbUJBQW1CLG9EQUFHO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanM/NmRiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2aWV3cG9ydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZpZXdwb3J0UmVjdCBmcm9tIFwiLi9nZXRWaWV3cG9ydFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudFJlY3QgZnJvbSBcIi4vZ2V0RG9jdW1lbnRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBjb250YWlucyBmcm9tIFwiLi9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tIFwiLi4vdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgbWF4LCBtaW4gfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBmYWxzZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuICByZWN0LnRvcCA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIHJlY3QubGVmdCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC53aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3QuaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QueCA9IHJlY3QubGVmdDtcbiAgcmVjdC55ID0gcmVjdC50b3A7XG4gIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIHtcbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50ID09PSB2aWV3cG9ydCA/IHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSkgOiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpID8gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSA6IHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufSAvLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXG4vLyBgaW5pdGlhbGBcblxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkge1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gbGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG4gIHZhciBjYW5Fc2NhcGVDbGlwcGluZyA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24pID49IDA7XG4gIHZhciBjbGlwcGVyRWxlbWVudCA9IGNhbkVzY2FwZUNsaXBwaW5nICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIGlmICghaXNFbGVtZW50KGNsaXBwZXJFbGVtZW50KSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMTQxNFxuXG5cbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50cy5maWx0ZXIoZnVuY3Rpb24gKGNsaXBwaW5nUGFyZW50KSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiYgY29udGFpbnMoY2xpcHBpbmdQYXJlbnQsIGNsaXBwZXJFbGVtZW50KSAmJiBnZXROb2RlTmFtZShjbGlwcGluZ1BhcmVudCkgIT09ICdib2R5JztcbiAgfSk7XG59IC8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIHBhcmVudHNcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoZWxlbWVudCwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSwgc3RyYXRlZ3kpIHtcbiAgdmFyIG1haW5DbGlwcGluZ1BhcmVudHMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nUGFyZW50cycgPyBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gW10uY29uY2F0KG1haW5DbGlwcGluZ1BhcmVudHMsIFtyb290Qm91bmRhcnldKTtcbiAgdmFyIGZpcnN0Q2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNbMF07XG4gIHZhciBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ1BhcmVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2NSZWN0LCBjbGlwcGluZ1BhcmVudCkge1xuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkpO1xuICBjbGlwcGluZ1JlY3Qud2lkdGggPSBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LmhlaWdodCA9IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wO1xuICBjbGlwcGluZ1JlY3QueCA9IGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QueSA9IGNsaXBwaW5nUmVjdC50b3A7XG4gIHJldHVybiBjbGlwcGluZ1JlY3Q7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getCompositeRect)\n/* harmony export */ });\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\");\n/* harmony import */ var _getNodeScroll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getNodeScroll.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js\");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getNodeName.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isScrollParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/math.js */ \"./node_modules/@popperjs/core/lib/utils/math.js\");\n\n\n\n\n\n\n\n\n\nfunction isElementScaled(element) {\n  var rect = element.getBoundingClientRect();\n  var scaleX = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_7__.round)(rect.width) / element.offsetWidth || 1;\n  var scaleY = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_7__.round)(rect.height) / element.offsetHeight || 1;\n  return scaleX !== 1 || scaleY !== 1;\n} // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\n\n\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  var isOffsetParentAnElement = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(offsetParent);\n  var offsetParentIsScaled = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(offsetParent) && isElementScaled(offsetParent);\n  var documentElement = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(offsetParent);\n  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n    (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(documentElement)) {\n      scroll = (0,_getNodeScroll_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(offsetParent);\n    }\n\n    if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(offsetParent)) {\n      offsets = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(offsetParent, true);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErRDtBQUNoQjtBQUNKO0FBQ0s7QUFDVztBQUNGO0FBQ1I7QUFDUjs7QUFFekM7QUFDQTtBQUNBLGVBQWUscURBQUs7QUFDcEIsZUFBZSxxREFBSztBQUNwQjtBQUNBLEVBQUU7QUFDRjs7O0FBR2U7QUFDZjtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLDZEQUFhO0FBQzdDLDZCQUE2Qiw2REFBYTtBQUMxQyx3QkFBd0Isa0VBQWtCO0FBQzFDLGFBQWEscUVBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLDJEQUFXO0FBQ25CLElBQUksOERBQWM7QUFDbEIsZUFBZSw2REFBYTtBQUM1Qjs7QUFFQSxRQUFRLDZEQUFhO0FBQ3JCLGdCQUFnQixxRUFBcUI7QUFDckM7QUFDQTtBQUNBLE1BQU07QUFDTixrQkFBa0IsbUVBQW1CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcz82ZTNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZVNjcm9sbCBmcm9tIFwiLi9nZXROb2RlU2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudFNjYWxlZChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IHJvdW5kKHJlY3Qud2lkdGgpIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxO1xuICB2YXIgc2NhbGVZID0gcm91bmQocmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMTtcbiAgcmV0dXJuIHNjYWxlWCAhPT0gMSB8fCBzY2FsZVkgIT09IDE7XG59IC8vIFJldHVybnMgdGhlIGNvbXBvc2l0ZSByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC5cbi8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb21wb3NpdGVSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnQsIGlzRml4ZWQpIHtcbiAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudElzU2NhbGVkID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzRWxlbWVudFNjYWxlZChvZmZzZXRQYXJlbnQpO1xuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnRJc1NjYWxlZCwgaXNGaXhlZCk7XG4gIHZhciBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gICAgaXNTY3JvbGxQYXJlbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIG9mZnNldHMgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlKTtcbiAgICAgIG9mZnNldHMueCArPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSArPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getComputedStyle)\n/* harmony export */ });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n\nfunction getComputedStyle(element) {\n  return (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element).getComputedStyle(element);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVDO0FBQ3hCO0FBQ2YsU0FBUyx5REFBUztBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzPzA5ZmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getDocumentElement)\n/* harmony export */ });\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\nfunction getDocumentElement(element) {\n  // $FlowFixMe[incompatible-return]: assume body is always available\n  return (((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\n  element.document) || window.document).documentElement;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEM7QUFDN0I7QUFDZjtBQUNBLFdBQVcseURBQVM7QUFDcEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanM/M2E4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getDocumentRect)\n/* harmony export */ });\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getDocumentElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getComputedStyle.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\");\n/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\");\n/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScroll.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/math.js */ \"./node_modules/@popperjs/core/lib/utils/math.js\");\n\n\n\n\n // Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element);\n  var winScroll = (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(element);\n  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_4__.max)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_4__.max)(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element);\n  var y = -winScroll.scrollTop;\n\n  if ((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(body || html).direction === 'rtl') {\n    x += (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_4__.max)(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudFJlY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXlEO0FBQ0o7QUFDTTtBQUNSO0FBQ1osQ0FBQztBQUN4Qzs7QUFFZTtBQUNmOztBQUVBLGFBQWEsa0VBQWtCO0FBQy9CLGtCQUFrQiwrREFBZTtBQUNqQztBQUNBLGNBQWMsbURBQUc7QUFDakIsZUFBZSxtREFBRztBQUNsQixrQ0FBa0MsbUVBQW1CO0FBQ3JEOztBQUVBLE1BQU0sZ0VBQWdCO0FBQ3RCLFNBQVMsbURBQUc7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudFJlY3QuanM/YmUwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCB7IG1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGVcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgdmFyIGJvZHkgPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHk7XG4gIHZhciB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5zY3JvbGxXaWR0aCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCk7XG4gIHZhciBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcbiAgdmFyIHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICB2YXIgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCkgLSB3aWR0aDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getHTMLElementScroll)\n/* harmony export */ });\nfunction getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRIVE1MRWxlbWVudFNjcm9sbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzPzU1MTUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRTY3JvbGwoZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getLayoutRect)\n/* harmony export */ });\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\");\n // Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\n\nfunction getLayoutRect(element) {\n  var clientRect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element); // Use the clientRect sizes if it's not been transformed.\n  // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n\n  if (Math.abs(clientRect.width - width) <= 1) {\n    width = clientRect.width;\n  }\n\n  if (Math.abs(clientRect.height - height) <= 1) {\n    height = clientRect.height;\n  }\n\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: width,\n    height: height\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStELENBQUM7QUFDaEU7O0FBRWU7QUFDZixtQkFBbUIscUVBQXFCLFdBQVc7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanM/MGM0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiOyAvLyBSZXR1cm5zIHRoZSBsYXlvdXQgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuIExheW91dFxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRMYXlvdXRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7IC8vIFVzZSB0aGUgY2xpZW50UmVjdCBzaXplcyBpZiBpdCdzIG5vdCBiZWVuIHRyYW5zZm9ybWVkLlxuICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEyMjNcblxuICB2YXIgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3Qud2lkdGggLSB3aWR0aCkgPD0gMSkge1xuICAgIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LmhlaWdodCAtIGhlaWdodCkgPD0gMSkge1xuICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getNodeName)\n/* harmony export */ });\nfunction getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlTmFtZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzPzc3Y2IiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getNodeScroll)\n/* harmony export */ });\n/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindowScroll.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\");\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n/* harmony import */ var _getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getHTMLElementScroll.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js\");\n\n\n\n\nfunction getNodeScroll(node) {\n  if (node === (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(node) || !(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(node)) {\n    return (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node);\n  } else {\n    return (0,_getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(node);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1EO0FBQ1o7QUFDUztBQUNhO0FBQzlDO0FBQ2YsZUFBZSx5REFBUyxXQUFXLDZEQUFhO0FBQ2hELFdBQVcsK0RBQWU7QUFDMUIsSUFBSTtBQUNKLFdBQVcsb0VBQW9CO0FBQy9CO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZVNjcm9sbC5qcz8yODIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRIVE1MRWxlbWVudFNjcm9sbCBmcm9tIFwiLi9nZXRIVE1MRWxlbWVudFNjcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChub2RlKSB7XG4gIGlmIChub2RlID09PSBnZXRXaW5kb3cobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRIVE1MRWxlbWVudFNjcm9sbChub2RlKTtcbiAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getOffsetParent)\n/* harmony export */ });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getNodeName.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getComputedStyle.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n/* harmony import */ var _isTableElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isTableElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js\");\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getParentNode.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\");\n/* harmony import */ var _utils_userAgent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/userAgent.js */ \"./node_modules/@popperjs/core/lib/utils/userAgent.js\");\n\n\n\n\n\n\n\n\nfunction getTrueOffsetParent(element) {\n  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(element) || // https://github.com/popperjs/popper-core/issues/837\n  (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\n\n\nfunction getContainingBlock(element) {\n  var isFirefox = /firefox/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])());\n  var isIE = /Trident/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])());\n\n  if (isIE && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(element)) {\n    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n    var elementCss = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element);\n\n    if (elementCss.position === 'fixed') {\n      return null;\n    }\n  }\n\n  var currentNode = (0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(element);\n\n  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isShadowRoot)(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(currentNode) && ['html', 'body'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(currentNode)) < 0) {\n    var css = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  var window = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element);\n  var offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && (0,_isTableElement_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(offsetParent) && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(offsetParent) === 'html' || (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(offsetParent) === 'body' && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(offsetParent).position === 'static')) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBdUM7QUFDSTtBQUNVO0FBQ1M7QUFDYjtBQUNGO0FBQ0M7O0FBRWhEO0FBQ0EsT0FBTyw2REFBYTtBQUNwQixFQUFFLGdFQUFnQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBLGtDQUFrQywrREFBVztBQUM3Qyw2QkFBNkIsK0RBQVc7O0FBRXhDLGNBQWMsNkRBQWE7QUFDM0I7QUFDQSxxQkFBcUIsZ0VBQWdCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsNkRBQWE7O0FBRWpDLE1BQU0sNERBQVk7QUFDbEI7QUFDQTs7QUFFQSxTQUFTLDZEQUFhLDBDQUEwQywyREFBVztBQUMzRSxjQUFjLGdFQUFnQixlQUFlO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7OztBQUdlO0FBQ2YsZUFBZSx5REFBUztBQUN4Qjs7QUFFQSx5QkFBeUIsOERBQWMsa0JBQWtCLGdFQUFnQjtBQUN6RTtBQUNBOztBQUVBLHVCQUF1QiwyREFBVyw2QkFBNkIsMkRBQVcsNkJBQTZCLGdFQUFnQjtBQUN2SDtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzPzNjMDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCwgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGlzVGFibGVFbGVtZW50IGZyb20gXCIuL2lzVGFibGVFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgZ2V0VUFTdHJpbmcgZnJvbSBcIi4uL3V0aWxzL3VzZXJBZ2VudC5qc1wiO1xuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbn0gLy8gYC5vZmZzZXRQYXJlbnRgIHJlcG9ydHMgYG51bGxgIGZvciBmaXhlZCBlbGVtZW50cywgd2hpbGUgYWJzb2x1dGUgZWxlbWVudHNcbi8vIHJldHVybiB0aGUgY29udGFpbmluZyBibG9ja1xuXG5cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIHZhciBpc0ZpcmVmb3ggPSAvZmlyZWZveC9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG4gIHZhciBpc0lFID0gL1RyaWRlbnQvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuXG4gIGlmIChpc0lFICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAvLyBJbiBJRSA5LCAxMCBhbmQgMTEgZml4ZWQgZWxlbWVudHMgY29udGFpbmluZyBibG9jayBpcyBhbHdheXMgZXN0YWJsaXNoZWQgYnkgdGhlIHZpZXdwb3J0XG4gICAgdmFyIGVsZW1lbnRDc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgaWYgKGVsZW1lbnRDc3MucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG5cbiAgaWYgKGlzU2hhZG93Um9vdChjdXJyZW50Tm9kZSkpIHtcbiAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmhvc3Q7XG4gIH1cblxuICB3aGlsZSAoaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgWydodG1sJywgJ2JvZHknXS5pbmRleE9mKGdldE5vZGVOYW1lKGN1cnJlbnROb2RlKSkgPCAwKSB7XG4gICAgdmFyIGNzcyA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudE5vZGUpOyAvLyBUaGlzIGlzIG5vbi1leGhhdXN0aXZlIGJ1dCBjb3ZlcnMgdGhlIG1vc3QgY29tbW9uIENTUyBwcm9wZXJ0aWVzIHRoYXRcbiAgICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG5cbiAgICBpZiAoY3NzLnRyYW5zZm9ybSAhPT0gJ25vbmUnIHx8IGNzcy5wZXJzcGVjdGl2ZSAhPT0gJ25vbmUnIHx8IGNzcy5jb250YWluID09PSAncGFpbnQnIHx8IFsndHJhbnNmb3JtJywgJ3BlcnNwZWN0aXZlJ10uaW5kZXhPZihjc3Mud2lsbENoYW5nZSkgIT09IC0xIHx8IGlzRmlyZWZveCAmJiBjc3Mud2lsbENoYW5nZSA9PT0gJ2ZpbHRlcicgfHwgaXNGaXJlZm94ICYmIGNzcy5maWx0ZXIgJiYgY3NzLmZpbHRlciAhPT0gJ25vbmUnKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KTtcblxuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luZG93O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getParentNode)\n/* harmony export */ });\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\n\n\nfunction getParentNode(element) {\n  if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element) === 'html') {\n    return element;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || ( // DOM Element detected\n    (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_2__.isShadowRoot)(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element) // fallback\n\n  );\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMkM7QUFDYztBQUNWO0FBQ2hDO0FBQ2YsTUFBTSwyREFBVztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFZO0FBQ2hCO0FBQ0EsSUFBSSxrRUFBa0I7O0FBRXRCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0UGFyZW50Tm9kZS5qcz81Y2JmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZ2V0Tm9kZU5hbWUoZWxlbWVudCkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuICgvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBlbGVtZW50LmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIGVsZW1lbnQucGFyZW50Tm9kZSB8fCAoIC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgaXNTaGFkb3dSb290KGVsZW1lbnQpID8gZWxlbWVudC5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgLy8gZmFsbGJhY2tcblxuICApO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getScrollParent)\n/* harmony export */ });\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getParentNode.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\");\n/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isScrollParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getNodeName.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\n\n\n\nfunction getScrollParent(node) {\n  if (['html', 'body', '#document'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node)) >= 0) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_3__.isHTMLElement)(node) && (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(node)) {\n    return node;\n  }\n\n  return getScrollParent((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRTY3JvbGxQYXJlbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0M7QUFDRTtBQUNOO0FBQ0s7QUFDakM7QUFDZiw0Q0FBNEMsMkRBQVc7QUFDdkQ7QUFDQTtBQUNBOztBQUVBLE1BQU0sNkRBQWEsVUFBVSw4REFBYztBQUMzQztBQUNBOztBQUVBLHlCQUF5Qiw2REFBYTtBQUN0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRTY3JvbGxQYXJlbnQuanM/MTcyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChub2RlKSB7XG4gIGlmIChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmRleE9mKGdldE5vZGVOYW1lKG5vZGUpKSA+PSAwKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KG5vZGUpICYmIGlzU2Nyb2xsUGFyZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUobm9kZSkpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getViewportRect)\n/* harmony export */ });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\");\n/* harmony import */ var _isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isLayoutViewport.js */ \"./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js\");\n\n\n\n\nfunction getViewportRect(element, strategy) {\n  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element);\n  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    var layoutViewport = (0,_isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element),\n    y: y\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBdUM7QUFDa0I7QUFDRTtBQUNOO0FBQ3RDO0FBQ2YsWUFBWSx5REFBUztBQUNyQixhQUFhLGtFQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnRUFBZ0I7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRUFBbUI7QUFDOUI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFZpZXdwb3J0UmVjdC5qcz85Y2M1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGlzTGF5b3V0Vmlld3BvcnQgZnJvbSBcIi4vaXNMYXlvdXRWaWV3cG9ydC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG5cbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XG4gICAgdmFyIGxheW91dFZpZXdwb3J0ID0gaXNMYXlvdXRWaWV3cG9ydCgpO1xuXG4gICAgaWYgKGxheW91dFZpZXdwb3J0IHx8ICFsYXlvdXRWaWV3cG9ydCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxuICAgIHk6IHlcbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js":
/*!****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getWindow)\n/* harmony export */ });\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzPzYxOTYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getWindowScroll)\n/* harmony export */ });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n\nfunction getWindowScroll(node) {\n  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUM7QUFDeEI7QUFDZixZQUFZLHlEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbC5qcz85MjU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getWindowScrollBarX)\n/* harmony export */ });\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\");\n\n\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let's assume\n  // it's not an issue. I don't think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn't cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element)).left + (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element).scrollLeft;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0Q7QUFDTjtBQUNOO0FBQ3BDO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFFQUFxQixDQUFDLGtFQUFrQixrQkFBa0IsK0RBQWU7QUFDbEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcz9lM2QwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XG4gIC8vIGFueXdheS5cbiAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isElement: () => (/* binding */ isElement),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot)\n/* harmony export */ });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n\n\nfunction isElement(node) {\n  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n\nfunction isHTMLElement(node) {\n  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n\nfunction isShadowRoot(node) {\n  // IE 11 has no ShadowRoot\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBdUM7O0FBRXZDO0FBQ0EsbUJBQW1CLHlEQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIseURBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix5REFBUztBQUM1QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanM/YTk0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxuZXhwb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isLayoutViewport)\n/* harmony export */ });\n/* harmony import */ var _utils_userAgent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/userAgent.js */ \"./node_modules/@popperjs/core/lib/utils/userAgent.js\");\n\nfunction isLayoutViewport() {\n  return !/^((?!chrome|android).)*safari/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])());\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc0xheW91dFZpZXdwb3J0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWdEO0FBQ2pDO0FBQ2YsZ0RBQWdELCtEQUFXO0FBQzNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzTGF5b3V0Vmlld3BvcnQuanM/MTBhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0VUFTdHJpbmcgZnJvbSBcIi4uL3V0aWxzL3VzZXJBZ2VudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNMYXlvdXRWaWV3cG9ydCgpIHtcbiAgcmV0dXJuICEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isScrollParent)\n/* harmony export */ });\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getComputedStyle.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\");\n\nfunction isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxRDtBQUN0QztBQUNmO0FBQ0EsMEJBQTBCLGdFQUFnQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qcz80NjAyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzU2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gRmlyZWZveCB3YW50cyB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WTtcblxuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isTableElement)\n/* harmony export */ });\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element)) >= 0;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1RhYmxlRWxlbWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEyQztBQUM1QjtBQUNmLHVDQUF1QywyREFBVztBQUNsRCIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1RhYmxlRWxlbWVudC5qcz81NjQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpID49IDA7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js":
/*!************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ listScrollParents)\n/* harmony export */ });\n/* harmony import */ var _getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getScrollParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js\");\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getParentNode.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\");\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isScrollParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\");\n\n\n\n\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the\nreference element's position.\n*/\n\nfunction listScrollParents(element, list) {\n  var _element$ownerDocumen;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  var scrollParent = (0,_getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element);\n  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(target)));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtRDtBQUNKO0FBQ1I7QUFDVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLCtEQUFlO0FBQ3BDO0FBQ0EsWUFBWSx5REFBUztBQUNyQiwrREFBK0QsOERBQWM7QUFDN0U7QUFDQTtBQUNBLHVDQUF1Qyw2REFBYTtBQUNwRCIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcz9kNjZiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRTY3JvbGxQYXJlbnQgZnJvbSBcIi4vZ2V0U2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG4vKlxuZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcbnVudGlsIHdlIGdldCB0byB0aGUgdG9wIHdpbmRvdyBvYmplY3QuIFRoaXMgbGlzdCBpcyB3aGF0IHdlIGF0dGFjaCBzY3JvbGwgbGlzdGVuZXJzXG50bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlXG5yZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxuKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cblxuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpO1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdKSA6IHNjcm9sbFBhcmVudDtcbiAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcbiAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKHRhcmdldCkpKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/enums.js":
/*!**************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/enums.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   afterMain: () => (/* binding */ afterMain),\n/* harmony export */   afterRead: () => (/* binding */ afterRead),\n/* harmony export */   afterWrite: () => (/* binding */ afterWrite),\n/* harmony export */   auto: () => (/* binding */ auto),\n/* harmony export */   basePlacements: () => (/* binding */ basePlacements),\n/* harmony export */   beforeMain: () => (/* binding */ beforeMain),\n/* harmony export */   beforeRead: () => (/* binding */ beforeRead),\n/* harmony export */   beforeWrite: () => (/* binding */ beforeWrite),\n/* harmony export */   bottom: () => (/* binding */ bottom),\n/* harmony export */   clippingParents: () => (/* binding */ clippingParents),\n/* harmony export */   end: () => (/* binding */ end),\n/* harmony export */   left: () => (/* binding */ left),\n/* harmony export */   main: () => (/* binding */ main),\n/* harmony export */   modifierPhases: () => (/* binding */ modifierPhases),\n/* harmony export */   placements: () => (/* binding */ placements),\n/* harmony export */   popper: () => (/* binding */ popper),\n/* harmony export */   read: () => (/* binding */ read),\n/* harmony export */   reference: () => (/* binding */ reference),\n/* harmony export */   right: () => (/* binding */ right),\n/* harmony export */   start: () => (/* binding */ start),\n/* harmony export */   top: () => (/* binding */ top),\n/* harmony export */   variationPlacements: () => (/* binding */ variationPlacements),\n/* harmony export */   viewport: () => (/* binding */ viewport),\n/* harmony export */   write: () => (/* binding */ write)\n/* harmony export */ });\nvar top = 'top';\nvar bottom = 'bottom';\nvar right = 'right';\nvar left = 'left';\nvar auto = 'auto';\nvar basePlacements = [top, bottom, right, left];\nvar start = 'start';\nvar end = 'end';\nvar clippingParents = 'clippingParents';\nvar viewport = 'viewport';\nvar popper = 'popper';\nvar reference = 'reference';\nvar variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nvar placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []); // modifiers that need to read the DOM\n\nvar beforeRead = 'beforeRead';\nvar read = 'read';\nvar afterRead = 'afterRead'; // pure-logic modifiers\n\nvar beforeMain = 'beforeMain';\nvar main = 'main';\nvar afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nvar beforeWrite = 'beforeWrite';\nvar write = 'write';\nvar afterWrite = 'afterWrite';\nvar modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQSxDQUFDO0FBQ007QUFDUDtBQUNBLENBQUMsT0FBTzs7QUFFRDtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzPzM1OTciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciB0b3AgPSAndG9wJztcbmV4cG9ydCB2YXIgYm90dG9tID0gJ2JvdHRvbSc7XG5leHBvcnQgdmFyIHJpZ2h0ID0gJ3JpZ2h0JztcbmV4cG9ydCB2YXIgbGVmdCA9ICdsZWZ0JztcbmV4cG9ydCB2YXIgYXV0byA9ICdhdXRvJztcbmV4cG9ydCB2YXIgYmFzZVBsYWNlbWVudHMgPSBbdG9wLCBib3R0b20sIHJpZ2h0LCBsZWZ0XTtcbmV4cG9ydCB2YXIgc3RhcnQgPSAnc3RhcnQnO1xuZXhwb3J0IHZhciBlbmQgPSAnZW5kJztcbmV4cG9ydCB2YXIgY2xpcHBpbmdQYXJlbnRzID0gJ2NsaXBwaW5nUGFyZW50cyc7XG5leHBvcnQgdmFyIHZpZXdwb3J0ID0gJ3ZpZXdwb3J0JztcbmV4cG9ydCB2YXIgcG9wcGVyID0gJ3BvcHBlcic7XG5leHBvcnQgdmFyIHJlZmVyZW5jZSA9ICdyZWZlcmVuY2UnO1xuZXhwb3J0IHZhciB2YXJpYXRpb25QbGFjZW1lbnRzID0gLyojX19QVVJFX18qL2Jhc2VQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7XG5leHBvcnQgdmFyIHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovW10uY29uY2F0KGJhc2VQbGFjZW1lbnRzLCBbYXV0b10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCwgcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTsgLy8gbW9kaWZpZXJzIHRoYXQgbmVlZCB0byByZWFkIHRoZSBET01cblxuZXhwb3J0IHZhciBiZWZvcmVSZWFkID0gJ2JlZm9yZVJlYWQnO1xuZXhwb3J0IHZhciByZWFkID0gJ3JlYWQnO1xuZXhwb3J0IHZhciBhZnRlclJlYWQgPSAnYWZ0ZXJSZWFkJzsgLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcblxuZXhwb3J0IHZhciBiZWZvcmVNYWluID0gJ2JlZm9yZU1haW4nO1xuZXhwb3J0IHZhciBtYWluID0gJ21haW4nO1xuZXhwb3J0IHZhciBhZnRlck1haW4gPSAnYWZ0ZXJNYWluJzsgLy8gbW9kaWZpZXIgd2l0aCB0aGUgcHVycG9zZSB0byB3cml0ZSB0byB0aGUgRE9NIChvciB3cml0ZSBpbnRvIGEgZnJhbWV3b3JrIHN0YXRlKVxuXG5leHBvcnQgdmFyIGJlZm9yZVdyaXRlID0gJ2JlZm9yZVdyaXRlJztcbmV4cG9ydCB2YXIgd3JpdGUgPSAnd3JpdGUnO1xuZXhwb3J0IHZhciBhZnRlcldyaXRlID0gJ2FmdGVyV3JpdGUnO1xuZXhwb3J0IHZhciBtb2RpZmllclBoYXNlcyA9IFtiZWZvcmVSZWFkLCByZWFkLCBhZnRlclJlYWQsIGJlZm9yZU1haW4sIG1haW4sIGFmdGVyTWFpbiwgYmVmb3JlV3JpdGUsIHdyaXRlLCBhZnRlcldyaXRlXTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/enums.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   afterMain: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterMain),\n/* harmony export */   afterRead: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterRead),\n/* harmony export */   afterWrite: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterWrite),\n/* harmony export */   applyStyles: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.applyStyles),\n/* harmony export */   arrow: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.arrow),\n/* harmony export */   auto: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.auto),\n/* harmony export */   basePlacements: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements),\n/* harmony export */   beforeMain: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeMain),\n/* harmony export */   beforeRead: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeRead),\n/* harmony export */   beforeWrite: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeWrite),\n/* harmony export */   bottom: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom),\n/* harmony export */   clippingParents: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.clippingParents),\n/* harmony export */   computeStyles: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.computeStyles),\n/* harmony export */   createPopper: () => (/* reexport safe */ _popper_js__WEBPACK_IMPORTED_MODULE_4__.createPopper),\n/* harmony export */   createPopperBase: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_2__.createPopper),\n/* harmony export */   createPopperLite: () => (/* reexport safe */ _popper_lite_js__WEBPACK_IMPORTED_MODULE_5__.createPopper),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   end: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.end),\n/* harmony export */   eventListeners: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.eventListeners),\n/* harmony export */   flip: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.flip),\n/* harmony export */   hide: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.hide),\n/* harmony export */   left: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.left),\n/* harmony export */   main: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.main),\n/* harmony export */   modifierPhases: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases),\n/* harmony export */   offset: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.offset),\n/* harmony export */   placements: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.placements),\n/* harmony export */   popper: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper),\n/* harmony export */   popperGenerator: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_2__.popperGenerator),\n/* harmony export */   popperOffsets: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.popperOffsets),\n/* harmony export */   preventOverflow: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.preventOverflow),\n/* harmony export */   read: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.read),\n/* harmony export */   reference: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.reference),\n/* harmony export */   right: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.right),\n/* harmony export */   start: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.start),\n/* harmony export */   top: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.top),\n/* harmony export */   variationPlacements: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements),\n/* harmony export */   viewport: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport),\n/* harmony export */   write: () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.write)\n/* harmony export */ });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/index.js */ \"./node_modules/@popperjs/core/lib/modifiers/index.js\");\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createPopper.js */ \"./node_modules/@popperjs/core/lib/createPopper.js\");\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createPopper.js */ \"./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _popper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./popper.js */ \"./node_modules/@popperjs/core/lib/popper.js\");\n/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./popper-lite.js */ \"./node_modules/@popperjs/core/lib/popper-lite.js\");\n\n // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJCO0FBQ1UsQ0FBQzs7QUFFZ0UsQ0FBQzs7QUFFNUQsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2luZGV4LmpzP2RiMDgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4vZW51bXMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL21vZGlmaWVycy9pbmRleC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IHBvcHBlckdlbmVyYXRvciwgZGV0ZWN0T3ZlcmZsb3csIGNyZWF0ZVBvcHBlciBhcyBjcmVhdGVQb3BwZXJCYXNlIH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyIH0gZnJvbSBcIi4vcG9wcGVyLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyIGFzIGNyZWF0ZVBvcHBlckxpdGUgfSBmcm9tIFwiLi9wb3BwZXItbGl0ZS5qc1wiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/index.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getNodeName.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\n // This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe[cannot-write]\n\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  state.styles = initialStyles;\n\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element)) {\n        return;\n      }\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: effect,\n  requires: ['computeStyles']\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcHBseVN0eWxlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBc0Q7QUFDSyxDQUFDO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDLFNBQVMsdUVBQWEsY0FBYyxxRUFBVztBQUMvQztBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVIOztBQUV2SDtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUksR0FBRzs7QUFFZCxXQUFXLHVFQUFhLGNBQWMscUVBQVc7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsRUFBRTs7O0FBR0YsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzP2YyZTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjsgLy8gVGhpcyBtb2RpZmllciB0YWtlcyB0aGUgc3R5bGVzIHByZXBhcmVkIGJ5IHRoZSBgY29tcHV0ZVN0eWxlc2AgbW9kaWZpZXJcbi8vIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIEhUTUxFbGVtZW50cyBzdWNoIGFzIHBvcHBlciBhbmQgYXJyb3dcblxuZnVuY3Rpb24gYXBwbHlTdHlsZXMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnN0eWxlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0byBleHRlbmQgdGhpcyBwcm9wZXJ0eSwgYnV0IGl0J3MgdGhlIG1vc3RcbiAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuXG5cbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcbiAgdmFyIGluaXRpYWxTdHlsZXMgPSB7XG4gICAgcG9wcGVyOiB7XG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGxlZnQ6ICcwJyxcbiAgICAgIHRvcDogJzAnLFxuICAgICAgbWFyZ2luOiAnMCdcbiAgICB9LFxuICAgIGFycm93OiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sXG4gICAgcmVmZXJlbmNlOiB7fVxuICB9O1xuICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgaW5pdGlhbFN0eWxlcy5wb3BwZXIpO1xuICBzdGF0ZS5zdHlsZXMgPSBpbml0aWFsU3R5bGVzO1xuXG4gIGlmIChzdGF0ZS5lbGVtZW50cy5hcnJvdykge1xuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGluaXRpYWxTdHlsZXMuYXJyb3cpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICAgIHZhciBzdHlsZVByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhzdGF0ZS5zdHlsZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBzdGF0ZS5zdHlsZXNbbmFtZV0gOiBpbml0aWFsU3R5bGVzW25hbWVdKTsgLy8gU2V0IGFsbCB2YWx1ZXMgdG8gYW4gZW1wdHkgc3RyaW5nIHRvIHVuc2V0IHRoZW1cblxuICAgICAgdmFyIHN0eWxlID0gc3R5bGVQcm9wZXJ0aWVzLnJlZHVjZShmdW5jdGlvbiAoc3R5bGUsIHByb3BlcnR5KSB7XG4gICAgICAgIHN0eWxlW3Byb3BlcnR5XSA9ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9LCB7fSk7IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGFwcGx5U3R5bGVzLFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/arrow.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/arrow.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\");\n/* harmony import */ var _dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/contains.js */ \"./node_modules/@popperjs/core/lib/dom-utils/contains.js\");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\");\n/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\");\n/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/within.js */ \"./node_modules/@popperjs/core/lib/utils/within.js\");\n/* harmony import */ var _utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/mergePaddingObject.js */ \"./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js\");\n/* harmony import */ var _utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/expandToHashMap.js */ \"./node_modules/@popperjs/core/lib/utils/expandToHashMap.js\");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nvar toPaddingObject = function toPaddingObject(padding, state) {\n  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding;\n  return (0,_utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(typeof padding !== 'number' ? padding : (0,_utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_8__.basePlacements));\n};\n\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n\n  var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(state.placement);\n  var axis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(basePlacement);\n  var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_8__.left, _enums_js__WEBPACK_IMPORTED_MODULE_8__.right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  var paddingObject = toPaddingObject(options.padding, state);\n  var arrowRect = (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(arrowElement);\n  var minProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_8__.top : _enums_js__WEBPACK_IMPORTED_MODULE_8__.left;\n  var maxProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_8__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_8__.right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_5__.within)(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options;\n  var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (!(0,_dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.elements.popper, arrowElement)) {\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect: effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTREO0FBQ0Y7QUFDVjtBQUNjO0FBQ2M7QUFDaEM7QUFDb0I7QUFDTjtBQUNhLENBQUM7O0FBRXhFO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0EsR0FBRztBQUNILFNBQVMsd0VBQWtCLHlDQUF5QyxxRUFBZSxVQUFVLHFEQUFjO0FBQzNHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzRUFBZ0I7QUFDdEMsYUFBYSw4RUFBd0I7QUFDckMsb0JBQW9CLDJDQUFJLEVBQUUsNENBQUs7QUFDL0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHVFQUFhO0FBQy9CLCtCQUErQiwwQ0FBRyxHQUFHLDJDQUFJO0FBQ3pDLCtCQUErQiw2Q0FBTSxHQUFHLDRDQUFLO0FBQzdDO0FBQ0E7QUFDQSwwQkFBMEIseUVBQWU7QUFDekM7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBTSxvQkFBb0I7O0FBRXpDO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyxrRUFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRixpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcz83ZWQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBjb250YWlucyBmcm9tIFwiLi4vZG9tLXV0aWxzL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHdpdGhpbiB9IGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4uL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qc1wiO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tIFwiLi4vdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzXCI7XG5pbXBvcnQgeyBsZWZ0LCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHRvcCwgYm90dG9tIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHRvUGFkZGluZ09iamVjdCA9IGZ1bmN0aW9uIHRvUGFkZGluZ09iamVjdChwYWRkaW5nLCBzdGF0ZSkge1xuICBwYWRkaW5nID0gdHlwZW9mIHBhZGRpbmcgPT09ICdmdW5jdGlvbicgPyBwYWRkaW5nKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogcGFkZGluZztcbiAgcmV0dXJuIG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG59O1xuXG5mdW5jdGlvbiBhcnJvdyhfcmVmKSB7XG4gIHZhciBfc3RhdGUkbW9kaWZpZXJzRGF0YSQ7XG5cbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIGlmICghYXJyb3dFbGVtZW50IHx8ICFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhZGRpbmdPYmplY3QgPSB0b1BhZGRpbmdPYmplY3Qob3B0aW9ucy5wYWRkaW5nLCBzdGF0ZSk7XG4gIHZhciBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XG4gIHZhciBtaW5Qcm9wID0gYXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgdmFyIG1heFByb3AgPSBheGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgdmFyIGVuZERpZmYgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbbGVuXSArIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5wb3BwZXJbbGVuXTtcbiAgdmFyIHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gIHZhciBhcnJvd09mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChhcnJvd0VsZW1lbnQpO1xuICB2YXIgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcbiAgdmFyIGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyOyAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIHBvcHBlciBpZiB0aGUgY2VudGVyIHBvaW50IGlzXG4gIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcblxuICB2YXIgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgdmFyIG1heCA9IGNsaWVudFNpemUgLSBhcnJvd1JlY3RbbGVuXSAtIHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XG4gIHZhciBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICB2YXIgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBQcmV2ZW50cyBicmVha2luZyBzeW50YXggaGlnaGxpZ2h0aW5nLi4uXG5cbiAgdmFyIGF4aXNQcm9wID0gYXhpcztcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IChfc3RhdGUkbW9kaWZpZXJzRGF0YSQgPSB7fSwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkW2F4aXNQcm9wXSA9IG9mZnNldCwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkLmNlbnRlck9mZnNldCA9IG9mZnNldCAtIGNlbnRlciwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkKTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRlbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50LFxuICAgICAgYXJyb3dFbGVtZW50ID0gX29wdGlvbnMkZWxlbWVudCA9PT0gdm9pZCAwID8gJ1tkYXRhLXBvcHBlci1hcnJvd10nIDogX29wdGlvbnMkZWxlbWVudDtcblxuICBpZiAoYXJyb3dFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQ1NTIHNlbGVjdG9yXG5cblxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRhaW5zKHN0YXRlLmVsZW1lbnRzLnBvcHBlciwgYXJyb3dFbGVtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXRlLmVsZW1lbnRzLmFycm93ID0gYXJyb3dFbGVtZW50O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnYXJyb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogYXJyb3csXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J11cbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/arrow.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   mapToStyles: () => (/* binding */ mapToStyles)\n/* harmony export */ });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\");\n/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/getComputedStyle.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\");\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/getVariation.js */ \"./node_modules/@popperjs/core/lib/utils/getVariation.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/math.js */ \"./node_modules/@popperjs/core/lib/utils/math.js\");\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsetsByDPR(_ref, win) {\n  var x = _ref.x,\n      y = _ref.y;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_7__.round)(x * dpr) / dpr || 0,\n    y: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_7__.round)(y * dpr) / dpr || 0\n  };\n}\n\nfunction mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      variation = _ref2.variation,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets,\n      isFixed = _ref2.isFixed;\n  var _offsets$x = offsets.x,\n      x = _offsets$x === void 0 ? 0 : _offsets$x,\n      _offsets$y = offsets.y,\n      y = _offsets$y === void 0 ? 0 : _offsets$y;\n\n  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\n    x: x,\n    y: y\n  }) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref3.x;\n  y = _ref3.y;\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = _enums_js__WEBPACK_IMPORTED_MODULE_0__.left;\n  var sideY = _enums_js__WEBPACK_IMPORTED_MODULE_0__.top;\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(popper);\n    var heightProp = 'clientHeight';\n    var widthProp = 'clientWidth';\n\n    if (offsetParent === (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(popper)) {\n      offsetParent = (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(popper);\n\n      if ((0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(offsetParent).position !== 'static' && position === 'absolute') {\n        heightProp = 'scrollHeight';\n        widthProp = 'scrollWidth';\n      }\n    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n\n    offsetParent = offsetParent;\n\n    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__.top || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__.left || placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__.right) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_0__.end) {\n      sideY = _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom;\n      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]\n      offsetParent[heightProp];\n      y -= offsetY - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__.left || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__.top || placement === _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_0__.end) {\n      sideX = _enums_js__WEBPACK_IMPORTED_MODULE_0__.right;\n      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]\n      offsetParent[widthProp];\n      x -= offsetX - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n    x: x,\n    y: y\n  }, (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(popper)) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref4.x;\n  y = _ref4.y;\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\n\nfunction computeStyles(_ref5) {\n  var state = _ref5.state,\n      options = _ref5.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n  var commonStyles = {\n    placement: (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(state.placement),\n    variation: (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration,\n    isFixed: state.options.strategy === 'fixed'\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBNEQ7QUFDRTtBQUNaO0FBQ2tCO0FBQ0o7QUFDSjtBQUNSO0FBQ1gsQ0FBQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHFEQUFLO0FBQ1osT0FBTyxxREFBSztBQUNaO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUFJO0FBQ2xCLGNBQWMsMENBQUc7QUFDakI7O0FBRUE7QUFDQSx1QkFBdUIseUVBQWU7QUFDdEM7QUFDQTs7QUFFQSx5QkFBeUIsbUVBQVM7QUFDbEMscUJBQXFCLDRFQUFrQjs7QUFFdkMsVUFBVSwwRUFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUEsc0JBQXNCLDBDQUFHLG1CQUFtQiwyQ0FBSSxrQkFBa0IsNENBQUssbUJBQW1CLDBDQUFHO0FBQzdGLGNBQWMsNkNBQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsMkNBQUksbUJBQW1CLDBDQUFHLGtCQUFrQiw2Q0FBTSxtQkFBbUIsMENBQUc7QUFDOUYsY0FBYyw0Q0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLG1FQUFTO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIsb0NBQW9DO0FBQy9EOztBQUVBLHlCQUF5QixxQ0FBcUM7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNFQUFnQjtBQUMvQixlQUFlLGtFQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsbURBQW1EO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EseUNBQXlDLGtEQUFrRDtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0YsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzPzNmOTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCBlbmQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB1bnNldFNpZGVzID0ge1xuICB0b3A6ICdhdXRvJyxcbiAgcmlnaHQ6ICdhdXRvJyxcbiAgYm90dG9tOiAnYXV0bycsXG4gIGxlZnQ6ICdhdXRvJ1xufTsgLy8gUm91bmQgdGhlIG9mZnNldHMgdG8gdGhlIG5lYXJlc3Qgc3VpdGFibGUgc3VicGl4ZWwgYmFzZWQgb24gdGhlIERQUi5cbi8vIFpvb21pbmcgY2FuIGNoYW5nZSB0aGUgRFBSLCBidXQgaXQgc2VlbXMgdG8gcmVwb3J0IGEgdmFsdWUgdGhhdCB3aWxsXG4vLyBjbGVhbmx5IGRpdmlkZSB0aGUgdmFsdWVzIGludG8gdGhlIGFwcHJvcHJpYXRlIHN1YnBpeGVscy5cblxuZnVuY3Rpb24gcm91bmRPZmZzZXRzQnlEUFIoX3JlZiwgd2luKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcbiAgdmFyIGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiB7XG4gICAgeDogcm91bmQoeCAqIGRwcikgLyBkcHIgfHwgMCxcbiAgICB5OiByb3VuZCh5ICogZHByKSAvIGRwciB8fCAwXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb1N0eWxlcyhfcmVmMikge1xuICB2YXIgX09iamVjdCRhc3NpZ24yO1xuXG4gIHZhciBwb3BwZXIgPSBfcmVmMi5wb3BwZXIsXG4gICAgICBwb3BwZXJSZWN0ID0gX3JlZjIucG9wcGVyUmVjdCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYyLnBsYWNlbWVudCxcbiAgICAgIHZhcmlhdGlvbiA9IF9yZWYyLnZhcmlhdGlvbixcbiAgICAgIG9mZnNldHMgPSBfcmVmMi5vZmZzZXRzLFxuICAgICAgcG9zaXRpb24gPSBfcmVmMi5wb3NpdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9yZWYyLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGFkYXB0aXZlID0gX3JlZjIuYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHMgPSBfcmVmMi5yb3VuZE9mZnNldHMsXG4gICAgICBpc0ZpeGVkID0gX3JlZjIuaXNGaXhlZDtcbiAgdmFyIF9vZmZzZXRzJHggPSBvZmZzZXRzLngsXG4gICAgICB4ID0gX29mZnNldHMkeCA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHgsXG4gICAgICBfb2Zmc2V0cyR5ID0gb2Zmc2V0cy55LFxuICAgICAgeSA9IF9vZmZzZXRzJHkgPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR5O1xuXG4gIHZhciBfcmVmMyA9IHR5cGVvZiByb3VuZE9mZnNldHMgPT09ICdmdW5jdGlvbicgPyByb3VuZE9mZnNldHMoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9KSA6IHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcblxuICB4ID0gX3JlZjMueDtcbiAgeSA9IF9yZWYzLnk7XG4gIHZhciBoYXNYID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneCcpO1xuICB2YXIgaGFzWSA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3knKTtcbiAgdmFyIHNpZGVYID0gbGVmdDtcbiAgdmFyIHNpZGVZID0gdG9wO1xuICB2YXIgd2luID0gd2luZG93O1xuXG4gIGlmIChhZGFwdGl2ZSkge1xuICAgIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKTtcbiAgICB2YXIgaGVpZ2h0UHJvcCA9ICdjbGllbnRIZWlnaHQnO1xuICAgIHZhciB3aWR0aFByb3AgPSAnY2xpZW50V2lkdGgnO1xuXG4gICAgaWYgKG9mZnNldFBhcmVudCA9PT0gZ2V0V2luZG93KHBvcHBlcikpIHtcbiAgICAgIG9mZnNldFBhcmVudCA9IGdldERvY3VtZW50RWxlbWVudChwb3BwZXIpO1xuXG4gICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uICE9PSAnc3RhdGljJyAmJiBwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJykge1xuICAgICAgICBoZWlnaHRQcm9wID0gJ3Njcm9sbEhlaWdodCc7XG4gICAgICAgIHdpZHRoUHJvcCA9ICdzY3JvbGxXaWR0aCc7XG4gICAgICB9XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYXN0XTogZm9yY2UgdHlwZSByZWZpbmVtZW50LCB3ZSBjb21wYXJlIG9mZnNldFBhcmVudCB3aXRoIHdpbmRvdyBhYm92ZSwgYnV0IEZsb3cgZG9lc24ndCBkZXRlY3QgaXRcblxuXG4gICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50O1xuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gdG9wIHx8IChwbGFjZW1lbnQgPT09IGxlZnQgfHwgcGxhY2VtZW50ID09PSByaWdodCkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVZID0gYm90dG9tO1xuICAgICAgdmFyIG9mZnNldFkgPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC5oZWlnaHQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFtoZWlnaHRQcm9wXTtcbiAgICAgIHkgLT0gb2Zmc2V0WSAtIHBvcHBlclJlY3QuaGVpZ2h0O1xuICAgICAgeSAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCAocGxhY2VtZW50ID09PSB0b3AgfHwgcGxhY2VtZW50ID09PSBib3R0b20pICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWCA9IHJpZ2h0O1xuICAgICAgdmFyIG9mZnNldFggPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC53aWR0aCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgb2Zmc2V0UGFyZW50W3dpZHRoUHJvcF07XG4gICAgICB4IC09IG9mZnNldFggLSBwb3BwZXJSZWN0LndpZHRoO1xuICAgICAgeCAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9LCBhZGFwdGl2ZSAmJiB1bnNldFNpZGVzKTtcblxuICB2YXIgX3JlZjQgPSByb3VuZE9mZnNldHMgPT09IHRydWUgPyByb3VuZE9mZnNldHNCeURQUih7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0sIGdldFdpbmRvdyhwb3BwZXIpKSA6IHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcblxuICB4ID0gX3JlZjQueDtcbiAgeSA9IF9yZWY0Lnk7XG5cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbikge1xuICAgIHZhciBfT2JqZWN0JGFzc2lnbjtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbiA9IHt9LCBfT2JqZWN0JGFzc2lnbltzaWRlWV0gPSBoYXNZID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduW3NpZGVYXSA9IGhhc1ggPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ24udHJhbnNmb3JtID0gKHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDEgPyBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4LCAwKVwiLCBfT2JqZWN0JGFzc2lnbikpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduMiA9IHt9LCBfT2JqZWN0JGFzc2lnbjJbc2lkZVldID0gaGFzWSA/IHkgKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yW3NpZGVYXSA9IGhhc1ggPyB4ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMi50cmFuc2Zvcm0gPSAnJywgX09iamVjdCRhc3NpZ24yKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZXMoX3JlZjUpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjUuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjUub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZ3B1QWNjZWxlcmF0LFxuICAgICAgX29wdGlvbnMkYWRhcHRpdmUgPSBvcHRpb25zLmFkYXB0aXZlLFxuICAgICAgYWRhcHRpdmUgPSBfb3B0aW9ucyRhZGFwdGl2ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFkYXB0aXZlLFxuICAgICAgX29wdGlvbnMkcm91bmRPZmZzZXRzID0gb3B0aW9ucy5yb3VuZE9mZnNldHMsXG4gICAgICByb3VuZE9mZnNldHMgPSBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyb3VuZE9mZnNldHM7XG4gIHZhciBjb21tb25TdHlsZXMgPSB7XG4gICAgcGxhY2VtZW50OiBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCksXG4gICAgdmFyaWF0aW9uOiBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KSxcbiAgICBwb3BwZXI6IHN0YXRlLmVsZW1lbnRzLnBvcHBlcixcbiAgICBwb3BwZXJSZWN0OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiBncHVBY2NlbGVyYXRpb24sXG4gICAgaXNGaXhlZDogc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJ1xuICB9O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMucG9wcGVyLCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgYWRhcHRpdmU6IGFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3cgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5hcnJvdyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5hcnJvdywgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBhZGFwdGl2ZTogZmFsc2UsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCc6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ2JlZm9yZVdyaXRlJyxcbiAgZm46IGNvbXB1dGVTdHlsZXMsXG4gIGRhdGE6IHt9XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/computeStyles.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n // eslint-disable-next-line import/no-unused-modules\n\nvar passive = {\n  passive: true\n};\n\nfunction effect(_ref) {\n  var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n  var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n  var window = (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: effect,\n  data: {}\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrRCxDQUFDOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUVBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzPzkxYzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciBwYXNzaXZlID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgZGF0YToge31cbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/eventListeners.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/flip.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/flip.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getOppositePlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js\");\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getOppositeVariationPlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js\");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/detectOverflow.js */ \"./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/computeAutoPlacement.js */ \"./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js\");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/getVariation.js */ \"./node_modules/@popperjs/core/lib/utils/getVariation.js\");\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction getExpandedFallbackPlacements(placement) {\n  if ((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_5__.auto) {\n    return [];\n  }\n\n  var oppositePlacement = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(placement);\n  return [(0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(placement), oppositePlacement, (0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [(0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_5__.auto ? (0,_utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(placement);\n\n    var isStartVariation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start;\n    var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_5__.top, _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.right : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left : isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(mainVariationSide);\n    }\n\n    var altVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases – research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9mbGlwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQW9FO0FBQ1I7QUFDMEI7QUFDOUI7QUFDWTtBQUNBO0FBQ2hCLENBQUM7O0FBRXJEO0FBQ0EsTUFBTSxzRUFBZ0IsZ0JBQWdCLDJDQUFJO0FBQzFDO0FBQ0E7O0FBRUEsMEJBQTBCLDBFQUFvQjtBQUM5QyxVQUFVLG1GQUE2QixnQ0FBZ0MsbUZBQTZCO0FBQ3BHOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzRUFBZ0I7QUFDdEM7QUFDQSxpR0FBaUcsMEVBQW9CO0FBQ3JIO0FBQ0Esc0JBQXNCLHNFQUFnQixnQkFBZ0IsMkNBQUksR0FBRywwRUFBb0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix1QkFBdUI7QUFDekM7O0FBRUEseUJBQXlCLHNFQUFnQjs7QUFFekMsMkJBQTJCLGtFQUFZLGdCQUFnQiw0Q0FBSztBQUM1RCxzQkFBc0IsMENBQUcsRUFBRSw2Q0FBTTtBQUNqQztBQUNBLG1CQUFtQixvRUFBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDREQUE0RCw0Q0FBSyxHQUFHLDJDQUFJLHNCQUFzQiw2Q0FBTSxHQUFHLDBDQUFHOztBQUUxRztBQUNBLDBCQUEwQiwwRUFBb0I7QUFDOUM7O0FBRUEsMkJBQTJCLDBFQUFvQjtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsUUFBUTtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZmxpcC5qcz81Y2NiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRPcHBvc2l0ZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgY29tcHV0ZUF1dG9QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyBib3R0b20sIHRvcCwgc3RhcnQsIHJpZ2h0LCBsZWZ0LCBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5mdW5jdGlvbiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgaWYgKGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5cbmZ1bmN0aW9uIGZsaXAoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgPSBvcHRpb25zLmZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9IG9wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGZsaXBWYXJpYXRpbyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IG9wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzO1xuICB2YXIgcHJlZmVycmVkUGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gYmFzZVBsYWNlbWVudCA9PT0gcHJlZmVycmVkUGxhY2VtZW50O1xuICB2YXIgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBWYXJpYXRpb25zID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocHJlZmVycmVkUGxhY2VtZW50KSk7XG4gIHZhciBwbGFjZW1lbnRzID0gW3ByZWZlcnJlZFBsYWNlbWVudF0uY29uY2F0KGZhbGxiYWNrUGxhY2VtZW50cykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0byA/IGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zOiBmbGlwVmFyaWF0aW9ucyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogYWxsb3dlZEF1dG9QbGFjZW1lbnRzXG4gICAgfSkgOiBwbGFjZW1lbnQpO1xuICB9LCBbXSk7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGNoZWNrc01hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIG1ha2VGYWxsYmFja0NoZWNrcyA9IHRydWU7XG4gIHZhciBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzWzBdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwbGFjZW1lbnQgPSBwbGFjZW1lbnRzW2ldO1xuXG4gICAgdmFyIF9iYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIGlzU3RhcnRWYXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gc3RhcnQ7XG4gICAgdmFyIGlzVmVydGljYWwgPSBbdG9wLCBib3R0b21dLmluZGV4T2YoX2Jhc2VQbGFjZW1lbnQpID49IDA7XG4gICAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSk7XG4gICAgdmFyIG1haW5WYXJpYXRpb25TaWRlID0gaXNWZXJ0aWNhbCA/IGlzU3RhcnRWYXJpYXRpb24gPyByaWdodCA6IGxlZnQgOiBpc1N0YXJ0VmFyaWF0aW9uID8gYm90dG9tIDogdG9wO1xuXG4gICAgaWYgKHJlZmVyZW5jZVJlY3RbbGVuXSA+IHBvcHBlclJlY3RbbGVuXSkge1xuICAgICAgbWFpblZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgfVxuXG4gICAgdmFyIGFsdFZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgdmFyIGNoZWNrcyA9IFtdO1xuXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W19iYXNlUGxhY2VtZW50XSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1ttYWluVmFyaWF0aW9uU2lkZV0gPD0gMCwgb3ZlcmZsb3dbYWx0VmFyaWF0aW9uU2lkZV0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgIHJldHVybiBjaGVjaztcbiAgICB9KSkge1xuICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgbWFrZUZhbGxiYWNrQ2hlY2tzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjaGVja3NNYXAuc2V0KHBsYWNlbWVudCwgY2hlY2tzKTtcbiAgfVxuXG4gIGlmIChtYWtlRmFsbGJhY2tDaGVja3MpIHtcbiAgICAvLyBgMmAgbWF5IGJlIGRlc2lyZWQgaW4gc29tZSBjYXNlcyDigJMgcmVzZWFyY2ggbGF0ZXJcbiAgICB2YXIgbnVtYmVyT2ZDaGVja3MgPSBmbGlwVmFyaWF0aW9ucyA/IDMgOiAxO1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2kpIHtcbiAgICAgIHZhciBmaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50cy5maW5kKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIGNoZWNrcyA9IGNoZWNrc01hcC5nZXQocGxhY2VtZW50KTtcblxuICAgICAgICBpZiAoY2hlY2tzKSB7XG4gICAgICAgICAgcmV0dXJuIGNoZWNrcy5zbGljZSgwLCBfaSkuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2s7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZml0dGluZ1BsYWNlbWVudCkge1xuICAgICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBmaXR0aW5nUGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaSA9IG51bWJlck9mQ2hlY2tzOyBfaSA+IDA7IF9pLS0pIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AoX2kpO1xuXG4gICAgICBpZiAoX3JldCA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUucGxhY2VtZW50ICE9PSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwID0gdHJ1ZTtcbiAgICBzdGF0ZS5wbGFjZW1lbnQgPSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgc3RhdGUucmVzZXQgPSB0cnVlO1xuICB9XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdmbGlwJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGZsaXAsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogZmFsc2VcbiAgfVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/flip.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/hide.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/hide.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/detectOverflow.js */ \"./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n\n\n\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom, _enums_js__WEBPACK_IMPORTED_MODULE_0__.left].some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n\nfunction hide(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(state, {\n    elementContext: 'reference'\n  });\n  var popperAltOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets: referenceClippingOffsets,\n    popperEscapeOffsets: popperEscapeOffsets,\n    isReferenceHidden: isReferenceHidden,\n    hasPopperEscaped: hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-reference-hidden': isReferenceHidden,\n    'data-popper-escaped': hasPopperEscaped\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'hide',\n  enabled: true,\n  phase: 'main',\n  requiresIfExists: ['preventOverflow'],\n  fn: hide\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9oaWRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1RDtBQUNDOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsMENBQUcsRUFBRSw0Q0FBSyxFQUFFLDZDQUFNLEVBQUUsMkNBQUk7QUFDbEM7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9FQUFjO0FBQ3hDO0FBQ0EsR0FBRztBQUNILDBCQUEwQixvRUFBYztBQUN4QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qcz8zNmY0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCwgcHJldmVudGVkT2Zmc2V0cykge1xuICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XG4gICAgcHJldmVudGVkT2Zmc2V0cyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCAtIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoICsgcHJldmVudGVkT2Zmc2V0cy54LFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQgKyBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGggLSBwcmV2ZW50ZWRPZmZzZXRzLnhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5zb21lKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93W3NpZGVdID49IDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoaWRlKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHByZXZlbnRlZE9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdztcbiAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgfSk7XG4gIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgfSk7XG4gIHZhciByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhyZWZlcmVuY2VPdmVyZmxvdywgcmVmZXJlbmNlUmVjdCk7XG4gIHZhciBwb3BwZXJFc2NhcGVPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocG9wcGVyQWx0T3ZlcmZsb3csIHBvcHBlclJlY3QsIHByZXZlbnRlZE9mZnNldHMpO1xuICB2YXIgaXNSZWZlcmVuY2VIaWRkZW4gPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzKTtcbiAgdmFyIGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbjogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogaGFzUG9wcGVyRXNjYXBlZFxuICB9O1xuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW4nOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdoaWRlJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXSxcbiAgZm46IGhpZGVcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/hide.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyStyles: () => (/* reexport safe */ _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   arrow: () => (/* reexport safe */ _arrow_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   computeStyles: () => (/* reexport safe */ _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   eventListeners: () => (/* reexport safe */ _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   flip: () => (/* reexport safe */ _flip_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   hide: () => (/* reexport safe */ _hide_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   offset: () => (/* reexport safe */ _offset_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   popperOffsets: () => (/* reexport safe */ _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   preventOverflow: () => (/* reexport safe */ _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./applyStyles.js */ \"./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\");\n/* harmony import */ var _arrow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./arrow.js */ \"./node_modules/@popperjs/core/lib/modifiers/arrow.js\");\n/* harmony import */ var _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./computeStyles.js */ \"./node_modules/@popperjs/core/lib/modifiers/computeStyles.js\");\n/* harmony import */ var _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eventListeners.js */ \"./node_modules/@popperjs/core/lib/modifiers/eventListeners.js\");\n/* harmony import */ var _flip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flip.js */ \"./node_modules/@popperjs/core/lib/modifiers/flip.js\");\n/* harmony import */ var _hide_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hide.js */ \"./node_modules/@popperjs/core/lib/modifiers/hide.js\");\n/* harmony import */ var _offset_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./offset.js */ \"./node_modules/@popperjs/core/lib/modifiers/offset.js\");\n/* harmony import */ var _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./popperOffsets.js */ \"./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\");\n/* harmony import */ var _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./preventOverflow.js */ \"./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDWjtBQUNnQjtBQUNFO0FBQ3BCO0FBQ0E7QUFDSTtBQUNjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2luZGV4LmpzPzRmNjkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCBhcyBhcHBseVN0eWxlcyB9IGZyb20gXCIuL2FwcGx5U3R5bGVzLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFycm93IH0gZnJvbSBcIi4vYXJyb3cuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY29tcHV0ZVN0eWxlcyB9IGZyb20gXCIuL2NvbXB1dGVTdHlsZXMuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZXZlbnRMaXN0ZW5lcnMgfSBmcm9tIFwiLi9ldmVudExpc3RlbmVycy5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmbGlwIH0gZnJvbSBcIi4vZmxpcC5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBoaWRlIH0gZnJvbSBcIi4vaGlkZS5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBvZmZzZXQgfSBmcm9tIFwiLi9vZmZzZXQuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcG9wcGVyT2Zmc2V0cyB9IGZyb20gXCIuL3BvcHBlck9mZnNldHMuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcHJldmVudE92ZXJmbG93IH0gZnJvbSBcIi4vcHJldmVudE92ZXJmbG93LmpzXCI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/index.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/offset.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/offset.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   distanceAndSkiddingToXY: () => (/* binding */ distanceAndSkiddingToXY)\n/* harmony export */ });\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(placement);\n  var invertDistance = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n    placement: placement\n  })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n\nfunction offset(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = _enums_js__WEBPACK_IMPORTED_MODULE_1__.placements.reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE0RDtBQUNELENBQUM7O0FBRXJEO0FBQ1Asc0JBQXNCLHNFQUFnQjtBQUN0Qyx3QkFBd0IsMkNBQUksRUFBRSwwQ0FBRzs7QUFFakMsbUVBQW1FO0FBQ25FO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsMkNBQUksRUFBRSw0Q0FBSztBQUNyQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaURBQVU7QUFDdkI7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvb2Zmc2V0LmpzPzg4MjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIHBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCByZWN0cywgb2Zmc2V0KSB7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgaW52ZXJ0RGlzdGFuY2UgPSBbbGVmdCwgdG9wXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyAtMSA6IDE7XG5cbiAgdmFyIF9yZWYgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSkpIDogb2Zmc2V0LFxuICAgICAgc2tpZGRpbmcgPSBfcmVmWzBdLFxuICAgICAgZGlzdGFuY2UgPSBfcmVmWzFdO1xuXG4gIHNraWRkaW5nID0gc2tpZGRpbmcgfHwgMDtcbiAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcbiAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8ge1xuICAgIHg6IGRpc3RhbmNlLFxuICAgIHk6IHNraWRkaW5nXG4gIH0gOiB7XG4gICAgeDogc2tpZGRpbmcsXG4gICAgeTogZGlzdGFuY2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgdmFyIF9vcHRpb25zJG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX29wdGlvbnMkb2Zmc2V0ID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfb3B0aW9ucyRvZmZzZXQ7XG4gIHZhciBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgdmFyIF9kYXRhJHN0YXRlJHBsYWNlbWVudCA9IGRhdGFbc3RhdGUucGxhY2VtZW50XSxcbiAgICAgIHggPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueCxcbiAgICAgIHkgPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ29mZnNldCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgZm46IG9mZnNldFxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/offset.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/computeOffsets.js */ \"./node_modules/@popperjs/core/lib/utils/computeOffsets.js\");\n\n\nfunction popperOffsets(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = (0,_utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {}\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvRUFBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRixpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanM/ZmRhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5cbmZ1bmN0aW9uIHBvcHBlck9mZnNldHMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcbiAgLy8gcHJvcGVybHkgcG9zaXRpb25lZCBuZWFyIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIHBsYWNlbWVudCwgYW5kIHdpbGwgYmUgYWRqdXN0ZWQgYnlcbiAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiBzdGF0ZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgZWxlbWVudDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAncmVhZCcsXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxuICBkYXRhOiB7fVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\");\n/* harmony import */ var _utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getAltAxis.js */ \"./node_modules/@popperjs/core/lib/utils/getAltAxis.js\");\n/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/within.js */ \"./node_modules/@popperjs/core/lib/utils/within.js\");\n/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/detectOverflow.js */ \"./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/getVariation.js */ \"./node_modules/@popperjs/core/lib/utils/getVariation.js\");\n/* harmony import */ var _utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/getFreshSideObject.js */ \"./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/math.js */ \"./node_modules/@popperjs/core/lib/utils/math.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(state.placement);\n  var variation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(basePlacement);\n  var altAxis = (0,_utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n\n    var mainSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.top : _enums_js__WEBPACK_IMPORTED_MODULE_0__.left;\n    var altSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_0__.right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = offset + overflow[mainSide];\n    var max = offset - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_0__.start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_0__.start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : (0,_utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_4__.within)(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset + maxOffset - offsetModifierValue;\n    var preventedOffset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_4__.within)(tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.min)(min, tetherMin) : min, offset, tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.max)(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n\n    var _mainSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.top : _enums_js__WEBPACK_IMPORTED_MODULE_0__.left;\n\n    var _altSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_0__.right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _len = altAxis === 'y' ? 'height' : 'width';\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var isOriginSide = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.left].indexOf(basePlacement) !== -1;\n\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n\n    var _preventedOffset = tether && isOriginSide ? (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_4__.withinMaxClamp)(_tetherMin, _offset, _tetherMax) : (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_4__.within)(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQThEO0FBQ0Y7QUFDZ0I7QUFDNUI7QUFDWTtBQUNGO0FBQ0k7QUFDTjtBQUNKO0FBQ1k7QUFDRTs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0VBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLHNFQUFnQjtBQUN0QyxrQkFBa0Isa0VBQVk7QUFDOUI7QUFDQSxpQkFBaUIsOEVBQXdCO0FBQ3pDLGdCQUFnQixnRUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsMENBQUcsR0FBRywyQ0FBSTtBQUNoRCxxQ0FBcUMsNkNBQU0sR0FBRyw0Q0FBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDRDQUFLO0FBQ3BDLCtCQUErQiw0Q0FBSywyQ0FBMkM7QUFDL0U7O0FBRUE7QUFDQSw2Q0FBNkMsdUVBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EseUhBQXlILHdFQUFrQjtBQUMzSTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0RBQU07QUFDekI7QUFDQTtBQUNBLG9EQUFvRCx5RUFBZTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3REFBTSxVQUFVLG9EQUFPLHlDQUF5QyxvREFBTztBQUNqRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsMENBQUcsR0FBRywyQ0FBSTs7QUFFakQsc0NBQXNDLDZDQUFNLEdBQUcsNENBQUs7O0FBRXBEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdCQUF3QiwwQ0FBRyxFQUFFLDJDQUFJOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQSxvREFBb0QsZ0VBQWMsb0NBQW9DLHdEQUFNOztBQUU1RztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRixpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qcz9mZTEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgc3RhcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRBbHRBeGlzIGZyb20gXCIuLi91dGlscy9nZXRBbHRBeGlzLmpzXCI7XG5pbXBvcnQgeyB3aXRoaW4sIHdpdGhpbk1heENsYW1wIH0gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4uL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuaW1wb3J0IHsgbWluIGFzIG1hdGhNaW4sIG1heCBhcyBtYXRoTWF4IH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgX29wdGlvbnMkdGV0aGVyID0gb3B0aW9ucy50ZXRoZXIsXG4gICAgICB0ZXRoZXIgPSBfb3B0aW9ucyR0ZXRoZXIgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyR0ZXRoZXIsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPSBvcHRpb25zLnRldGhlck9mZnNldCxcbiAgICAgIHRldGhlck9mZnNldCA9IF9vcHRpb25zJHRldGhlck9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHRldGhlck9mZnNldDtcbiAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgcGFkZGluZzogcGFkZGluZyxcbiAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnlcbiAgfSk7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSAhdmFyaWF0aW9uO1xuICB2YXIgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBhbHRBeGlzID0gZ2V0QWx0QXhpcyhtYWluQXhpcyk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiB0ZXRoZXJPZmZzZXQ7XG4gIHZhciBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZSxcbiAgICBhbHRBeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZVxuICB9IDogT2JqZWN0LmFzc2lnbih7XG4gICAgbWFpbkF4aXM6IDAsXG4gICAgYWx0QXhpczogMFxuICB9LCB0ZXRoZXJPZmZzZXRWYWx1ZSk7XG4gIHZhciBvZmZzZXRNb2RpZmllclN0YXRlID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFtzdGF0ZS5wbGFjZW1lbnRdIDogbnVsbDtcbiAgdmFyIGRhdGEgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkO1xuXG4gICAgdmFyIG1haW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG9mZnNldCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdO1xuICAgIHZhciBtaW4gPSBvZmZzZXQgKyBvdmVyZmxvd1ttYWluU2lkZV07XG4gICAgdmFyIG1heCA9IG9mZnNldCAtIG92ZXJmbG93W2FsdFNpZGVdO1xuICAgIHZhciBhZGRpdGl2ZSA9IHRldGhlciA/IC1wb3BwZXJSZWN0W2xlbl0gLyAyIDogMDtcbiAgICB2YXIgbWluTGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IHJlZmVyZW5jZVJlY3RbbGVuXSA6IHBvcHBlclJlY3RbbGVuXTtcbiAgICB2YXIgbWF4TGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IC1wb3BwZXJSZWN0W2xlbl0gOiAtcmVmZXJlbmNlUmVjdFtsZW5dOyAvLyBXZSBuZWVkIHRvIGluY2x1ZGUgdGhlIGFycm93IGluIHRoZSBjYWxjdWxhdGlvbiBzbyB0aGUgYXJyb3cgZG9lc24ndCBnb1xuICAgIC8vIG91dHNpZGUgdGhlIHJlZmVyZW5jZSBib3VuZHNcblxuICAgIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgICB2YXIgYXJyb3dSZWN0ID0gdGV0aGVyICYmIGFycm93RWxlbWVudCA/IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KSA6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nT2JqZWN0ID0gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddID8gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddLnBhZGRpbmcgOiBnZXRGcmVzaFNpZGVPYmplY3QoKTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWluID0gYXJyb3dQYWRkaW5nT2JqZWN0W21haW5TaWRlXTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWF4ID0gYXJyb3dQYWRkaW5nT2JqZWN0W2FsdFNpZGVdOyAvLyBJZiB0aGUgcmVmZXJlbmNlIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGFycm93IGxlbmd0aCwgd2UgZG9uJ3Qgd2FudFxuICAgIC8vIHRvIGluY2x1ZGUgaXRzIGZ1bGwgc2l6ZSBpbiB0aGUgY2FsY3VsYXRpb24uIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGxcbiAgICAvLyBhbmQgbmVhciB0aGUgZWRnZSBvZiBhIGJvdW5kYXJ5LCB0aGUgcG9wcGVyIGNhbiBvdmVyZmxvdyBldmVuIGlmIHRoZVxuICAgIC8vIHJlZmVyZW5jZSBpcyBub3Qgb3ZlcmZsb3dpbmcgYXMgd2VsbCAoZS5nLiB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggbm9cbiAgICAvLyB3aWR0aCBvciBoZWlnaHQpXG5cbiAgICB2YXIgYXJyb3dMZW4gPSB3aXRoaW4oMCwgcmVmZXJlbmNlUmVjdFtsZW5dLCBhcnJvd1JlY3RbbGVuXSk7XG4gICAgdmFyIG1pbk9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IHJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgLSBhZGRpdGl2ZSAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWluTGVuIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgdmFyIG1heE9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IC1yZWZlcmVuY2VSZWN0W2xlbl0gLyAyICsgYWRkaXRpdmUgKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1heExlbiArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBhcnJvd09mZnNldFBhcmVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93ICYmIGdldE9mZnNldFBhcmVudChzdGF0ZS5lbGVtZW50cy5hcnJvdyk7XG4gICAgdmFyIGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50ID8gbWFpbkF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwIDogMDtcbiAgICB2YXIgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW21haW5BeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJCA6IDA7XG4gICAgdmFyIHRldGhlck1pbiA9IG9mZnNldCArIG1pbk9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWUgLSBjbGllbnRPZmZzZXQ7XG4gICAgdmFyIHRldGhlck1heCA9IG9mZnNldCArIG1heE9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWU7XG4gICAgdmFyIHByZXZlbnRlZE9mZnNldCA9IHdpdGhpbih0ZXRoZXIgPyBtYXRoTWluKG1pbiwgdGV0aGVyTWluKSA6IG1pbiwgb2Zmc2V0LCB0ZXRoZXIgPyBtYXRoTWF4KG1heCwgdGV0aGVyTWF4KSA6IG1heCk7XG4gICAgcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQgLSBvZmZzZXQ7XG4gIH1cblxuICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDI7XG5cbiAgICB2YXIgX21haW5TaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IHRvcCA6IGxlZnQ7XG5cbiAgICB2YXIgX2FsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gYm90dG9tIDogcmlnaHQ7XG5cbiAgICB2YXIgX29mZnNldCA9IHBvcHBlck9mZnNldHNbYWx0QXhpc107XG5cbiAgICB2YXIgX2xlbiA9IGFsdEF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHZhciBfbWluID0gX29mZnNldCArIG92ZXJmbG93W19tYWluU2lkZV07XG5cbiAgICB2YXIgX21heCA9IF9vZmZzZXQgLSBvdmVyZmxvd1tfYWx0U2lkZV07XG5cbiAgICB2YXIgaXNPcmlnaW5TaWRlID0gW3RvcCwgbGVmdF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgICB2YXIgX29mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkMiA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbYWx0QXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyIDogMDtcblxuICAgIHZhciBfdGV0aGVyTWluID0gaXNPcmlnaW5TaWRlID8gX21pbiA6IF9vZmZzZXQgLSByZWZlcmVuY2VSZWN0W19sZW5dIC0gcG9wcGVyUmVjdFtfbGVuXSAtIF9vZmZzZXRNb2RpZmllclZhbHVlICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXM7XG5cbiAgICB2YXIgX3RldGhlck1heCA9IGlzT3JpZ2luU2lkZSA/IF9vZmZzZXQgKyByZWZlcmVuY2VSZWN0W19sZW5dICsgcG9wcGVyUmVjdFtfbGVuXSAtIF9vZmZzZXRNb2RpZmllclZhbHVlIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXMgOiBfbWF4O1xuXG4gICAgdmFyIF9wcmV2ZW50ZWRPZmZzZXQgPSB0ZXRoZXIgJiYgaXNPcmlnaW5TaWRlID8gd2l0aGluTWF4Q2xhbXAoX3RldGhlck1pbiwgX29mZnNldCwgX3RldGhlck1heCkgOiB3aXRoaW4odGV0aGVyID8gX3RldGhlck1pbiA6IF9taW4sIF9vZmZzZXQsIHRldGhlciA/IF90ZXRoZXJNYXggOiBfbWF4KTtcblxuICAgIHBvcHBlck9mZnNldHNbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0IC0gX29mZnNldDtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper-lite.js":
/*!********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper-lite.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPopper: () => (/* binding */ createPopper),\n/* harmony export */   defaultModifiers: () => (/* binding */ defaultModifiers),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   popperGenerator: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_0__.popperGenerator)\n/* harmony export */ });\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createPopper.js */ \"./node_modules/@popperjs/core/lib/createPopper.js\");\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createPopper.js */ \"./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ \"./node_modules/@popperjs/core/lib/modifiers/eventListeners.js\");\n/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ \"./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\");\n/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ \"./node_modules/@popperjs/core/lib/modifiers/computeStyles.js\");\n/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ \"./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\");\n\n\n\n\n\nvar defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]];\nvar createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_0__.popperGenerator)({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci1saXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDVDtBQUNGO0FBQ0E7QUFDSjtBQUNyRCx3QkFBd0Isb0VBQWMsRUFBRSxtRUFBYSxFQUFFLG1FQUFhLEVBQUUsaUVBQVc7QUFDakYsZ0NBQWdDLGlFQUFlO0FBQy9DO0FBQ0EsQ0FBQyxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLWxpdGUuanM/ZjgzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzLCBjb21wdXRlU3R5bGVzLCBhcHBseVN0eWxlc107XG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciwgcG9wcGVyR2VuZXJhdG9yLCBkZWZhdWx0TW9kaWZpZXJzLCBkZXRlY3RPdmVyZmxvdyB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/popper-lite.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyStyles: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.applyStyles),\n/* harmony export */   arrow: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.arrow),\n/* harmony export */   computeStyles: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.computeStyles),\n/* harmony export */   createPopper: () => (/* binding */ createPopper),\n/* harmony export */   createPopperLite: () => (/* reexport safe */ _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__.createPopper),\n/* harmony export */   defaultModifiers: () => (/* binding */ defaultModifiers),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   eventListeners: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.eventListeners),\n/* harmony export */   flip: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.flip),\n/* harmony export */   hide: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.hide),\n/* harmony export */   offset: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.offset),\n/* harmony export */   popperGenerator: () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_0__.popperGenerator),\n/* harmony export */   popperOffsets: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.popperOffsets),\n/* harmony export */   preventOverflow: () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.preventOverflow)\n/* harmony export */ });\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createPopper.js */ \"./node_modules/@popperjs/core/lib/createPopper.js\");\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createPopper.js */ \"./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ \"./node_modules/@popperjs/core/lib/modifiers/eventListeners.js\");\n/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ \"./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\");\n/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ \"./node_modules/@popperjs/core/lib/modifiers/computeStyles.js\");\n/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ \"./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\");\n/* harmony import */ var _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modifiers/offset.js */ \"./node_modules/@popperjs/core/lib/modifiers/offset.js\");\n/* harmony import */ var _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modifiers/flip.js */ \"./node_modules/@popperjs/core/lib/modifiers/flip.js\");\n/* harmony import */ var _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modifiers/preventOverflow.js */ \"./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js\");\n/* harmony import */ var _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./modifiers/arrow.js */ \"./node_modules/@popperjs/core/lib/modifiers/arrow.js\");\n/* harmony import */ var _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./modifiers/hide.js */ \"./node_modules/@popperjs/core/lib/modifiers/hide.js\");\n/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./popper-lite.js */ \"./node_modules/@popperjs/core/lib/popper-lite.js\");\n/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modifiers/index.js */ \"./node_modules/@popperjs/core/lib/modifiers/index.js\");\n\n\n\n\n\n\n\n\n\n\nvar defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"], _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"], _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"], _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"], _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"], _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]];\nvar createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_0__.popperGenerator)({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDVDtBQUNGO0FBQ0E7QUFDSjtBQUNWO0FBQ0o7QUFDc0I7QUFDcEI7QUFDRjtBQUN2Qyx3QkFBd0Isb0VBQWMsRUFBRSxtRUFBYSxFQUFFLG1FQUFhLEVBQUUsaUVBQVcsRUFBRSw0REFBTSxFQUFFLDBEQUFJLEVBQUUscUVBQWUsRUFBRSwyREFBSyxFQUFFLDJEQUFJO0FBQzdILGdDQUFnQyxpRUFBZTtBQUMvQztBQUNBLENBQUMsR0FBRzs7QUFFdUUsQ0FBQzs7QUFFUixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLmpzP2FmNTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcG9wcGVyR2VuZXJhdG9yLCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gXCIuL2NyZWF0ZVBvcHBlci5qc1wiO1xuaW1wb3J0IGV2ZW50TGlzdGVuZXJzIGZyb20gXCIuL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qc1wiO1xuaW1wb3J0IHBvcHBlck9mZnNldHMgZnJvbSBcIi4vbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanNcIjtcbmltcG9ydCBjb21wdXRlU3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzXCI7XG5pbXBvcnQgYXBwbHlTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzXCI7XG5pbXBvcnQgb2Zmc2V0IGZyb20gXCIuL21vZGlmaWVycy9vZmZzZXQuanNcIjtcbmltcG9ydCBmbGlwIGZyb20gXCIuL21vZGlmaWVycy9mbGlwLmpzXCI7XG5pbXBvcnQgcHJldmVudE92ZXJmbG93IGZyb20gXCIuL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBhcnJvdyBmcm9tIFwiLi9tb2RpZmllcnMvYXJyb3cuanNcIjtcbmltcG9ydCBoaWRlIGZyb20gXCIuL21vZGlmaWVycy9oaWRlLmpzXCI7XG52YXIgZGVmYXVsdE1vZGlmaWVycyA9IFtldmVudExpc3RlbmVycywgcG9wcGVyT2Zmc2V0cywgY29tcHV0ZVN0eWxlcywgYXBwbHlTdHlsZXMsIG9mZnNldCwgZmxpcCwgcHJldmVudE92ZXJmbG93LCBhcnJvdywgaGlkZV07XG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciwgcG9wcGVyR2VuZXJhdG9yLCBkZWZhdWx0TW9kaWZpZXJzLCBkZXRlY3RPdmVyZmxvdyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciBhcyBjcmVhdGVQb3BwZXJMaXRlIH0gZnJvbSBcIi4vcG9wcGVyLWxpdGUuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgKiBmcm9tIFwiLi9tb2RpZmllcnMvaW5kZXguanNcIjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/popper.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ computeAutoPlacement)\n/* harmony export */ });\n/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getVariation.js */ \"./node_modules/@popperjs/core/lib/utils/getVariation.js\");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detectOverflow.js */ \"./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBasePlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n\n\n\n\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.placements : _options$allowedAutoP;\n  var variation = (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(placement);\n  var placements = variation ? flipVariations ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.variationPlacements : _enums_js__WEBPACK_IMPORTED_MODULE_1__.variationPlacements.filter(function (placement) {\n    return (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(placement) === variation;\n  }) : _enums_js__WEBPACK_IMPORTED_MODULE_1__.basePlacements;\n  var allowedPlacements = placements.filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  });\n\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements;\n  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\n    acc[placement] = (0,_detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[(0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTZDO0FBQ2tEO0FBQzlDO0FBQ0k7QUFDdEM7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsaURBQWE7QUFDOUUsa0JBQWtCLDREQUFZO0FBQzlCLGdEQUFnRCwwREFBbUIsR0FBRywwREFBbUI7QUFDekYsV0FBVyw0REFBWTtBQUN2QixHQUFHLElBQUkscURBQWM7QUFDckI7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0EscUJBQXFCLDhEQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFLGdFQUFnQjtBQUN2QjtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qcz9lOTI0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyB2YXJpYXRpb25QbGFjZW1lbnRzLCBiYXNlUGxhY2VtZW50cywgcGxhY2VtZW50cyBhcyBhbGxQbGFjZW1lbnRzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9IF9vcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9PT0gdm9pZCAwID8gYWxsUGxhY2VtZW50cyA6IF9vcHRpb25zJGFsbG93ZWRBdXRvUDtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpO1xuICB2YXIgcGxhY2VtZW50cyA9IHZhcmlhdGlvbiA/IGZsaXBWYXJpYXRpb25zID8gdmFyaWF0aW9uUGxhY2VtZW50cyA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcbiAgfSkgOiBiYXNlUGxhY2VtZW50cztcbiAgdmFyIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhbGxvd2VkQXV0b1BsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpID49IDA7XG4gIH0pO1xuXG4gIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV06IEZsb3cgc2VlbXMgdG8gaGF2ZSBwcm9ibGVtcyB3aXRoIHR3byBhcnJheSB1bmlvbnMuLi5cblxuXG4gIHZhciBvdmVyZmxvd3MgPSBhbGxvd2VkUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KVtnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCldO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG92ZXJmbG93cykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBvdmVyZmxvd3NbYV0gLSBvdmVyZmxvd3NbYl07XG4gIH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeOffsets.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ computeOffsets)\n/* harmony export */ });\n/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBasePlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ \"./node_modules/@popperjs/core/lib/utils/getVariation.js\");\n/* harmony import */ var _getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getMainAxisFromPlacement.js */ \"./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n\n\n\n\nfunction computeOffsets(_ref) {\n  var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n  var basePlacement = placement ? (0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(placement) : null;\n  var variation = placement ? (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n\n  switch (basePlacement) {\n    case _enums_js__WEBPACK_IMPORTED_MODULE_3__.top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n\n    case _enums_js__WEBPACK_IMPORTED_MODULE_3__.bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case _enums_js__WEBPACK_IMPORTED_MODULE_3__.right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case _enums_js__WEBPACK_IMPORTED_MODULE_3__.left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  var mainAxis = basePlacement ? (0,_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(basePlacement) : null;\n\n  if (mainAxis != null) {\n    var len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variation) {\n      case _enums_js__WEBPACK_IMPORTED_MODULE_3__.start:\n        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n        break;\n\n      case _enums_js__WEBPACK_IMPORTED_MODULE_3__.end:\n        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n        break;\n\n      default:\n    }\n  }\n\n  return offsets;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXFEO0FBQ1I7QUFDd0I7QUFDRjtBQUNwRDtBQUNmO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnRUFBZ0I7QUFDbEQsOEJBQThCLDREQUFZO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsMENBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsNkNBQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsNENBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsMkNBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsd0VBQXdCOztBQUV6RDtBQUNBOztBQUVBO0FBQ0EsV0FBVyw0Q0FBSztBQUNoQjtBQUNBOztBQUVBLFdBQVcsMENBQUc7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanM/ZTU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgc3RhcnQsIGVuZCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZU9mZnNldHMoX3JlZikge1xuICB2YXIgcmVmZXJlbmNlID0gX3JlZi5yZWZlcmVuY2UsXG4gICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZi5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50ID8gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudCA/IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBlbGVtZW50LndpZHRoIC8gMjtcbiAgdmFyIGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZWxlbWVudC5oZWlnaHQgLyAyO1xuICB2YXIgb2Zmc2V0cztcblxuICBzd2l0Y2ggKGJhc2VQbGFjZW1lbnQpIHtcbiAgICBjYXNlIHRvcDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZWxlbWVudC5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgYm90dG9tOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHJpZ2h0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgbGVmdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZWxlbWVudC53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueVxuICAgICAgfTtcbiAgfVxuXG4gIHZhciBtYWluQXhpcyA9IGJhc2VQbGFjZW1lbnQgPyBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCkgOiBudWxsO1xuXG4gIGlmIChtYWluQXhpcyAhPSBudWxsKSB7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICBzd2l0Y2ggKHZhcmlhdGlvbikge1xuICAgICAgY2FzZSBzdGFydDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSAtIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgZW5kOlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdICsgKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/computeOffsets.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/debounce.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/debounce.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ debounce)\n/* harmony export */ });\nfunction debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZWJvdW5jZS5qcz8yNjI3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlYm91bmNlKGZuKSB7XG4gIHZhciBwZW5kaW5nO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVzb2x2ZShmbigpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGVuZGluZztcbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/debounce.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/detectOverflow.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ detectOverflow)\n/* harmony export */ });\n/* harmony import */ var _dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getClippingRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js\");\n/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getBoundingClientRect.js */ \"./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\");\n/* harmony import */ var _computeOffsets_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./computeOffsets.js */ \"./node_modules/@popperjs/core/lib/utils/computeOffsets.js\");\n/* harmony import */ var _rectToClientRect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rectToClientRect.js */ \"./node_modules/@popperjs/core/lib/utils/rectToClientRect.js\");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ \"./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n/* harmony import */ var _mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mergePaddingObject.js */ \"./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js\");\n/* harmony import */ var _expandToHashMap_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./expandToHashMap.js */ \"./node_modules/@popperjs/core/lib/utils/expandToHashMap.js\");\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$strategy = _options.strategy,\n      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = (0,_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(typeof padding !== 'number' ? padding : (0,_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_5__.basePlacements));\n  var altContext = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_5__.popper ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.reference : _enums_js__WEBPACK_IMPORTED_MODULE_5__.popper;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = (0,_dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])((0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_6__.isElement)(element) ? element : element.contextElement || (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(state.elements.popper), boundary, rootBoundary, strategy);\n  var referenceClientRect = (0,_dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.elements.reference);\n  var popperOffsets = (0,_computeOffsets_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = (0,_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(Object.assign({}, popperRect, popperOffsets));\n  var elementClientRect = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_5__.popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_5__.popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [_enums_js__WEBPACK_IMPORTED_MODULE_5__.right, _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [_enums_js__WEBPACK_IMPORTED_MODULE_5__.top, _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBOEQ7QUFDTTtBQUNNO0FBQ3pCO0FBQ0k7QUFDMEQ7QUFDeEQ7QUFDRTtBQUNOLENBQUM7O0FBRXJDO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxzREFBZTtBQUMvRDtBQUNBLHdEQUF3RCwrQ0FBUTtBQUNoRTtBQUNBLDBEQUEwRCw2Q0FBTTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrRUFBa0IseUNBQXlDLCtEQUFlLFVBQVUscURBQWM7QUFDeEgsc0NBQXNDLDZDQUFNLEdBQUcsZ0RBQVMsR0FBRyw2Q0FBTTtBQUNqRTtBQUNBO0FBQ0EsMkJBQTJCLHlFQUFlLENBQUMsbUVBQVMsZ0RBQWdELDRFQUFrQjtBQUN0SCw0QkFBNEIsK0VBQXFCO0FBQ2pELHNCQUFzQiw4REFBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsZ0VBQWdCLGlCQUFpQjtBQUMxRCw2Q0FBNkMsNkNBQU0sMkNBQTJDO0FBQzlGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0MseUJBQXlCLDZDQUFNO0FBQy9CO0FBQ0E7QUFDQSxzQkFBc0IsNENBQUssRUFBRSw2Q0FBTTtBQUNuQyxrQkFBa0IsMENBQUcsRUFBRSw2Q0FBTTtBQUM3QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanM/MTYxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0Q2xpcHBpbmdSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4vY29tcHV0ZU9mZnNldHMuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuL3JlY3RUb0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCB7IGNsaXBwaW5nUGFyZW50cywgcmVmZXJlbmNlLCBwb3BwZXIsIGJvdHRvbSwgdG9wLCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4vbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuL2V4cGFuZFRvSGFzaE1hcC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBzdGF0ZS5wbGFjZW1lbnQgOiBfb3B0aW9ucyRwbGFjZW1lbnQsXG4gICAgICBfb3B0aW9ucyRzdHJhdGVneSA9IF9vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgc3RyYXRlZ3kgPSBfb3B0aW9ucyRzdHJhdGVneSA9PT0gdm9pZCAwID8gc3RhdGUuc3RyYXRlZ3kgOiBfb3B0aW9ucyRzdHJhdGVneSxcbiAgICAgIF9vcHRpb25zJGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zJGJvdW5kYXJ5ID09PSB2b2lkIDAgPyBjbGlwcGluZ1BhcmVudHMgOiBfb3B0aW9ucyRib3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9PT0gdm9pZCAwID8gdmlld3BvcnQgOiBfb3B0aW9ucyRyb290Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRlbGVtZW50Q29udGUgPSBfb3B0aW9ucy5lbGVtZW50Q29udGV4dCxcbiAgICAgIGVsZW1lbnRDb250ZXh0ID0gX29wdGlvbnMkZWxlbWVudENvbnRlID09PSB2b2lkIDAgPyBwb3BwZXIgOiBfb3B0aW9ucyRlbGVtZW50Q29udGUsXG4gICAgICBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9IF9vcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zJHBhZGRpbmcgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRwYWRkaW5nO1xuICB2YXIgcGFkZGluZ09iamVjdCA9IG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG4gIHZhciBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHJlZmVyZW5jZSA6IHBvcHBlcjtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICB2YXIgY2xpcHBpbmdDbGllbnRSZWN0ID0gZ2V0Q2xpcHBpbmdSZWN0KGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IGdldERvY3VtZW50RWxlbWVudChzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSk7XG4gIHZhciByZWZlcmVuY2VDbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICBlbGVtZW50OiBwb3BwZXJSZWN0LFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pO1xuICB2YXIgcG9wcGVyQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoT2JqZWN0LmFzc2lnbih7fSwgcG9wcGVyUmVjdCwgcG9wcGVyT2Zmc2V0cykpO1xuICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuXG4gIHZhciBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgfTtcbiAgdmFyIG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDsgLy8gT2Zmc2V0cyBjYW4gYmUgYXBwbGllZCBvbmx5IHRvIHRoZSBwb3BwZXIgZWxlbWVudFxuXG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0RGF0YVtwbGFjZW1lbnRdO1xuICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICB2YXIgYXhpcyA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAneScgOiAneCc7XG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvdmVyZmxvd09mZnNldHM7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/detectOverflow.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ expandToHashMap)\n/* harmony export */ });\nfunction expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcz85ZjgwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4cGFuZFRvSGFzaE1hcCh2YWx1ZSwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2hNYXAsIGtleSkge1xuICAgIGhhc2hNYXBba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBoYXNoTWFwO1xuICB9LCB7fSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/expandToHashMap.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getAltAxis.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getAltAxis)\n/* harmony export */ });\nfunction getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanM/MzJiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/getAltAxis.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getBasePlacement)\n/* harmony export */ });\n\nfunction getBasePlacement(placement) {\n  return placement.split('-')[0];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFtQztBQUNwQjtBQUNmO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzP2RlOTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getFreshSideObject)\n/* harmony export */ });\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcz83ZTY5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEZyZXNoU2lkZU9iamVjdCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getMainAxisFromPlacement)\n/* harmony export */ });\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzPzFlMzIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpID49IDAgPyAneCcgOiAneSc7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getOppositePlacement)\n/* harmony export */ });\nvar hash = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qcz9lNTg0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBoYXNoID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getOppositeVariationPlacement)\n/* harmony export */ });\nvar hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return hash[matched];\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzPzNlZTkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGhhc2ggPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getVariation.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getVariation.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getVariation)\n/* harmony export */ });\nfunction getVariation(placement) {\n  return placement.split('-')[1];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzPzYwOTIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/getVariation.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/math.js":
/*!*******************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/math.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   round: () => (/* binding */ round)\n/* harmony export */ });\nvar max = Math.max;\nvar min = Math.min;\nvar round = Math.round;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21hdGguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQU87QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qcz8yYWYwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgdmFyIG1pbiA9IE1hdGgubWluO1xuZXhwb3J0IHZhciByb3VuZCA9IE1hdGgucm91bmQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/math.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergeByName.js":
/*!**************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergeByName.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ mergeByName)\n/* harmony export */ });\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlQnlOYW1lLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1QixLQUFLO0FBQ0w7QUFDQSxHQUFHLElBQUksR0FBRzs7QUFFVjtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VCeU5hbWUuanM/OTQ4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZUJ5TmFtZShtb2RpZmllcnMpIHtcbiAgdmFyIG1lcmdlZCA9IG1vZGlmaWVycy5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgY3VycmVudCkge1xuICAgIHZhciBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xuICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmcgPyBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZywgY3VycmVudCwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3Rpbmcub3B0aW9ucywgY3VycmVudC5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLmRhdGEsIGN1cnJlbnQuZGF0YSlcbiAgICB9KSA6IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pOyAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LnZhbHVlc1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG1lcmdlZFtrZXldO1xuICB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/mergeByName.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ mergePaddingObject)\n/* harmony export */ });\n/* harmony import */ var _getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFreshSideObject.js */ \"./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js\");\n\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, (0,_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(), paddingObject);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5RDtBQUMxQztBQUNmLHlCQUF5QixFQUFFLGtFQUFrQjtBQUM3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcz81NzYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4vZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZVBhZGRpbmdPYmplY3QocGFkZGluZ09iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZ2V0RnJlc2hTaWRlT2JqZWN0KCksIHBhZGRpbmdPYmplY3QpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/orderModifiers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ orderModifiers)\n/* harmony export */ });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ \"./node_modules/@popperjs/core/lib/enums.js\");\n // source: https://stackoverflow.com/questions/49875255\n\nfunction order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\n\nfunction orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = order(modifiers); // order based on phase\n\n  return _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases.reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTZDLENBQUM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsR0FBRzs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRWU7QUFDZjtBQUNBLDJDQUEyQzs7QUFFM0MsU0FBUyxxREFBYztBQUN2QjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzPzRmMTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbW9kaWZpZXJQaGFzZXMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTg3NTI1NVxuXG5mdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XG4gIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XG5cbiAgZnVuY3Rpb24gc29ydChtb2RpZmllcikge1xuICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuICAgIHZhciByZXF1aXJlcyA9IFtdLmNvbmNhdChtb2RpZmllci5yZXF1aXJlcyB8fCBbXSwgbW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgcmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgdmFyIGRlcE1vZGlmaWVyID0gbWFwLmdldChkZXApO1xuXG4gICAgICAgIGlmIChkZXBNb2RpZmllcikge1xuICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0LnB1c2gobW9kaWZpZXIpO1xuICB9XG5cbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHZpc2l0ZWQgb2JqZWN0XG4gICAgICBzb3J0KG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRlck1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXG4gIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXIobW9kaWZpZXJzKTsgLy8gb3JkZXIgYmFzZWQgb24gcGhhc2VcblxuICByZXR1cm4gbW9kaWZpZXJQaGFzZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICByZXR1cm4gbW9kaWZpZXIucGhhc2UgPT09IHBoYXNlO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/orderModifiers.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rectToClientRect)\n/* harmony export */ });\nfunction rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2YseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qcz8zMjQxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xuICAgIGxlZnQ6IHJlY3QueCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/rectToClientRect.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/userAgent.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/userAgent.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getUAString)\n/* harmony export */ });\nfunction getUAString() {\n  var uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(function (item) {\n      return item.brand + \"/\" + item.version;\n    }).join(' ');\n  }\n\n  return navigator.userAgent;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3VzZXJBZ2VudC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3VzZXJBZ2VudC5qcz8zOGZkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFVBU3RyaW5nKCkge1xuICB2YXIgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG5cbiAgaWYgKHVhRGF0YSAhPSBudWxsICYmIHVhRGF0YS5icmFuZHMgJiYgQXJyYXkuaXNBcnJheSh1YURhdGEuYnJhbmRzKSkge1xuICAgIHJldHVybiB1YURhdGEuYnJhbmRzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uYnJhbmQgKyBcIi9cIiArIGl0ZW0udmVyc2lvbjtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cblxuICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/userAgent.js\n\n}");

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/within.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/within.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   within: () => (/* binding */ within),\n/* harmony export */   withinMaxClamp: () => (/* binding */ withinMaxClamp)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"./node_modules/@popperjs/core/lib/utils/math.js\");\n\nfunction within(min, value, max) {\n  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(min, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(value, max));\n}\nfunction withinMaxClamp(min, value, max) {\n  var v = within(min, value, max);\n  return v > max ? max : v;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkQ7QUFDcEQ7QUFDUCxTQUFTLDZDQUFPLE1BQU0sNkNBQU87QUFDN0I7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcz8zN2EzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1heCBhcyBtYXRoTWF4LCBtaW4gYXMgbWF0aE1pbiB9IGZyb20gXCIuL21hdGguanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KSB7XG4gIHJldHVybiBtYXRoTWF4KG1pbiwgbWF0aE1pbih2YWx1ZSwgbWF4KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2l0aGluTWF4Q2xhbXAobWluLCB2YWx1ZSwgbWF4KSB7XG4gIHZhciB2ID0gd2l0aGluKG1pbiwgdmFsdWUsIG1heCk7XG4gIHJldHVybiB2ID4gbWF4ID8gbWF4IDogdjtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@popperjs/core/lib/utils/within.js\n\n}");

/***/ }),

/***/ "./node_modules/bootstrap/dist/js/bootstrap.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/bootstrap/dist/js/bootstrap.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Alert: () => (/* binding */ Alert),\n/* harmony export */   Button: () => (/* binding */ Button),\n/* harmony export */   Carousel: () => (/* binding */ Carousel),\n/* harmony export */   Collapse: () => (/* binding */ Collapse),\n/* harmony export */   Dropdown: () => (/* binding */ Dropdown),\n/* harmony export */   Modal: () => (/* binding */ Modal),\n/* harmony export */   Offcanvas: () => (/* binding */ Offcanvas),\n/* harmony export */   Popover: () => (/* binding */ Popover),\n/* harmony export */   ScrollSpy: () => (/* binding */ ScrollSpy),\n/* harmony export */   Tab: () => (/* binding */ Tab),\n/* harmony export */   Toast: () => (/* binding */ Toast),\n/* harmony export */   Tooltip: () => (/* binding */ Tooltip)\n/* harmony export */ });\n/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ \"./node_modules/@popperjs/core/lib/index.js\");\n/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @popperjs/core */ \"./node_modules/@popperjs/core/lib/popper.js\");\n/*!\n  * Bootstrap v5.3.7 (https://getbootstrap.com/)\n  * Copyright 2011-2025 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\n\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap dom/data.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n/**\n * Constants\n */\n\nconst elementMap = new Map();\nconst Data = {\n  set(element, key, instance) {\n    if (!elementMap.has(element)) {\n      elementMap.set(element, new Map());\n    }\n    const instanceMap = elementMap.get(element);\n\n    // make it clear we only want one instance per element\n    // can be removed later when multiple key/instances are fine to be used\n    if (!instanceMap.has(key) && instanceMap.size !== 0) {\n      // eslint-disable-next-line no-console\n      console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);\n      return;\n    }\n    instanceMap.set(key, instance);\n  },\n  get(element, key) {\n    if (elementMap.has(element)) {\n      return elementMap.get(element).get(key) || null;\n    }\n    return null;\n  },\n  remove(element, key) {\n    if (!elementMap.has(element)) {\n      return;\n    }\n    const instanceMap = elementMap.get(element);\n    instanceMap.delete(key);\n\n    // free up element references if there are no instances left for an element\n    if (instanceMap.size === 0) {\n      elementMap.delete(element);\n    }\n  }\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/index.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nconst MAX_UID = 1000000;\nconst MILLISECONDS_MULTIPLIER = 1000;\nconst TRANSITION_END = 'transitionend';\n\n/**\n * Properly escape IDs selectors to handle weird IDs\n * @param {string} selector\n * @returns {string}\n */\nconst parseSelector = selector => {\n  if (selector && window.CSS && window.CSS.escape) {\n    // document.querySelector needs escaping to handle IDs (html5+) containing for instance /\n    selector = selector.replace(/#([^\\s\"#']+)/g, (match, id) => `#${CSS.escape(id)}`);\n  }\n  return selector;\n};\n\n// Shout-out Angus Croll (https://goo.gl/pxwQGp)\nconst toType = object => {\n  if (object === null || object === undefined) {\n    return `${object}`;\n  }\n  return Object.prototype.toString.call(object).match(/\\s([a-z]+)/i)[1].toLowerCase();\n};\n\n/**\n * Public Util API\n */\n\nconst getUID = prefix => {\n  do {\n    prefix += Math.floor(Math.random() * MAX_UID);\n  } while (document.getElementById(prefix));\n  return prefix;\n};\nconst getTransitionDurationFromElement = element => {\n  if (!element) {\n    return 0;\n  }\n\n  // Get transition-duration of the element\n  let {\n    transitionDuration,\n    transitionDelay\n  } = window.getComputedStyle(element);\n  const floatTransitionDuration = Number.parseFloat(transitionDuration);\n  const floatTransitionDelay = Number.parseFloat(transitionDelay);\n\n  // Return 0 if element or transition duration is not found\n  if (!floatTransitionDuration && !floatTransitionDelay) {\n    return 0;\n  }\n\n  // If multiple durations are defined, take the first\n  transitionDuration = transitionDuration.split(',')[0];\n  transitionDelay = transitionDelay.split(',')[0];\n  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n};\nconst triggerTransitionEnd = element => {\n  element.dispatchEvent(new Event(TRANSITION_END));\n};\nconst isElement = object => {\n  if (!object || typeof object !== 'object') {\n    return false;\n  }\n  if (typeof object.jquery !== 'undefined') {\n    object = object[0];\n  }\n  return typeof object.nodeType !== 'undefined';\n};\nconst getElement = object => {\n  // it's a jQuery object or a node element\n  if (isElement(object)) {\n    return object.jquery ? object[0] : object;\n  }\n  if (typeof object === 'string' && object.length > 0) {\n    return document.querySelector(parseSelector(object));\n  }\n  return null;\n};\nconst isVisible = element => {\n  if (!isElement(element) || element.getClientRects().length === 0) {\n    return false;\n  }\n  const elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible';\n  // Handle `details` element as its content may falsie appear visible when it is closed\n  const closedDetails = element.closest('details:not([open])');\n  if (!closedDetails) {\n    return elementIsVisible;\n  }\n  if (closedDetails !== element) {\n    const summary = element.closest('summary');\n    if (summary && summary.parentNode !== closedDetails) {\n      return false;\n    }\n    if (summary === null) {\n      return false;\n    }\n  }\n  return elementIsVisible;\n};\nconst isDisabled = element => {\n  if (!element || element.nodeType !== Node.ELEMENT_NODE) {\n    return true;\n  }\n  if (element.classList.contains('disabled')) {\n    return true;\n  }\n  if (typeof element.disabled !== 'undefined') {\n    return element.disabled;\n  }\n  return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';\n};\nconst findShadowRoot = element => {\n  if (!document.documentElement.attachShadow) {\n    return null;\n  }\n\n  // Can find the shadow root otherwise it'll return the document\n  if (typeof element.getRootNode === 'function') {\n    const root = element.getRootNode();\n    return root instanceof ShadowRoot ? root : null;\n  }\n  if (element instanceof ShadowRoot) {\n    return element;\n  }\n\n  // when we don't find a shadow root\n  if (!element.parentNode) {\n    return null;\n  }\n  return findShadowRoot(element.parentNode);\n};\nconst noop = () => {};\n\n/**\n * Trick to restart an element's animation\n *\n * @param {HTMLElement} element\n * @return void\n *\n * @see https://www.harrytheo.com/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation\n */\nconst reflow = element => {\n  element.offsetHeight; // eslint-disable-line no-unused-expressions\n};\nconst getjQuery = () => {\n  if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {\n    return window.jQuery;\n  }\n  return null;\n};\nconst DOMContentLoadedCallbacks = [];\nconst onDOMContentLoaded = callback => {\n  if (document.readyState === 'loading') {\n    // add listener on the first call when the document is in loading state\n    if (!DOMContentLoadedCallbacks.length) {\n      document.addEventListener('DOMContentLoaded', () => {\n        for (const callback of DOMContentLoadedCallbacks) {\n          callback();\n        }\n      });\n    }\n    DOMContentLoadedCallbacks.push(callback);\n  } else {\n    callback();\n  }\n};\nconst isRTL = () => document.documentElement.dir === 'rtl';\nconst defineJQueryPlugin = plugin => {\n  onDOMContentLoaded(() => {\n    const $ = getjQuery();\n    /* istanbul ignore if */\n    if ($) {\n      const name = plugin.NAME;\n      const JQUERY_NO_CONFLICT = $.fn[name];\n      $.fn[name] = plugin.jQueryInterface;\n      $.fn[name].Constructor = plugin;\n      $.fn[name].noConflict = () => {\n        $.fn[name] = JQUERY_NO_CONFLICT;\n        return plugin.jQueryInterface;\n      };\n    }\n  });\n};\nconst execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {\n  return typeof possibleCallback === 'function' ? possibleCallback.call(...args) : defaultValue;\n};\nconst executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {\n  if (!waitForTransition) {\n    execute(callback);\n    return;\n  }\n  const durationPadding = 5;\n  const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;\n  let called = false;\n  const handler = ({\n    target\n  }) => {\n    if (target !== transitionElement) {\n      return;\n    }\n    called = true;\n    transitionElement.removeEventListener(TRANSITION_END, handler);\n    execute(callback);\n  };\n  transitionElement.addEventListener(TRANSITION_END, handler);\n  setTimeout(() => {\n    if (!called) {\n      triggerTransitionEnd(transitionElement);\n    }\n  }, emulatedDuration);\n};\n\n/**\n * Return the previous/next element of a list.\n *\n * @param {array} list    The list of elements\n * @param activeElement   The active element\n * @param shouldGetNext   Choose to get next or previous element\n * @param isCycleAllowed\n * @return {Element|elem} The proper element\n */\nconst getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {\n  const listLength = list.length;\n  let index = list.indexOf(activeElement);\n\n  // if the element does not exist in the list return an element\n  // depending on the direction and if cycle is allowed\n  if (index === -1) {\n    return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];\n  }\n  index += shouldGetNext ? 1 : -1;\n  if (isCycleAllowed) {\n    index = (index + listLength) % listLength;\n  }\n  return list[Math.max(0, Math.min(index, listLength - 1))];\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap dom/event-handler.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst namespaceRegex = /[^.]*(?=\\..*)\\.|.*/;\nconst stripNameRegex = /\\..*/;\nconst stripUidRegex = /::\\d+$/;\nconst eventRegistry = {}; // Events storage\nlet uidEvent = 1;\nconst customEvents = {\n  mouseenter: 'mouseover',\n  mouseleave: 'mouseout'\n};\nconst nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);\n\n/**\n * Private methods\n */\n\nfunction makeEventUid(element, uid) {\n  return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;\n}\nfunction getElementEvents(element) {\n  const uid = makeEventUid(element);\n  element.uidEvent = uid;\n  eventRegistry[uid] = eventRegistry[uid] || {};\n  return eventRegistry[uid];\n}\nfunction bootstrapHandler(element, fn) {\n  return function handler(event) {\n    hydrateObj(event, {\n      delegateTarget: element\n    });\n    if (handler.oneOff) {\n      EventHandler.off(element, event.type, fn);\n    }\n    return fn.apply(element, [event]);\n  };\n}\nfunction bootstrapDelegationHandler(element, selector, fn) {\n  return function handler(event) {\n    const domElements = element.querySelectorAll(selector);\n    for (let {\n      target\n    } = event; target && target !== this; target = target.parentNode) {\n      for (const domElement of domElements) {\n        if (domElement !== target) {\n          continue;\n        }\n        hydrateObj(event, {\n          delegateTarget: target\n        });\n        if (handler.oneOff) {\n          EventHandler.off(element, event.type, selector, fn);\n        }\n        return fn.apply(target, [event]);\n      }\n    }\n  };\n}\nfunction findHandler(events, callable, delegationSelector = null) {\n  return Object.values(events).find(event => event.callable === callable && event.delegationSelector === delegationSelector);\n}\nfunction normalizeParameters(originalTypeEvent, handler, delegationFunction) {\n  const isDelegated = typeof handler === 'string';\n  // TODO: tooltip passes `false` instead of selector, so we need to check\n  const callable = isDelegated ? delegationFunction : handler || delegationFunction;\n  let typeEvent = getTypeEvent(originalTypeEvent);\n  if (!nativeEvents.has(typeEvent)) {\n    typeEvent = originalTypeEvent;\n  }\n  return [isDelegated, callable, typeEvent];\n}\nfunction addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {\n  if (typeof originalTypeEvent !== 'string' || !element) {\n    return;\n  }\n  let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);\n\n  // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position\n  // this prevents the handler from being dispatched the same way as mouseover or mouseout does\n  if (originalTypeEvent in customEvents) {\n    const wrapFunction = fn => {\n      return function (event) {\n        if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {\n          return fn.call(this, event);\n        }\n      };\n    };\n    callable = wrapFunction(callable);\n  }\n  const events = getElementEvents(element);\n  const handlers = events[typeEvent] || (events[typeEvent] = {});\n  const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);\n  if (previousFunction) {\n    previousFunction.oneOff = previousFunction.oneOff && oneOff;\n    return;\n  }\n  const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));\n  const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);\n  fn.delegationSelector = isDelegated ? handler : null;\n  fn.callable = callable;\n  fn.oneOff = oneOff;\n  fn.uidEvent = uid;\n  handlers[uid] = fn;\n  element.addEventListener(typeEvent, fn, isDelegated);\n}\nfunction removeHandler(element, events, typeEvent, handler, delegationSelector) {\n  const fn = findHandler(events[typeEvent], handler, delegationSelector);\n  if (!fn) {\n    return;\n  }\n  element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));\n  delete events[typeEvent][fn.uidEvent];\n}\nfunction removeNamespacedHandlers(element, events, typeEvent, namespace) {\n  const storeElementEvent = events[typeEvent] || {};\n  for (const [handlerKey, event] of Object.entries(storeElementEvent)) {\n    if (handlerKey.includes(namespace)) {\n      removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n    }\n  }\n}\nfunction getTypeEvent(event) {\n  // allow to get the native events from namespaced events ('click.bs.button' --> 'click')\n  event = event.replace(stripNameRegex, '');\n  return customEvents[event] || event;\n}\nconst EventHandler = {\n  on(element, event, handler, delegationFunction) {\n    addHandler(element, event, handler, delegationFunction, false);\n  },\n  one(element, event, handler, delegationFunction) {\n    addHandler(element, event, handler, delegationFunction, true);\n  },\n  off(element, originalTypeEvent, handler, delegationFunction) {\n    if (typeof originalTypeEvent !== 'string' || !element) {\n      return;\n    }\n    const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);\n    const inNamespace = typeEvent !== originalTypeEvent;\n    const events = getElementEvents(element);\n    const storeElementEvent = events[typeEvent] || {};\n    const isNamespace = originalTypeEvent.startsWith('.');\n    if (typeof callable !== 'undefined') {\n      // Simplest case: handler is passed, remove that listener ONLY.\n      if (!Object.keys(storeElementEvent).length) {\n        return;\n      }\n      removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);\n      return;\n    }\n    if (isNamespace) {\n      for (const elementEvent of Object.keys(events)) {\n        removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));\n      }\n    }\n    for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {\n      const handlerKey = keyHandlers.replace(stripUidRegex, '');\n      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {\n        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n      }\n    }\n  },\n  trigger(element, event, args) {\n    if (typeof event !== 'string' || !element) {\n      return null;\n    }\n    const $ = getjQuery();\n    const typeEvent = getTypeEvent(event);\n    const inNamespace = event !== typeEvent;\n    let jQueryEvent = null;\n    let bubbles = true;\n    let nativeDispatch = true;\n    let defaultPrevented = false;\n    if (inNamespace && $) {\n      jQueryEvent = $.Event(event, args);\n      $(element).trigger(jQueryEvent);\n      bubbles = !jQueryEvent.isPropagationStopped();\n      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\n      defaultPrevented = jQueryEvent.isDefaultPrevented();\n    }\n    const evt = hydrateObj(new Event(event, {\n      bubbles,\n      cancelable: true\n    }), args);\n    if (defaultPrevented) {\n      evt.preventDefault();\n    }\n    if (nativeDispatch) {\n      element.dispatchEvent(evt);\n    }\n    if (evt.defaultPrevented && jQueryEvent) {\n      jQueryEvent.preventDefault();\n    }\n    return evt;\n  }\n};\nfunction hydrateObj(obj, meta = {}) {\n  for (const [key, value] of Object.entries(meta)) {\n    try {\n      obj[key] = value;\n    } catch (_unused) {\n      Object.defineProperty(obj, key, {\n        configurable: true,\n        get() {\n          return value;\n        }\n      });\n    }\n  }\n  return obj;\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap dom/manipulator.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nfunction normalizeData(value) {\n  if (value === 'true') {\n    return true;\n  }\n  if (value === 'false') {\n    return false;\n  }\n  if (value === Number(value).toString()) {\n    return Number(value);\n  }\n  if (value === '' || value === 'null') {\n    return null;\n  }\n  if (typeof value !== 'string') {\n    return value;\n  }\n  try {\n    return JSON.parse(decodeURIComponent(value));\n  } catch (_unused) {\n    return value;\n  }\n}\nfunction normalizeDataKey(key) {\n  return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);\n}\nconst Manipulator = {\n  setDataAttribute(element, key, value) {\n    element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);\n  },\n  removeDataAttribute(element, key) {\n    element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);\n  },\n  getDataAttributes(element) {\n    if (!element) {\n      return {};\n    }\n    const attributes = {};\n    const bsKeys = Object.keys(element.dataset).filter(key => key.startsWith('bs') && !key.startsWith('bsConfig'));\n    for (const key of bsKeys) {\n      let pureKey = key.replace(/^bs/, '');\n      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1);\n      attributes[pureKey] = normalizeData(element.dataset[key]);\n    }\n    return attributes;\n  },\n  getDataAttribute(element, key) {\n    return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));\n  }\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/config.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Class definition\n */\n\nclass Config {\n  // Getters\n  static get Default() {\n    return {};\n  }\n  static get DefaultType() {\n    return {};\n  }\n  static get NAME() {\n    throw new Error('You have to implement the static method \"NAME\", for each component!');\n  }\n  _getConfig(config) {\n    config = this._mergeConfigObj(config);\n    config = this._configAfterMerge(config);\n    this._typeCheckConfig(config);\n    return config;\n  }\n  _configAfterMerge(config) {\n    return config;\n  }\n  _mergeConfigObj(config, element) {\n    const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse\n\n    return {\n      ...this.constructor.Default,\n      ...(typeof jsonConfig === 'object' ? jsonConfig : {}),\n      ...(isElement(element) ? Manipulator.getDataAttributes(element) : {}),\n      ...(typeof config === 'object' ? config : {})\n    };\n  }\n  _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {\n    for (const [property, expectedTypes] of Object.entries(configTypes)) {\n      const value = config[property];\n      const valueType = isElement(value) ? 'element' : toType(value);\n      if (!new RegExp(expectedTypes).test(valueType)) {\n        throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`);\n      }\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap base-component.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst VERSION = '5.3.7';\n\n/**\n * Class definition\n */\n\nclass BaseComponent extends Config {\n  constructor(element, config) {\n    super();\n    element = getElement(element);\n    if (!element) {\n      return;\n    }\n    this._element = element;\n    this._config = this._getConfig(config);\n    Data.set(this._element, this.constructor.DATA_KEY, this);\n  }\n\n  // Public\n  dispose() {\n    Data.remove(this._element, this.constructor.DATA_KEY);\n    EventHandler.off(this._element, this.constructor.EVENT_KEY);\n    for (const propertyName of Object.getOwnPropertyNames(this)) {\n      this[propertyName] = null;\n    }\n  }\n\n  // Private\n  _queueCallback(callback, element, isAnimated = true) {\n    executeAfterTransition(callback, element, isAnimated);\n  }\n  _getConfig(config) {\n    config = this._mergeConfigObj(config, this._element);\n    config = this._configAfterMerge(config);\n    this._typeCheckConfig(config);\n    return config;\n  }\n\n  // Static\n  static getInstance(element) {\n    return Data.get(getElement(element), this.DATA_KEY);\n  }\n  static getOrCreateInstance(element, config = {}) {\n    return this.getInstance(element) || new this(element, typeof config === 'object' ? config : null);\n  }\n  static get VERSION() {\n    return VERSION;\n  }\n  static get DATA_KEY() {\n    return `bs.${this.NAME}`;\n  }\n  static get EVENT_KEY() {\n    return `.${this.DATA_KEY}`;\n  }\n  static eventName(name) {\n    return `${name}${this.EVENT_KEY}`;\n  }\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap dom/selector-engine.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nconst getSelector = element => {\n  let selector = element.getAttribute('data-bs-target');\n  if (!selector || selector === '#') {\n    let hrefAttribute = element.getAttribute('href');\n\n    // The only valid content that could double as a selector are IDs or classes,\n    // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\n    // `document.querySelector` will rightfully complain it is invalid.\n    // See https://github.com/twbs/bootstrap/issues/32273\n    if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) {\n      return null;\n    }\n\n    // Just in case some CMS puts out a full URL with the anchor appended\n    if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {\n      hrefAttribute = `#${hrefAttribute.split('#')[1]}`;\n    }\n    selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;\n  }\n  return selector ? selector.split(',').map(sel => parseSelector(sel)).join(',') : null;\n};\nconst SelectorEngine = {\n  find(selector, element = document.documentElement) {\n    return [].concat(...Element.prototype.querySelectorAll.call(element, selector));\n  },\n  findOne(selector, element = document.documentElement) {\n    return Element.prototype.querySelector.call(element, selector);\n  },\n  children(element, selector) {\n    return [].concat(...element.children).filter(child => child.matches(selector));\n  },\n  parents(element, selector) {\n    const parents = [];\n    let ancestor = element.parentNode.closest(selector);\n    while (ancestor) {\n      parents.push(ancestor);\n      ancestor = ancestor.parentNode.closest(selector);\n    }\n    return parents;\n  },\n  prev(element, selector) {\n    let previous = element.previousElementSibling;\n    while (previous) {\n      if (previous.matches(selector)) {\n        return [previous];\n      }\n      previous = previous.previousElementSibling;\n    }\n    return [];\n  },\n  // TODO: this is now unused; remove later along with prev()\n  next(element, selector) {\n    let next = element.nextElementSibling;\n    while (next) {\n      if (next.matches(selector)) {\n        return [next];\n      }\n      next = next.nextElementSibling;\n    }\n    return [];\n  },\n  focusableChildren(element) {\n    const focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable=\"true\"]'].map(selector => `${selector}:not([tabindex^=\"-\"])`).join(',');\n    return this.find(focusables, element).filter(el => !isDisabled(el) && isVisible(el));\n  },\n  getSelectorFromElement(element) {\n    const selector = getSelector(element);\n    if (selector) {\n      return SelectorEngine.findOne(selector) ? selector : null;\n    }\n    return null;\n  },\n  getElementFromSelector(element) {\n    const selector = getSelector(element);\n    return selector ? SelectorEngine.findOne(selector) : null;\n  },\n  getMultipleElementsFromSelector(element) {\n    const selector = getSelector(element);\n    return selector ? SelectorEngine.find(selector) : [];\n  }\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/component-functions.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nconst enableDismissTrigger = (component, method = 'hide') => {\n  const clickEvent = `click.dismiss${component.EVENT_KEY}`;\n  const name = component.NAME;\n  EventHandler.on(document, clickEvent, `[data-bs-dismiss=\"${name}\"]`, function (event) {\n    if (['A', 'AREA'].includes(this.tagName)) {\n      event.preventDefault();\n    }\n    if (isDisabled(this)) {\n      return;\n    }\n    const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);\n    const instance = component.getOrCreateInstance(target);\n\n    // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method\n    instance[method]();\n  });\n};\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap alert.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$f = 'alert';\nconst DATA_KEY$a = 'bs.alert';\nconst EVENT_KEY$b = `.${DATA_KEY$a}`;\nconst EVENT_CLOSE = `close${EVENT_KEY$b}`;\nconst EVENT_CLOSED = `closed${EVENT_KEY$b}`;\nconst CLASS_NAME_FADE$5 = 'fade';\nconst CLASS_NAME_SHOW$8 = 'show';\n\n/**\n * Class definition\n */\n\nclass Alert extends BaseComponent {\n  // Getters\n  static get NAME() {\n    return NAME$f;\n  }\n\n  // Public\n  close() {\n    const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);\n    if (closeEvent.defaultPrevented) {\n      return;\n    }\n    this._element.classList.remove(CLASS_NAME_SHOW$8);\n    const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);\n    this._queueCallback(() => this._destroyElement(), this._element, isAnimated);\n  }\n\n  // Private\n  _destroyElement() {\n    this._element.remove();\n    EventHandler.trigger(this._element, EVENT_CLOSED);\n    this.dispose();\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Alert.getOrCreateInstance(this);\n      if (typeof config !== 'string') {\n        return;\n      }\n      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config](this);\n    });\n  }\n}\n\n/**\n * Data API implementation\n */\n\nenableDismissTrigger(Alert, 'close');\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Alert);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap button.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$e = 'button';\nconst DATA_KEY$9 = 'bs.button';\nconst EVENT_KEY$a = `.${DATA_KEY$9}`;\nconst DATA_API_KEY$6 = '.data-api';\nconst CLASS_NAME_ACTIVE$3 = 'active';\nconst SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle=\"button\"]';\nconst EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;\n\n/**\n * Class definition\n */\n\nclass Button extends BaseComponent {\n  // Getters\n  static get NAME() {\n    return NAME$e;\n  }\n\n  // Public\n  toggle() {\n    // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method\n    this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Button.getOrCreateInstance(this);\n      if (config === 'toggle') {\n        data[config]();\n      }\n    });\n  }\n}\n\n/**\n * Data API implementation\n */\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event => {\n  event.preventDefault();\n  const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);\n  const data = Button.getOrCreateInstance(button);\n  data.toggle();\n});\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Button);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/swipe.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$d = 'swipe';\nconst EVENT_KEY$9 = '.bs.swipe';\nconst EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;\nconst EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;\nconst EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;\nconst EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;\nconst EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;\nconst POINTER_TYPE_TOUCH = 'touch';\nconst POINTER_TYPE_PEN = 'pen';\nconst CLASS_NAME_POINTER_EVENT = 'pointer-event';\nconst SWIPE_THRESHOLD = 40;\nconst Default$c = {\n  endCallback: null,\n  leftCallback: null,\n  rightCallback: null\n};\nconst DefaultType$c = {\n  endCallback: '(function|null)',\n  leftCallback: '(function|null)',\n  rightCallback: '(function|null)'\n};\n\n/**\n * Class definition\n */\n\nclass Swipe extends Config {\n  constructor(element, config) {\n    super();\n    this._element = element;\n    if (!element || !Swipe.isSupported()) {\n      return;\n    }\n    this._config = this._getConfig(config);\n    this._deltaX = 0;\n    this._supportPointerEvents = Boolean(window.PointerEvent);\n    this._initEvents();\n  }\n\n  // Getters\n  static get Default() {\n    return Default$c;\n  }\n  static get DefaultType() {\n    return DefaultType$c;\n  }\n  static get NAME() {\n    return NAME$d;\n  }\n\n  // Public\n  dispose() {\n    EventHandler.off(this._element, EVENT_KEY$9);\n  }\n\n  // Private\n  _start(event) {\n    if (!this._supportPointerEvents) {\n      this._deltaX = event.touches[0].clientX;\n      return;\n    }\n    if (this._eventIsPointerPenTouch(event)) {\n      this._deltaX = event.clientX;\n    }\n  }\n  _end(event) {\n    if (this._eventIsPointerPenTouch(event)) {\n      this._deltaX = event.clientX - this._deltaX;\n    }\n    this._handleSwipe();\n    execute(this._config.endCallback);\n  }\n  _move(event) {\n    this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;\n  }\n  _handleSwipe() {\n    const absDeltaX = Math.abs(this._deltaX);\n    if (absDeltaX <= SWIPE_THRESHOLD) {\n      return;\n    }\n    const direction = absDeltaX / this._deltaX;\n    this._deltaX = 0;\n    if (!direction) {\n      return;\n    }\n    execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);\n  }\n  _initEvents() {\n    if (this._supportPointerEvents) {\n      EventHandler.on(this._element, EVENT_POINTERDOWN, event => this._start(event));\n      EventHandler.on(this._element, EVENT_POINTERUP, event => this._end(event));\n      this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n    } else {\n      EventHandler.on(this._element, EVENT_TOUCHSTART, event => this._start(event));\n      EventHandler.on(this._element, EVENT_TOUCHMOVE, event => this._move(event));\n      EventHandler.on(this._element, EVENT_TOUCHEND, event => this._end(event));\n    }\n  }\n  _eventIsPointerPenTouch(event) {\n    return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);\n  }\n\n  // Static\n  static isSupported() {\n    return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;\n  }\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap carousel.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$c = 'carousel';\nconst DATA_KEY$8 = 'bs.carousel';\nconst EVENT_KEY$8 = `.${DATA_KEY$8}`;\nconst DATA_API_KEY$5 = '.data-api';\nconst ARROW_LEFT_KEY$1 = 'ArrowLeft';\nconst ARROW_RIGHT_KEY$1 = 'ArrowRight';\nconst TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n\nconst ORDER_NEXT = 'next';\nconst ORDER_PREV = 'prev';\nconst DIRECTION_LEFT = 'left';\nconst DIRECTION_RIGHT = 'right';\nconst EVENT_SLIDE = `slide${EVENT_KEY$8}`;\nconst EVENT_SLID = `slid${EVENT_KEY$8}`;\nconst EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;\nconst EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;\nconst EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;\nconst EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;\nconst EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;\nconst EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;\nconst CLASS_NAME_CAROUSEL = 'carousel';\nconst CLASS_NAME_ACTIVE$2 = 'active';\nconst CLASS_NAME_SLIDE = 'slide';\nconst CLASS_NAME_END = 'carousel-item-end';\nconst CLASS_NAME_START = 'carousel-item-start';\nconst CLASS_NAME_NEXT = 'carousel-item-next';\nconst CLASS_NAME_PREV = 'carousel-item-prev';\nconst SELECTOR_ACTIVE = '.active';\nconst SELECTOR_ITEM = '.carousel-item';\nconst SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;\nconst SELECTOR_ITEM_IMG = '.carousel-item img';\nconst SELECTOR_INDICATORS = '.carousel-indicators';\nconst SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';\nconst SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]';\nconst KEY_TO_DIRECTION = {\n  [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,\n  [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT\n};\nconst Default$b = {\n  interval: 5000,\n  keyboard: true,\n  pause: 'hover',\n  ride: false,\n  touch: true,\n  wrap: true\n};\nconst DefaultType$b = {\n  interval: '(number|boolean)',\n  // TODO:v6 remove boolean support\n  keyboard: 'boolean',\n  pause: '(string|boolean)',\n  ride: '(boolean|string)',\n  touch: 'boolean',\n  wrap: 'boolean'\n};\n\n/**\n * Class definition\n */\n\nclass Carousel extends BaseComponent {\n  constructor(element, config) {\n    super(element, config);\n    this._interval = null;\n    this._activeElement = null;\n    this._isSliding = false;\n    this.touchTimeout = null;\n    this._swipeHelper = null;\n    this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);\n    this._addEventListeners();\n    if (this._config.ride === CLASS_NAME_CAROUSEL) {\n      this.cycle();\n    }\n  }\n\n  // Getters\n  static get Default() {\n    return Default$b;\n  }\n  static get DefaultType() {\n    return DefaultType$b;\n  }\n  static get NAME() {\n    return NAME$c;\n  }\n\n  // Public\n  next() {\n    this._slide(ORDER_NEXT);\n  }\n  nextWhenVisible() {\n    // FIXME TODO use `document.visibilityState`\n    // Don't call next when the page isn't visible\n    // or the carousel or its parent isn't visible\n    if (!document.hidden && isVisible(this._element)) {\n      this.next();\n    }\n  }\n  prev() {\n    this._slide(ORDER_PREV);\n  }\n  pause() {\n    if (this._isSliding) {\n      triggerTransitionEnd(this._element);\n    }\n    this._clearInterval();\n  }\n  cycle() {\n    this._clearInterval();\n    this._updateInterval();\n    this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);\n  }\n  _maybeEnableCycle() {\n    if (!this._config.ride) {\n      return;\n    }\n    if (this._isSliding) {\n      EventHandler.one(this._element, EVENT_SLID, () => this.cycle());\n      return;\n    }\n    this.cycle();\n  }\n  to(index) {\n    const items = this._getItems();\n    if (index > items.length - 1 || index < 0) {\n      return;\n    }\n    if (this._isSliding) {\n      EventHandler.one(this._element, EVENT_SLID, () => this.to(index));\n      return;\n    }\n    const activeIndex = this._getItemIndex(this._getActive());\n    if (activeIndex === index) {\n      return;\n    }\n    const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\n    this._slide(order, items[index]);\n  }\n  dispose() {\n    if (this._swipeHelper) {\n      this._swipeHelper.dispose();\n    }\n    super.dispose();\n  }\n\n  // Private\n  _configAfterMerge(config) {\n    config.defaultInterval = config.interval;\n    return config;\n  }\n  _addEventListeners() {\n    if (this._config.keyboard) {\n      EventHandler.on(this._element, EVENT_KEYDOWN$1, event => this._keydown(event));\n    }\n    if (this._config.pause === 'hover') {\n      EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());\n      EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());\n    }\n    if (this._config.touch && Swipe.isSupported()) {\n      this._addTouchEventListeners();\n    }\n  }\n  _addTouchEventListeners() {\n    for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {\n      EventHandler.on(img, EVENT_DRAG_START, event => event.preventDefault());\n    }\n    const endCallBack = () => {\n      if (this._config.pause !== 'hover') {\n        return;\n      }\n\n      // If it's a touch-enabled device, mouseenter/leave are fired as\n      // part of the mouse compatibility events on first tap - the carousel\n      // would stop cycling until user tapped out of it;\n      // here, we listen for touchend, explicitly pause the carousel\n      // (as if it's the second time we tap on it, mouseenter compat event\n      // is NOT fired) and after a timeout (to allow for mouse compatibility\n      // events to fire) we explicitly restart cycling\n\n      this.pause();\n      if (this.touchTimeout) {\n        clearTimeout(this.touchTimeout);\n      }\n      this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);\n    };\n    const swipeConfig = {\n      leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),\n      rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),\n      endCallback: endCallBack\n    };\n    this._swipeHelper = new Swipe(this._element, swipeConfig);\n  }\n  _keydown(event) {\n    if (/input|textarea/i.test(event.target.tagName)) {\n      return;\n    }\n    const direction = KEY_TO_DIRECTION[event.key];\n    if (direction) {\n      event.preventDefault();\n      this._slide(this._directionToOrder(direction));\n    }\n  }\n  _getItemIndex(element) {\n    return this._getItems().indexOf(element);\n  }\n  _setActiveIndicatorElement(index) {\n    if (!this._indicatorsElement) {\n      return;\n    }\n    const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);\n    activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);\n    activeIndicator.removeAttribute('aria-current');\n    const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to=\"${index}\"]`, this._indicatorsElement);\n    if (newActiveIndicator) {\n      newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);\n      newActiveIndicator.setAttribute('aria-current', 'true');\n    }\n  }\n  _updateInterval() {\n    const element = this._activeElement || this._getActive();\n    if (!element) {\n      return;\n    }\n    const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);\n    this._config.interval = elementInterval || this._config.defaultInterval;\n  }\n  _slide(order, element = null) {\n    if (this._isSliding) {\n      return;\n    }\n    const activeElement = this._getActive();\n    const isNext = order === ORDER_NEXT;\n    const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);\n    if (nextElement === activeElement) {\n      return;\n    }\n    const nextElementIndex = this._getItemIndex(nextElement);\n    const triggerEvent = eventName => {\n      return EventHandler.trigger(this._element, eventName, {\n        relatedTarget: nextElement,\n        direction: this._orderToDirection(order),\n        from: this._getItemIndex(activeElement),\n        to: nextElementIndex\n      });\n    };\n    const slideEvent = triggerEvent(EVENT_SLIDE);\n    if (slideEvent.defaultPrevented) {\n      return;\n    }\n    if (!activeElement || !nextElement) {\n      // Some weirdness is happening, so we bail\n      // TODO: change tests that use empty divs to avoid this check\n      return;\n    }\n    const isCycling = Boolean(this._interval);\n    this.pause();\n    this._isSliding = true;\n    this._setActiveIndicatorElement(nextElementIndex);\n    this._activeElement = nextElement;\n    const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\n    const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\n    nextElement.classList.add(orderClassName);\n    reflow(nextElement);\n    activeElement.classList.add(directionalClassName);\n    nextElement.classList.add(directionalClassName);\n    const completeCallBack = () => {\n      nextElement.classList.remove(directionalClassName, orderClassName);\n      nextElement.classList.add(CLASS_NAME_ACTIVE$2);\n      activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);\n      this._isSliding = false;\n      triggerEvent(EVENT_SLID);\n    };\n    this._queueCallback(completeCallBack, activeElement, this._isAnimated());\n    if (isCycling) {\n      this.cycle();\n    }\n  }\n  _isAnimated() {\n    return this._element.classList.contains(CLASS_NAME_SLIDE);\n  }\n  _getActive() {\n    return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n  }\n  _getItems() {\n    return SelectorEngine.find(SELECTOR_ITEM, this._element);\n  }\n  _clearInterval() {\n    if (this._interval) {\n      clearInterval(this._interval);\n      this._interval = null;\n    }\n  }\n  _directionToOrder(direction) {\n    if (isRTL()) {\n      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\n    }\n    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\n  }\n  _orderToDirection(order) {\n    if (isRTL()) {\n      return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Carousel.getOrCreateInstance(this, config);\n      if (typeof config === 'number') {\n        data.to(config);\n        return;\n      }\n      if (typeof config === 'string') {\n        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n        data[config]();\n      }\n    });\n  }\n}\n\n/**\n * Data API implementation\n */\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function (event) {\n  const target = SelectorEngine.getElementFromSelector(this);\n  if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\n    return;\n  }\n  event.preventDefault();\n  const carousel = Carousel.getOrCreateInstance(target);\n  const slideIndex = this.getAttribute('data-bs-slide-to');\n  if (slideIndex) {\n    carousel.to(slideIndex);\n    carousel._maybeEnableCycle();\n    return;\n  }\n  if (Manipulator.getDataAttribute(this, 'slide') === 'next') {\n    carousel.next();\n    carousel._maybeEnableCycle();\n    return;\n  }\n  carousel.prev();\n  carousel._maybeEnableCycle();\n});\nEventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {\n  const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);\n  for (const carousel of carousels) {\n    Carousel.getOrCreateInstance(carousel);\n  }\n});\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Carousel);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap collapse.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$b = 'collapse';\nconst DATA_KEY$7 = 'bs.collapse';\nconst EVENT_KEY$7 = `.${DATA_KEY$7}`;\nconst DATA_API_KEY$4 = '.data-api';\nconst EVENT_SHOW$6 = `show${EVENT_KEY$7}`;\nconst EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;\nconst EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;\nconst EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;\nconst EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;\nconst CLASS_NAME_SHOW$7 = 'show';\nconst CLASS_NAME_COLLAPSE = 'collapse';\nconst CLASS_NAME_COLLAPSING = 'collapsing';\nconst CLASS_NAME_COLLAPSED = 'collapsed';\nconst CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;\nconst CLASS_NAME_HORIZONTAL = 'collapse-horizontal';\nconst WIDTH = 'width';\nconst HEIGHT = 'height';\nconst SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';\nconst SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle=\"collapse\"]';\nconst Default$a = {\n  parent: null,\n  toggle: true\n};\nconst DefaultType$a = {\n  parent: '(null|element)',\n  toggle: 'boolean'\n};\n\n/**\n * Class definition\n */\n\nclass Collapse extends BaseComponent {\n  constructor(element, config) {\n    super(element, config);\n    this._isTransitioning = false;\n    this._triggerArray = [];\n    const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);\n    for (const elem of toggleList) {\n      const selector = SelectorEngine.getSelectorFromElement(elem);\n      const filterElement = SelectorEngine.find(selector).filter(foundElement => foundElement === this._element);\n      if (selector !== null && filterElement.length) {\n        this._triggerArray.push(elem);\n      }\n    }\n    this._initializeChildren();\n    if (!this._config.parent) {\n      this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());\n    }\n    if (this._config.toggle) {\n      this.toggle();\n    }\n  }\n\n  // Getters\n  static get Default() {\n    return Default$a;\n  }\n  static get DefaultType() {\n    return DefaultType$a;\n  }\n  static get NAME() {\n    return NAME$b;\n  }\n\n  // Public\n  toggle() {\n    if (this._isShown()) {\n      this.hide();\n    } else {\n      this.show();\n    }\n  }\n  show() {\n    if (this._isTransitioning || this._isShown()) {\n      return;\n    }\n    let activeChildren = [];\n\n    // find active children\n    if (this._config.parent) {\n      activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter(element => element !== this._element).map(element => Collapse.getOrCreateInstance(element, {\n        toggle: false\n      }));\n    }\n    if (activeChildren.length && activeChildren[0]._isTransitioning) {\n      return;\n    }\n    const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);\n    if (startEvent.defaultPrevented) {\n      return;\n    }\n    for (const activeInstance of activeChildren) {\n      activeInstance.hide();\n    }\n    const dimension = this._getDimension();\n    this._element.classList.remove(CLASS_NAME_COLLAPSE);\n    this._element.classList.add(CLASS_NAME_COLLAPSING);\n    this._element.style[dimension] = 0;\n    this._addAriaAndCollapsedClass(this._triggerArray, true);\n    this._isTransitioning = true;\n    const complete = () => {\n      this._isTransitioning = false;\n      this._element.classList.remove(CLASS_NAME_COLLAPSING);\n      this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n      this._element.style[dimension] = '';\n      EventHandler.trigger(this._element, EVENT_SHOWN$6);\n    };\n    const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n    const scrollSize = `scroll${capitalizedDimension}`;\n    this._queueCallback(complete, this._element, true);\n    this._element.style[dimension] = `${this._element[scrollSize]}px`;\n  }\n  hide() {\n    if (this._isTransitioning || !this._isShown()) {\n      return;\n    }\n    const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);\n    if (startEvent.defaultPrevented) {\n      return;\n    }\n    const dimension = this._getDimension();\n    this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;\n    reflow(this._element);\n    this._element.classList.add(CLASS_NAME_COLLAPSING);\n    this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n    for (const trigger of this._triggerArray) {\n      const element = SelectorEngine.getElementFromSelector(trigger);\n      if (element && !this._isShown(element)) {\n        this._addAriaAndCollapsedClass([trigger], false);\n      }\n    }\n    this._isTransitioning = true;\n    const complete = () => {\n      this._isTransitioning = false;\n      this._element.classList.remove(CLASS_NAME_COLLAPSING);\n      this._element.classList.add(CLASS_NAME_COLLAPSE);\n      EventHandler.trigger(this._element, EVENT_HIDDEN$6);\n    };\n    this._element.style[dimension] = '';\n    this._queueCallback(complete, this._element, true);\n  }\n\n  // Private\n  _isShown(element = this._element) {\n    return element.classList.contains(CLASS_NAME_SHOW$7);\n  }\n  _configAfterMerge(config) {\n    config.toggle = Boolean(config.toggle); // Coerce string values\n    config.parent = getElement(config.parent);\n    return config;\n  }\n  _getDimension() {\n    return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;\n  }\n  _initializeChildren() {\n    if (!this._config.parent) {\n      return;\n    }\n    const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);\n    for (const element of children) {\n      const selected = SelectorEngine.getElementFromSelector(element);\n      if (selected) {\n        this._addAriaAndCollapsedClass([element], this._isShown(selected));\n      }\n    }\n  }\n  _getFirstLevelChildren(selector) {\n    const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);\n    // remove children if greater depth\n    return SelectorEngine.find(selector, this._config.parent).filter(element => !children.includes(element));\n  }\n  _addAriaAndCollapsedClass(triggerArray, isOpen) {\n    if (!triggerArray.length) {\n      return;\n    }\n    for (const element of triggerArray) {\n      element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);\n      element.setAttribute('aria-expanded', isOpen);\n    }\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    const _config = {};\n    if (typeof config === 'string' && /show|hide/.test(config)) {\n      _config.toggle = false;\n    }\n    return this.each(function () {\n      const data = Collapse.getOrCreateInstance(this, _config);\n      if (typeof config === 'string') {\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n        data[config]();\n      }\n    });\n  }\n}\n\n/**\n * Data API implementation\n */\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {\n  // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n  if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {\n    event.preventDefault();\n  }\n  for (const element of SelectorEngine.getMultipleElementsFromSelector(this)) {\n    Collapse.getOrCreateInstance(element, {\n      toggle: false\n    }).toggle();\n  }\n});\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Collapse);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap dropdown.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$a = 'dropdown';\nconst DATA_KEY$6 = 'bs.dropdown';\nconst EVENT_KEY$6 = `.${DATA_KEY$6}`;\nconst DATA_API_KEY$3 = '.data-api';\nconst ESCAPE_KEY$2 = 'Escape';\nconst TAB_KEY$1 = 'Tab';\nconst ARROW_UP_KEY$1 = 'ArrowUp';\nconst ARROW_DOWN_KEY$1 = 'ArrowDown';\nconst RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button\n\nconst EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;\nconst EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;\nconst EVENT_SHOW$5 = `show${EVENT_KEY$6}`;\nconst EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;\nconst EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;\nconst EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;\nconst EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;\nconst CLASS_NAME_SHOW$6 = 'show';\nconst CLASS_NAME_DROPUP = 'dropup';\nconst CLASS_NAME_DROPEND = 'dropend';\nconst CLASS_NAME_DROPSTART = 'dropstart';\nconst CLASS_NAME_DROPUP_CENTER = 'dropup-center';\nconst CLASS_NAME_DROPDOWN_CENTER = 'dropdown-center';\nconst SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle=\"dropdown\"]:not(.disabled):not(:disabled)';\nconst SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;\nconst SELECTOR_MENU = '.dropdown-menu';\nconst SELECTOR_NAVBAR = '.navbar';\nconst SELECTOR_NAVBAR_NAV = '.navbar-nav';\nconst SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';\nconst PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';\nconst PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';\nconst PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';\nconst PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';\nconst PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';\nconst PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';\nconst PLACEMENT_TOPCENTER = 'top';\nconst PLACEMENT_BOTTOMCENTER = 'bottom';\nconst Default$9 = {\n  autoClose: true,\n  boundary: 'clippingParents',\n  display: 'dynamic',\n  offset: [0, 2],\n  popperConfig: null,\n  reference: 'toggle'\n};\nconst DefaultType$9 = {\n  autoClose: '(boolean|string)',\n  boundary: '(string|element)',\n  display: 'string',\n  offset: '(array|string|function)',\n  popperConfig: '(null|object|function)',\n  reference: '(string|element|object)'\n};\n\n/**\n * Class definition\n */\n\nclass Dropdown extends BaseComponent {\n  constructor(element, config) {\n    super(element, config);\n    this._popper = null;\n    this._parent = this._element.parentNode; // dropdown wrapper\n    // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/\n    this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);\n    this._inNavbar = this._detectNavbar();\n  }\n\n  // Getters\n  static get Default() {\n    return Default$9;\n  }\n  static get DefaultType() {\n    return DefaultType$9;\n  }\n  static get NAME() {\n    return NAME$a;\n  }\n\n  // Public\n  toggle() {\n    return this._isShown() ? this.hide() : this.show();\n  }\n  show() {\n    if (isDisabled(this._element) || this._isShown()) {\n      return;\n    }\n    const relatedTarget = {\n      relatedTarget: this._element\n    };\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);\n    if (showEvent.defaultPrevented) {\n      return;\n    }\n    this._createPopper();\n\n    // If this is a touch-enabled device we add extra\n    // empty mouseover listeners to the body's immediate children;\n    // only needed because of broken event delegation on iOS\n    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n    if ('ontouchstart' in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {\n      for (const element of [].concat(...document.body.children)) {\n        EventHandler.on(element, 'mouseover', noop);\n      }\n    }\n    this._element.focus();\n    this._element.setAttribute('aria-expanded', true);\n    this._menu.classList.add(CLASS_NAME_SHOW$6);\n    this._element.classList.add(CLASS_NAME_SHOW$6);\n    EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);\n  }\n  hide() {\n    if (isDisabled(this._element) || !this._isShown()) {\n      return;\n    }\n    const relatedTarget = {\n      relatedTarget: this._element\n    };\n    this._completeHide(relatedTarget);\n  }\n  dispose() {\n    if (this._popper) {\n      this._popper.destroy();\n    }\n    super.dispose();\n  }\n  update() {\n    this._inNavbar = this._detectNavbar();\n    if (this._popper) {\n      this._popper.update();\n    }\n  }\n\n  // Private\n  _completeHide(relatedTarget) {\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n\n    // If this is a touch-enabled device we remove the extra\n    // empty mouseover listeners we added for iOS support\n    if ('ontouchstart' in document.documentElement) {\n      for (const element of [].concat(...document.body.children)) {\n        EventHandler.off(element, 'mouseover', noop);\n      }\n    }\n    if (this._popper) {\n      this._popper.destroy();\n    }\n    this._menu.classList.remove(CLASS_NAME_SHOW$6);\n    this._element.classList.remove(CLASS_NAME_SHOW$6);\n    this._element.setAttribute('aria-expanded', 'false');\n    Manipulator.removeDataAttribute(this._menu, 'popper');\n    EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);\n\n    // Explicitly return focus to the trigger element\n    this._element.focus();\n  }\n  _getConfig(config) {\n    config = super._getConfig(config);\n    if (typeof config.reference === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {\n      // Popper virtual elements require a getBoundingClientRect method\n      throw new TypeError(`${NAME$a.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`);\n    }\n    return config;\n  }\n  _createPopper() {\n    if (typeof _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ === 'undefined') {\n      throw new TypeError('Bootstrap\\'s dropdowns require Popper (https://popper.js.org/docs/v2/)');\n    }\n    let referenceElement = this._element;\n    if (this._config.reference === 'parent') {\n      referenceElement = this._parent;\n    } else if (isElement(this._config.reference)) {\n      referenceElement = getElement(this._config.reference);\n    } else if (typeof this._config.reference === 'object') {\n      referenceElement = this._config.reference;\n    }\n    const popperConfig = this._getPopperConfig();\n    this._popper = _popperjs_core__WEBPACK_IMPORTED_MODULE_1__.createPopper(referenceElement, this._menu, popperConfig);\n  }\n  _isShown() {\n    return this._menu.classList.contains(CLASS_NAME_SHOW$6);\n  }\n  _getPlacement() {\n    const parentDropdown = this._parent;\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {\n      return PLACEMENT_RIGHT;\n    }\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {\n      return PLACEMENT_LEFT;\n    }\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {\n      return PLACEMENT_TOPCENTER;\n    }\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {\n      return PLACEMENT_BOTTOMCENTER;\n    }\n\n    // We need to trim the value because custom properties can also include spaces\n    const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {\n      return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n    }\n    return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\n  }\n  _detectNavbar() {\n    return this._element.closest(SELECTOR_NAVBAR) !== null;\n  }\n  _getOffset() {\n    const {\n      offset\n    } = this._config;\n    if (typeof offset === 'string') {\n      return offset.split(',').map(value => Number.parseInt(value, 10));\n    }\n    if (typeof offset === 'function') {\n      return popperData => offset(popperData, this._element);\n    }\n    return offset;\n  }\n  _getPopperConfig() {\n    const defaultBsPopperConfig = {\n      placement: this._getPlacement(),\n      modifiers: [{\n        name: 'preventOverflow',\n        options: {\n          boundary: this._config.boundary\n        }\n      }, {\n        name: 'offset',\n        options: {\n          offset: this._getOffset()\n        }\n      }]\n    };\n\n    // Disable Popper if we have a static display or Dropdown is in Navbar\n    if (this._inNavbar || this._config.display === 'static') {\n      Manipulator.setDataAttribute(this._menu, 'popper', 'static'); // TODO: v6 remove\n      defaultBsPopperConfig.modifiers = [{\n        name: 'applyStyles',\n        enabled: false\n      }];\n    }\n    return {\n      ...defaultBsPopperConfig,\n      ...execute(this._config.popperConfig, [undefined, defaultBsPopperConfig])\n    };\n  }\n  _selectMenuItem({\n    key,\n    target\n  }) {\n    const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(element => isVisible(element));\n    if (!items.length) {\n      return;\n    }\n\n    // if target isn't included in items (e.g. when expanding the dropdown)\n    // allow cycling to get the last item in case key equals ARROW_UP_KEY\n    getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Dropdown.getOrCreateInstance(this, config);\n      if (typeof config !== 'string') {\n        return;\n      }\n      if (typeof data[config] === 'undefined') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config]();\n    });\n  }\n  static clearMenus(event) {\n    if (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1) {\n      return;\n    }\n    const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);\n    for (const toggle of openToggles) {\n      const context = Dropdown.getInstance(toggle);\n      if (!context || context._config.autoClose === false) {\n        continue;\n      }\n      const composedPath = event.composedPath();\n      const isMenuTarget = composedPath.includes(context._menu);\n      if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {\n        continue;\n      }\n\n      // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu\n      if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {\n        continue;\n      }\n      const relatedTarget = {\n        relatedTarget: context._element\n      };\n      if (event.type === 'click') {\n        relatedTarget.clickEvent = event;\n      }\n      context._completeHide(relatedTarget);\n    }\n  }\n  static dataApiKeydownHandler(event) {\n    // If not an UP | DOWN | ESCAPE key => not a dropdown command\n    // If input/textarea && if key is other than ESCAPE => not a dropdown command\n\n    const isInput = /input|textarea/i.test(event.target.tagName);\n    const isEscapeEvent = event.key === ESCAPE_KEY$2;\n    const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);\n    if (!isUpOrDownEvent && !isEscapeEvent) {\n      return;\n    }\n    if (isInput && !isEscapeEvent) {\n      return;\n    }\n    event.preventDefault();\n\n    // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/\n    const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);\n    const instance = Dropdown.getOrCreateInstance(getToggleButton);\n    if (isUpOrDownEvent) {\n      event.stopPropagation();\n      instance.show();\n      instance._selectMenuItem(event);\n      return;\n    }\n    if (instance._isShown()) {\n      // else is escape and we check if it is shown\n      event.stopPropagation();\n      instance.hide();\n      getToggleButton.focus();\n    }\n  }\n}\n\n/**\n * Data API implementation\n */\n\nEventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);\nEventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);\nEventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);\nEventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);\nEventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {\n  event.preventDefault();\n  Dropdown.getOrCreateInstance(this).toggle();\n});\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Dropdown);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/backdrop.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$9 = 'backdrop';\nconst CLASS_NAME_FADE$4 = 'fade';\nconst CLASS_NAME_SHOW$5 = 'show';\nconst EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;\nconst Default$8 = {\n  className: 'modal-backdrop',\n  clickCallback: null,\n  isAnimated: false,\n  isVisible: true,\n  // if false, we use the backdrop helper without adding any element to the dom\n  rootElement: 'body' // give the choice to place backdrop under different elements\n};\nconst DefaultType$8 = {\n  className: 'string',\n  clickCallback: '(function|null)',\n  isAnimated: 'boolean',\n  isVisible: 'boolean',\n  rootElement: '(element|string)'\n};\n\n/**\n * Class definition\n */\n\nclass Backdrop extends Config {\n  constructor(config) {\n    super();\n    this._config = this._getConfig(config);\n    this._isAppended = false;\n    this._element = null;\n  }\n\n  // Getters\n  static get Default() {\n    return Default$8;\n  }\n  static get DefaultType() {\n    return DefaultType$8;\n  }\n  static get NAME() {\n    return NAME$9;\n  }\n\n  // Public\n  show(callback) {\n    if (!this._config.isVisible) {\n      execute(callback);\n      return;\n    }\n    this._append();\n    const element = this._getElement();\n    if (this._config.isAnimated) {\n      reflow(element);\n    }\n    element.classList.add(CLASS_NAME_SHOW$5);\n    this._emulateAnimation(() => {\n      execute(callback);\n    });\n  }\n  hide(callback) {\n    if (!this._config.isVisible) {\n      execute(callback);\n      return;\n    }\n    this._getElement().classList.remove(CLASS_NAME_SHOW$5);\n    this._emulateAnimation(() => {\n      this.dispose();\n      execute(callback);\n    });\n  }\n  dispose() {\n    if (!this._isAppended) {\n      return;\n    }\n    EventHandler.off(this._element, EVENT_MOUSEDOWN);\n    this._element.remove();\n    this._isAppended = false;\n  }\n\n  // Private\n  _getElement() {\n    if (!this._element) {\n      const backdrop = document.createElement('div');\n      backdrop.className = this._config.className;\n      if (this._config.isAnimated) {\n        backdrop.classList.add(CLASS_NAME_FADE$4);\n      }\n      this._element = backdrop;\n    }\n    return this._element;\n  }\n  _configAfterMerge(config) {\n    // use getElement() with the default \"body\" to get a fresh Element on each instantiation\n    config.rootElement = getElement(config.rootElement);\n    return config;\n  }\n  _append() {\n    if (this._isAppended) {\n      return;\n    }\n    const element = this._getElement();\n    this._config.rootElement.append(element);\n    EventHandler.on(element, EVENT_MOUSEDOWN, () => {\n      execute(this._config.clickCallback);\n    });\n    this._isAppended = true;\n  }\n  _emulateAnimation(callback) {\n    executeAfterTransition(callback, this._getElement(), this._config.isAnimated);\n  }\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/focustrap.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$8 = 'focustrap';\nconst DATA_KEY$5 = 'bs.focustrap';\nconst EVENT_KEY$5 = `.${DATA_KEY$5}`;\nconst EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;\nconst EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;\nconst TAB_KEY = 'Tab';\nconst TAB_NAV_FORWARD = 'forward';\nconst TAB_NAV_BACKWARD = 'backward';\nconst Default$7 = {\n  autofocus: true,\n  trapElement: null // The element to trap focus inside of\n};\nconst DefaultType$7 = {\n  autofocus: 'boolean',\n  trapElement: 'element'\n};\n\n/**\n * Class definition\n */\n\nclass FocusTrap extends Config {\n  constructor(config) {\n    super();\n    this._config = this._getConfig(config);\n    this._isActive = false;\n    this._lastTabNavDirection = null;\n  }\n\n  // Getters\n  static get Default() {\n    return Default$7;\n  }\n  static get DefaultType() {\n    return DefaultType$7;\n  }\n  static get NAME() {\n    return NAME$8;\n  }\n\n  // Public\n  activate() {\n    if (this._isActive) {\n      return;\n    }\n    if (this._config.autofocus) {\n      this._config.trapElement.focus();\n    }\n    EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop\n    EventHandler.on(document, EVENT_FOCUSIN$2, event => this._handleFocusin(event));\n    EventHandler.on(document, EVENT_KEYDOWN_TAB, event => this._handleKeydown(event));\n    this._isActive = true;\n  }\n  deactivate() {\n    if (!this._isActive) {\n      return;\n    }\n    this._isActive = false;\n    EventHandler.off(document, EVENT_KEY$5);\n  }\n\n  // Private\n  _handleFocusin(event) {\n    const {\n      trapElement\n    } = this._config;\n    if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {\n      return;\n    }\n    const elements = SelectorEngine.focusableChildren(trapElement);\n    if (elements.length === 0) {\n      trapElement.focus();\n    } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {\n      elements[elements.length - 1].focus();\n    } else {\n      elements[0].focus();\n    }\n  }\n  _handleKeydown(event) {\n    if (event.key !== TAB_KEY) {\n      return;\n    }\n    this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;\n  }\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/scrollBar.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';\nconst SELECTOR_STICKY_CONTENT = '.sticky-top';\nconst PROPERTY_PADDING = 'padding-right';\nconst PROPERTY_MARGIN = 'margin-right';\n\n/**\n * Class definition\n */\n\nclass ScrollBarHelper {\n  constructor() {\n    this._element = document.body;\n  }\n\n  // Public\n  getWidth() {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\n    const documentWidth = document.documentElement.clientWidth;\n    return Math.abs(window.innerWidth - documentWidth);\n  }\n  hide() {\n    const width = this.getWidth();\n    this._disableOverFlow();\n    // give padding to element to balance the hidden scrollbar width\n    this._setElementAttributes(this._element, PROPERTY_PADDING, calculatedValue => calculatedValue + width);\n    // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth\n    this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, calculatedValue => calculatedValue + width);\n    this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, calculatedValue => calculatedValue - width);\n  }\n  reset() {\n    this._resetElementAttributes(this._element, 'overflow');\n    this._resetElementAttributes(this._element, PROPERTY_PADDING);\n    this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);\n    this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);\n  }\n  isOverflowing() {\n    return this.getWidth() > 0;\n  }\n\n  // Private\n  _disableOverFlow() {\n    this._saveInitialAttribute(this._element, 'overflow');\n    this._element.style.overflow = 'hidden';\n  }\n  _setElementAttributes(selector, styleProperty, callback) {\n    const scrollbarWidth = this.getWidth();\n    const manipulationCallBack = element => {\n      if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {\n        return;\n      }\n      this._saveInitialAttribute(element, styleProperty);\n      const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);\n      element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);\n    };\n    this._applyManipulationCallback(selector, manipulationCallBack);\n  }\n  _saveInitialAttribute(element, styleProperty) {\n    const actualValue = element.style.getPropertyValue(styleProperty);\n    if (actualValue) {\n      Manipulator.setDataAttribute(element, styleProperty, actualValue);\n    }\n  }\n  _resetElementAttributes(selector, styleProperty) {\n    const manipulationCallBack = element => {\n      const value = Manipulator.getDataAttribute(element, styleProperty);\n      // We only want to remove the property if the value is `null`; the value can also be zero\n      if (value === null) {\n        element.style.removeProperty(styleProperty);\n        return;\n      }\n      Manipulator.removeDataAttribute(element, styleProperty);\n      element.style.setProperty(styleProperty, value);\n    };\n    this._applyManipulationCallback(selector, manipulationCallBack);\n  }\n  _applyManipulationCallback(selector, callBack) {\n    if (isElement(selector)) {\n      callBack(selector);\n      return;\n    }\n    for (const sel of SelectorEngine.find(selector, this._element)) {\n      callBack(sel);\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap modal.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$7 = 'modal';\nconst DATA_KEY$4 = 'bs.modal';\nconst EVENT_KEY$4 = `.${DATA_KEY$4}`;\nconst DATA_API_KEY$2 = '.data-api';\nconst ESCAPE_KEY$1 = 'Escape';\nconst EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;\nconst EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;\nconst EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;\nconst EVENT_SHOW$4 = `show${EVENT_KEY$4}`;\nconst EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;\nconst EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;\nconst EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;\nconst EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;\nconst EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;\nconst EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;\nconst CLASS_NAME_OPEN = 'modal-open';\nconst CLASS_NAME_FADE$3 = 'fade';\nconst CLASS_NAME_SHOW$4 = 'show';\nconst CLASS_NAME_STATIC = 'modal-static';\nconst OPEN_SELECTOR$1 = '.modal.show';\nconst SELECTOR_DIALOG = '.modal-dialog';\nconst SELECTOR_MODAL_BODY = '.modal-body';\nconst SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle=\"modal\"]';\nconst Default$6 = {\n  backdrop: true,\n  focus: true,\n  keyboard: true\n};\nconst DefaultType$6 = {\n  backdrop: '(boolean|string)',\n  focus: 'boolean',\n  keyboard: 'boolean'\n};\n\n/**\n * Class definition\n */\n\nclass Modal extends BaseComponent {\n  constructor(element, config) {\n    super(element, config);\n    this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\n    this._backdrop = this._initializeBackDrop();\n    this._focustrap = this._initializeFocusTrap();\n    this._isShown = false;\n    this._isTransitioning = false;\n    this._scrollBar = new ScrollBarHelper();\n    this._addEventListeners();\n  }\n\n  // Getters\n  static get Default() {\n    return Default$6;\n  }\n  static get DefaultType() {\n    return DefaultType$6;\n  }\n  static get NAME() {\n    return NAME$7;\n  }\n\n  // Public\n  toggle(relatedTarget) {\n    return this._isShown ? this.hide() : this.show(relatedTarget);\n  }\n  show(relatedTarget) {\n    if (this._isShown || this._isTransitioning) {\n      return;\n    }\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {\n      relatedTarget\n    });\n    if (showEvent.defaultPrevented) {\n      return;\n    }\n    this._isShown = true;\n    this._isTransitioning = true;\n    this._scrollBar.hide();\n    document.body.classList.add(CLASS_NAME_OPEN);\n    this._adjustDialog();\n    this._backdrop.show(() => this._showElement(relatedTarget));\n  }\n  hide() {\n    if (!this._isShown || this._isTransitioning) {\n      return;\n    }\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n    this._isShown = false;\n    this._isTransitioning = true;\n    this._focustrap.deactivate();\n    this._element.classList.remove(CLASS_NAME_SHOW$4);\n    this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());\n  }\n  dispose() {\n    EventHandler.off(window, EVENT_KEY$4);\n    EventHandler.off(this._dialog, EVENT_KEY$4);\n    this._backdrop.dispose();\n    this._focustrap.deactivate();\n    super.dispose();\n  }\n  handleUpdate() {\n    this._adjustDialog();\n  }\n\n  // Private\n  _initializeBackDrop() {\n    return new Backdrop({\n      isVisible: Boolean(this._config.backdrop),\n      // 'static' option will be translated to true, and booleans will keep their value,\n      isAnimated: this._isAnimated()\n    });\n  }\n  _initializeFocusTrap() {\n    return new FocusTrap({\n      trapElement: this._element\n    });\n  }\n  _showElement(relatedTarget) {\n    // try to append dynamic modal\n    if (!document.body.contains(this._element)) {\n      document.body.append(this._element);\n    }\n    this._element.style.display = 'block';\n    this._element.removeAttribute('aria-hidden');\n    this._element.setAttribute('aria-modal', true);\n    this._element.setAttribute('role', 'dialog');\n    this._element.scrollTop = 0;\n    const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);\n    if (modalBody) {\n      modalBody.scrollTop = 0;\n    }\n    reflow(this._element);\n    this._element.classList.add(CLASS_NAME_SHOW$4);\n    const transitionComplete = () => {\n      if (this._config.focus) {\n        this._focustrap.activate();\n      }\n      this._isTransitioning = false;\n      EventHandler.trigger(this._element, EVENT_SHOWN$4, {\n        relatedTarget\n      });\n    };\n    this._queueCallback(transitionComplete, this._dialog, this._isAnimated());\n  }\n  _addEventListeners() {\n    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, event => {\n      if (event.key !== ESCAPE_KEY$1) {\n        return;\n      }\n      if (this._config.keyboard) {\n        this.hide();\n        return;\n      }\n      this._triggerBackdropTransition();\n    });\n    EventHandler.on(window, EVENT_RESIZE$1, () => {\n      if (this._isShown && !this._isTransitioning) {\n        this._adjustDialog();\n      }\n    });\n    EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, event => {\n      // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks\n      EventHandler.one(this._element, EVENT_CLICK_DISMISS, event2 => {\n        if (this._element !== event.target || this._element !== event2.target) {\n          return;\n        }\n        if (this._config.backdrop === 'static') {\n          this._triggerBackdropTransition();\n          return;\n        }\n        if (this._config.backdrop) {\n          this.hide();\n        }\n      });\n    });\n  }\n  _hideModal() {\n    this._element.style.display = 'none';\n    this._element.setAttribute('aria-hidden', true);\n    this._element.removeAttribute('aria-modal');\n    this._element.removeAttribute('role');\n    this._isTransitioning = false;\n    this._backdrop.hide(() => {\n      document.body.classList.remove(CLASS_NAME_OPEN);\n      this._resetAdjustments();\n      this._scrollBar.reset();\n      EventHandler.trigger(this._element, EVENT_HIDDEN$4);\n    });\n  }\n  _isAnimated() {\n    return this._element.classList.contains(CLASS_NAME_FADE$3);\n  }\n  _triggerBackdropTransition() {\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n    const initialOverflowY = this._element.style.overflowY;\n    // return if the following background transition hasn't yet completed\n    if (initialOverflowY === 'hidden' || this._element.classList.contains(CLASS_NAME_STATIC)) {\n      return;\n    }\n    if (!isModalOverflowing) {\n      this._element.style.overflowY = 'hidden';\n    }\n    this._element.classList.add(CLASS_NAME_STATIC);\n    this._queueCallback(() => {\n      this._element.classList.remove(CLASS_NAME_STATIC);\n      this._queueCallback(() => {\n        this._element.style.overflowY = initialOverflowY;\n      }, this._dialog);\n    }, this._dialog);\n    this._element.focus();\n  }\n\n  /**\n   * The following methods are used to handle overflowing modals\n   */\n\n  _adjustDialog() {\n    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n    const scrollbarWidth = this._scrollBar.getWidth();\n    const isBodyOverflowing = scrollbarWidth > 0;\n    if (isBodyOverflowing && !isModalOverflowing) {\n      const property = isRTL() ? 'paddingLeft' : 'paddingRight';\n      this._element.style[property] = `${scrollbarWidth}px`;\n    }\n    if (!isBodyOverflowing && isModalOverflowing) {\n      const property = isRTL() ? 'paddingRight' : 'paddingLeft';\n      this._element.style[property] = `${scrollbarWidth}px`;\n    }\n  }\n  _resetAdjustments() {\n    this._element.style.paddingLeft = '';\n    this._element.style.paddingRight = '';\n  }\n\n  // Static\n  static jQueryInterface(config, relatedTarget) {\n    return this.each(function () {\n      const data = Modal.getOrCreateInstance(this, config);\n      if (typeof config !== 'string') {\n        return;\n      }\n      if (typeof data[config] === 'undefined') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config](relatedTarget);\n    });\n  }\n}\n\n/**\n * Data API implementation\n */\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {\n  const target = SelectorEngine.getElementFromSelector(this);\n  if (['A', 'AREA'].includes(this.tagName)) {\n    event.preventDefault();\n  }\n  EventHandler.one(target, EVENT_SHOW$4, showEvent => {\n    if (showEvent.defaultPrevented) {\n      // only register focus restorer if modal will actually get shown\n      return;\n    }\n    EventHandler.one(target, EVENT_HIDDEN$4, () => {\n      if (isVisible(this)) {\n        this.focus();\n      }\n    });\n  });\n\n  // avoid conflict when clicking modal toggler while another one is open\n  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);\n  if (alreadyOpen) {\n    Modal.getInstance(alreadyOpen).hide();\n  }\n  const data = Modal.getOrCreateInstance(target);\n  data.toggle(this);\n});\nenableDismissTrigger(Modal);\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Modal);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap offcanvas.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$6 = 'offcanvas';\nconst DATA_KEY$3 = 'bs.offcanvas';\nconst EVENT_KEY$3 = `.${DATA_KEY$3}`;\nconst DATA_API_KEY$1 = '.data-api';\nconst EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;\nconst ESCAPE_KEY = 'Escape';\nconst CLASS_NAME_SHOW$3 = 'show';\nconst CLASS_NAME_SHOWING$1 = 'showing';\nconst CLASS_NAME_HIDING = 'hiding';\nconst CLASS_NAME_BACKDROP = 'offcanvas-backdrop';\nconst OPEN_SELECTOR = '.offcanvas.show';\nconst EVENT_SHOW$3 = `show${EVENT_KEY$3}`;\nconst EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;\nconst EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;\nconst EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;\nconst EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;\nconst EVENT_RESIZE = `resize${EVENT_KEY$3}`;\nconst EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;\nconst EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;\nconst SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle=\"offcanvas\"]';\nconst Default$5 = {\n  backdrop: true,\n  keyboard: true,\n  scroll: false\n};\nconst DefaultType$5 = {\n  backdrop: '(boolean|string)',\n  keyboard: 'boolean',\n  scroll: 'boolean'\n};\n\n/**\n * Class definition\n */\n\nclass Offcanvas extends BaseComponent {\n  constructor(element, config) {\n    super(element, config);\n    this._isShown = false;\n    this._backdrop = this._initializeBackDrop();\n    this._focustrap = this._initializeFocusTrap();\n    this._addEventListeners();\n  }\n\n  // Getters\n  static get Default() {\n    return Default$5;\n  }\n  static get DefaultType() {\n    return DefaultType$5;\n  }\n  static get NAME() {\n    return NAME$6;\n  }\n\n  // Public\n  toggle(relatedTarget) {\n    return this._isShown ? this.hide() : this.show(relatedTarget);\n  }\n  show(relatedTarget) {\n    if (this._isShown) {\n      return;\n    }\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {\n      relatedTarget\n    });\n    if (showEvent.defaultPrevented) {\n      return;\n    }\n    this._isShown = true;\n    this._backdrop.show();\n    if (!this._config.scroll) {\n      new ScrollBarHelper().hide();\n    }\n    this._element.setAttribute('aria-modal', true);\n    this._element.setAttribute('role', 'dialog');\n    this._element.classList.add(CLASS_NAME_SHOWING$1);\n    const completeCallBack = () => {\n      if (!this._config.scroll || this._config.backdrop) {\n        this._focustrap.activate();\n      }\n      this._element.classList.add(CLASS_NAME_SHOW$3);\n      this._element.classList.remove(CLASS_NAME_SHOWING$1);\n      EventHandler.trigger(this._element, EVENT_SHOWN$3, {\n        relatedTarget\n      });\n    };\n    this._queueCallback(completeCallBack, this._element, true);\n  }\n  hide() {\n    if (!this._isShown) {\n      return;\n    }\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n    this._focustrap.deactivate();\n    this._element.blur();\n    this._isShown = false;\n    this._element.classList.add(CLASS_NAME_HIDING);\n    this._backdrop.hide();\n    const completeCallback = () => {\n      this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);\n      this._element.removeAttribute('aria-modal');\n      this._element.removeAttribute('role');\n      if (!this._config.scroll) {\n        new ScrollBarHelper().reset();\n      }\n      EventHandler.trigger(this._element, EVENT_HIDDEN$3);\n    };\n    this._queueCallback(completeCallback, this._element, true);\n  }\n  dispose() {\n    this._backdrop.dispose();\n    this._focustrap.deactivate();\n    super.dispose();\n  }\n\n  // Private\n  _initializeBackDrop() {\n    const clickCallback = () => {\n      if (this._config.backdrop === 'static') {\n        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n        return;\n      }\n      this.hide();\n    };\n\n    // 'static' option will be translated to true, and booleans will keep their value\n    const isVisible = Boolean(this._config.backdrop);\n    return new Backdrop({\n      className: CLASS_NAME_BACKDROP,\n      isVisible,\n      isAnimated: true,\n      rootElement: this._element.parentNode,\n      clickCallback: isVisible ? clickCallback : null\n    });\n  }\n  _initializeFocusTrap() {\n    return new FocusTrap({\n      trapElement: this._element\n    });\n  }\n  _addEventListeners() {\n    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {\n      if (event.key !== ESCAPE_KEY) {\n        return;\n      }\n      if (this._config.keyboard) {\n        this.hide();\n        return;\n      }\n      EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n    });\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Offcanvas.getOrCreateInstance(this, config);\n      if (typeof config !== 'string') {\n        return;\n      }\n      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config](this);\n    });\n  }\n}\n\n/**\n * Data API implementation\n */\n\nEventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {\n  const target = SelectorEngine.getElementFromSelector(this);\n  if (['A', 'AREA'].includes(this.tagName)) {\n    event.preventDefault();\n  }\n  if (isDisabled(this)) {\n    return;\n  }\n  EventHandler.one(target, EVENT_HIDDEN$3, () => {\n    // focus on trigger when it is closed\n    if (isVisible(this)) {\n      this.focus();\n    }\n  });\n\n  // avoid conflict when clicking a toggler of an offcanvas, while another is open\n  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);\n  if (alreadyOpen && alreadyOpen !== target) {\n    Offcanvas.getInstance(alreadyOpen).hide();\n  }\n  const data = Offcanvas.getOrCreateInstance(target);\n  data.toggle(this);\n});\nEventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {\n  for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {\n    Offcanvas.getOrCreateInstance(selector).show();\n  }\n});\nEventHandler.on(window, EVENT_RESIZE, () => {\n  for (const element of SelectorEngine.find('[aria-modal][class*=show][class*=offcanvas-]')) {\n    if (getComputedStyle(element).position !== 'fixed') {\n      Offcanvas.getOrCreateInstance(element).hide();\n    }\n  }\n});\nenableDismissTrigger(Offcanvas);\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Offcanvas);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/sanitizer.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n// js-docs-start allow-list\nconst ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\nconst DefaultAllowlist = {\n  // Global attributes allowed on any supplied element below.\n  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\n  a: ['target', 'href', 'title', 'rel'],\n  area: [],\n  b: [],\n  br: [],\n  col: [],\n  code: [],\n  dd: [],\n  div: [],\n  dl: [],\n  dt: [],\n  em: [],\n  hr: [],\n  h1: [],\n  h2: [],\n  h3: [],\n  h4: [],\n  h5: [],\n  h6: [],\n  i: [],\n  img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],\n  li: [],\n  ol: [],\n  p: [],\n  pre: [],\n  s: [],\n  small: [],\n  span: [],\n  sub: [],\n  sup: [],\n  strong: [],\n  u: [],\n  ul: []\n};\n// js-docs-end allow-list\n\nconst uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);\n\n/**\n * A pattern that recognizes URLs that are safe wrt. XSS in URL navigation\n * contexts.\n *\n * Shout-out to Angular https://github.com/angular/angular/blob/15.2.8/packages/core/src/sanitization/url_sanitizer.ts#L38\n */\nconst SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;\nconst allowedAttribute = (attribute, allowedAttributeList) => {\n  const attributeName = attribute.nodeName.toLowerCase();\n  if (allowedAttributeList.includes(attributeName)) {\n    if (uriAttributes.has(attributeName)) {\n      return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));\n    }\n    return true;\n  }\n\n  // Check if a regular expression validates the attribute.\n  return allowedAttributeList.filter(attributeRegex => attributeRegex instanceof RegExp).some(regex => regex.test(attributeName));\n};\nfunction sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {\n  if (!unsafeHtml.length) {\n    return unsafeHtml;\n  }\n  if (sanitizeFunction && typeof sanitizeFunction === 'function') {\n    return sanitizeFunction(unsafeHtml);\n  }\n  const domParser = new window.DOMParser();\n  const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');\n  const elements = [].concat(...createdDocument.body.querySelectorAll('*'));\n  for (const element of elements) {\n    const elementName = element.nodeName.toLowerCase();\n    if (!Object.keys(allowList).includes(elementName)) {\n      element.remove();\n      continue;\n    }\n    const attributeList = [].concat(...element.attributes);\n    const allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);\n    for (const attribute of attributeList) {\n      if (!allowedAttribute(attribute, allowedAttributes)) {\n        element.removeAttribute(attribute.nodeName);\n      }\n    }\n  }\n  return createdDocument.body.innerHTML;\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap util/template-factory.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$5 = 'TemplateFactory';\nconst Default$4 = {\n  allowList: DefaultAllowlist,\n  content: {},\n  // { selector : text ,  selector2 : text2 , }\n  extraClass: '',\n  html: false,\n  sanitize: true,\n  sanitizeFn: null,\n  template: '<div></div>'\n};\nconst DefaultType$4 = {\n  allowList: 'object',\n  content: 'object',\n  extraClass: '(string|function)',\n  html: 'boolean',\n  sanitize: 'boolean',\n  sanitizeFn: '(null|function)',\n  template: 'string'\n};\nconst DefaultContentType = {\n  entry: '(string|element|function|null)',\n  selector: '(string|element)'\n};\n\n/**\n * Class definition\n */\n\nclass TemplateFactory extends Config {\n  constructor(config) {\n    super();\n    this._config = this._getConfig(config);\n  }\n\n  // Getters\n  static get Default() {\n    return Default$4;\n  }\n  static get DefaultType() {\n    return DefaultType$4;\n  }\n  static get NAME() {\n    return NAME$5;\n  }\n\n  // Public\n  getContent() {\n    return Object.values(this._config.content).map(config => this._resolvePossibleFunction(config)).filter(Boolean);\n  }\n  hasContent() {\n    return this.getContent().length > 0;\n  }\n  changeContent(content) {\n    this._checkContent(content);\n    this._config.content = {\n      ...this._config.content,\n      ...content\n    };\n    return this;\n  }\n  toHtml() {\n    const templateWrapper = document.createElement('div');\n    templateWrapper.innerHTML = this._maybeSanitize(this._config.template);\n    for (const [selector, text] of Object.entries(this._config.content)) {\n      this._setContent(templateWrapper, text, selector);\n    }\n    const template = templateWrapper.children[0];\n    const extraClass = this._resolvePossibleFunction(this._config.extraClass);\n    if (extraClass) {\n      template.classList.add(...extraClass.split(' '));\n    }\n    return template;\n  }\n\n  // Private\n  _typeCheckConfig(config) {\n    super._typeCheckConfig(config);\n    this._checkContent(config.content);\n  }\n  _checkContent(arg) {\n    for (const [selector, content] of Object.entries(arg)) {\n      super._typeCheckConfig({\n        selector,\n        entry: content\n      }, DefaultContentType);\n    }\n  }\n  _setContent(template, content, selector) {\n    const templateElement = SelectorEngine.findOne(selector, template);\n    if (!templateElement) {\n      return;\n    }\n    content = this._resolvePossibleFunction(content);\n    if (!content) {\n      templateElement.remove();\n      return;\n    }\n    if (isElement(content)) {\n      this._putElementInTemplate(getElement(content), templateElement);\n      return;\n    }\n    if (this._config.html) {\n      templateElement.innerHTML = this._maybeSanitize(content);\n      return;\n    }\n    templateElement.textContent = content;\n  }\n  _maybeSanitize(arg) {\n    return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;\n  }\n  _resolvePossibleFunction(arg) {\n    return execute(arg, [undefined, this]);\n  }\n  _putElementInTemplate(element, templateElement) {\n    if (this._config.html) {\n      templateElement.innerHTML = '';\n      templateElement.append(element);\n      return;\n    }\n    templateElement.textContent = element.textContent;\n  }\n}\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap tooltip.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$4 = 'tooltip';\nconst DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);\nconst CLASS_NAME_FADE$2 = 'fade';\nconst CLASS_NAME_MODAL = 'modal';\nconst CLASS_NAME_SHOW$2 = 'show';\nconst SELECTOR_TOOLTIP_INNER = '.tooltip-inner';\nconst SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;\nconst EVENT_MODAL_HIDE = 'hide.bs.modal';\nconst TRIGGER_HOVER = 'hover';\nconst TRIGGER_FOCUS = 'focus';\nconst TRIGGER_CLICK = 'click';\nconst TRIGGER_MANUAL = 'manual';\nconst EVENT_HIDE$2 = 'hide';\nconst EVENT_HIDDEN$2 = 'hidden';\nconst EVENT_SHOW$2 = 'show';\nconst EVENT_SHOWN$2 = 'shown';\nconst EVENT_INSERTED = 'inserted';\nconst EVENT_CLICK$1 = 'click';\nconst EVENT_FOCUSIN$1 = 'focusin';\nconst EVENT_FOCUSOUT$1 = 'focusout';\nconst EVENT_MOUSEENTER = 'mouseenter';\nconst EVENT_MOUSELEAVE = 'mouseleave';\nconst AttachmentMap = {\n  AUTO: 'auto',\n  TOP: 'top',\n  RIGHT: isRTL() ? 'left' : 'right',\n  BOTTOM: 'bottom',\n  LEFT: isRTL() ? 'right' : 'left'\n};\nconst Default$3 = {\n  allowList: DefaultAllowlist,\n  animation: true,\n  boundary: 'clippingParents',\n  container: false,\n  customClass: '',\n  delay: 0,\n  fallbackPlacements: ['top', 'right', 'bottom', 'left'],\n  html: false,\n  offset: [0, 6],\n  placement: 'top',\n  popperConfig: null,\n  sanitize: true,\n  sanitizeFn: null,\n  selector: false,\n  template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"tooltip-arrow\"></div>' + '<div class=\"tooltip-inner\"></div>' + '</div>',\n  title: '',\n  trigger: 'hover focus'\n};\nconst DefaultType$3 = {\n  allowList: 'object',\n  animation: 'boolean',\n  boundary: '(string|element)',\n  container: '(string|element|boolean)',\n  customClass: '(string|function)',\n  delay: '(number|object)',\n  fallbackPlacements: 'array',\n  html: 'boolean',\n  offset: '(array|string|function)',\n  placement: '(string|function)',\n  popperConfig: '(null|object|function)',\n  sanitize: 'boolean',\n  sanitizeFn: '(null|function)',\n  selector: '(string|boolean)',\n  template: 'string',\n  title: '(string|element|function)',\n  trigger: 'string'\n};\n\n/**\n * Class definition\n */\n\nclass Tooltip extends BaseComponent {\n  constructor(element, config) {\n    if (typeof _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ === 'undefined') {\n      throw new TypeError('Bootstrap\\'s tooltips require Popper (https://popper.js.org/docs/v2/)');\n    }\n    super(element, config);\n\n    // Private\n    this._isEnabled = true;\n    this._timeout = 0;\n    this._isHovered = null;\n    this._activeTrigger = {};\n    this._popper = null;\n    this._templateFactory = null;\n    this._newContent = null;\n\n    // Protected\n    this.tip = null;\n    this._setListeners();\n    if (!this._config.selector) {\n      this._fixTitle();\n    }\n  }\n\n  // Getters\n  static get Default() {\n    return Default$3;\n  }\n  static get DefaultType() {\n    return DefaultType$3;\n  }\n  static get NAME() {\n    return NAME$4;\n  }\n\n  // Public\n  enable() {\n    this._isEnabled = true;\n  }\n  disable() {\n    this._isEnabled = false;\n  }\n  toggleEnabled() {\n    this._isEnabled = !this._isEnabled;\n  }\n  toggle() {\n    if (!this._isEnabled) {\n      return;\n    }\n    if (this._isShown()) {\n      this._leave();\n      return;\n    }\n    this._enter();\n  }\n  dispose() {\n    clearTimeout(this._timeout);\n    EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n    if (this._element.getAttribute('data-bs-original-title')) {\n      this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title'));\n    }\n    this._disposePopper();\n    super.dispose();\n  }\n  show() {\n    if (this._element.style.display === 'none') {\n      throw new Error('Please use show on visible elements');\n    }\n    if (!(this._isWithContent() && this._isEnabled)) {\n      return;\n    }\n    const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));\n    const shadowRoot = findShadowRoot(this._element);\n    const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);\n    if (showEvent.defaultPrevented || !isInTheDom) {\n      return;\n    }\n\n    // TODO: v6 remove this or make it optional\n    this._disposePopper();\n    const tip = this._getTipElement();\n    this._element.setAttribute('aria-describedby', tip.getAttribute('id'));\n    const {\n      container\n    } = this._config;\n    if (!this._element.ownerDocument.documentElement.contains(this.tip)) {\n      container.append(tip);\n      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));\n    }\n    this._popper = this._createPopper(tip);\n    tip.classList.add(CLASS_NAME_SHOW$2);\n\n    // If this is a touch-enabled device we add extra\n    // empty mouseover listeners to the body's immediate children;\n    // only needed because of broken event delegation on iOS\n    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n    if ('ontouchstart' in document.documentElement) {\n      for (const element of [].concat(...document.body.children)) {\n        EventHandler.on(element, 'mouseover', noop);\n      }\n    }\n    const complete = () => {\n      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));\n      if (this._isHovered === false) {\n        this._leave();\n      }\n      this._isHovered = false;\n    };\n    this._queueCallback(complete, this.tip, this._isAnimated());\n  }\n  hide() {\n    if (!this._isShown()) {\n      return;\n    }\n    const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n    const tip = this._getTipElement();\n    tip.classList.remove(CLASS_NAME_SHOW$2);\n\n    // If this is a touch-enabled device we remove the extra\n    // empty mouseover listeners we added for iOS support\n    if ('ontouchstart' in document.documentElement) {\n      for (const element of [].concat(...document.body.children)) {\n        EventHandler.off(element, 'mouseover', noop);\n      }\n    }\n    this._activeTrigger[TRIGGER_CLICK] = false;\n    this._activeTrigger[TRIGGER_FOCUS] = false;\n    this._activeTrigger[TRIGGER_HOVER] = false;\n    this._isHovered = null; // it is a trick to support manual triggering\n\n    const complete = () => {\n      if (this._isWithActiveTrigger()) {\n        return;\n      }\n      if (!this._isHovered) {\n        this._disposePopper();\n      }\n      this._element.removeAttribute('aria-describedby');\n      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));\n    };\n    this._queueCallback(complete, this.tip, this._isAnimated());\n  }\n  update() {\n    if (this._popper) {\n      this._popper.update();\n    }\n  }\n\n  // Protected\n  _isWithContent() {\n    return Boolean(this._getTitle());\n  }\n  _getTipElement() {\n    if (!this.tip) {\n      this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());\n    }\n    return this.tip;\n  }\n  _createTipElement(content) {\n    const tip = this._getTemplateFactory(content).toHtml();\n\n    // TODO: remove this check in v6\n    if (!tip) {\n      return null;\n    }\n    tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);\n    // TODO: v6 the following can be achieved with CSS only\n    tip.classList.add(`bs-${this.constructor.NAME}-auto`);\n    const tipId = getUID(this.constructor.NAME).toString();\n    tip.setAttribute('id', tipId);\n    if (this._isAnimated()) {\n      tip.classList.add(CLASS_NAME_FADE$2);\n    }\n    return tip;\n  }\n  setContent(content) {\n    this._newContent = content;\n    if (this._isShown()) {\n      this._disposePopper();\n      this.show();\n    }\n  }\n  _getTemplateFactory(content) {\n    if (this._templateFactory) {\n      this._templateFactory.changeContent(content);\n    } else {\n      this._templateFactory = new TemplateFactory({\n        ...this._config,\n        // the `content` var has to be after `this._config`\n        // to override config.content in case of popover\n        content,\n        extraClass: this._resolvePossibleFunction(this._config.customClass)\n      });\n    }\n    return this._templateFactory;\n  }\n  _getContentForTemplate() {\n    return {\n      [SELECTOR_TOOLTIP_INNER]: this._getTitle()\n    };\n  }\n  _getTitle() {\n    return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title');\n  }\n\n  // Private\n  _initializeOnDelegatedTarget(event) {\n    return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());\n  }\n  _isAnimated() {\n    return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);\n  }\n  _isShown() {\n    return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);\n  }\n  _createPopper(tip) {\n    const placement = execute(this._config.placement, [this, tip, this._element]);\n    const attachment = AttachmentMap[placement.toUpperCase()];\n    return _popperjs_core__WEBPACK_IMPORTED_MODULE_1__.createPopper(this._element, tip, this._getPopperConfig(attachment));\n  }\n  _getOffset() {\n    const {\n      offset\n    } = this._config;\n    if (typeof offset === 'string') {\n      return offset.split(',').map(value => Number.parseInt(value, 10));\n    }\n    if (typeof offset === 'function') {\n      return popperData => offset(popperData, this._element);\n    }\n    return offset;\n  }\n  _resolvePossibleFunction(arg) {\n    return execute(arg, [this._element, this._element]);\n  }\n  _getPopperConfig(attachment) {\n    const defaultBsPopperConfig = {\n      placement: attachment,\n      modifiers: [{\n        name: 'flip',\n        options: {\n          fallbackPlacements: this._config.fallbackPlacements\n        }\n      }, {\n        name: 'offset',\n        options: {\n          offset: this._getOffset()\n        }\n      }, {\n        name: 'preventOverflow',\n        options: {\n          boundary: this._config.boundary\n        }\n      }, {\n        name: 'arrow',\n        options: {\n          element: `.${this.constructor.NAME}-arrow`\n        }\n      }, {\n        name: 'preSetPlacement',\n        enabled: true,\n        phase: 'beforeMain',\n        fn: data => {\n          // Pre-set Popper's placement attribute in order to read the arrow sizes properly.\n          // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement\n          this._getTipElement().setAttribute('data-popper-placement', data.state.placement);\n        }\n      }]\n    };\n    return {\n      ...defaultBsPopperConfig,\n      ...execute(this._config.popperConfig, [undefined, defaultBsPopperConfig])\n    };\n  }\n  _setListeners() {\n    const triggers = this._config.trigger.split(' ');\n    for (const trigger of triggers) {\n      if (trigger === 'click') {\n        EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, event => {\n          const context = this._initializeOnDelegatedTarget(event);\n          context._activeTrigger[TRIGGER_CLICK] = !(context._isShown() && context._activeTrigger[TRIGGER_CLICK]);\n          context.toggle();\n        });\n      } else if (trigger !== TRIGGER_MANUAL) {\n        const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);\n        const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);\n        EventHandler.on(this._element, eventIn, this._config.selector, event => {\n          const context = this._initializeOnDelegatedTarget(event);\n          context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n          context._enter();\n        });\n        EventHandler.on(this._element, eventOut, this._config.selector, event => {\n          const context = this._initializeOnDelegatedTarget(event);\n          context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);\n          context._leave();\n        });\n      }\n    }\n    this._hideModalHandler = () => {\n      if (this._element) {\n        this.hide();\n      }\n    };\n    EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n  }\n  _fixTitle() {\n    const title = this._element.getAttribute('title');\n    if (!title) {\n      return;\n    }\n    if (!this._element.getAttribute('aria-label') && !this._element.textContent.trim()) {\n      this._element.setAttribute('aria-label', title);\n    }\n    this._element.setAttribute('data-bs-original-title', title); // DO NOT USE IT. Is only for backwards compatibility\n    this._element.removeAttribute('title');\n  }\n  _enter() {\n    if (this._isShown() || this._isHovered) {\n      this._isHovered = true;\n      return;\n    }\n    this._isHovered = true;\n    this._setTimeout(() => {\n      if (this._isHovered) {\n        this.show();\n      }\n    }, this._config.delay.show);\n  }\n  _leave() {\n    if (this._isWithActiveTrigger()) {\n      return;\n    }\n    this._isHovered = false;\n    this._setTimeout(() => {\n      if (!this._isHovered) {\n        this.hide();\n      }\n    }, this._config.delay.hide);\n  }\n  _setTimeout(handler, timeout) {\n    clearTimeout(this._timeout);\n    this._timeout = setTimeout(handler, timeout);\n  }\n  _isWithActiveTrigger() {\n    return Object.values(this._activeTrigger).includes(true);\n  }\n  _getConfig(config) {\n    const dataAttributes = Manipulator.getDataAttributes(this._element);\n    for (const dataAttribute of Object.keys(dataAttributes)) {\n      if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {\n        delete dataAttributes[dataAttribute];\n      }\n    }\n    config = {\n      ...dataAttributes,\n      ...(typeof config === 'object' && config ? config : {})\n    };\n    config = this._mergeConfigObj(config);\n    config = this._configAfterMerge(config);\n    this._typeCheckConfig(config);\n    return config;\n  }\n  _configAfterMerge(config) {\n    config.container = config.container === false ? document.body : getElement(config.container);\n    if (typeof config.delay === 'number') {\n      config.delay = {\n        show: config.delay,\n        hide: config.delay\n      };\n    }\n    if (typeof config.title === 'number') {\n      config.title = config.title.toString();\n    }\n    if (typeof config.content === 'number') {\n      config.content = config.content.toString();\n    }\n    return config;\n  }\n  _getDelegateConfig() {\n    const config = {};\n    for (const [key, value] of Object.entries(this._config)) {\n      if (this.constructor.Default[key] !== value) {\n        config[key] = value;\n      }\n    }\n    config.selector = false;\n    config.trigger = 'manual';\n\n    // In the future can be replaced with:\n    // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])\n    // `Object.fromEntries(keysWithDifferentValues)`\n    return config;\n  }\n  _disposePopper() {\n    if (this._popper) {\n      this._popper.destroy();\n      this._popper = null;\n    }\n    if (this.tip) {\n      this.tip.remove();\n      this.tip = null;\n    }\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Tooltip.getOrCreateInstance(this, config);\n      if (typeof config !== 'string') {\n        return;\n      }\n      if (typeof data[config] === 'undefined') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config]();\n    });\n  }\n}\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Tooltip);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap popover.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$3 = 'popover';\nconst SELECTOR_TITLE = '.popover-header';\nconst SELECTOR_CONTENT = '.popover-body';\nconst Default$2 = {\n  ...Tooltip.Default,\n  content: '',\n  offset: [0, 8],\n  placement: 'right',\n  template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"popover-arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div>' + '</div>',\n  trigger: 'click'\n};\nconst DefaultType$2 = {\n  ...Tooltip.DefaultType,\n  content: '(null|string|element|function)'\n};\n\n/**\n * Class definition\n */\n\nclass Popover extends Tooltip {\n  // Getters\n  static get Default() {\n    return Default$2;\n  }\n  static get DefaultType() {\n    return DefaultType$2;\n  }\n  static get NAME() {\n    return NAME$3;\n  }\n\n  // Overrides\n  _isWithContent() {\n    return this._getTitle() || this._getContent();\n  }\n\n  // Private\n  _getContentForTemplate() {\n    return {\n      [SELECTOR_TITLE]: this._getTitle(),\n      [SELECTOR_CONTENT]: this._getContent()\n    };\n  }\n  _getContent() {\n    return this._resolvePossibleFunction(this._config.content);\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Popover.getOrCreateInstance(this, config);\n      if (typeof config !== 'string') {\n        return;\n      }\n      if (typeof data[config] === 'undefined') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config]();\n    });\n  }\n}\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Popover);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap scrollspy.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$2 = 'scrollspy';\nconst DATA_KEY$2 = 'bs.scrollspy';\nconst EVENT_KEY$2 = `.${DATA_KEY$2}`;\nconst DATA_API_KEY = '.data-api';\nconst EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;\nconst EVENT_CLICK = `click${EVENT_KEY$2}`;\nconst EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;\nconst CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';\nconst CLASS_NAME_ACTIVE$1 = 'active';\nconst SELECTOR_DATA_SPY = '[data-bs-spy=\"scroll\"]';\nconst SELECTOR_TARGET_LINKS = '[href]';\nconst SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';\nconst SELECTOR_NAV_LINKS = '.nav-link';\nconst SELECTOR_NAV_ITEMS = '.nav-item';\nconst SELECTOR_LIST_ITEMS = '.list-group-item';\nconst SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;\nconst SELECTOR_DROPDOWN = '.dropdown';\nconst SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';\nconst Default$1 = {\n  offset: null,\n  // TODO: v6 @deprecated, keep it for backwards compatibility reasons\n  rootMargin: '0px 0px -25%',\n  smoothScroll: false,\n  target: null,\n  threshold: [0.1, 0.5, 1]\n};\nconst DefaultType$1 = {\n  offset: '(number|null)',\n  // TODO v6 @deprecated, keep it for backwards compatibility reasons\n  rootMargin: 'string',\n  smoothScroll: 'boolean',\n  target: 'element',\n  threshold: 'array'\n};\n\n/**\n * Class definition\n */\n\nclass ScrollSpy extends BaseComponent {\n  constructor(element, config) {\n    super(element, config);\n\n    // this._element is the observablesContainer and config.target the menu links wrapper\n    this._targetLinks = new Map();\n    this._observableSections = new Map();\n    this._rootElement = getComputedStyle(this._element).overflowY === 'visible' ? null : this._element;\n    this._activeTarget = null;\n    this._observer = null;\n    this._previousScrollData = {\n      visibleEntryTop: 0,\n      parentScrollTop: 0\n    };\n    this.refresh(); // initialize\n  }\n\n  // Getters\n  static get Default() {\n    return Default$1;\n  }\n  static get DefaultType() {\n    return DefaultType$1;\n  }\n  static get NAME() {\n    return NAME$2;\n  }\n\n  // Public\n  refresh() {\n    this._initializeTargetsAndObservables();\n    this._maybeEnableSmoothScroll();\n    if (this._observer) {\n      this._observer.disconnect();\n    } else {\n      this._observer = this._getNewObserver();\n    }\n    for (const section of this._observableSections.values()) {\n      this._observer.observe(section);\n    }\n  }\n  dispose() {\n    this._observer.disconnect();\n    super.dispose();\n  }\n\n  // Private\n  _configAfterMerge(config) {\n    // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case\n    config.target = getElement(config.target) || document.body;\n\n    // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only\n    config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;\n    if (typeof config.threshold === 'string') {\n      config.threshold = config.threshold.split(',').map(value => Number.parseFloat(value));\n    }\n    return config;\n  }\n  _maybeEnableSmoothScroll() {\n    if (!this._config.smoothScroll) {\n      return;\n    }\n\n    // unregister any previous listeners\n    EventHandler.off(this._config.target, EVENT_CLICK);\n    EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, event => {\n      const observableSection = this._observableSections.get(event.target.hash);\n      if (observableSection) {\n        event.preventDefault();\n        const root = this._rootElement || window;\n        const height = observableSection.offsetTop - this._element.offsetTop;\n        if (root.scrollTo) {\n          root.scrollTo({\n            top: height,\n            behavior: 'smooth'\n          });\n          return;\n        }\n\n        // Chrome 60 doesn't support `scrollTo`\n        root.scrollTop = height;\n      }\n    });\n  }\n  _getNewObserver() {\n    const options = {\n      root: this._rootElement,\n      threshold: this._config.threshold,\n      rootMargin: this._config.rootMargin\n    };\n    return new IntersectionObserver(entries => this._observerCallback(entries), options);\n  }\n\n  // The logic of selection\n  _observerCallback(entries) {\n    const targetElement = entry => this._targetLinks.get(`#${entry.target.id}`);\n    const activate = entry => {\n      this._previousScrollData.visibleEntryTop = entry.target.offsetTop;\n      this._process(targetElement(entry));\n    };\n    const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;\n    const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;\n    this._previousScrollData.parentScrollTop = parentScrollTop;\n    for (const entry of entries) {\n      if (!entry.isIntersecting) {\n        this._activeTarget = null;\n        this._clearActiveClass(targetElement(entry));\n        continue;\n      }\n      const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;\n      // if we are scrolling down, pick the bigger offsetTop\n      if (userScrollsDown && entryIsLowerThanPrevious) {\n        activate(entry);\n        // if parent isn't scrolled, let's keep the first visible item, breaking the iteration\n        if (!parentScrollTop) {\n          return;\n        }\n        continue;\n      }\n\n      // if we are scrolling up, pick the smallest offsetTop\n      if (!userScrollsDown && !entryIsLowerThanPrevious) {\n        activate(entry);\n      }\n    }\n  }\n  _initializeTargetsAndObservables() {\n    this._targetLinks = new Map();\n    this._observableSections = new Map();\n    const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);\n    for (const anchor of targetLinks) {\n      // ensure that the anchor has an id and is not disabled\n      if (!anchor.hash || isDisabled(anchor)) {\n        continue;\n      }\n      const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);\n\n      // ensure that the observableSection exists & is visible\n      if (isVisible(observableSection)) {\n        this._targetLinks.set(decodeURI(anchor.hash), anchor);\n        this._observableSections.set(anchor.hash, observableSection);\n      }\n    }\n  }\n  _process(target) {\n    if (this._activeTarget === target) {\n      return;\n    }\n    this._clearActiveClass(this._config.target);\n    this._activeTarget = target;\n    target.classList.add(CLASS_NAME_ACTIVE$1);\n    this._activateParents(target);\n    EventHandler.trigger(this._element, EVENT_ACTIVATE, {\n      relatedTarget: target\n    });\n  }\n  _activateParents(target) {\n    // Activate dropdown parents\n    if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {\n      SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);\n      return;\n    }\n    for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {\n      // Set triggered links parents as active\n      // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n      for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {\n        item.classList.add(CLASS_NAME_ACTIVE$1);\n      }\n    }\n  }\n  _clearActiveClass(parent) {\n    parent.classList.remove(CLASS_NAME_ACTIVE$1);\n    const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);\n    for (const node of activeNodes) {\n      node.classList.remove(CLASS_NAME_ACTIVE$1);\n    }\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = ScrollSpy.getOrCreateInstance(this, config);\n      if (typeof config !== 'string') {\n        return;\n      }\n      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config]();\n    });\n  }\n}\n\n/**\n * Data API implementation\n */\n\nEventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {\n  for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {\n    ScrollSpy.getOrCreateInstance(spy);\n  }\n});\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(ScrollSpy);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap tab.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME$1 = 'tab';\nconst DATA_KEY$1 = 'bs.tab';\nconst EVENT_KEY$1 = `.${DATA_KEY$1}`;\nconst EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;\nconst EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;\nconst EVENT_SHOW$1 = `show${EVENT_KEY$1}`;\nconst EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;\nconst EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;\nconst EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;\nconst EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;\nconst ARROW_LEFT_KEY = 'ArrowLeft';\nconst ARROW_RIGHT_KEY = 'ArrowRight';\nconst ARROW_UP_KEY = 'ArrowUp';\nconst ARROW_DOWN_KEY = 'ArrowDown';\nconst HOME_KEY = 'Home';\nconst END_KEY = 'End';\nconst CLASS_NAME_ACTIVE = 'active';\nconst CLASS_NAME_FADE$1 = 'fade';\nconst CLASS_NAME_SHOW$1 = 'show';\nconst CLASS_DROPDOWN = 'dropdown';\nconst SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';\nconst SELECTOR_DROPDOWN_MENU = '.dropdown-menu';\nconst NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;\nconst SELECTOR_TAB_PANEL = '.list-group, .nav, [role=\"tablist\"]';\nconst SELECTOR_OUTER = '.nav-item, .list-group-item';\nconst SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role=\"tab\"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;\nconst SELECTOR_DATA_TOGGLE = '[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]'; // TODO: could only be `tab` in v6\nconst SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;\nconst SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle=\"tab\"], .${CLASS_NAME_ACTIVE}[data-bs-toggle=\"pill\"], .${CLASS_NAME_ACTIVE}[data-bs-toggle=\"list\"]`;\n\n/**\n * Class definition\n */\n\nclass Tab extends BaseComponent {\n  constructor(element) {\n    super(element);\n    this._parent = this._element.closest(SELECTOR_TAB_PANEL);\n    if (!this._parent) {\n      return;\n      // TODO: should throw exception in v6\n      // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)\n    }\n\n    // Set up initial aria attributes\n    this._setInitialAttributes(this._parent, this._getChildren());\n    EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event));\n  }\n\n  // Getters\n  static get NAME() {\n    return NAME$1;\n  }\n\n  // Public\n  show() {\n    // Shows this elem and deactivate the active sibling if exists\n    const innerElem = this._element;\n    if (this._elemIsActive(innerElem)) {\n      return;\n    }\n\n    // Search for active tab on same parent to deactivate it\n    const active = this._getActiveElem();\n    const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {\n      relatedTarget: innerElem\n    }) : null;\n    const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {\n      relatedTarget: active\n    });\n    if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {\n      return;\n    }\n    this._deactivate(active, innerElem);\n    this._activate(innerElem, active);\n  }\n\n  // Private\n  _activate(element, relatedElem) {\n    if (!element) {\n      return;\n    }\n    element.classList.add(CLASS_NAME_ACTIVE);\n    this._activate(SelectorEngine.getElementFromSelector(element)); // Search and activate/show the proper section\n\n    const complete = () => {\n      if (element.getAttribute('role') !== 'tab') {\n        element.classList.add(CLASS_NAME_SHOW$1);\n        return;\n      }\n      element.removeAttribute('tabindex');\n      element.setAttribute('aria-selected', true);\n      this._toggleDropDown(element, true);\n      EventHandler.trigger(element, EVENT_SHOWN$1, {\n        relatedTarget: relatedElem\n      });\n    };\n    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n  }\n  _deactivate(element, relatedElem) {\n    if (!element) {\n      return;\n    }\n    element.classList.remove(CLASS_NAME_ACTIVE);\n    element.blur();\n    this._deactivate(SelectorEngine.getElementFromSelector(element)); // Search and deactivate the shown section too\n\n    const complete = () => {\n      if (element.getAttribute('role') !== 'tab') {\n        element.classList.remove(CLASS_NAME_SHOW$1);\n        return;\n      }\n      element.setAttribute('aria-selected', false);\n      element.setAttribute('tabindex', '-1');\n      this._toggleDropDown(element, false);\n      EventHandler.trigger(element, EVENT_HIDDEN$1, {\n        relatedTarget: relatedElem\n      });\n    };\n    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n  }\n  _keydown(event) {\n    if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY, HOME_KEY, END_KEY].includes(event.key)) {\n      return;\n    }\n    event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page\n    event.preventDefault();\n    const children = this._getChildren().filter(element => !isDisabled(element));\n    let nextActiveElement;\n    if ([HOME_KEY, END_KEY].includes(event.key)) {\n      nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];\n    } else {\n      const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);\n      nextActiveElement = getNextActiveElement(children, event.target, isNext, true);\n    }\n    if (nextActiveElement) {\n      nextActiveElement.focus({\n        preventScroll: true\n      });\n      Tab.getOrCreateInstance(nextActiveElement).show();\n    }\n  }\n  _getChildren() {\n    // collection of inner elements\n    return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);\n  }\n  _getActiveElem() {\n    return this._getChildren().find(child => this._elemIsActive(child)) || null;\n  }\n  _setInitialAttributes(parent, children) {\n    this._setAttributeIfNotExists(parent, 'role', 'tablist');\n    for (const child of children) {\n      this._setInitialAttributesOnChild(child);\n    }\n  }\n  _setInitialAttributesOnChild(child) {\n    child = this._getInnerElement(child);\n    const isActive = this._elemIsActive(child);\n    const outerElem = this._getOuterElement(child);\n    child.setAttribute('aria-selected', isActive);\n    if (outerElem !== child) {\n      this._setAttributeIfNotExists(outerElem, 'role', 'presentation');\n    }\n    if (!isActive) {\n      child.setAttribute('tabindex', '-1');\n    }\n    this._setAttributeIfNotExists(child, 'role', 'tab');\n\n    // set attributes to the related panel too\n    this._setInitialAttributesOnTargetPanel(child);\n  }\n  _setInitialAttributesOnTargetPanel(child) {\n    const target = SelectorEngine.getElementFromSelector(child);\n    if (!target) {\n      return;\n    }\n    this._setAttributeIfNotExists(target, 'role', 'tabpanel');\n    if (child.id) {\n      this._setAttributeIfNotExists(target, 'aria-labelledby', `${child.id}`);\n    }\n  }\n  _toggleDropDown(element, open) {\n    const outerElem = this._getOuterElement(element);\n    if (!outerElem.classList.contains(CLASS_DROPDOWN)) {\n      return;\n    }\n    const toggle = (selector, className) => {\n      const element = SelectorEngine.findOne(selector, outerElem);\n      if (element) {\n        element.classList.toggle(className, open);\n      }\n    };\n    toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);\n    toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);\n    outerElem.setAttribute('aria-expanded', open);\n  }\n  _setAttributeIfNotExists(element, attribute, value) {\n    if (!element.hasAttribute(attribute)) {\n      element.setAttribute(attribute, value);\n    }\n  }\n  _elemIsActive(elem) {\n    return elem.classList.contains(CLASS_NAME_ACTIVE);\n  }\n\n  // Try to get the inner element (usually the .nav-link)\n  _getInnerElement(elem) {\n    return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);\n  }\n\n  // Try to get the outer element (usually the .nav-item)\n  _getOuterElement(elem) {\n    return elem.closest(SELECTOR_OUTER) || elem;\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Tab.getOrCreateInstance(this);\n      if (typeof config !== 'string') {\n        return;\n      }\n      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n        throw new TypeError(`No method named \"${config}\"`);\n      }\n      data[config]();\n    });\n  }\n}\n\n/**\n * Data API implementation\n */\n\nEventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {\n  if (['A', 'AREA'].includes(this.tagName)) {\n    event.preventDefault();\n  }\n  if (isDisabled(this)) {\n    return;\n  }\n  Tab.getOrCreateInstance(this).show();\n});\n\n/**\n * Initialize on focus\n */\nEventHandler.on(window, EVENT_LOAD_DATA_API, () => {\n  for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {\n    Tab.getOrCreateInstance(element);\n  }\n});\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Tab);\n\n/**\n * --------------------------------------------------------------------------\n * Bootstrap toast.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\n\n/**\n * Constants\n */\n\nconst NAME = 'toast';\nconst DATA_KEY = 'bs.toast';\nconst EVENT_KEY = `.${DATA_KEY}`;\nconst EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;\nconst EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;\nconst EVENT_FOCUSIN = `focusin${EVENT_KEY}`;\nconst EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;\nconst EVENT_HIDE = `hide${EVENT_KEY}`;\nconst EVENT_HIDDEN = `hidden${EVENT_KEY}`;\nconst EVENT_SHOW = `show${EVENT_KEY}`;\nconst EVENT_SHOWN = `shown${EVENT_KEY}`;\nconst CLASS_NAME_FADE = 'fade';\nconst CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility\nconst CLASS_NAME_SHOW = 'show';\nconst CLASS_NAME_SHOWING = 'showing';\nconst DefaultType = {\n  animation: 'boolean',\n  autohide: 'boolean',\n  delay: 'number'\n};\nconst Default = {\n  animation: true,\n  autohide: true,\n  delay: 5000\n};\n\n/**\n * Class definition\n */\n\nclass Toast extends BaseComponent {\n  constructor(element, config) {\n    super(element, config);\n    this._timeout = null;\n    this._hasMouseInteraction = false;\n    this._hasKeyboardInteraction = false;\n    this._setListeners();\n  }\n\n  // Getters\n  static get Default() {\n    return Default;\n  }\n  static get DefaultType() {\n    return DefaultType;\n  }\n  static get NAME() {\n    return NAME;\n  }\n\n  // Public\n  show() {\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);\n    if (showEvent.defaultPrevented) {\n      return;\n    }\n    this._clearTimeout();\n    if (this._config.animation) {\n      this._element.classList.add(CLASS_NAME_FADE);\n    }\n    const complete = () => {\n      this._element.classList.remove(CLASS_NAME_SHOWING);\n      EventHandler.trigger(this._element, EVENT_SHOWN);\n      this._maybeScheduleHide();\n    };\n    this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated\n    reflow(this._element);\n    this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);\n    this._queueCallback(complete, this._element, this._config.animation);\n  }\n  hide() {\n    if (!this.isShown()) {\n      return;\n    }\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\n    if (hideEvent.defaultPrevented) {\n      return;\n    }\n    const complete = () => {\n      this._element.classList.add(CLASS_NAME_HIDE); // @deprecated\n      this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);\n      EventHandler.trigger(this._element, EVENT_HIDDEN);\n    };\n    this._element.classList.add(CLASS_NAME_SHOWING);\n    this._queueCallback(complete, this._element, this._config.animation);\n  }\n  dispose() {\n    this._clearTimeout();\n    if (this.isShown()) {\n      this._element.classList.remove(CLASS_NAME_SHOW);\n    }\n    super.dispose();\n  }\n  isShown() {\n    return this._element.classList.contains(CLASS_NAME_SHOW);\n  }\n\n  // Private\n  _maybeScheduleHide() {\n    if (!this._config.autohide) {\n      return;\n    }\n    if (this._hasMouseInteraction || this._hasKeyboardInteraction) {\n      return;\n    }\n    this._timeout = setTimeout(() => {\n      this.hide();\n    }, this._config.delay);\n  }\n  _onInteraction(event, isInteracting) {\n    switch (event.type) {\n      case 'mouseover':\n      case 'mouseout':\n        {\n          this._hasMouseInteraction = isInteracting;\n          break;\n        }\n      case 'focusin':\n      case 'focusout':\n        {\n          this._hasKeyboardInteraction = isInteracting;\n          break;\n        }\n    }\n    if (isInteracting) {\n      this._clearTimeout();\n      return;\n    }\n    const nextElement = event.relatedTarget;\n    if (this._element === nextElement || this._element.contains(nextElement)) {\n      return;\n    }\n    this._maybeScheduleHide();\n  }\n  _setListeners() {\n    EventHandler.on(this._element, EVENT_MOUSEOVER, event => this._onInteraction(event, true));\n    EventHandler.on(this._element, EVENT_MOUSEOUT, event => this._onInteraction(event, false));\n    EventHandler.on(this._element, EVENT_FOCUSIN, event => this._onInteraction(event, true));\n    EventHandler.on(this._element, EVENT_FOCUSOUT, event => this._onInteraction(event, false));\n  }\n  _clearTimeout() {\n    clearTimeout(this._timeout);\n    this._timeout = null;\n  }\n\n  // Static\n  static jQueryInterface(config) {\n    return this.each(function () {\n      const data = Toast.getOrCreateInstance(this, config);\n      if (typeof config === 'string') {\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n        data[config](this);\n      }\n    });\n  }\n}\n\n/**\n * Data API implementation\n */\n\nenableDismissTrigger(Toast);\n\n/**\n * jQuery\n */\n\ndefineJQueryPlugin(Toast);\n\n\n//# sourceMappingURL=bootstrap.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsa0NBQWtDO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxlQUFlO0FBQ25GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsSUFBSSxJQUFJLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLE1BQU07QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkNBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkMsa0NBQWtDLFlBQVk7QUFDOUMsd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDZDQUE2QztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QywrQ0FBK0MsWUFBWTtBQUMzRCxnQ0FBZ0MsWUFBWTtBQUM1Qyw0QkFBNEIsWUFBWTtBQUN4Qyw4QkFBOEIsWUFBWTtBQUMxQyxnQ0FBZ0MsWUFBWTtBQUM1Qyw0Q0FBNEMsWUFBWTtBQUN4RCxvREFBb0QsWUFBWTtBQUNoRSxrREFBa0QsWUFBWTtBQUM5RCx1Q0FBdUMsWUFBWSxFQUFFLGVBQWU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQSxxQ0FBcUMsWUFBWSxFQUFFLGVBQWU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEMsOEJBQThCLFlBQVk7QUFDMUMsNEJBQTRCLFlBQVk7QUFDeEMsNkNBQTZDLFlBQVk7QUFDekQsZ0NBQWdDLFlBQVk7QUFDNUMsOEJBQThCLFlBQVk7QUFDMUMsdUNBQXVDLFlBQVksRUFBRSxlQUFlO0FBQ3BFLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsMkNBQU07QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0RBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxTQUFTO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0Isb0NBQW9DLFVBQVU7QUFDOUMsa0NBQWtDLFVBQVU7QUFDNUMsZ0NBQWdDLFVBQVU7QUFDMUMsa0NBQWtDLFVBQVU7QUFDNUMsMEJBQTBCLFVBQVU7QUFDcEMsOEJBQThCLFVBQVU7QUFDeEMsMEJBQTBCLFVBQVU7QUFDcEMsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFa0g7QUFDbEgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9kaXN0L2pzL2Jvb3RzdHJhcC5lc20uanM/MGE2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgKiBCb290c3RyYXAgdjUuMy43IChodHRwczovL2dldGJvb3RzdHJhcC5jb20vKVxuICAqIENvcHlyaWdodCAyMDExLTIwMjUgVGhlIEJvb3RzdHJhcCBBdXRob3JzIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvZ3JhcGhzL2NvbnRyaWJ1dG9ycylcbiAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgKi9cbmltcG9ydCAqIGFzIFBvcHBlciBmcm9tICdAcG9wcGVyanMvY29yZSc7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCBkb20vZGF0YS5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgZWxlbWVudE1hcCA9IG5ldyBNYXAoKTtcbmNvbnN0IERhdGEgPSB7XG4gIHNldChlbGVtZW50LCBrZXksIGluc3RhbmNlKSB7XG4gICAgaWYgKCFlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xuICAgICAgZWxlbWVudE1hcC5zZXQoZWxlbWVudCwgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgY29uc3QgaW5zdGFuY2VNYXAgPSBlbGVtZW50TWFwLmdldChlbGVtZW50KTtcblxuICAgIC8vIG1ha2UgaXQgY2xlYXIgd2Ugb25seSB3YW50IG9uZSBpbnN0YW5jZSBwZXIgZWxlbWVudFxuICAgIC8vIGNhbiBiZSByZW1vdmVkIGxhdGVyIHdoZW4gbXVsdGlwbGUga2V5L2luc3RhbmNlcyBhcmUgZmluZSB0byBiZSB1c2VkXG4gICAgaWYgKCFpbnN0YW5jZU1hcC5oYXMoa2V5KSAmJiBpbnN0YW5jZU1hcC5zaXplICE9PSAwKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcihgQm9vdHN0cmFwIGRvZXNuJ3QgYWxsb3cgbW9yZSB0aGFuIG9uZSBpbnN0YW5jZSBwZXIgZWxlbWVudC4gQm91bmQgaW5zdGFuY2U6ICR7QXJyYXkuZnJvbShpbnN0YW5jZU1hcC5rZXlzKCkpWzBdfS5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5zdGFuY2VNYXAuc2V0KGtleSwgaW5zdGFuY2UpO1xuICB9LFxuICBnZXQoZWxlbWVudCwga2V5KSB7XG4gICAgaWYgKGVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gZWxlbWVudE1hcC5nZXQoZWxlbWVudCkuZ2V0KGtleSkgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHJlbW92ZShlbGVtZW50LCBrZXkpIHtcbiAgICBpZiAoIWVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluc3RhbmNlTWFwID0gZWxlbWVudE1hcC5nZXQoZWxlbWVudCk7XG4gICAgaW5zdGFuY2VNYXAuZGVsZXRlKGtleSk7XG5cbiAgICAvLyBmcmVlIHVwIGVsZW1lbnQgcmVmZXJlbmNlcyBpZiB0aGVyZSBhcmUgbm8gaW5zdGFuY2VzIGxlZnQgZm9yIGFuIGVsZW1lbnRcbiAgICBpZiAoaW5zdGFuY2VNYXAuc2l6ZSA9PT0gMCkge1xuICAgICAgZWxlbWVudE1hcC5kZWxldGUoZWxlbWVudCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgdXRpbC9pbmRleC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE1BWF9VSUQgPSAxMDAwMDAwO1xuY29uc3QgTUlMTElTRUNPTkRTX01VTFRJUExJRVIgPSAxMDAwO1xuY29uc3QgVFJBTlNJVElPTl9FTkQgPSAndHJhbnNpdGlvbmVuZCc7XG5cbi8qKlxuICogUHJvcGVybHkgZXNjYXBlIElEcyBzZWxlY3RvcnMgdG8gaGFuZGxlIHdlaXJkIElEc1xuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBwYXJzZVNlbGVjdG9yID0gc2VsZWN0b3IgPT4ge1xuICBpZiAoc2VsZWN0b3IgJiYgd2luZG93LkNTUyAmJiB3aW5kb3cuQ1NTLmVzY2FwZSkge1xuICAgIC8vIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgbmVlZHMgZXNjYXBpbmcgdG8gaGFuZGxlIElEcyAoaHRtbDUrKSBjb250YWluaW5nIGZvciBpbnN0YW5jZSAvXG4gICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC8jKFteXFxzXCIjJ10rKS9nLCAobWF0Y2gsIGlkKSA9PiBgIyR7Q1NTLmVzY2FwZShpZCl9YCk7XG4gIH1cbiAgcmV0dXJuIHNlbGVjdG9yO1xufTtcblxuLy8gU2hvdXQtb3V0IEFuZ3VzIENyb2xsIChodHRwczovL2dvby5nbC9weHdRR3ApXG5jb25zdCB0b1R5cGUgPSBvYmplY3QgPT4ge1xuICBpZiAob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGAke29iamVjdH1gO1xuICB9XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKTtcbn07XG5cbi8qKlxuICogUHVibGljIFV0aWwgQVBJXG4gKi9cblxuY29uc3QgZ2V0VUlEID0gcHJlZml4ID0+IHtcbiAgZG8ge1xuICAgIHByZWZpeCArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBNQVhfVUlEKTtcbiAgfSB3aGlsZSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocHJlZml4KSk7XG4gIHJldHVybiBwcmVmaXg7XG59O1xuY29uc3QgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQgPSBlbGVtZW50ID0+IHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBHZXQgdHJhbnNpdGlvbi1kdXJhdGlvbiBvZiB0aGUgZWxlbWVudFxuICBsZXQge1xuICAgIHRyYW5zaXRpb25EdXJhdGlvbixcbiAgICB0cmFuc2l0aW9uRGVsYXlcbiAgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICBjb25zdCBmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiA9IE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EdXJhdGlvbik7XG4gIGNvbnN0IGZsb2F0VHJhbnNpdGlvbkRlbGF5ID0gTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KTtcblxuICAvLyBSZXR1cm4gMCBpZiBlbGVtZW50IG9yIHRyYW5zaXRpb24gZHVyYXRpb24gaXMgbm90IGZvdW5kXG4gIGlmICghZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24gJiYgIWZsb2F0VHJhbnNpdGlvbkRlbGF5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBJZiBtdWx0aXBsZSBkdXJhdGlvbnMgYXJlIGRlZmluZWQsIHRha2UgdGhlIGZpcnN0XG4gIHRyYW5zaXRpb25EdXJhdGlvbiA9IHRyYW5zaXRpb25EdXJhdGlvbi5zcGxpdCgnLCcpWzBdO1xuICB0cmFuc2l0aW9uRGVsYXkgPSB0cmFuc2l0aW9uRGVsYXkuc3BsaXQoJywnKVswXTtcbiAgcmV0dXJuIChOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pICsgTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KSkgKiBNSUxMSVNFQ09ORFNfTVVMVElQTElFUjtcbn07XG5jb25zdCB0cmlnZ2VyVHJhbnNpdGlvbkVuZCA9IGVsZW1lbnQgPT4ge1xuICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFRSQU5TSVRJT05fRU5EKSk7XG59O1xuY29uc3QgaXNFbGVtZW50ID0gb2JqZWN0ID0+IHtcbiAgaWYgKCFvYmplY3QgfHwgdHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBvYmplY3QuanF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIG9iamVjdCA9IG9iamVjdFswXTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIG9iamVjdC5ub2RlVHlwZSAhPT0gJ3VuZGVmaW5lZCc7XG59O1xuY29uc3QgZ2V0RWxlbWVudCA9IG9iamVjdCA9PiB7XG4gIC8vIGl0J3MgYSBqUXVlcnkgb2JqZWN0IG9yIGEgbm9kZSBlbGVtZW50XG4gIGlmIChpc0VsZW1lbnQob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3QuanF1ZXJ5ID8gb2JqZWN0WzBdIDogb2JqZWN0O1xuICB9XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBhcnNlU2VsZWN0b3Iob2JqZWN0KSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgaXNWaXNpYmxlID0gZWxlbWVudCA9PiB7XG4gIGlmICghaXNFbGVtZW50KGVsZW1lbnQpIHx8IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZWxlbWVudElzVmlzaWJsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgndmlzaWJpbGl0eScpID09PSAndmlzaWJsZSc7XG4gIC8vIEhhbmRsZSBgZGV0YWlsc2AgZWxlbWVudCBhcyBpdHMgY29udGVudCBtYXkgZmFsc2llIGFwcGVhciB2aXNpYmxlIHdoZW4gaXQgaXMgY2xvc2VkXG4gIGNvbnN0IGNsb3NlZERldGFpbHMgPSBlbGVtZW50LmNsb3Nlc3QoJ2RldGFpbHM6bm90KFtvcGVuXSknKTtcbiAgaWYgKCFjbG9zZWREZXRhaWxzKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRJc1Zpc2libGU7XG4gIH1cbiAgaWYgKGNsb3NlZERldGFpbHMgIT09IGVsZW1lbnQpIHtcbiAgICBjb25zdCBzdW1tYXJ5ID0gZWxlbWVudC5jbG9zZXN0KCdzdW1tYXJ5Jyk7XG4gICAgaWYgKHN1bW1hcnkgJiYgc3VtbWFyeS5wYXJlbnROb2RlICE9PSBjbG9zZWREZXRhaWxzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdW1tYXJ5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbGVtZW50SXNWaXNpYmxlO1xufTtcbmNvbnN0IGlzRGlzYWJsZWQgPSBlbGVtZW50ID0+IHtcbiAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbGVtZW50LmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBlbGVtZW50LmRpc2FibGVkO1xuICB9XG4gIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlzYWJsZWQnKSAhPT0gJ2ZhbHNlJztcbn07XG5jb25zdCBmaW5kU2hhZG93Um9vdCA9IGVsZW1lbnQgPT4ge1xuICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRhY2hTaGFkb3cpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIENhbiBmaW5kIHRoZSBzaGFkb3cgcm9vdCBvdGhlcndpc2UgaXQnbGwgcmV0dXJuIHRoZSBkb2N1bWVudFxuICBpZiAodHlwZW9mIGVsZW1lbnQuZ2V0Um9vdE5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCByb290ID0gZWxlbWVudC5nZXRSb290Tm9kZSgpO1xuICAgIHJldHVybiByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHJvb3QgOiBudWxsO1xuICB9XG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLy8gd2hlbiB3ZSBkb24ndCBmaW5kIGEgc2hhZG93IHJvb3RcbiAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZmluZFNoYWRvd1Jvb3QoZWxlbWVudC5wYXJlbnROb2RlKTtcbn07XG5jb25zdCBub29wID0gKCkgPT4ge307XG5cbi8qKlxuICogVHJpY2sgdG8gcmVzdGFydCBhbiBlbGVtZW50J3MgYW5pbWF0aW9uXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB2b2lkXG4gKlxuICogQHNlZSBodHRwczovL3d3dy5oYXJyeXRoZW8uY29tL2Jsb2cvMjAyMS8wMi9yZXN0YXJ0LWEtY3NzLWFuaW1hdGlvbi13aXRoLWphdmFzY3JpcHQvI3Jlc3RhcnRpbmctYS1jc3MtYW5pbWF0aW9uXG4gKi9cbmNvbnN0IHJlZmxvdyA9IGVsZW1lbnQgPT4ge1xuICBlbGVtZW50Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbn07XG5jb25zdCBnZXRqUXVlcnkgPSAoKSA9PiB7XG4gIGlmICh3aW5kb3cualF1ZXJ5ICYmICFkb2N1bWVudC5ib2R5Lmhhc0F0dHJpYnV0ZSgnZGF0YS1icy1uby1qcXVlcnknKSkge1xuICAgIHJldHVybiB3aW5kb3cualF1ZXJ5O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbmNvbnN0IERPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MgPSBbXTtcbmNvbnN0IG9uRE9NQ29udGVudExvYWRlZCA9IGNhbGxiYWNrID0+IHtcbiAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgIC8vIGFkZCBsaXN0ZW5lciBvbiB0aGUgZmlyc3QgY2FsbCB3aGVuIHRoZSBkb2N1bWVudCBpcyBpbiBsb2FkaW5nIHN0YXRlXG4gICAgaWYgKCFET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIERPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufTtcbmNvbnN0IGlzUlRMID0gKCkgPT4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRpciA9PT0gJ3J0bCc7XG5jb25zdCBkZWZpbmVKUXVlcnlQbHVnaW4gPSBwbHVnaW4gPT4ge1xuICBvbkRPTUNvbnRlbnRMb2FkZWQoKCkgPT4ge1xuICAgIGNvbnN0ICQgPSBnZXRqUXVlcnkoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoJCkge1xuICAgICAgY29uc3QgbmFtZSA9IHBsdWdpbi5OQU1FO1xuICAgICAgY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltuYW1lXTtcbiAgICAgICQuZm5bbmFtZV0gPSBwbHVnaW4ualF1ZXJ5SW50ZXJmYWNlO1xuICAgICAgJC5mbltuYW1lXS5Db25zdHJ1Y3RvciA9IHBsdWdpbjtcbiAgICAgICQuZm5bbmFtZV0ubm9Db25mbGljdCA9ICgpID0+IHtcbiAgICAgICAgJC5mbltuYW1lXSA9IEpRVUVSWV9OT19DT05GTElDVDtcbiAgICAgICAgcmV0dXJuIHBsdWdpbi5qUXVlcnlJbnRlcmZhY2U7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgZXhlY3V0ZSA9IChwb3NzaWJsZUNhbGxiYWNrLCBhcmdzID0gW10sIGRlZmF1bHRWYWx1ZSA9IHBvc3NpYmxlQ2FsbGJhY2spID0+IHtcbiAgcmV0dXJuIHR5cGVvZiBwb3NzaWJsZUNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gcG9zc2libGVDYWxsYmFjay5jYWxsKC4uLmFyZ3MpIDogZGVmYXVsdFZhbHVlO1xufTtcbmNvbnN0IGV4ZWN1dGVBZnRlclRyYW5zaXRpb24gPSAoY2FsbGJhY2ssIHRyYW5zaXRpb25FbGVtZW50LCB3YWl0Rm9yVHJhbnNpdGlvbiA9IHRydWUpID0+IHtcbiAgaWYgKCF3YWl0Rm9yVHJhbnNpdGlvbikge1xuICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkdXJhdGlvblBhZGRpbmcgPSA1O1xuICBjb25zdCBlbXVsYXRlZER1cmF0aW9uID0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodHJhbnNpdGlvbkVsZW1lbnQpICsgZHVyYXRpb25QYWRkaW5nO1xuICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gIGNvbnN0IGhhbmRsZXIgPSAoe1xuICAgIHRhcmdldFxuICB9KSA9PiB7XG4gICAgaWYgKHRhcmdldCAhPT0gdHJhbnNpdGlvbkVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB0cmFuc2l0aW9uRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFRSQU5TSVRJT05fRU5ELCBoYW5kbGVyKTtcbiAgICBleGVjdXRlKGNhbGxiYWNrKTtcbiAgfTtcbiAgdHJhbnNpdGlvbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9OX0VORCwgaGFuZGxlcik7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICB0cmlnZ2VyVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRWxlbWVudCk7XG4gICAgfVxuICB9LCBlbXVsYXRlZER1cmF0aW9uKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBwcmV2aW91cy9uZXh0IGVsZW1lbnQgb2YgYSBsaXN0LlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IGxpc3QgICAgVGhlIGxpc3Qgb2YgZWxlbWVudHNcbiAqIEBwYXJhbSBhY3RpdmVFbGVtZW50ICAgVGhlIGFjdGl2ZSBlbGVtZW50XG4gKiBAcGFyYW0gc2hvdWxkR2V0TmV4dCAgIENob29zZSB0byBnZXQgbmV4dCBvciBwcmV2aW91cyBlbGVtZW50XG4gKiBAcGFyYW0gaXNDeWNsZUFsbG93ZWRcbiAqIEByZXR1cm4ge0VsZW1lbnR8ZWxlbX0gVGhlIHByb3BlciBlbGVtZW50XG4gKi9cbmNvbnN0IGdldE5leHRBY3RpdmVFbGVtZW50ID0gKGxpc3QsIGFjdGl2ZUVsZW1lbnQsIHNob3VsZEdldE5leHQsIGlzQ3ljbGVBbGxvd2VkKSA9PiB7XG4gIGNvbnN0IGxpc3RMZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgbGV0IGluZGV4ID0gbGlzdC5pbmRleE9mKGFjdGl2ZUVsZW1lbnQpO1xuXG4gIC8vIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0IGluIHRoZSBsaXN0IHJldHVybiBhbiBlbGVtZW50XG4gIC8vIGRlcGVuZGluZyBvbiB0aGUgZGlyZWN0aW9uIGFuZCBpZiBjeWNsZSBpcyBhbGxvd2VkXG4gIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gIXNob3VsZEdldE5leHQgJiYgaXNDeWNsZUFsbG93ZWQgPyBsaXN0W2xpc3RMZW5ndGggLSAxXSA6IGxpc3RbMF07XG4gIH1cbiAgaW5kZXggKz0gc2hvdWxkR2V0TmV4dCA/IDEgOiAtMTtcbiAgaWYgKGlzQ3ljbGVBbGxvd2VkKSB7XG4gICAgaW5kZXggPSAoaW5kZXggKyBsaXN0TGVuZ3RoKSAlIGxpc3RMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGxpc3RbTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIGxpc3RMZW5ndGggLSAxKSldO1xufTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIGRvbS9ldmVudC1oYW5kbGVyLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IG5hbWVzcGFjZVJlZ2V4ID0gL1teLl0qKD89XFwuLiopXFwufC4qLztcbmNvbnN0IHN0cmlwTmFtZVJlZ2V4ID0gL1xcLi4qLztcbmNvbnN0IHN0cmlwVWlkUmVnZXggPSAvOjpcXGQrJC87XG5jb25zdCBldmVudFJlZ2lzdHJ5ID0ge307IC8vIEV2ZW50cyBzdG9yYWdlXG5sZXQgdWlkRXZlbnQgPSAxO1xuY29uc3QgY3VzdG9tRXZlbnRzID0ge1xuICBtb3VzZWVudGVyOiAnbW91c2VvdmVyJyxcbiAgbW91c2VsZWF2ZTogJ21vdXNlb3V0J1xufTtcbmNvbnN0IG5hdGl2ZUV2ZW50cyA9IG5ldyBTZXQoWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZXVwJywgJ21vdXNlZG93bicsICdjb250ZXh0bWVudScsICdtb3VzZXdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdtb3VzZW1vdmUnLCAnc2VsZWN0c3RhcnQnLCAnc2VsZWN0ZW5kJywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnb3JpZW50YXRpb25jaGFuZ2UnLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnLCAncG9pbnRlcmRvd24nLCAncG9pbnRlcm1vdmUnLCAncG9pbnRlcnVwJywgJ3BvaW50ZXJsZWF2ZScsICdwb2ludGVyY2FuY2VsJywgJ2dlc3R1cmVzdGFydCcsICdnZXN0dXJlY2hhbmdlJywgJ2dlc3R1cmVlbmQnLCAnZm9jdXMnLCAnYmx1cicsICdjaGFuZ2UnLCAncmVzZXQnLCAnc2VsZWN0JywgJ3N1Ym1pdCcsICdmb2N1c2luJywgJ2ZvY3Vzb3V0JywgJ2xvYWQnLCAndW5sb2FkJywgJ2JlZm9yZXVubG9hZCcsICdyZXNpemUnLCAnbW92ZScsICdET01Db250ZW50TG9hZGVkJywgJ3JlYWR5c3RhdGVjaGFuZ2UnLCAnZXJyb3InLCAnYWJvcnQnLCAnc2Nyb2xsJ10pO1xuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kc1xuICovXG5cbmZ1bmN0aW9uIG1ha2VFdmVudFVpZChlbGVtZW50LCB1aWQpIHtcbiAgcmV0dXJuIHVpZCAmJiBgJHt1aWR9Ojoke3VpZEV2ZW50Kyt9YCB8fCBlbGVtZW50LnVpZEV2ZW50IHx8IHVpZEV2ZW50Kys7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50RXZlbnRzKGVsZW1lbnQpIHtcbiAgY29uc3QgdWlkID0gbWFrZUV2ZW50VWlkKGVsZW1lbnQpO1xuICBlbGVtZW50LnVpZEV2ZW50ID0gdWlkO1xuICBldmVudFJlZ2lzdHJ5W3VpZF0gPSBldmVudFJlZ2lzdHJ5W3VpZF0gfHwge307XG4gIHJldHVybiBldmVudFJlZ2lzdHJ5W3VpZF07XG59XG5mdW5jdGlvbiBib290c3RyYXBIYW5kbGVyKGVsZW1lbnQsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgaHlkcmF0ZU9iaihldmVudCwge1xuICAgICAgZGVsZWdhdGVUYXJnZXQ6IGVsZW1lbnRcbiAgICB9KTtcbiAgICBpZiAoaGFuZGxlci5vbmVPZmYpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgZXZlbnQudHlwZSwgZm4pO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkoZWxlbWVudCwgW2V2ZW50XSk7XG4gIH07XG59XG5mdW5jdGlvbiBib290c3RyYXBEZWxlZ2F0aW9uSGFuZGxlcihlbGVtZW50LCBzZWxlY3RvciwgZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZXIoZXZlbnQpIHtcbiAgICBjb25zdCBkb21FbGVtZW50cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgZm9yIChsZXQge1xuICAgICAgdGFyZ2V0XG4gICAgfSA9IGV2ZW50OyB0YXJnZXQgJiYgdGFyZ2V0ICE9PSB0aGlzOyB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZSkge1xuICAgICAgZm9yIChjb25zdCBkb21FbGVtZW50IG9mIGRvbUVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50ICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBoeWRyYXRlT2JqKGV2ZW50LCB7XG4gICAgICAgICAgZGVsZWdhdGVUYXJnZXQ6IHRhcmdldFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhbmRsZXIub25lT2ZmKSB7XG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCBldmVudC50eXBlLCBzZWxlY3RvciwgZm4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0YXJnZXQsIFtldmVudF0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRIYW5kbGVyKGV2ZW50cywgY2FsbGFibGUsIGRlbGVnYXRpb25TZWxlY3RvciA9IG51bGwpIHtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZXZlbnRzKS5maW5kKGV2ZW50ID0+IGV2ZW50LmNhbGxhYmxlID09PSBjYWxsYWJsZSAmJiBldmVudC5kZWxlZ2F0aW9uU2VsZWN0b3IgPT09IGRlbGVnYXRpb25TZWxlY3Rvcik7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQYXJhbWV0ZXJzKG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pIHtcbiAgY29uc3QgaXNEZWxlZ2F0ZWQgPSB0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZyc7XG4gIC8vIFRPRE86IHRvb2x0aXAgcGFzc2VzIGBmYWxzZWAgaW5zdGVhZCBvZiBzZWxlY3Rvciwgc28gd2UgbmVlZCB0byBjaGVja1xuICBjb25zdCBjYWxsYWJsZSA9IGlzRGVsZWdhdGVkID8gZGVsZWdhdGlvbkZ1bmN0aW9uIDogaGFuZGxlciB8fCBkZWxlZ2F0aW9uRnVuY3Rpb247XG4gIGxldCB0eXBlRXZlbnQgPSBnZXRUeXBlRXZlbnQob3JpZ2luYWxUeXBlRXZlbnQpO1xuICBpZiAoIW5hdGl2ZUV2ZW50cy5oYXModHlwZUV2ZW50KSkge1xuICAgIHR5cGVFdmVudCA9IG9yaWdpbmFsVHlwZUV2ZW50O1xuICB9XG4gIHJldHVybiBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdO1xufVxuZnVuY3Rpb24gYWRkSGFuZGxlcihlbGVtZW50LCBvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uLCBvbmVPZmYpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbFR5cGVFdmVudCAhPT0gJ3N0cmluZycgfHwgIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IFtpc0RlbGVnYXRlZCwgY2FsbGFibGUsIHR5cGVFdmVudF0gPSBub3JtYWxpemVQYXJhbWV0ZXJzKG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pO1xuXG4gIC8vIGluIGNhc2Ugb2YgbW91c2VlbnRlciBvciBtb3VzZWxlYXZlIHdyYXAgdGhlIGhhbmRsZXIgd2l0aGluIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgZm9yIGl0cyBET00gcG9zaXRpb25cbiAgLy8gdGhpcyBwcmV2ZW50cyB0aGUgaGFuZGxlciBmcm9tIGJlaW5nIGRpc3BhdGNoZWQgdGhlIHNhbWUgd2F5IGFzIG1vdXNlb3ZlciBvciBtb3VzZW91dCBkb2VzXG4gIGlmIChvcmlnaW5hbFR5cGVFdmVudCBpbiBjdXN0b21FdmVudHMpIHtcbiAgICBjb25zdCB3cmFwRnVuY3Rpb24gPSBmbiA9PiB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghZXZlbnQucmVsYXRlZFRhcmdldCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0ICE9PSBldmVudC5kZWxlZ2F0ZVRhcmdldCAmJiAhZXZlbnQuZGVsZWdhdGVUYXJnZXQuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBjYWxsYWJsZSA9IHdyYXBGdW5jdGlvbihjYWxsYWJsZSk7XG4gIH1cbiAgY29uc3QgZXZlbnRzID0gZ2V0RWxlbWVudEV2ZW50cyhlbGVtZW50KTtcbiAgY29uc3QgaGFuZGxlcnMgPSBldmVudHNbdHlwZUV2ZW50XSB8fCAoZXZlbnRzW3R5cGVFdmVudF0gPSB7fSk7XG4gIGNvbnN0IHByZXZpb3VzRnVuY3Rpb24gPSBmaW5kSGFuZGxlcihoYW5kbGVycywgY2FsbGFibGUsIGlzRGVsZWdhdGVkID8gaGFuZGxlciA6IG51bGwpO1xuICBpZiAocHJldmlvdXNGdW5jdGlvbikge1xuICAgIHByZXZpb3VzRnVuY3Rpb24ub25lT2ZmID0gcHJldmlvdXNGdW5jdGlvbi5vbmVPZmYgJiYgb25lT2ZmO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB1aWQgPSBtYWtlRXZlbnRVaWQoY2FsbGFibGUsIG9yaWdpbmFsVHlwZUV2ZW50LnJlcGxhY2UobmFtZXNwYWNlUmVnZXgsICcnKSk7XG4gIGNvbnN0IGZuID0gaXNEZWxlZ2F0ZWQgPyBib290c3RyYXBEZWxlZ2F0aW9uSGFuZGxlcihlbGVtZW50LCBoYW5kbGVyLCBjYWxsYWJsZSkgOiBib290c3RyYXBIYW5kbGVyKGVsZW1lbnQsIGNhbGxhYmxlKTtcbiAgZm4uZGVsZWdhdGlvblNlbGVjdG9yID0gaXNEZWxlZ2F0ZWQgPyBoYW5kbGVyIDogbnVsbDtcbiAgZm4uY2FsbGFibGUgPSBjYWxsYWJsZTtcbiAgZm4ub25lT2ZmID0gb25lT2ZmO1xuICBmbi51aWRFdmVudCA9IHVpZDtcbiAgaGFuZGxlcnNbdWlkXSA9IGZuO1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZUV2ZW50LCBmbiwgaXNEZWxlZ2F0ZWQpO1xufVxuZnVuY3Rpb24gcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvblNlbGVjdG9yKSB7XG4gIGNvbnN0IGZuID0gZmluZEhhbmRsZXIoZXZlbnRzW3R5cGVFdmVudF0sIGhhbmRsZXIsIGRlbGVnYXRpb25TZWxlY3Rvcik7XG4gIGlmICghZm4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGVFdmVudCwgZm4sIEJvb2xlYW4oZGVsZWdhdGlvblNlbGVjdG9yKSk7XG4gIGRlbGV0ZSBldmVudHNbdHlwZUV2ZW50XVtmbi51aWRFdmVudF07XG59XG5mdW5jdGlvbiByZW1vdmVOYW1lc3BhY2VkSGFuZGxlcnMoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIG5hbWVzcGFjZSkge1xuICBjb25zdCBzdG9yZUVsZW1lbnRFdmVudCA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IHt9O1xuICBmb3IgKGNvbnN0IFtoYW5kbGVyS2V5LCBldmVudF0gb2YgT2JqZWN0LmVudHJpZXMoc3RvcmVFbGVtZW50RXZlbnQpKSB7XG4gICAgaWYgKGhhbmRsZXJLZXkuaW5jbHVkZXMobmFtZXNwYWNlKSkge1xuICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgZXZlbnQuY2FsbGFibGUsIGV2ZW50LmRlbGVnYXRpb25TZWxlY3Rvcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRUeXBlRXZlbnQoZXZlbnQpIHtcbiAgLy8gYWxsb3cgdG8gZ2V0IHRoZSBuYXRpdmUgZXZlbnRzIGZyb20gbmFtZXNwYWNlZCBldmVudHMgKCdjbGljay5icy5idXR0b24nIC0tPiAnY2xpY2snKVxuICBldmVudCA9IGV2ZW50LnJlcGxhY2Uoc3RyaXBOYW1lUmVnZXgsICcnKTtcbiAgcmV0dXJuIGN1c3RvbUV2ZW50c1tldmVudF0gfHwgZXZlbnQ7XG59XG5jb25zdCBFdmVudEhhbmRsZXIgPSB7XG4gIG9uKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pIHtcbiAgICBhZGRIYW5kbGVyKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24sIGZhbHNlKTtcbiAgfSxcbiAgb25lKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pIHtcbiAgICBhZGRIYW5kbGVyKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24sIHRydWUpO1xuICB9LFxuICBvZmYoZWxlbWVudCwgb3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbikge1xuICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUeXBlRXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtpc0RlbGVnYXRlZCwgY2FsbGFibGUsIHR5cGVFdmVudF0gPSBub3JtYWxpemVQYXJhbWV0ZXJzKG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pO1xuICAgIGNvbnN0IGluTmFtZXNwYWNlID0gdHlwZUV2ZW50ICE9PSBvcmlnaW5hbFR5cGVFdmVudDtcbiAgICBjb25zdCBldmVudHMgPSBnZXRFbGVtZW50RXZlbnRzKGVsZW1lbnQpO1xuICAgIGNvbnN0IHN0b3JlRWxlbWVudEV2ZW50ID0gZXZlbnRzW3R5cGVFdmVudF0gfHwge307XG4gICAgY29uc3QgaXNOYW1lc3BhY2UgPSBvcmlnaW5hbFR5cGVFdmVudC5zdGFydHNXaXRoKCcuJyk7XG4gICAgaWYgKHR5cGVvZiBjYWxsYWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFNpbXBsZXN0IGNhc2U6IGhhbmRsZXIgaXMgcGFzc2VkLCByZW1vdmUgdGhhdCBsaXN0ZW5lciBPTkxZLlxuICAgICAgaWYgKCFPYmplY3Qua2V5cyhzdG9yZUVsZW1lbnRFdmVudCkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGNhbGxhYmxlLCBpc0RlbGVnYXRlZCA/IGhhbmRsZXIgOiBudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzTmFtZXNwYWNlKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnRFdmVudCBvZiBPYmplY3Qua2V5cyhldmVudHMpKSB7XG4gICAgICAgIHJlbW92ZU5hbWVzcGFjZWRIYW5kbGVycyhlbGVtZW50LCBldmVudHMsIGVsZW1lbnRFdmVudCwgb3JpZ2luYWxUeXBlRXZlbnQuc2xpY2UoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXlIYW5kbGVycywgZXZlbnRdIG9mIE9iamVjdC5lbnRyaWVzKHN0b3JlRWxlbWVudEV2ZW50KSkge1xuICAgICAgY29uc3QgaGFuZGxlcktleSA9IGtleUhhbmRsZXJzLnJlcGxhY2Uoc3RyaXBVaWRSZWdleCwgJycpO1xuICAgICAgaWYgKCFpbk5hbWVzcGFjZSB8fCBvcmlnaW5hbFR5cGVFdmVudC5pbmNsdWRlcyhoYW5kbGVyS2V5KSkge1xuICAgICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBldmVudC5jYWxsYWJsZSwgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHRyaWdnZXIoZWxlbWVudCwgZXZlbnQsIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSAnc3RyaW5nJyB8fCAhZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0ICQgPSBnZXRqUXVlcnkoKTtcbiAgICBjb25zdCB0eXBlRXZlbnQgPSBnZXRUeXBlRXZlbnQoZXZlbnQpO1xuICAgIGNvbnN0IGluTmFtZXNwYWNlID0gZXZlbnQgIT09IHR5cGVFdmVudDtcbiAgICBsZXQgalF1ZXJ5RXZlbnQgPSBudWxsO1xuICAgIGxldCBidWJibGVzID0gdHJ1ZTtcbiAgICBsZXQgbmF0aXZlRGlzcGF0Y2ggPSB0cnVlO1xuICAgIGxldCBkZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG4gICAgaWYgKGluTmFtZXNwYWNlICYmICQpIHtcbiAgICAgIGpRdWVyeUV2ZW50ID0gJC5FdmVudChldmVudCwgYXJncyk7XG4gICAgICAkKGVsZW1lbnQpLnRyaWdnZXIoalF1ZXJ5RXZlbnQpO1xuICAgICAgYnViYmxlcyA9ICFqUXVlcnlFdmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpO1xuICAgICAgbmF0aXZlRGlzcGF0Y2ggPSAhalF1ZXJ5RXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKTtcbiAgICAgIGRlZmF1bHRQcmV2ZW50ZWQgPSBqUXVlcnlFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICB9XG4gICAgY29uc3QgZXZ0ID0gaHlkcmF0ZU9iaihuZXcgRXZlbnQoZXZlbnQsIHtcbiAgICAgIGJ1YmJsZXMsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSksIGFyZ3MpO1xuICAgIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgaWYgKG5hdGl2ZURpc3BhdGNoKSB7XG4gICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICB9XG4gICAgaWYgKGV2dC5kZWZhdWx0UHJldmVudGVkICYmIGpRdWVyeUV2ZW50KSB7XG4gICAgICBqUXVlcnlFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICByZXR1cm4gZXZ0O1xuICB9XG59O1xuZnVuY3Rpb24gaHlkcmF0ZU9iaihvYmosIG1ldGEgPSB7fSkge1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtZXRhKSkge1xuICAgIHRyeSB7XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgZG9tL21hbmlwdWxhdG9yLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplRGF0YSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09ICd0cnVlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodmFsdWUgPT09IE51bWJlcih2YWx1ZSkudG9TdHJpbmcoKSkge1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09ICdudWxsJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZURhdGFLZXkoa2V5KSB7XG4gIHJldHVybiBrZXkucmVwbGFjZSgvW0EtWl0vZywgY2hyID0+IGAtJHtjaHIudG9Mb3dlckNhc2UoKX1gKTtcbn1cbmNvbnN0IE1hbmlwdWxhdG9yID0ge1xuICBzZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIGtleSwgdmFsdWUpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gLCB2YWx1ZSk7XG4gIH0sXG4gIHJlbW92ZURhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5KSB7XG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YCk7XG4gIH0sXG4gIGdldERhdGFBdHRyaWJ1dGVzKGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgIGNvbnN0IGJzS2V5cyA9IE9iamVjdC5rZXlzKGVsZW1lbnQuZGF0YXNldCkuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aCgnYnMnKSAmJiAha2V5LnN0YXJ0c1dpdGgoJ2JzQ29uZmlnJykpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGJzS2V5cykge1xuICAgICAgbGV0IHB1cmVLZXkgPSBrZXkucmVwbGFjZSgvXmJzLywgJycpO1xuICAgICAgcHVyZUtleSA9IHB1cmVLZXkuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBwdXJlS2V5LnNsaWNlKDEpO1xuICAgICAgYXR0cmlidXRlc1twdXJlS2V5XSA9IG5vcm1hbGl6ZURhdGEoZWxlbWVudC5kYXRhc2V0W2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfSxcbiAgZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXkpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplRGF0YShlbGVtZW50LmdldEF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gKSk7XG4gIH1cbn07XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCB1dGlsL2NvbmZpZy5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgQ29uZmlnIHtcbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBoYXZlIHRvIGltcGxlbWVudCB0aGUgc3RhdGljIG1ldGhvZCBcIk5BTUVcIiwgZm9yIGVhY2ggY29tcG9uZW50IScpO1xuICB9XG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0gdGhpcy5fbWVyZ2VDb25maWdPYmooY29uZmlnKTtcbiAgICBjb25maWcgPSB0aGlzLl9jb25maWdBZnRlck1lcmdlKGNvbmZpZyk7XG4gICAgdGhpcy5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIF9tZXJnZUNvbmZpZ09iaihjb25maWcsIGVsZW1lbnQpIHtcbiAgICBjb25zdCBqc29uQ29uZmlnID0gaXNFbGVtZW50KGVsZW1lbnQpID8gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCAnY29uZmlnJykgOiB7fTsgLy8gdHJ5IHRvIHBhcnNlXG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LFxuICAgICAgLi4uKHR5cGVvZiBqc29uQ29uZmlnID09PSAnb2JqZWN0JyA/IGpzb25Db25maWcgOiB7fSksXG4gICAgICAuLi4oaXNFbGVtZW50KGVsZW1lbnQpID8gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXMoZWxlbWVudCkgOiB7fSksXG4gICAgICAuLi4odHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiB7fSlcbiAgICB9O1xuICB9XG4gIF90eXBlQ2hlY2tDb25maWcoY29uZmlnLCBjb25maWdUeXBlcyA9IHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpIHtcbiAgICBmb3IgKGNvbnN0IFtwcm9wZXJ0eSwgZXhwZWN0ZWRUeXBlc10gb2YgT2JqZWN0LmVudHJpZXMoY29uZmlnVHlwZXMpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNvbmZpZ1twcm9wZXJ0eV07XG4gICAgICBjb25zdCB2YWx1ZVR5cGUgPSBpc0VsZW1lbnQodmFsdWUpID8gJ2VsZW1lbnQnIDogdG9UeXBlKHZhbHVlKTtcbiAgICAgIGlmICghbmV3IFJlZ0V4cChleHBlY3RlZFR5cGVzKS50ZXN0KHZhbHVlVHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUUudG9VcHBlckNhc2UoKX06IE9wdGlvbiBcIiR7cHJvcGVydHl9XCIgcHJvdmlkZWQgdHlwZSBcIiR7dmFsdWVUeXBlfVwiIGJ1dCBleHBlY3RlZCB0eXBlIFwiJHtleHBlY3RlZFR5cGVzfVwiLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgYmFzZS1jb21wb25lbnQuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgVkVSU0lPTiA9ICc1LjMuNyc7XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIEJhc2VDb21wb25lbnQgZXh0ZW5kcyBDb25maWcge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIGVsZW1lbnQgPSBnZXRFbGVtZW50KGVsZW1lbnQpO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICBEYXRhLnNldCh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLCB0aGlzKTtcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICBkaXNwb3NlKCkge1xuICAgIERhdGEucmVtb3ZlKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVkpO1xuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9LRVkpO1xuICAgIGZvciAoY29uc3QgcHJvcGVydHlOYW1lIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XG4gICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX3F1ZXVlQ2FsbGJhY2soY2FsbGJhY2ssIGVsZW1lbnQsIGlzQW5pbWF0ZWQgPSB0cnVlKSB7XG4gICAgZXhlY3V0ZUFmdGVyVHJhbnNpdGlvbihjYWxsYmFjaywgZWxlbWVudCwgaXNBbmltYXRlZCk7XG4gIH1cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB0aGlzLl9tZXJnZUNvbmZpZ09iaihjb25maWcsIHRoaXMuX2VsZW1lbnQpO1xuICAgIGNvbmZpZyA9IHRoaXMuX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKTtcbiAgICB0aGlzLl90eXBlQ2hlY2tDb25maWcoY29uZmlnKTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBnZXRJbnN0YW5jZShlbGVtZW50KSB7XG4gICAgcmV0dXJuIERhdGEuZ2V0KGdldEVsZW1lbnQoZWxlbWVudCksIHRoaXMuREFUQV9LRVkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoZWxlbWVudCkgfHwgbmV3IHRoaXMoZWxlbWVudCwgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiBudWxsKTtcbiAgfVxuICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XG4gICAgcmV0dXJuIFZFUlNJT047XG4gIH1cbiAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICByZXR1cm4gYGJzLiR7dGhpcy5OQU1FfWA7XG4gIH1cbiAgc3RhdGljIGdldCBFVkVOVF9LRVkoKSB7XG4gICAgcmV0dXJuIGAuJHt0aGlzLkRBVEFfS0VZfWA7XG4gIH1cbiAgc3RhdGljIGV2ZW50TmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIGAke25hbWV9JHt0aGlzLkVWRU5UX0tFWX1gO1xuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCBkb20vc2VsZWN0b3ItZW5naW5lLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgZ2V0U2VsZWN0b3IgPSBlbGVtZW50ID0+IHtcbiAgbGV0IHNlbGVjdG9yID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtdGFyZ2V0Jyk7XG4gIGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09ICcjJykge1xuICAgIGxldCBocmVmQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcblxuICAgIC8vIFRoZSBvbmx5IHZhbGlkIGNvbnRlbnQgdGhhdCBjb3VsZCBkb3VibGUgYXMgYSBzZWxlY3RvciBhcmUgSURzIG9yIGNsYXNzZXMsXG4gICAgLy8gc28gZXZlcnl0aGluZyBzdGFydGluZyB3aXRoIGAjYCBvciBgLmAuIElmIGEgXCJyZWFsXCIgVVJMIGlzIHVzZWQgYXMgdGhlIHNlbGVjdG9yLFxuICAgIC8vIGBkb2N1bWVudC5xdWVyeVNlbGVjdG9yYCB3aWxsIHJpZ2h0ZnVsbHkgY29tcGxhaW4gaXQgaXMgaW52YWxpZC5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2lzc3Vlcy8zMjI3M1xuICAgIGlmICghaHJlZkF0dHJpYnV0ZSB8fCAhaHJlZkF0dHJpYnV0ZS5pbmNsdWRlcygnIycpICYmICFocmVmQXR0cmlidXRlLnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gSnVzdCBpbiBjYXNlIHNvbWUgQ01TIHB1dHMgb3V0IGEgZnVsbCBVUkwgd2l0aCB0aGUgYW5jaG9yIGFwcGVuZGVkXG4gICAgaWYgKGhyZWZBdHRyaWJ1dGUuaW5jbHVkZXMoJyMnKSAmJiAhaHJlZkF0dHJpYnV0ZS5zdGFydHNXaXRoKCcjJykpIHtcbiAgICAgIGhyZWZBdHRyaWJ1dGUgPSBgIyR7aHJlZkF0dHJpYnV0ZS5zcGxpdCgnIycpWzFdfWA7XG4gICAgfVxuICAgIHNlbGVjdG9yID0gaHJlZkF0dHJpYnV0ZSAmJiBocmVmQXR0cmlidXRlICE9PSAnIycgPyBocmVmQXR0cmlidXRlLnRyaW0oKSA6IG51bGw7XG4gIH1cbiAgcmV0dXJuIHNlbGVjdG9yID8gc2VsZWN0b3Iuc3BsaXQoJywnKS5tYXAoc2VsID0+IHBhcnNlU2VsZWN0b3Ioc2VsKSkuam9pbignLCcpIDogbnVsbDtcbn07XG5jb25zdCBTZWxlY3RvckVuZ2luZSA9IHtcbiAgZmluZChzZWxlY3RvciwgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoLi4uRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbC5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKSk7XG4gIH0sXG4gIGZpbmRPbmUoc2VsZWN0b3IsIGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3Rvci5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgfSxcbiAgY2hpbGRyZW4oZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KC4uLmVsZW1lbnQuY2hpbGRyZW4pLmZpbHRlcihjaGlsZCA9PiBjaGlsZC5tYXRjaGVzKHNlbGVjdG9yKSk7XG4gIH0sXG4gIHBhcmVudHMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgbGV0IGFuY2VzdG9yID0gZWxlbWVudC5wYXJlbnROb2RlLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgcGFyZW50cy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50Tm9kZS5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudHM7XG4gIH0sXG4gIHByZXYoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICBsZXQgcHJldmlvdXMgPSBlbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgd2hpbGUgKHByZXZpb3VzKSB7XG4gICAgICBpZiAocHJldmlvdXMubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgICAgcmV0dXJuIFtwcmV2aW91c107XG4gICAgICB9XG4gICAgICBwcmV2aW91cyA9IHByZXZpb3VzLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfSxcbiAgLy8gVE9ETzogdGhpcyBpcyBub3cgdW51c2VkOyByZW1vdmUgbGF0ZXIgYWxvbmcgd2l0aCBwcmV2KClcbiAgbmV4dChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIGxldCBuZXh0ID0gZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgd2hpbGUgKG5leHQpIHtcbiAgICAgIGlmIChuZXh0Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBbbmV4dF07XG4gICAgICB9XG4gICAgICBuZXh0ID0gbmV4dC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfSxcbiAgZm9jdXNhYmxlQ2hpbGRyZW4oZWxlbWVudCkge1xuICAgIGNvbnN0IGZvY3VzYWJsZXMgPSBbJ2EnLCAnYnV0dG9uJywgJ2lucHV0JywgJ3RleHRhcmVhJywgJ3NlbGVjdCcsICdkZXRhaWxzJywgJ1t0YWJpbmRleF0nLCAnW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0nXS5tYXAoc2VsZWN0b3IgPT4gYCR7c2VsZWN0b3J9Om5vdChbdGFiaW5kZXhePVwiLVwiXSlgKS5qb2luKCcsJyk7XG4gICAgcmV0dXJuIHRoaXMuZmluZChmb2N1c2FibGVzLCBlbGVtZW50KS5maWx0ZXIoZWwgPT4gIWlzRGlzYWJsZWQoZWwpICYmIGlzVmlzaWJsZShlbCkpO1xuICB9LFxuICBnZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpIHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGVsZW1lbnQpO1xuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoc2VsZWN0b3IpID8gc2VsZWN0b3IgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KSB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihlbGVtZW50KTtcbiAgICByZXR1cm4gc2VsZWN0b3IgPyBTZWxlY3RvckVuZ2luZS5maW5kT25lKHNlbGVjdG9yKSA6IG51bGw7XG4gIH0sXG4gIGdldE11bHRpcGxlRWxlbWVudHNGcm9tU2VsZWN0b3IoZWxlbWVudCkge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoZWxlbWVudCk7XG4gICAgcmV0dXJuIHNlbGVjdG9yID8gU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3RvcikgOiBbXTtcbiAgfVxufTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIHV0aWwvY29tcG9uZW50LWZ1bmN0aW9ucy5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IGVuYWJsZURpc21pc3NUcmlnZ2VyID0gKGNvbXBvbmVudCwgbWV0aG9kID0gJ2hpZGUnKSA9PiB7XG4gIGNvbnN0IGNsaWNrRXZlbnQgPSBgY2xpY2suZGlzbWlzcyR7Y29tcG9uZW50LkVWRU5UX0tFWX1gO1xuICBjb25zdCBuYW1lID0gY29tcG9uZW50Lk5BTUU7XG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgY2xpY2tFdmVudCwgYFtkYXRhLWJzLWRpc21pc3M9XCIke25hbWV9XCJdYCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgaWYgKGlzRGlzYWJsZWQodGhpcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKSB8fCB0aGlzLmNsb3Nlc3QoYC4ke25hbWV9YCk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBjb21wb25lbnQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpO1xuXG4gICAgLy8gTWV0aG9kIGFyZ3VtZW50IGlzIGxlZnQsIGZvciBBbGVydCBhbmQgb25seSwgYXMgaXQgZG9lc24ndCBpbXBsZW1lbnQgdGhlICdoaWRlJyBtZXRob2RcbiAgICBpbnN0YW5jZVttZXRob2RdKCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIGFsZXJ0LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkZiA9ICdhbGVydCc7XG5jb25zdCBEQVRBX0tFWSRhID0gJ2JzLmFsZXJ0JztcbmNvbnN0IEVWRU5UX0tFWSRiID0gYC4ke0RBVEFfS0VZJGF9YDtcbmNvbnN0IEVWRU5UX0NMT1NFID0gYGNsb3NlJHtFVkVOVF9LRVkkYn1gO1xuY29uc3QgRVZFTlRfQ0xPU0VEID0gYGNsb3NlZCR7RVZFTlRfS0VZJGJ9YDtcbmNvbnN0IENMQVNTX05BTUVfRkFERSQ1ID0gJ2ZhZGUnO1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDggPSAnc2hvdyc7XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIEFsZXJ0IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJGY7XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgY2xvc2UoKSB7XG4gICAgY29uc3QgY2xvc2VFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMT1NFKTtcbiAgICBpZiAoY2xvc2VFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckOCk7XG4gICAgY29uc3QgaXNBbmltYXRlZCA9IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQ1KTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHRoaXMuX2Rlc3Ryb3lFbGVtZW50KCksIHRoaXMuX2VsZW1lbnQsIGlzQW5pbWF0ZWQpO1xuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfZGVzdHJveUVsZW1lbnQoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmUoKTtcbiAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTE9TRUQpO1xuICAgIHRoaXMuZGlzcG9zZSgpO1xuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gQWxlcnQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgIH1cbiAgICAgIGRhdGFbY29uZmlnXSh0aGlzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cblxuZW5hYmxlRGlzbWlzc1RyaWdnZXIoQWxlcnQsICdjbG9zZScpO1xuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihBbGVydCk7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCBidXR0b24uanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTkFNRSRlID0gJ2J1dHRvbic7XG5jb25zdCBEQVRBX0tFWSQ5ID0gJ2JzLmJ1dHRvbic7XG5jb25zdCBFVkVOVF9LRVkkYSA9IGAuJHtEQVRBX0tFWSQ5fWA7XG5jb25zdCBEQVRBX0FQSV9LRVkkNiA9ICcuZGF0YS1hcGknO1xuY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUkMyA9ICdhY3RpdmUnO1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkNSA9ICdbZGF0YS1icy10b2dnbGU9XCJidXR0b25cIl0nO1xuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNiA9IGBjbGljayR7RVZFTlRfS0VZJGF9JHtEQVRBX0FQSV9LRVkkNn1gO1xuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBCdXR0b24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUUkZTtcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICB0b2dnbGUoKSB7XG4gICAgLy8gVG9nZ2xlIGNsYXNzIGFuZCBzeW5jIHRoZSBgYXJpYS1wcmVzc2VkYCBhdHRyaWJ1dGUgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBgLnRvZ2dsZSgpYCBtZXRob2RcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1wcmVzc2VkJywgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKENMQVNTX05BTUVfQUNUSVZFJDMpKTtcbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IEJ1dHRvbi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgaWYgKGNvbmZpZyA9PT0gJ3RvZ2dsZScpIHtcbiAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNiwgU0VMRUNUT1JfREFUQV9UT0dHTEUkNSwgZXZlbnQgPT4ge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBjb25zdCBidXR0b24gPSBldmVudC50YXJnZXQuY2xvc2VzdChTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1KTtcbiAgY29uc3QgZGF0YSA9IEJ1dHRvbi5nZXRPckNyZWF0ZUluc3RhbmNlKGJ1dHRvbik7XG4gIGRhdGEudG9nZ2xlKCk7XG59KTtcblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oQnV0dG9uKTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIHV0aWwvc3dpcGUuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTkFNRSRkID0gJ3N3aXBlJztcbmNvbnN0IEVWRU5UX0tFWSQ5ID0gJy5icy5zd2lwZSc7XG5jb25zdCBFVkVOVF9UT1VDSFNUQVJUID0gYHRvdWNoc3RhcnQke0VWRU5UX0tFWSQ5fWA7XG5jb25zdCBFVkVOVF9UT1VDSE1PVkUgPSBgdG91Y2htb3ZlJHtFVkVOVF9LRVkkOX1gO1xuY29uc3QgRVZFTlRfVE9VQ0hFTkQgPSBgdG91Y2hlbmQke0VWRU5UX0tFWSQ5fWA7XG5jb25zdCBFVkVOVF9QT0lOVEVSRE9XTiA9IGBwb2ludGVyZG93biR7RVZFTlRfS0VZJDl9YDtcbmNvbnN0IEVWRU5UX1BPSU5URVJVUCA9IGBwb2ludGVydXAke0VWRU5UX0tFWSQ5fWA7XG5jb25zdCBQT0lOVEVSX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xuY29uc3QgUE9JTlRFUl9UWVBFX1BFTiA9ICdwZW4nO1xuY29uc3QgQ0xBU1NfTkFNRV9QT0lOVEVSX0VWRU5UID0gJ3BvaW50ZXItZXZlbnQnO1xuY29uc3QgU1dJUEVfVEhSRVNIT0xEID0gNDA7XG5jb25zdCBEZWZhdWx0JGMgPSB7XG4gIGVuZENhbGxiYWNrOiBudWxsLFxuICBsZWZ0Q2FsbGJhY2s6IG51bGwsXG4gIHJpZ2h0Q2FsbGJhY2s6IG51bGxcbn07XG5jb25zdCBEZWZhdWx0VHlwZSRjID0ge1xuICBlbmRDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKScsXG4gIGxlZnRDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKScsXG4gIHJpZ2h0Q2FsbGJhY2s6ICcoZnVuY3Rpb258bnVsbCknXG59O1xuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBTd2lwZSBleHRlbmRzIENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgaWYgKCFlbGVtZW50IHx8ICFTd2lwZS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX2RlbHRhWCA9IDA7XG4gICAgdGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMgPSBCb29sZWFuKHdpbmRvdy5Qb2ludGVyRXZlbnQpO1xuICAgIHRoaXMuX2luaXRFdmVudHMoKTtcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0JGM7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGUkYztcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUUkZDtcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICBkaXNwb3NlKCkge1xuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZJDkpO1xuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfc3RhcnQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX3N1cHBvcnRQb2ludGVyRXZlbnRzKSB7XG4gICAgICB0aGlzLl9kZWx0YVggPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9ldmVudElzUG9pbnRlclBlblRvdWNoKGV2ZW50KSkge1xuICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQuY2xpZW50WDtcbiAgICB9XG4gIH1cbiAgX2VuZChldmVudCkge1xuICAgIGlmICh0aGlzLl9ldmVudElzUG9pbnRlclBlblRvdWNoKGV2ZW50KSkge1xuICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQuY2xpZW50WCAtIHRoaXMuX2RlbHRhWDtcbiAgICB9XG4gICAgdGhpcy5faGFuZGxlU3dpcGUoKTtcbiAgICBleGVjdXRlKHRoaXMuX2NvbmZpZy5lbmRDYWxsYmFjayk7XG4gIH1cbiAgX21vdmUoZXZlbnQpIHtcbiAgICB0aGlzLl9kZWx0YVggPSBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSA/IDAgOiBldmVudC50b3VjaGVzWzBdLmNsaWVudFggLSB0aGlzLl9kZWx0YVg7XG4gIH1cbiAgX2hhbmRsZVN3aXBlKCkge1xuICAgIGNvbnN0IGFic0RlbHRhWCA9IE1hdGguYWJzKHRoaXMuX2RlbHRhWCk7XG4gICAgaWYgKGFic0RlbHRhWCA8PSBTV0lQRV9USFJFU0hPTEQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGlyZWN0aW9uID0gYWJzRGVsdGFYIC8gdGhpcy5fZGVsdGFYO1xuICAgIHRoaXMuX2RlbHRhWCA9IDA7XG4gICAgaWYgKCFkaXJlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXhlY3V0ZShkaXJlY3Rpb24gPiAwID8gdGhpcy5fY29uZmlnLnJpZ2h0Q2FsbGJhY2sgOiB0aGlzLl9jb25maWcubGVmdENhbGxiYWNrKTtcbiAgfVxuICBfaW5pdEV2ZW50cygpIHtcbiAgICBpZiAodGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9QT0lOVEVSRE9XTiwgZXZlbnQgPT4gdGhpcy5fc3RhcnQoZXZlbnQpKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9QT0lOVEVSVVAsIGV2ZW50ID0+IHRoaXMuX2VuZChldmVudCkpO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfUE9JTlRFUl9FVkVOVCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9UT1VDSFNUQVJULCBldmVudCA9PiB0aGlzLl9zdGFydChldmVudCkpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNITU9WRSwgZXZlbnQgPT4gdGhpcy5fbW92ZShldmVudCkpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNIRU5ELCBldmVudCA9PiB0aGlzLl9lbmQoZXZlbnQpKTtcbiAgICB9XG4gIH1cbiAgX2V2ZW50SXNQb2ludGVyUGVuVG91Y2goZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMgJiYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSBQT0lOVEVSX1RZUEVfUEVOIHx8IGV2ZW50LnBvaW50ZXJUeXBlID09PSBQT0lOVEVSX1RZUEVfVE9VQ0gpO1xuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBpc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDA7XG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIGNhcm91c2VsLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkYyA9ICdjYXJvdXNlbCc7XG5jb25zdCBEQVRBX0tFWSQ4ID0gJ2JzLmNhcm91c2VsJztcbmNvbnN0IEVWRU5UX0tFWSQ4ID0gYC4ke0RBVEFfS0VZJDh9YDtcbmNvbnN0IERBVEFfQVBJX0tFWSQ1ID0gJy5kYXRhLWFwaSc7XG5jb25zdCBBUlJPV19MRUZUX0tFWSQxID0gJ0Fycm93TGVmdCc7XG5jb25zdCBBUlJPV19SSUdIVF9LRVkkMSA9ICdBcnJvd1JpZ2h0JztcbmNvbnN0IFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgPSA1MDA7IC8vIFRpbWUgZm9yIG1vdXNlIGNvbXBhdCBldmVudHMgdG8gZmlyZSBhZnRlciB0b3VjaFxuXG5jb25zdCBPUkRFUl9ORVhUID0gJ25leHQnO1xuY29uc3QgT1JERVJfUFJFViA9ICdwcmV2JztcbmNvbnN0IERJUkVDVElPTl9MRUZUID0gJ2xlZnQnO1xuY29uc3QgRElSRUNUSU9OX1JJR0hUID0gJ3JpZ2h0JztcbmNvbnN0IEVWRU5UX1NMSURFID0gYHNsaWRlJHtFVkVOVF9LRVkkOH1gO1xuY29uc3QgRVZFTlRfU0xJRCA9IGBzbGlkJHtFVkVOVF9LRVkkOH1gO1xuY29uc3QgRVZFTlRfS0VZRE9XTiQxID0gYGtleWRvd24ke0VWRU5UX0tFWSQ4fWA7XG5jb25zdCBFVkVOVF9NT1VTRUVOVEVSJDEgPSBgbW91c2VlbnRlciR7RVZFTlRfS0VZJDh9YDtcbmNvbnN0IEVWRU5UX01PVVNFTEVBVkUkMSA9IGBtb3VzZWxlYXZlJHtFVkVOVF9LRVkkOH1gO1xuY29uc3QgRVZFTlRfRFJBR19TVEFSVCA9IGBkcmFnc3RhcnQke0VWRU5UX0tFWSQ4fWA7XG5jb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJJDMgPSBgbG9hZCR7RVZFTlRfS0VZJDh9JHtEQVRBX0FQSV9LRVkkNX1gO1xuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNSA9IGBjbGljayR7RVZFTlRfS0VZJDh9JHtEQVRBX0FQSV9LRVkkNX1gO1xuY29uc3QgQ0xBU1NfTkFNRV9DQVJPVVNFTCA9ICdjYXJvdXNlbCc7XG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSQyID0gJ2FjdGl2ZSc7XG5jb25zdCBDTEFTU19OQU1FX1NMSURFID0gJ3NsaWRlJztcbmNvbnN0IENMQVNTX05BTUVfRU5EID0gJ2Nhcm91c2VsLWl0ZW0tZW5kJztcbmNvbnN0IENMQVNTX05BTUVfU1RBUlQgPSAnY2Fyb3VzZWwtaXRlbS1zdGFydCc7XG5jb25zdCBDTEFTU19OQU1FX05FWFQgPSAnY2Fyb3VzZWwtaXRlbS1uZXh0JztcbmNvbnN0IENMQVNTX05BTUVfUFJFViA9ICdjYXJvdXNlbC1pdGVtLXByZXYnO1xuY29uc3QgU0VMRUNUT1JfQUNUSVZFID0gJy5hY3RpdmUnO1xuY29uc3QgU0VMRUNUT1JfSVRFTSA9ICcuY2Fyb3VzZWwtaXRlbSc7XG5jb25zdCBTRUxFQ1RPUl9BQ1RJVkVfSVRFTSA9IFNFTEVDVE9SX0FDVElWRSArIFNFTEVDVE9SX0lURU07XG5jb25zdCBTRUxFQ1RPUl9JVEVNX0lNRyA9ICcuY2Fyb3VzZWwtaXRlbSBpbWcnO1xuY29uc3QgU0VMRUNUT1JfSU5ESUNBVE9SUyA9ICcuY2Fyb3VzZWwtaW5kaWNhdG9ycyc7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1NMSURFID0gJ1tkYXRhLWJzLXNsaWRlXSwgW2RhdGEtYnMtc2xpZGUtdG9dJztcbmNvbnN0IFNFTEVDVE9SX0RBVEFfUklERSA9ICdbZGF0YS1icy1yaWRlPVwiY2Fyb3VzZWxcIl0nO1xuY29uc3QgS0VZX1RPX0RJUkVDVElPTiA9IHtcbiAgW0FSUk9XX0xFRlRfS0VZJDFdOiBESVJFQ1RJT05fUklHSFQsXG4gIFtBUlJPV19SSUdIVF9LRVkkMV06IERJUkVDVElPTl9MRUZUXG59O1xuY29uc3QgRGVmYXVsdCRiID0ge1xuICBpbnRlcnZhbDogNTAwMCxcbiAga2V5Ym9hcmQ6IHRydWUsXG4gIHBhdXNlOiAnaG92ZXInLFxuICByaWRlOiBmYWxzZSxcbiAgdG91Y2g6IHRydWUsXG4gIHdyYXA6IHRydWVcbn07XG5jb25zdCBEZWZhdWx0VHlwZSRiID0ge1xuICBpbnRlcnZhbDogJyhudW1iZXJ8Ym9vbGVhbiknLFxuICAvLyBUT0RPOnY2IHJlbW92ZSBib29sZWFuIHN1cHBvcnRcbiAga2V5Ym9hcmQ6ICdib29sZWFuJyxcbiAgcGF1c2U6ICcoc3RyaW5nfGJvb2xlYW4pJyxcbiAgcmlkZTogJyhib29sZWFufHN0cmluZyknLFxuICB0b3VjaDogJ2Jvb2xlYW4nLFxuICB3cmFwOiAnYm9vbGVhbidcbn07XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIENhcm91c2VsIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xuICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gbnVsbDtcbiAgICB0aGlzLl9zd2lwZUhlbHBlciA9IG51bGw7XG4gICAgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0lORElDQVRPUlMsIHRoaXMuX2VsZW1lbnQpO1xuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5yaWRlID09PSBDTEFTU19OQU1FX0NBUk9VU0VMKSB7XG4gICAgICB0aGlzLmN5Y2xlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHQkYjtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZSRiO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSRjO1xuICB9XG5cbiAgLy8gUHVibGljXG4gIG5leHQoKSB7XG4gICAgdGhpcy5fc2xpZGUoT1JERVJfTkVYVCk7XG4gIH1cbiAgbmV4dFdoZW5WaXNpYmxlKCkge1xuICAgIC8vIEZJWE1FIFRPRE8gdXNlIGBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGVgXG4gICAgLy8gRG9uJ3QgY2FsbCBuZXh0IHdoZW4gdGhlIHBhZ2UgaXNuJ3QgdmlzaWJsZVxuICAgIC8vIG9yIHRoZSBjYXJvdXNlbCBvciBpdHMgcGFyZW50IGlzbid0IHZpc2libGVcbiAgICBpZiAoIWRvY3VtZW50LmhpZGRlbiAmJiBpc1Zpc2libGUodGhpcy5fZWxlbWVudCkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgfVxuICBwcmV2KCkge1xuICAgIHRoaXMuX3NsaWRlKE9SREVSX1BSRVYpO1xuICB9XG4gIHBhdXNlKCkge1xuICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgIHRyaWdnZXJUcmFuc2l0aW9uRW5kKHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cbiAgICB0aGlzLl9jbGVhckludGVydmFsKCk7XG4gIH1cbiAgY3ljbGUoKSB7XG4gICAgdGhpcy5fY2xlYXJJbnRlcnZhbCgpO1xuICAgIHRoaXMuX3VwZGF0ZUludGVydmFsKCk7XG4gICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLm5leHRXaGVuVmlzaWJsZSgpLCB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xuICB9XG4gIF9tYXliZUVuYWJsZUN5Y2xlKCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLnJpZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9TTElELCAoKSA9PiB0aGlzLmN5Y2xlKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN5Y2xlKCk7XG4gIH1cbiAgdG8oaW5kZXgpIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zKCk7XG4gICAgaWYgKGluZGV4ID4gaXRlbXMubGVuZ3RoIC0gMSB8fCBpbmRleCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9TTElELCAoKSA9PiB0aGlzLnRvKGluZGV4KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KHRoaXMuX2dldEFjdGl2ZSgpKTtcbiAgICBpZiAoYWN0aXZlSW5kZXggPT09IGluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9yZGVyID0gaW5kZXggPiBhY3RpdmVJbmRleCA/IE9SREVSX05FWFQgOiBPUkRFUl9QUkVWO1xuICAgIHRoaXMuX3NsaWRlKG9yZGVyLCBpdGVtc1tpbmRleF0pO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuX3N3aXBlSGVscGVyKSB7XG4gICAgICB0aGlzLl9zd2lwZUhlbHBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XG4gICAgY29uZmlnLmRlZmF1bHRJbnRlcnZhbCA9IGNvbmZpZy5pbnRlcnZhbDtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZRE9XTiQxLCBldmVudCA9PiB0aGlzLl9rZXlkb3duKGV2ZW50KSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jb25maWcucGF1c2UgPT09ICdob3ZlcicpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRUVOVEVSJDEsICgpID0+IHRoaXMucGF1c2UoKSk7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VMRUFWRSQxLCAoKSA9PiB0aGlzLl9tYXliZUVuYWJsZUN5Y2xlKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY29uZmlnLnRvdWNoICYmIFN3aXBlLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRoaXMuX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gIH1cbiAgX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgZm9yIChjb25zdCBpbWcgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNX0lNRywgdGhpcy5fZWxlbWVudCkpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbihpbWcsIEVWRU5UX0RSQUdfU1RBUlQsIGV2ZW50ID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCkpO1xuICAgIH1cbiAgICBjb25zdCBlbmRDYWxsQmFjayA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jb25maWcucGF1c2UgIT09ICdob3ZlcicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCdzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2UsIG1vdXNlZW50ZXIvbGVhdmUgYXJlIGZpcmVkIGFzXG4gICAgICAvLyBwYXJ0IG9mIHRoZSBtb3VzZSBjb21wYXRpYmlsaXR5IGV2ZW50cyBvbiBmaXJzdCB0YXAgLSB0aGUgY2Fyb3VzZWxcbiAgICAgIC8vIHdvdWxkIHN0b3AgY3ljbGluZyB1bnRpbCB1c2VyIHRhcHBlZCBvdXQgb2YgaXQ7XG4gICAgICAvLyBoZXJlLCB3ZSBsaXN0ZW4gZm9yIHRvdWNoZW5kLCBleHBsaWNpdGx5IHBhdXNlIHRoZSBjYXJvdXNlbFxuICAgICAgLy8gKGFzIGlmIGl0J3MgdGhlIHNlY29uZCB0aW1lIHdlIHRhcCBvbiBpdCwgbW91c2VlbnRlciBjb21wYXQgZXZlbnRcbiAgICAgIC8vIGlzIE5PVCBmaXJlZCkgYW5kIGFmdGVyIGEgdGltZW91dCAodG8gYWxsb3cgZm9yIG1vdXNlIGNvbXBhdGliaWxpdHlcbiAgICAgIC8vIGV2ZW50cyB0byBmaXJlKSB3ZSBleHBsaWNpdGx5IHJlc3RhcnQgY3ljbGluZ1xuXG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICBpZiAodGhpcy50b3VjaFRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudG91Y2hUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9tYXliZUVuYWJsZUN5Y2xlKCksIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgKyB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xuICAgIH07XG4gICAgY29uc3Qgc3dpcGVDb25maWcgPSB7XG4gICAgICBsZWZ0Q2FsbGJhY2s6ICgpID0+IHRoaXMuX3NsaWRlKHRoaXMuX2RpcmVjdGlvblRvT3JkZXIoRElSRUNUSU9OX0xFRlQpKSxcbiAgICAgIHJpZ2h0Q2FsbGJhY2s6ICgpID0+IHRoaXMuX3NsaWRlKHRoaXMuX2RpcmVjdGlvblRvT3JkZXIoRElSRUNUSU9OX1JJR0hUKSksXG4gICAgICBlbmRDYWxsYmFjazogZW5kQ2FsbEJhY2tcbiAgICB9O1xuICAgIHRoaXMuX3N3aXBlSGVscGVyID0gbmV3IFN3aXBlKHRoaXMuX2VsZW1lbnQsIHN3aXBlQ29uZmlnKTtcbiAgfVxuICBfa2V5ZG93bihldmVudCkge1xuICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBLRVlfVE9fRElSRUNUSU9OW2V2ZW50LmtleV07XG4gICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuX3NsaWRlKHRoaXMuX2RpcmVjdGlvblRvT3JkZXIoZGlyZWN0aW9uKSk7XG4gICAgfVxuICB9XG4gIF9nZXRJdGVtSW5kZXgoZWxlbWVudCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRJdGVtcygpLmluZGV4T2YoZWxlbWVudCk7XG4gIH1cbiAgX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQoaW5kZXgpIHtcbiAgICBpZiAoIXRoaXMuX2luZGljYXRvcnNFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZUluZGljYXRvciA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFLCB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCk7XG4gICAgYWN0aXZlSW5kaWNhdG9yLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XG4gICAgYWN0aXZlSW5kaWNhdG9yLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1jdXJyZW50Jyk7XG4gICAgY29uc3QgbmV3QWN0aXZlSW5kaWNhdG9yID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShgW2RhdGEtYnMtc2xpZGUtdG89XCIke2luZGV4fVwiXWAsIHRoaXMuX2luZGljYXRvcnNFbGVtZW50KTtcbiAgICBpZiAobmV3QWN0aXZlSW5kaWNhdG9yKSB7XG4gICAgICBuZXdBY3RpdmVJbmRpY2F0b3IuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQyKTtcbiAgICAgIG5ld0FjdGl2ZUluZGljYXRvci5zZXRBdHRyaWJ1dGUoJ2FyaWEtY3VycmVudCcsICd0cnVlJyk7XG4gICAgfVxuICB9XG4gIF91cGRhdGVJbnRlcnZhbCgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fYWN0aXZlRWxlbWVudCB8fCB0aGlzLl9nZXRBY3RpdmUoKTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudEludGVydmFsID0gTnVtYmVyLnBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLWludGVydmFsJyksIDEwKTtcbiAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSBlbGVtZW50SW50ZXJ2YWwgfHwgdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbDtcbiAgfVxuICBfc2xpZGUob3JkZXIsIGVsZW1lbnQgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gdGhpcy5fZ2V0QWN0aXZlKCk7XG4gICAgY29uc3QgaXNOZXh0ID0gb3JkZXIgPT09IE9SREVSX05FWFQ7XG4gICAgY29uc3QgbmV4dEVsZW1lbnQgPSBlbGVtZW50IHx8IGdldE5leHRBY3RpdmVFbGVtZW50KHRoaXMuX2dldEl0ZW1zKCksIGFjdGl2ZUVsZW1lbnQsIGlzTmV4dCwgdGhpcy5fY29uZmlnLndyYXApO1xuICAgIGlmIChuZXh0RWxlbWVudCA9PT0gYWN0aXZlRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXh0RWxlbWVudEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KG5leHRFbGVtZW50KTtcbiAgICBjb25zdCB0cmlnZ2VyRXZlbnQgPSBldmVudE5hbWUgPT4ge1xuICAgICAgcmV0dXJuIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGV2ZW50TmFtZSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBuZXh0RWxlbWVudCxcbiAgICAgICAgZGlyZWN0aW9uOiB0aGlzLl9vcmRlclRvRGlyZWN0aW9uKG9yZGVyKSxcbiAgICAgICAgZnJvbTogdGhpcy5fZ2V0SXRlbUluZGV4KGFjdGl2ZUVsZW1lbnQpLFxuICAgICAgICB0bzogbmV4dEVsZW1lbnRJbmRleFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzbGlkZUV2ZW50ID0gdHJpZ2dlckV2ZW50KEVWRU5UX1NMSURFKTtcbiAgICBpZiAoc2xpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghYWN0aXZlRWxlbWVudCB8fCAhbmV4dEVsZW1lbnQpIHtcbiAgICAgIC8vIFNvbWUgd2VpcmRuZXNzIGlzIGhhcHBlbmluZywgc28gd2UgYmFpbFxuICAgICAgLy8gVE9ETzogY2hhbmdlIHRlc3RzIHRoYXQgdXNlIGVtcHR5IGRpdnMgdG8gYXZvaWQgdGhpcyBjaGVja1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc0N5Y2xpbmcgPSBCb29sZWFuKHRoaXMuX2ludGVydmFsKTtcbiAgICB0aGlzLnBhdXNlKCk7XG4gICAgdGhpcy5faXNTbGlkaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG5leHRFbGVtZW50SW5kZXgpO1xuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICBjb25zdCBkaXJlY3Rpb25hbENsYXNzTmFtZSA9IGlzTmV4dCA/IENMQVNTX05BTUVfU1RBUlQgOiBDTEFTU19OQU1FX0VORDtcbiAgICBjb25zdCBvcmRlckNsYXNzTmFtZSA9IGlzTmV4dCA/IENMQVNTX05BTUVfTkVYVCA6IENMQVNTX05BTUVfUFJFVjtcbiAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKG9yZGVyQ2xhc3NOYW1lKTtcbiAgICByZWZsb3cobmV4dEVsZW1lbnQpO1xuICAgIGFjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG4gICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG4gICAgY29uc3QgY29tcGxldGVDYWxsQmFjayA9ICgpID0+IHtcbiAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoZGlyZWN0aW9uYWxDbGFzc05hbWUsIG9yZGVyQ2xhc3NOYW1lKTtcbiAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XG4gICAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMiwgb3JkZXJDbGFzc05hbWUsIGRpcmVjdGlvbmFsQ2xhc3NOYW1lKTtcbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xuICAgICAgdHJpZ2dlckV2ZW50KEVWRU5UX1NMSUQpO1xuICAgIH07XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZUNhbGxCYWNrLCBhY3RpdmVFbGVtZW50LCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xuICAgIGlmIChpc0N5Y2xpbmcpIHtcbiAgICAgIHRoaXMuY3ljbGUoKTtcbiAgICB9XG4gIH1cbiAgX2lzQW5pbWF0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0xJREUpO1xuICB9XG4gIF9nZXRBY3RpdmUoKSB7XG4gICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFX0lURU0sIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIF9nZXRJdGVtcygpIHtcbiAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBfY2xlYXJJbnRlcnZhbCgpIHtcbiAgICBpZiAodGhpcy5faW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xuICAgIH1cbiAgfVxuICBfZGlyZWN0aW9uVG9PcmRlcihkaXJlY3Rpb24pIHtcbiAgICBpZiAoaXNSVEwoKSkge1xuICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQgPyBPUkRFUl9QUkVWIDogT1JERVJfTkVYVDtcbiAgICB9XG4gICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQgPyBPUkRFUl9ORVhUIDogT1JERVJfUFJFVjtcbiAgfVxuICBfb3JkZXJUb0RpcmVjdGlvbihvcmRlcikge1xuICAgIGlmIChpc1JUTCgpKSB7XG4gICAgICByZXR1cm4gb3JkZXIgPT09IE9SREVSX1BSRVYgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICB9XG4gICAgcmV0dXJuIG9yZGVyID09PSBPUkRFUl9QUkVWID8gRElSRUNUSU9OX1JJR0hUIDogRElSRUNUSU9OX0xFRlQ7XG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBDYXJvdXNlbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZGF0YS50byhjb25maWcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cblxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQ1LCBTRUxFQ1RPUl9EQVRBX1NMSURFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKTtcbiAgaWYgKCF0YXJnZXQgfHwgIXRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9DQVJPVVNFTCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgY29uc3QgY2Fyb3VzZWwgPSBDYXJvdXNlbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XG4gIGNvbnN0IHNsaWRlSW5kZXggPSB0aGlzLmdldEF0dHJpYnV0ZSgnZGF0YS1icy1zbGlkZS10bycpO1xuICBpZiAoc2xpZGVJbmRleCkge1xuICAgIGNhcm91c2VsLnRvKHNsaWRlSW5kZXgpO1xuICAgIGNhcm91c2VsLl9tYXliZUVuYWJsZUN5Y2xlKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlKHRoaXMsICdzbGlkZScpID09PSAnbmV4dCcpIHtcbiAgICBjYXJvdXNlbC5uZXh0KCk7XG4gICAgY2Fyb3VzZWwuX21heWJlRW5hYmxlQ3ljbGUoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY2Fyb3VzZWwucHJldigpO1xuICBjYXJvdXNlbC5fbWF5YmVFbmFibGVDeWNsZSgpO1xufSk7XG5FdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJJDMsICgpID0+IHtcbiAgY29uc3QgY2Fyb3VzZWxzID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1JJREUpO1xuICBmb3IgKGNvbnN0IGNhcm91c2VsIG9mIGNhcm91c2Vscykge1xuICAgIENhcm91c2VsLmdldE9yQ3JlYXRlSW5zdGFuY2UoY2Fyb3VzZWwpO1xuICB9XG59KTtcblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oQ2Fyb3VzZWwpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgY29sbGFwc2UuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTkFNRSRiID0gJ2NvbGxhcHNlJztcbmNvbnN0IERBVEFfS0VZJDcgPSAnYnMuY29sbGFwc2UnO1xuY29uc3QgRVZFTlRfS0VZJDcgPSBgLiR7REFUQV9LRVkkN31gO1xuY29uc3QgREFUQV9BUElfS0VZJDQgPSAnLmRhdGEtYXBpJztcbmNvbnN0IEVWRU5UX1NIT1ckNiA9IGBzaG93JHtFVkVOVF9LRVkkN31gO1xuY29uc3QgRVZFTlRfU0hPV04kNiA9IGBzaG93biR7RVZFTlRfS0VZJDd9YDtcbmNvbnN0IEVWRU5UX0hJREUkNiA9IGBoaWRlJHtFVkVOVF9LRVkkN31gO1xuY29uc3QgRVZFTlRfSElEREVOJDYgPSBgaGlkZGVuJHtFVkVOVF9LRVkkN31gO1xuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNCA9IGBjbGljayR7RVZFTlRfS0VZJDd9JHtEQVRBX0FQSV9LRVkkNH1gO1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDcgPSAnc2hvdyc7XG5jb25zdCBDTEFTU19OQU1FX0NPTExBUFNFID0gJ2NvbGxhcHNlJztcbmNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0lORyA9ICdjb2xsYXBzaW5nJztcbmNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0VEID0gJ2NvbGxhcHNlZCc7XG5jb25zdCBDTEFTU19OQU1FX0RFRVBFUl9DSElMRFJFTiA9IGA6c2NvcGUgLiR7Q0xBU1NfTkFNRV9DT0xMQVBTRX0gLiR7Q0xBU1NfTkFNRV9DT0xMQVBTRX1gO1xuY29uc3QgQ0xBU1NfTkFNRV9IT1JJWk9OVEFMID0gJ2NvbGxhcHNlLWhvcml6b250YWwnO1xuY29uc3QgV0lEVEggPSAnd2lkdGgnO1xuY29uc3QgSEVJR0hUID0gJ2hlaWdodCc7XG5jb25zdCBTRUxFQ1RPUl9BQ1RJVkVTID0gJy5jb2xsYXBzZS5zaG93LCAuY29sbGFwc2UuY29sbGFwc2luZyc7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0ID0gJ1tkYXRhLWJzLXRvZ2dsZT1cImNvbGxhcHNlXCJdJztcbmNvbnN0IERlZmF1bHQkYSA9IHtcbiAgcGFyZW50OiBudWxsLFxuICB0b2dnbGU6IHRydWVcbn07XG5jb25zdCBEZWZhdWx0VHlwZSRhID0ge1xuICBwYXJlbnQ6ICcobnVsbHxlbGVtZW50KScsXG4gIHRvZ2dsZTogJ2Jvb2xlYW4nXG59O1xuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBDb2xsYXBzZSBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3RyaWdnZXJBcnJheSA9IFtdO1xuICAgIGNvbnN0IHRvZ2dsZUxpc3QgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQpO1xuICAgIGZvciAoY29uc3QgZWxlbSBvZiB0b2dnbGVMaXN0KSB7XG4gICAgICBjb25zdCBzZWxlY3RvciA9IFNlbGVjdG9yRW5naW5lLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbSk7XG4gICAgICBjb25zdCBmaWx0ZXJFbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3RvcikuZmlsdGVyKGZvdW5kRWxlbWVudCA9PiBmb3VuZEVsZW1lbnQgPT09IHRoaXMuX2VsZW1lbnQpO1xuICAgICAgaWYgKHNlbGVjdG9yICE9PSBudWxsICYmIGZpbHRlckVsZW1lbnQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJBcnJheS5wdXNoKGVsZW0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsaXplQ2hpbGRyZW4oKTtcbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl90cmlnZ2VyQXJyYXksIHRoaXMuX2lzU2hvd24oKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jb25maWcudG9nZ2xlKSB7XG4gICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0JGE7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGUkYTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUUkYjtcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cbiAgfVxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgdGhpcy5faXNTaG93bigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBhY3RpdmVDaGlsZHJlbiA9IFtdO1xuXG4gICAgLy8gZmluZCBhY3RpdmUgY2hpbGRyZW5cbiAgICBpZiAodGhpcy5fY29uZmlnLnBhcmVudCkge1xuICAgICAgYWN0aXZlQ2hpbGRyZW4gPSB0aGlzLl9nZXRGaXJzdExldmVsQ2hpbGRyZW4oU0VMRUNUT1JfQUNUSVZFUykuZmlsdGVyKGVsZW1lbnQgPT4gZWxlbWVudCAhPT0gdGhpcy5fZWxlbWVudCkubWFwKGVsZW1lbnQgPT4gQ29sbGFwc2UuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50LCB7XG4gICAgICAgIHRvZ2dsZTogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKGFjdGl2ZUNoaWxkcmVuLmxlbmd0aCAmJiBhY3RpdmVDaGlsZHJlblswXS5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDYpO1xuICAgIGlmIChzdGFydEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBhY3RpdmVJbnN0YW5jZSBvZiBhY3RpdmVDaGlsZHJlbikge1xuICAgICAgYWN0aXZlSW5zdGFuY2UuaGlkZSgpO1xuICAgIH1cbiAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKTtcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTRSk7XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gMDtcbiAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fdHJpZ2dlckFycmF5LCB0cnVlKTtcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNFLCBDTEFTU19OQU1FX1NIT1ckNyk7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAnJztcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDYpO1xuICAgIH07XG4gICAgY29uc3QgY2FwaXRhbGl6ZWREaW1lbnNpb24gPSBkaW1lbnNpb25bMF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSgxKTtcbiAgICBjb25zdCBzY3JvbGxTaXplID0gYHNjcm9sbCR7Y2FwaXRhbGl6ZWREaW1lbnNpb259YDtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0cnVlKTtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSBgJHt0aGlzLl9lbGVtZW50W3Njcm9sbFNpemVdfXB4YDtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgIXRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGFydEV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQ2KTtcbiAgICBpZiAoc3RhcnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpO1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IGAke3RoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZGltZW5zaW9uXX1weGA7XG4gICAgcmVmbG93KHRoaXMuX2VsZW1lbnQpO1xuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0NPTExBUFNFLCBDTEFTU19OQU1FX1NIT1ckNyk7XG4gICAgZm9yIChjb25zdCB0cmlnZ2VyIG9mIHRoaXMuX3RyaWdnZXJBcnJheSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IodHJpZ2dlcik7XG4gICAgICBpZiAoZWxlbWVudCAmJiAhdGhpcy5faXNTaG93bihlbGVtZW50KSkge1xuICAgICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoW3RyaWdnZXJdLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0UpO1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDYpO1xuICAgIH07XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9pc1Nob3duKGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ3KTtcbiAgfVxuICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcbiAgICBjb25maWcudG9nZ2xlID0gQm9vbGVhbihjb25maWcudG9nZ2xlKTsgLy8gQ29lcmNlIHN0cmluZyB2YWx1ZXNcbiAgICBjb25maWcucGFyZW50ID0gZ2V0RWxlbWVudChjb25maWcucGFyZW50KTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIF9nZXREaW1lbnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfSE9SSVpPTlRBTCkgPyBXSURUSCA6IEhFSUdIVDtcbiAgfVxuICBfaW5pdGlhbGl6ZUNoaWxkcmVuKCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2dldEZpcnN0TGV2ZWxDaGlsZHJlbihTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0KTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KTtcbiAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoW2VsZW1lbnRdLCB0aGlzLl9pc1Nob3duKHNlbGVjdGVkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9nZXRGaXJzdExldmVsQ2hpbGRyZW4oc2VsZWN0b3IpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IFNlbGVjdG9yRW5naW5lLmZpbmQoQ0xBU1NfTkFNRV9ERUVQRVJfQ0hJTERSRU4sIHRoaXMuX2NvbmZpZy5wYXJlbnQpO1xuICAgIC8vIHJlbW92ZSBjaGlsZHJlbiBpZiBncmVhdGVyIGRlcHRoXG4gICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IsIHRoaXMuX2NvbmZpZy5wYXJlbnQpLmZpbHRlcihlbGVtZW50ID0+ICFjaGlsZHJlbi5pbmNsdWRlcyhlbGVtZW50KSk7XG4gIH1cbiAgX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0cmlnZ2VyQXJyYXksIGlzT3Blbikge1xuICAgIGlmICghdHJpZ2dlckFycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdHJpZ2dlckFycmF5KSB7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoQ0xBU1NfTkFNRV9DT0xMQVBTRUQsICFpc09wZW4pO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBpc09wZW4pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIGNvbnN0IF9jb25maWcgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycgJiYgL3Nob3d8aGlkZS8udGVzdChjb25maWcpKSB7XG4gICAgICBfY29uZmlnLnRvZ2dsZSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBDb2xsYXBzZS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIF9jb25maWcpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNCwgU0VMRUNUT1JfREFUQV9UT0dHTEUkNCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIHByZXZlbnREZWZhdWx0IG9ubHkgZm9yIDxhPiBlbGVtZW50cyAod2hpY2ggY2hhbmdlIHRoZSBVUkwpIG5vdCBpbnNpZGUgdGhlIGNvbGxhcHNpYmxlIGVsZW1lbnRcbiAgaWYgKGV2ZW50LnRhcmdldC50YWdOYW1lID09PSAnQScgfHwgZXZlbnQuZGVsZWdhdGVUYXJnZXQgJiYgZXZlbnQuZGVsZWdhdGVUYXJnZXQudGFnTmFtZSA9PT0gJ0EnKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgU2VsZWN0b3JFbmdpbmUuZ2V0TXVsdGlwbGVFbGVtZW50c0Zyb21TZWxlY3Rvcih0aGlzKSkge1xuICAgIENvbGxhcHNlLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCwge1xuICAgICAgdG9nZ2xlOiBmYWxzZVxuICAgIH0pLnRvZ2dsZSgpO1xuICB9XG59KTtcblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oQ29sbGFwc2UpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgZHJvcGRvd24uanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTkFNRSRhID0gJ2Ryb3Bkb3duJztcbmNvbnN0IERBVEFfS0VZJDYgPSAnYnMuZHJvcGRvd24nO1xuY29uc3QgRVZFTlRfS0VZJDYgPSBgLiR7REFUQV9LRVkkNn1gO1xuY29uc3QgREFUQV9BUElfS0VZJDMgPSAnLmRhdGEtYXBpJztcbmNvbnN0IEVTQ0FQRV9LRVkkMiA9ICdFc2NhcGUnO1xuY29uc3QgVEFCX0tFWSQxID0gJ1RhYic7XG5jb25zdCBBUlJPV19VUF9LRVkkMSA9ICdBcnJvd1VwJztcbmNvbnN0IEFSUk9XX0RPV05fS0VZJDEgPSAnQXJyb3dEb3duJztcbmNvbnN0IFJJR0hUX01PVVNFX0JVVFRPTiA9IDI7IC8vIE1vdXNlRXZlbnQuYnV0dG9uIHZhbHVlIGZvciB0aGUgc2Vjb25kYXJ5IGJ1dHRvbiwgdXN1YWxseSB0aGUgcmlnaHQgYnV0dG9uXG5cbmNvbnN0IEVWRU5UX0hJREUkNSA9IGBoaWRlJHtFVkVOVF9LRVkkNn1gO1xuY29uc3QgRVZFTlRfSElEREVOJDUgPSBgaGlkZGVuJHtFVkVOVF9LRVkkNn1gO1xuY29uc3QgRVZFTlRfU0hPVyQ1ID0gYHNob3cke0VWRU5UX0tFWSQ2fWA7XG5jb25zdCBFVkVOVF9TSE9XTiQ1ID0gYHNob3duJHtFVkVOVF9LRVkkNn1gO1xuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMyA9IGBjbGljayR7RVZFTlRfS0VZJDZ9JHtEQVRBX0FQSV9LRVkkM31gO1xuY29uc3QgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSA9IGBrZXlkb3duJHtFVkVOVF9LRVkkNn0ke0RBVEFfQVBJX0tFWSQzfWA7XG5jb25zdCBFVkVOVF9LRVlVUF9EQVRBX0FQSSA9IGBrZXl1cCR7RVZFTlRfS0VZJDZ9JHtEQVRBX0FQSV9LRVkkM31gO1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDYgPSAnc2hvdyc7XG5jb25zdCBDTEFTU19OQU1FX0RST1BVUCA9ICdkcm9wdXAnO1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QRU5EID0gJ2Ryb3BlbmQnO1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QU1RBUlQgPSAnZHJvcHN0YXJ0JztcbmNvbnN0IENMQVNTX05BTUVfRFJPUFVQX0NFTlRFUiA9ICdkcm9wdXAtY2VudGVyJztcbmNvbnN0IENMQVNTX05BTUVfRFJPUERPV05fQ0VOVEVSID0gJ2Ryb3Bkb3duLWNlbnRlcic7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzID0gJ1tkYXRhLWJzLXRvZ2dsZT1cImRyb3Bkb3duXCJdOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpJztcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFX1NIT1dOID0gYCR7U0VMRUNUT1JfREFUQV9UT0dHTEUkM30uJHtDTEFTU19OQU1FX1NIT1ckNn1gO1xuY29uc3QgU0VMRUNUT1JfTUVOVSA9ICcuZHJvcGRvd24tbWVudSc7XG5jb25zdCBTRUxFQ1RPUl9OQVZCQVIgPSAnLm5hdmJhcic7XG5jb25zdCBTRUxFQ1RPUl9OQVZCQVJfTkFWID0gJy5uYXZiYXItbmF2JztcbmNvbnN0IFNFTEVDVE9SX1ZJU0lCTEVfSVRFTVMgPSAnLmRyb3Bkb3duLW1lbnUgLmRyb3Bkb3duLWl0ZW06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZCknO1xuY29uc3QgUExBQ0VNRU5UX1RPUCA9IGlzUlRMKCkgPyAndG9wLWVuZCcgOiAndG9wLXN0YXJ0JztcbmNvbnN0IFBMQUNFTUVOVF9UT1BFTkQgPSBpc1JUTCgpID8gJ3RvcC1zdGFydCcgOiAndG9wLWVuZCc7XG5jb25zdCBQTEFDRU1FTlRfQk9UVE9NID0gaXNSVEwoKSA/ICdib3R0b20tZW5kJyA6ICdib3R0b20tc3RhcnQnO1xuY29uc3QgUExBQ0VNRU5UX0JPVFRPTUVORCA9IGlzUlRMKCkgPyAnYm90dG9tLXN0YXJ0JyA6ICdib3R0b20tZW5kJztcbmNvbnN0IFBMQUNFTUVOVF9SSUdIVCA9IGlzUlRMKCkgPyAnbGVmdC1zdGFydCcgOiAncmlnaHQtc3RhcnQnO1xuY29uc3QgUExBQ0VNRU5UX0xFRlQgPSBpc1JUTCgpID8gJ3JpZ2h0LXN0YXJ0JyA6ICdsZWZ0LXN0YXJ0JztcbmNvbnN0IFBMQUNFTUVOVF9UT1BDRU5URVIgPSAndG9wJztcbmNvbnN0IFBMQUNFTUVOVF9CT1RUT01DRU5URVIgPSAnYm90dG9tJztcbmNvbnN0IERlZmF1bHQkOSA9IHtcbiAgYXV0b0Nsb3NlOiB0cnVlLFxuICBib3VuZGFyeTogJ2NsaXBwaW5nUGFyZW50cycsXG4gIGRpc3BsYXk6ICdkeW5hbWljJyxcbiAgb2Zmc2V0OiBbMCwgMl0sXG4gIHBvcHBlckNvbmZpZzogbnVsbCxcbiAgcmVmZXJlbmNlOiAndG9nZ2xlJ1xufTtcbmNvbnN0IERlZmF1bHRUeXBlJDkgPSB7XG4gIGF1dG9DbG9zZTogJyhib29sZWFufHN0cmluZyknLFxuICBib3VuZGFyeTogJyhzdHJpbmd8ZWxlbWVudCknLFxuICBkaXNwbGF5OiAnc3RyaW5nJyxcbiAgb2Zmc2V0OiAnKGFycmF5fHN0cmluZ3xmdW5jdGlvbiknLFxuICBwb3BwZXJDb25maWc6ICcobnVsbHxvYmplY3R8ZnVuY3Rpb24pJyxcbiAgcmVmZXJlbmNlOiAnKHN0cmluZ3xlbGVtZW50fG9iamVjdCknXG59O1xuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBEcm9wZG93biBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XG4gICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlOyAvLyBkcm9wZG93biB3cmFwcGVyXG4gICAgLy8gVE9ETzogdjYgcmV2ZXJ0ICMzNzAxMSAmIGNoYW5nZSBtYXJrdXAgaHR0cHM6Ly9nZXRib290c3RyYXAuY29tL2RvY3MvNS4zL2Zvcm1zL2lucHV0LWdyb3VwL1xuICAgIHRoaXMuX21lbnUgPSBTZWxlY3RvckVuZ2luZS5uZXh0KHRoaXMuX2VsZW1lbnQsIFNFTEVDVE9SX01FTlUpWzBdIHx8IFNlbGVjdG9yRW5naW5lLnByZXYodGhpcy5fZWxlbWVudCwgU0VMRUNUT1JfTUVOVSlbMF0gfHwgU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9NRU5VLCB0aGlzLl9wYXJlbnQpO1xuICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCk7XG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCQ5O1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlJDk7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJGE7XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Nob3duKCkgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKGlzRGlzYWJsZWQodGhpcy5fZWxlbWVudCkgfHwgdGhpcy5faXNTaG93bigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfTtcbiAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDUsIHJlbGF0ZWRUYXJnZXQpO1xuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jcmVhdGVQb3BwZXIoKTtcblxuICAgIC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSBhZGQgZXh0cmFcbiAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xuICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXG4gICAgLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDE0LzAyL21vdXNlX2V2ZW50X2J1Yi5odG1sXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhdGhpcy5fcGFyZW50LmNsb3Nlc3QoU0VMRUNUT1JfTkFWQkFSX05BVikpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSk7XG4gICAgdGhpcy5fbWVudS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ2KTtcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDYpO1xuICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDUsIHJlbGF0ZWRUYXJnZXQpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKGlzRGlzYWJsZWQodGhpcy5fZWxlbWVudCkgfHwgIXRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgIH07XG4gICAgdGhpcy5fY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuX3BvcHBlcikge1xuICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpO1xuICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgIHRoaXMuX3BvcHBlci51cGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9jb21wbGV0ZUhpZGUocmVsYXRlZFRhcmdldCkge1xuICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkNSwgcmVsYXRlZFRhcmdldCk7XG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcbiAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCAnbW91c2VvdmVyJywgbm9vcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuX21lbnUuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckNik7XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ2KTtcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgIE1hbmlwdWxhdG9yLnJlbW92ZURhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgJ3BvcHBlcicpO1xuICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQ1LCByZWxhdGVkVGFyZ2V0KTtcblxuICAgIC8vIEV4cGxpY2l0bHkgcmV0dXJuIGZvY3VzIHRvIHRoZSB0cmlnZ2VyIGVsZW1lbnRcbiAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XG4gIH1cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSBzdXBlci5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmZXJlbmNlID09PSAnb2JqZWN0JyAmJiAhaXNFbGVtZW50KGNvbmZpZy5yZWZlcmVuY2UpICYmIHR5cGVvZiBjb25maWcucmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gUG9wcGVyIHZpcnR1YWwgZWxlbWVudHMgcmVxdWlyZSBhIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBtZXRob2RcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7TkFNRSRhLnRvVXBwZXJDYXNlKCl9OiBPcHRpb24gXCJyZWZlcmVuY2VcIiBwcm92aWRlZCB0eXBlIFwib2JqZWN0XCIgd2l0aG91dCBhIHJlcXVpcmVkIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIgbWV0aG9kLmApO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIF9jcmVhdGVQb3BwZXIoKSB7XG4gICAgaWYgKHR5cGVvZiBQb3BwZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXCdzIGRyb3Bkb3ducyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnL2RvY3MvdjIvKScpO1xuICAgIH1cbiAgICBsZXQgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09ICdwYXJlbnQnKSB7XG4gICAgICByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fcGFyZW50O1xuICAgIH0gZWxzZSBpZiAoaXNFbGVtZW50KHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpKSB7XG4gICAgICByZWZlcmVuY2VFbGVtZW50ID0gZ2V0RWxlbWVudCh0aGlzLl9jb25maWcucmVmZXJlbmNlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9jb25maWcucmVmZXJlbmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX2NvbmZpZy5yZWZlcmVuY2U7XG4gICAgfVxuICAgIGNvbnN0IHBvcHBlckNvbmZpZyA9IHRoaXMuX2dldFBvcHBlckNvbmZpZygpO1xuICAgIHRoaXMuX3BvcHBlciA9IFBvcHBlci5jcmVhdGVQb3BwZXIocmVmZXJlbmNlRWxlbWVudCwgdGhpcy5fbWVudSwgcG9wcGVyQ29uZmlnKTtcbiAgfVxuICBfaXNTaG93bigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVudS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDYpO1xuICB9XG4gIF9nZXRQbGFjZW1lbnQoKSB7XG4gICAgY29uc3QgcGFyZW50RHJvcGRvd24gPSB0aGlzLl9wYXJlbnQ7XG4gICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BFTkQpKSB7XG4gICAgICByZXR1cm4gUExBQ0VNRU5UX1JJR0hUO1xuICAgIH1cbiAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUFNUQVJUKSkge1xuICAgICAgcmV0dXJuIFBMQUNFTUVOVF9MRUZUO1xuICAgIH1cbiAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUFVQX0NFTlRFUikpIHtcbiAgICAgIHJldHVybiBQTEFDRU1FTlRfVE9QQ0VOVEVSO1xuICAgIH1cbiAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUERPV05fQ0VOVEVSKSkge1xuICAgICAgcmV0dXJuIFBMQUNFTUVOVF9CT1RUT01DRU5URVI7XG4gICAgfVxuXG4gICAgLy8gV2UgbmVlZCB0byB0cmltIHRoZSB2YWx1ZSBiZWNhdXNlIGN1c3RvbSBwcm9wZXJ0aWVzIGNhbiBhbHNvIGluY2x1ZGUgc3BhY2VzXG4gICAgY29uc3QgaXNFbmQgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX21lbnUpLmdldFByb3BlcnR5VmFsdWUoJy0tYnMtcG9zaXRpb24nKS50cmltKCkgPT09ICdlbmQnO1xuICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QVVApKSB7XG4gICAgICByZXR1cm4gaXNFbmQgPyBQTEFDRU1FTlRfVE9QRU5EIDogUExBQ0VNRU5UX1RPUDtcbiAgICB9XG4gICAgcmV0dXJuIGlzRW5kID8gUExBQ0VNRU5UX0JPVFRPTUVORCA6IFBMQUNFTUVOVF9CT1RUT007XG4gIH1cbiAgX2RldGVjdE5hdmJhcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX05BVkJBUikgIT09IG51bGw7XG4gIH1cbiAgX2dldE9mZnNldCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBvZmZzZXRcbiAgICB9ID0gdGhpcy5fY29uZmlnO1xuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG9mZnNldC5zcGxpdCgnLCcpLm1hcCh2YWx1ZSA9PiBOdW1iZXIucGFyc2VJbnQodmFsdWUsIDEwKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcG9wcGVyRGF0YSA9PiBvZmZzZXQocG9wcGVyRGF0YSwgdGhpcy5fZWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cbiAgX2dldFBvcHBlckNvbmZpZygpIHtcbiAgICBjb25zdCBkZWZhdWx0QnNQb3BwZXJDb25maWcgPSB7XG4gICAgICBwbGFjZW1lbnQ6IHRoaXMuX2dldFBsYWNlbWVudCgpLFxuICAgICAgbW9kaWZpZXJzOiBbe1xuICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgfVxuICAgICAgfV1cbiAgICB9O1xuXG4gICAgLy8gRGlzYWJsZSBQb3BwZXIgaWYgd2UgaGF2ZSBhIHN0YXRpYyBkaXNwbGF5IG9yIERyb3Bkb3duIGlzIGluIE5hdmJhclxuICAgIGlmICh0aGlzLl9pbk5hdmJhciB8fCB0aGlzLl9jb25maWcuZGlzcGxheSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgIE1hbmlwdWxhdG9yLnNldERhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgJ3BvcHBlcicsICdzdGF0aWMnKTsgLy8gVE9ETzogdjYgcmVtb3ZlXG4gICAgICBkZWZhdWx0QnNQb3BwZXJDb25maWcubW9kaWZpZXJzID0gW3tcbiAgICAgICAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGVmYXVsdEJzUG9wcGVyQ29uZmlnLFxuICAgICAgLi4uZXhlY3V0ZSh0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnLCBbdW5kZWZpbmVkLCBkZWZhdWx0QnNQb3BwZXJDb25maWddKVxuICAgIH07XG4gIH1cbiAgX3NlbGVjdE1lbnVJdGVtKHtcbiAgICBrZXksXG4gICAgdGFyZ2V0XG4gIH0pIHtcbiAgICBjb25zdCBpdGVtcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfVklTSUJMRV9JVEVNUywgdGhpcy5fbWVudSkuZmlsdGVyKGVsZW1lbnQgPT4gaXNWaXNpYmxlKGVsZW1lbnQpKTtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIHRhcmdldCBpc24ndCBpbmNsdWRlZCBpbiBpdGVtcyAoZS5nLiB3aGVuIGV4cGFuZGluZyB0aGUgZHJvcGRvd24pXG4gICAgLy8gYWxsb3cgY3ljbGluZyB0byBnZXQgdGhlIGxhc3QgaXRlbSBpbiBjYXNlIGtleSBlcXVhbHMgQVJST1dfVVBfS0VZXG4gICAgZ2V0TmV4dEFjdGl2ZUVsZW1lbnQoaXRlbXMsIHRhcmdldCwga2V5ID09PSBBUlJPV19ET1dOX0tFWSQxLCAhaXRlbXMuaW5jbHVkZXModGFyZ2V0KSkuZm9jdXMoKTtcbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IERyb3Bkb3duLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgIH1cbiAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBjbGVhck1lbnVzKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gUklHSFRfTU9VU0VfQlVUVE9OIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQua2V5ICE9PSBUQUJfS0VZJDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3BlblRvZ2dsZXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFX1NIT1dOKTtcbiAgICBmb3IgKGNvbnN0IHRvZ2dsZSBvZiBvcGVuVG9nZ2xlcykge1xuICAgICAgY29uc3QgY29udGV4dCA9IERyb3Bkb3duLmdldEluc3RhbmNlKHRvZ2dsZSk7XG4gICAgICBpZiAoIWNvbnRleHQgfHwgY29udGV4dC5fY29uZmlnLmF1dG9DbG9zZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjb21wb3NlZFBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICAgIGNvbnN0IGlzTWVudVRhcmdldCA9IGNvbXBvc2VkUGF0aC5pbmNsdWRlcyhjb250ZXh0Ll9tZW51KTtcbiAgICAgIGlmIChjb21wb3NlZFBhdGguaW5jbHVkZXMoY29udGV4dC5fZWxlbWVudCkgfHwgY29udGV4dC5fY29uZmlnLmF1dG9DbG9zZSA9PT0gJ2luc2lkZScgJiYgIWlzTWVudVRhcmdldCB8fCBjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSAnb3V0c2lkZScgJiYgaXNNZW51VGFyZ2V0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBUYWIgbmF2aWdhdGlvbiB0aHJvdWdoIHRoZSBkcm9wZG93biBtZW51IG9yIGV2ZW50cyBmcm9tIGNvbnRhaW5lZCBpbnB1dHMgc2hvdWxkbid0IGNsb3NlIHRoZSBtZW51XG4gICAgICBpZiAoY29udGV4dC5fbWVudS5jb250YWlucyhldmVudC50YXJnZXQpICYmIChldmVudC50eXBlID09PSAna2V5dXAnICYmIGV2ZW50LmtleSA9PT0gVEFCX0tFWSQxIHx8IC9pbnB1dHxzZWxlY3R8b3B0aW9ufHRleHRhcmVhfGZvcm0vaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBjb250ZXh0Ll9lbGVtZW50XG4gICAgICB9O1xuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldC5jbGlja0V2ZW50ID0gZXZlbnQ7XG4gICAgICB9XG4gICAgICBjb250ZXh0Ll9jb21wbGV0ZUhpZGUocmVsYXRlZFRhcmdldCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBkYXRhQXBpS2V5ZG93bkhhbmRsZXIoZXZlbnQpIHtcbiAgICAvLyBJZiBub3QgYW4gVVAgfCBET1dOIHwgRVNDQVBFIGtleSA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG4gICAgLy8gSWYgaW5wdXQvdGV4dGFyZWEgJiYgaWYga2V5IGlzIG90aGVyIHRoYW4gRVNDQVBFID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcblxuICAgIGNvbnN0IGlzSW5wdXQgPSAvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKTtcbiAgICBjb25zdCBpc0VzY2FwZUV2ZW50ID0gZXZlbnQua2V5ID09PSBFU0NBUEVfS0VZJDI7XG4gICAgY29uc3QgaXNVcE9yRG93bkV2ZW50ID0gW0FSUk9XX1VQX0tFWSQxLCBBUlJPV19ET1dOX0tFWSQxXS5pbmNsdWRlcyhldmVudC5rZXkpO1xuICAgIGlmICghaXNVcE9yRG93bkV2ZW50ICYmICFpc0VzY2FwZUV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0lucHV0ICYmICFpc0VzY2FwZUV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAvLyBUT0RPOiB2NiByZXZlcnQgIzM3MDExICYgY2hhbmdlIG1hcmt1cCBodHRwczovL2dldGJvb3RzdHJhcC5jb20vZG9jcy81LjMvZm9ybXMvaW5wdXQtZ3JvdXAvXG4gICAgY29uc3QgZ2V0VG9nZ2xlQnV0dG9uID0gdGhpcy5tYXRjaGVzKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMpID8gdGhpcyA6IFNlbGVjdG9yRW5naW5lLnByZXYodGhpcywgU0VMRUNUT1JfREFUQV9UT0dHTEUkMylbMF0gfHwgU2VsZWN0b3JFbmdpbmUubmV4dCh0aGlzLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzKVswXSB8fCBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMsIGV2ZW50LmRlbGVnYXRlVGFyZ2V0LnBhcmVudE5vZGUpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gRHJvcGRvd24uZ2V0T3JDcmVhdGVJbnN0YW5jZShnZXRUb2dnbGVCdXR0b24pO1xuICAgIGlmIChpc1VwT3JEb3duRXZlbnQpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaW5zdGFuY2Uuc2hvdygpO1xuICAgICAgaW5zdGFuY2UuX3NlbGVjdE1lbnVJdGVtKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlLl9pc1Nob3duKCkpIHtcbiAgICAgIC8vIGVsc2UgaXMgZXNjYXBlIGFuZCB3ZSBjaGVjayBpZiBpdCBpcyBzaG93blxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBpbnN0YW5jZS5oaWRlKCk7XG4gICAgICBnZXRUb2dnbGVCdXR0b24uZm9jdXMoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUkMywgRHJvcGRvd24uZGF0YUFwaUtleWRvd25IYW5kbGVyKTtcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfTUVOVSwgRHJvcGRvd24uZGF0YUFwaUtleWRvd25IYW5kbGVyKTtcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMywgRHJvcGRvd24uY2xlYXJNZW51cyk7XG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWVVQX0RBVEFfQVBJLCBEcm9wZG93bi5jbGVhck1lbnVzKTtcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMywgU0VMRUNUT1JfREFUQV9UT0dHTEUkMywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIERyb3Bkb3duLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykudG9nZ2xlKCk7XG59KTtcblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oRHJvcGRvd24pO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgdXRpbC9iYWNrZHJvcC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FJDkgPSAnYmFja2Ryb3AnO1xuY29uc3QgQ0xBU1NfTkFNRV9GQURFJDQgPSAnZmFkZSc7XG5jb25zdCBDTEFTU19OQU1FX1NIT1ckNSA9ICdzaG93JztcbmNvbnN0IEVWRU5UX01PVVNFRE9XTiA9IGBtb3VzZWRvd24uYnMuJHtOQU1FJDl9YDtcbmNvbnN0IERlZmF1bHQkOCA9IHtcbiAgY2xhc3NOYW1lOiAnbW9kYWwtYmFja2Ryb3AnLFxuICBjbGlja0NhbGxiYWNrOiBudWxsLFxuICBpc0FuaW1hdGVkOiBmYWxzZSxcbiAgaXNWaXNpYmxlOiB0cnVlLFxuICAvLyBpZiBmYWxzZSwgd2UgdXNlIHRoZSBiYWNrZHJvcCBoZWxwZXIgd2l0aG91dCBhZGRpbmcgYW55IGVsZW1lbnQgdG8gdGhlIGRvbVxuICByb290RWxlbWVudDogJ2JvZHknIC8vIGdpdmUgdGhlIGNob2ljZSB0byBwbGFjZSBiYWNrZHJvcCB1bmRlciBkaWZmZXJlbnQgZWxlbWVudHNcbn07XG5jb25zdCBEZWZhdWx0VHlwZSQ4ID0ge1xuICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICBjbGlja0NhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJyxcbiAgaXNBbmltYXRlZDogJ2Jvb2xlYW4nLFxuICBpc1Zpc2libGU6ICdib29sZWFuJyxcbiAgcm9vdEVsZW1lbnQ6ICcoZWxlbWVudHxzdHJpbmcpJ1xufTtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgQmFja2Ryb3AgZXh0ZW5kcyBDb25maWcge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX2lzQXBwZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0JDg7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGUkODtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUUkOTtcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICBzaG93KGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XG4gICAgICBleGVjdXRlKGNhbGxiYWNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fYXBwZW5kKCk7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2dldEVsZW1lbnQoKTtcbiAgICBpZiAodGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpIHtcbiAgICAgIHJlZmxvdyhlbGVtZW50KTtcbiAgICB9XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ1KTtcbiAgICB0aGlzLl9lbXVsYXRlQW5pbWF0aW9uKCgpID0+IHtcbiAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xuICAgIH0pO1xuICB9XG4gIGhpZGUoY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5pc1Zpc2libGUpIHtcbiAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9nZXRFbGVtZW50KCkuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckNSk7XG4gICAgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xuICAgIH0pO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKCF0aGlzLl9pc0FwcGVuZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VET1dOKTtcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZSgpO1xuICAgIHRoaXMuX2lzQXBwZW5kZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2dldEVsZW1lbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9lbGVtZW50KSB7XG4gICAgICBjb25zdCBiYWNrZHJvcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgYmFja2Ryb3AuY2xhc3NOYW1lID0gdGhpcy5fY29uZmlnLmNsYXNzTmFtZTtcbiAgICAgIGlmICh0aGlzLl9jb25maWcuaXNBbmltYXRlZCkge1xuICAgICAgICBiYWNrZHJvcC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSQ0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBiYWNrZHJvcDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gIH1cbiAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XG4gICAgLy8gdXNlIGdldEVsZW1lbnQoKSB3aXRoIHRoZSBkZWZhdWx0IFwiYm9keVwiIHRvIGdldCBhIGZyZXNoIEVsZW1lbnQgb24gZWFjaCBpbnN0YW50aWF0aW9uXG4gICAgY29uZmlnLnJvb3RFbGVtZW50ID0gZ2V0RWxlbWVudChjb25maWcucm9vdEVsZW1lbnQpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbiAgX2FwcGVuZCgpIHtcbiAgICBpZiAodGhpcy5faXNBcHBlbmRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZ2V0RWxlbWVudCgpO1xuICAgIHRoaXMuX2NvbmZpZy5yb290RWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgRXZlbnRIYW5kbGVyLm9uKGVsZW1lbnQsIEVWRU5UX01PVVNFRE9XTiwgKCkgPT4ge1xuICAgICAgZXhlY3V0ZSh0aGlzLl9jb25maWcuY2xpY2tDYWxsYmFjayk7XG4gICAgfSk7XG4gICAgdGhpcy5faXNBcHBlbmRlZCA9IHRydWU7XG4gIH1cbiAgX2VtdWxhdGVBbmltYXRpb24oY2FsbGJhY2spIHtcbiAgICBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uKGNhbGxiYWNrLCB0aGlzLl9nZXRFbGVtZW50KCksIHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkKTtcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgdXRpbC9mb2N1c3RyYXAuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTkFNRSQ4ID0gJ2ZvY3VzdHJhcCc7XG5jb25zdCBEQVRBX0tFWSQ1ID0gJ2JzLmZvY3VzdHJhcCc7XG5jb25zdCBFVkVOVF9LRVkkNSA9IGAuJHtEQVRBX0tFWSQ1fWA7XG5jb25zdCBFVkVOVF9GT0NVU0lOJDIgPSBgZm9jdXNpbiR7RVZFTlRfS0VZJDV9YDtcbmNvbnN0IEVWRU5UX0tFWURPV05fVEFCID0gYGtleWRvd24udGFiJHtFVkVOVF9LRVkkNX1gO1xuY29uc3QgVEFCX0tFWSA9ICdUYWInO1xuY29uc3QgVEFCX05BVl9GT1JXQVJEID0gJ2ZvcndhcmQnO1xuY29uc3QgVEFCX05BVl9CQUNLV0FSRCA9ICdiYWNrd2FyZCc7XG5jb25zdCBEZWZhdWx0JDcgPSB7XG4gIGF1dG9mb2N1czogdHJ1ZSxcbiAgdHJhcEVsZW1lbnQ6IG51bGwgLy8gVGhlIGVsZW1lbnQgdG8gdHJhcCBmb2N1cyBpbnNpZGUgb2Zcbn07XG5jb25zdCBEZWZhdWx0VHlwZSQ3ID0ge1xuICBhdXRvZm9jdXM6ICdib29sZWFuJyxcbiAgdHJhcEVsZW1lbnQ6ICdlbGVtZW50J1xufTtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgRm9jdXNUcmFwIGV4dGVuZHMgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuX2xhc3RUYWJOYXZEaXJlY3Rpb24gPSBudWxsO1xuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHQkNztcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZSQ3O1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSQ4O1xuICB9XG5cbiAgLy8gUHVibGljXG4gIGFjdGl2YXRlKCkge1xuICAgIGlmICh0aGlzLl9pc0FjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY29uZmlnLmF1dG9mb2N1cykge1xuICAgICAgdGhpcy5fY29uZmlnLnRyYXBFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICAgIEV2ZW50SGFuZGxlci5vZmYoZG9jdW1lbnQsIEVWRU5UX0tFWSQ1KTsgLy8gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXG4gICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOJDIsIGV2ZW50ID0+IHRoaXMuX2hhbmRsZUZvY3VzaW4oZXZlbnQpKTtcbiAgICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWURPV05fVEFCLCBldmVudCA9PiB0aGlzLl9oYW5kbGVLZXlkb3duKGV2ZW50KSk7XG4gICAgdGhpcy5faXNBY3RpdmUgPSB0cnVlO1xuICB9XG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc0FjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIEV2ZW50SGFuZGxlci5vZmYoZG9jdW1lbnQsIEVWRU5UX0tFWSQ1KTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2hhbmRsZUZvY3VzaW4oZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICB0cmFwRWxlbWVudFxuICAgIH0gPSB0aGlzLl9jb25maWc7XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gZG9jdW1lbnQgfHwgZXZlbnQudGFyZ2V0ID09PSB0cmFwRWxlbWVudCB8fCB0cmFwRWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gU2VsZWN0b3JFbmdpbmUuZm9jdXNhYmxlQ2hpbGRyZW4odHJhcEVsZW1lbnQpO1xuICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRyYXBFbGVtZW50LmZvY3VzKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID09PSBUQUJfTkFWX0JBQ0tXQVJEKSB7XG4gICAgICBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXS5mb2N1cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50c1swXS5mb2N1cygpO1xuICAgIH1cbiAgfVxuICBfaGFuZGxlS2V5ZG93bihldmVudCkge1xuICAgIGlmIChldmVudC5rZXkgIT09IFRBQl9LRVkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbGFzdFRhYk5hdkRpcmVjdGlvbiA9IGV2ZW50LnNoaWZ0S2V5ID8gVEFCX05BVl9CQUNLV0FSRCA6IFRBQl9OQVZfRk9SV0FSRDtcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgdXRpbC9zY3JvbGxCYXIuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgU0VMRUNUT1JfRklYRURfQ09OVEVOVCA9ICcuZml4ZWQtdG9wLCAuZml4ZWQtYm90dG9tLCAuaXMtZml4ZWQsIC5zdGlja3ktdG9wJztcbmNvbnN0IFNFTEVDVE9SX1NUSUNLWV9DT05URU5UID0gJy5zdGlja3ktdG9wJztcbmNvbnN0IFBST1BFUlRZX1BBRERJTkcgPSAncGFkZGluZy1yaWdodCc7XG5jb25zdCBQUk9QRVJUWV9NQVJHSU4gPSAnbWFyZ2luLXJpZ2h0JztcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgU2Nyb2xsQmFySGVscGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IGRvY3VtZW50LmJvZHk7XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgZ2V0V2lkdGgoKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9pbm5lcldpZHRoI3VzYWdlX25vdGVzXG4gICAgY29uc3QgZG9jdW1lbnRXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICByZXR1cm4gTWF0aC5hYnMod2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudFdpZHRoKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgIHRoaXMuX2Rpc2FibGVPdmVyRmxvdygpO1xuICAgIC8vIGdpdmUgcGFkZGluZyB0byBlbGVtZW50IHRvIGJhbGFuY2UgdGhlIGhpZGRlbiBzY3JvbGxiYXIgd2lkdGhcbiAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCBQUk9QRVJUWV9QQURESU5HLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlICsgd2lkdGgpO1xuICAgIC8vIHRyaWNrOiBXZSBhZGp1c3QgcG9zaXRpdmUgcGFkZGluZ1JpZ2h0IGFuZCBuZWdhdGl2ZSBtYXJnaW5SaWdodCB0byBzdGlja3ktdG9wIGVsZW1lbnRzIHRvIGtlZXAgc2hvd2luZyBmdWxsd2lkdGhcbiAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9GSVhFRF9DT05URU5ULCBQUk9QRVJUWV9QQURESU5HLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlICsgd2lkdGgpO1xuICAgIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX1NUSUNLWV9DT05URU5ULCBQUk9QRVJUWV9NQVJHSU4sIGNhbGN1bGF0ZWRWYWx1ZSA9PiBjYWxjdWxhdGVkVmFsdWUgLSB3aWR0aCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCAnb3ZlcmZsb3cnKTtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsIFBST1BFUlRZX1BBRERJTkcpO1xuICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfRklYRURfQ09OVEVOVCwgUFJPUEVSVFlfUEFERElORyk7XG4gICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCwgUFJPUEVSVFlfTUFSR0lOKTtcbiAgfVxuICBpc092ZXJmbG93aW5nKCkge1xuICAgIHJldHVybiB0aGlzLmdldFdpZHRoKCkgPiAwO1xuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfZGlzYWJsZU92ZXJGbG93KCkge1xuICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKHRoaXMuX2VsZW1lbnQsICdvdmVyZmxvdycpO1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgfVxuICBfc2V0RWxlbWVudEF0dHJpYnV0ZXMoc2VsZWN0b3IsIHN0eWxlUHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgY29uc3QgbWFuaXB1bGF0aW9uQ2FsbEJhY2sgPSBlbGVtZW50ID0+IHtcbiAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9lbGVtZW50ICYmIHdpbmRvdy5pbm5lcldpZHRoID4gZWxlbWVudC5jbGllbnRXaWR0aCArIHNjcm9sbGJhcldpZHRoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpO1xuICAgICAgY29uc3QgY2FsY3VsYXRlZFZhbHVlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShzdHlsZVByb3BlcnR5KTtcbiAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVQcm9wZXJ0eSwgYCR7Y2FsbGJhY2soTnVtYmVyLnBhcnNlRmxvYXQoY2FsY3VsYXRlZFZhbHVlKSl9cHhgKTtcbiAgICB9O1xuICAgIHRoaXMuX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2soc2VsZWN0b3IsIG1hbmlwdWxhdGlvbkNhbGxCYWNrKTtcbiAgfVxuICBfc2F2ZUluaXRpYWxBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSkge1xuICAgIGNvbnN0IGFjdHVhbFZhbHVlID0gZWxlbWVudC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHN0eWxlUHJvcGVydHkpO1xuICAgIGlmIChhY3R1YWxWYWx1ZSkge1xuICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5LCBhY3R1YWxWYWx1ZSk7XG4gICAgfVxuICB9XG4gIF9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHNlbGVjdG9yLCBzdHlsZVByb3BlcnR5KSB7XG4gICAgY29uc3QgbWFuaXB1bGF0aW9uQ2FsbEJhY2sgPSBlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5KTtcbiAgICAgIC8vIFdlIG9ubHkgd2FudCB0byByZW1vdmUgdGhlIHByb3BlcnR5IGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGA7IHRoZSB2YWx1ZSBjYW4gYWxzbyBiZSB6ZXJvXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShzdHlsZVByb3BlcnR5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgTWFuaXB1bGF0b3IucmVtb3ZlRGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5KTtcbiAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgIH07XG4gICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayhzZWxlY3RvciwgbWFuaXB1bGF0aW9uQ2FsbEJhY2spO1xuICB9XG4gIF9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHNlbGVjdG9yLCBjYWxsQmFjaykge1xuICAgIGlmIChpc0VsZW1lbnQoc2VsZWN0b3IpKSB7XG4gICAgICBjYWxsQmFjayhzZWxlY3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc2VsIG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IsIHRoaXMuX2VsZW1lbnQpKSB7XG4gICAgICBjYWxsQmFjayhzZWwpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgbW9kYWwuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTkFNRSQ3ID0gJ21vZGFsJztcbmNvbnN0IERBVEFfS0VZJDQgPSAnYnMubW9kYWwnO1xuY29uc3QgRVZFTlRfS0VZJDQgPSBgLiR7REFUQV9LRVkkNH1gO1xuY29uc3QgREFUQV9BUElfS0VZJDIgPSAnLmRhdGEtYXBpJztcbmNvbnN0IEVTQ0FQRV9LRVkkMSA9ICdFc2NhcGUnO1xuY29uc3QgRVZFTlRfSElERSQ0ID0gYGhpZGUke0VWRU5UX0tFWSQ0fWA7XG5jb25zdCBFVkVOVF9ISURFX1BSRVZFTlRFRCQxID0gYGhpZGVQcmV2ZW50ZWQke0VWRU5UX0tFWSQ0fWA7XG5jb25zdCBFVkVOVF9ISURERU4kNCA9IGBoaWRkZW4ke0VWRU5UX0tFWSQ0fWA7XG5jb25zdCBFVkVOVF9TSE9XJDQgPSBgc2hvdyR7RVZFTlRfS0VZJDR9YDtcbmNvbnN0IEVWRU5UX1NIT1dOJDQgPSBgc2hvd24ke0VWRU5UX0tFWSQ0fWA7XG5jb25zdCBFVkVOVF9SRVNJWkUkMSA9IGByZXNpemUke0VWRU5UX0tFWSQ0fWA7XG5jb25zdCBFVkVOVF9DTElDS19ESVNNSVNTID0gYGNsaWNrLmRpc21pc3Mke0VWRU5UX0tFWSQ0fWA7XG5jb25zdCBFVkVOVF9NT1VTRURPV05fRElTTUlTUyA9IGBtb3VzZWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZJDR9YDtcbmNvbnN0IEVWRU5UX0tFWURPV05fRElTTUlTUyQxID0gYGtleWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZJDR9YDtcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDIgPSBgY2xpY2ske0VWRU5UX0tFWSQ0fSR7REFUQV9BUElfS0VZJDJ9YDtcbmNvbnN0IENMQVNTX05BTUVfT1BFTiA9ICdtb2RhbC1vcGVuJztcbmNvbnN0IENMQVNTX05BTUVfRkFERSQzID0gJ2ZhZGUnO1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDQgPSAnc2hvdyc7XG5jb25zdCBDTEFTU19OQU1FX1NUQVRJQyA9ICdtb2RhbC1zdGF0aWMnO1xuY29uc3QgT1BFTl9TRUxFQ1RPUiQxID0gJy5tb2RhbC5zaG93JztcbmNvbnN0IFNFTEVDVE9SX0RJQUxPRyA9ICcubW9kYWwtZGlhbG9nJztcbmNvbnN0IFNFTEVDVE9SX01PREFMX0JPRFkgPSAnLm1vZGFsLWJvZHknO1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkMiA9ICdbZGF0YS1icy10b2dnbGU9XCJtb2RhbFwiXSc7XG5jb25zdCBEZWZhdWx0JDYgPSB7XG4gIGJhY2tkcm9wOiB0cnVlLFxuICBmb2N1czogdHJ1ZSxcbiAga2V5Ym9hcmQ6IHRydWVcbn07XG5jb25zdCBEZWZhdWx0VHlwZSQ2ID0ge1xuICBiYWNrZHJvcDogJyhib29sZWFufHN0cmluZyknLFxuICBmb2N1czogJ2Jvb2xlYW4nLFxuICBrZXlib2FyZDogJ2Jvb2xlYW4nXG59O1xuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBNb2RhbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuICAgIHRoaXMuX2RpYWxvZyA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfRElBTE9HLCB0aGlzLl9lbGVtZW50KTtcbiAgICB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpO1xuICAgIHRoaXMuX2ZvY3VzdHJhcCA9IHRoaXMuX2luaXRpYWxpemVGb2N1c1RyYXAoKTtcbiAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fc2Nyb2xsQmFyID0gbmV3IFNjcm9sbEJhckhlbHBlcigpO1xuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCQ2O1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlJDY7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJDc7XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKHJlbGF0ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHJlbGF0ZWRUYXJnZXQpO1xuICB9XG4gIHNob3cocmVsYXRlZFRhcmdldCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duIHx8IHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDQsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICB9KTtcbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faXNTaG93biA9IHRydWU7XG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpO1xuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX09QRU4pO1xuICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xuICAgIHRoaXMuX2JhY2tkcm9wLnNob3coKCkgPT4gdGhpcy5fc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCkpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Nob3duIHx8IHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDQpO1xuICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpO1xuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckNCk7XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB0aGlzLl9oaWRlTW9kYWwoKSwgdGhpcy5fZWxlbWVudCwgdGhpcy5faXNBbmltYXRlZCgpKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIEV2ZW50SGFuZGxlci5vZmYod2luZG93LCBFVkVOVF9LRVkkNCk7XG4gICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9kaWFsb2csIEVWRU5UX0tFWSQ0KTtcbiAgICB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCk7XG4gICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKTtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgaGFuZGxlVXBkYXRlKCkge1xuICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgIHJldHVybiBuZXcgQmFja2Ryb3Aoe1xuICAgICAgaXNWaXNpYmxlOiBCb29sZWFuKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCksXG4gICAgICAvLyAnc3RhdGljJyBvcHRpb24gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRydWUsIGFuZCBib29sZWFucyB3aWxsIGtlZXAgdGhlaXIgdmFsdWUsXG4gICAgICBpc0FuaW1hdGVkOiB0aGlzLl9pc0FuaW1hdGVkKClcbiAgICB9KTtcbiAgfVxuICBfaW5pdGlhbGl6ZUZvY3VzVHJhcCgpIHtcbiAgICByZXR1cm4gbmV3IEZvY3VzVHJhcCh7XG4gICAgICB0cmFwRWxlbWVudDogdGhpcy5fZWxlbWVudFxuICAgIH0pO1xuICB9XG4gIF9zaG93RWxlbWVudChyZWxhdGVkVGFyZ2V0KSB7XG4gICAgLy8gdHJ5IHRvIGFwcGVuZCBkeW5hbWljIG1vZGFsXG4gICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZCh0aGlzLl9lbGVtZW50KTtcbiAgICB9XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcsIHRydWUpO1xuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpO1xuICAgIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMDtcbiAgICBjb25zdCBtb2RhbEJvZHkgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX01PREFMX0JPRFksIHRoaXMuX2RpYWxvZyk7XG4gICAgaWYgKG1vZGFsQm9keSkge1xuICAgICAgbW9kYWxCb2R5LnNjcm9sbFRvcCA9IDA7XG4gICAgfVxuICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KTtcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDQpO1xuICAgIGNvbnN0IHRyYW5zaXRpb25Db21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jb25maWcuZm9jdXMpIHtcbiAgICAgICAgdGhpcy5fZm9jdXN0cmFwLmFjdGl2YXRlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDQsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldFxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKHRyYW5zaXRpb25Db21wbGV0ZSwgdGhpcy5fZGlhbG9nLCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xuICB9XG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZRE9XTl9ESVNNSVNTJDEsIGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC5rZXkgIT09IEVTQ0FQRV9LRVkkMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XG4gICAgfSk7XG4gICAgRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfUkVTSVpFJDEsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duICYmICF0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgdGhpcy5fYWRqdXN0RGlhbG9nKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFRE9XTl9ESVNNSVNTLCBldmVudCA9PiB7XG4gICAgICAvLyBhIGJhZCB0cmljayB0byBzZWdyZWdhdGUgY2xpY2tzIHRoYXQgbWF5IHN0YXJ0IGluc2lkZSBkaWFsb2cgYnV0IGVuZCBvdXRzaWRlLCBhbmQgYXZvaWQgbGlzdGVuIHRvIHNjcm9sbGJhciBjbGlja3NcbiAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgRVZFTlRfQ0xJQ0tfRElTTUlTUywgZXZlbnQyID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQgIT09IGV2ZW50LnRhcmdldCB8fCB0aGlzLl9lbGVtZW50ICE9PSBldmVudDIudGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3AgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgdGhpcy5fdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wKSB7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9oaWRlTW9kYWwoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW1vZGFsJyk7XG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9iYWNrZHJvcC5oaWRlKCgpID0+IHtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX09QRU4pO1xuICAgICAgdGhpcy5fcmVzZXRBZGp1c3RtZW50cygpO1xuICAgICAgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCk7XG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kNCk7XG4gICAgfSk7XG4gIH1cbiAgX2lzQW5pbWF0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQzKTtcbiAgfVxuICBfdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpIHtcbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFX1BSRVZFTlRFRCQxKTtcbiAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNNb2RhbE92ZXJmbG93aW5nID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIGNvbnN0IGluaXRpYWxPdmVyZmxvd1kgPSB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WTtcbiAgICAvLyByZXR1cm4gaWYgdGhlIGZvbGxvd2luZyBiYWNrZ3JvdW5kIHRyYW5zaXRpb24gaGFzbid0IHlldCBjb21wbGV0ZWRcbiAgICBpZiAoaW5pdGlhbE92ZXJmbG93WSA9PT0gJ2hpZGRlbicgfHwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TVEFUSUMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9ICdoaWRkZW4nO1xuICAgIH1cbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TVEFUSUMpO1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU1RBVElDKTtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9IGluaXRpYWxPdmVyZmxvd1k7XG4gICAgICB9LCB0aGlzLl9kaWFsb2cpO1xuICAgIH0sIHRoaXMuX2RpYWxvZyk7XG4gICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgdXNlZCB0byBoYW5kbGUgb3ZlcmZsb3dpbmcgbW9kYWxzXG4gICAqL1xuXG4gIF9hZGp1c3REaWFsb2coKSB7XG4gICAgY29uc3QgaXNNb2RhbE92ZXJmbG93aW5nID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIGNvbnN0IHNjcm9sbGJhcldpZHRoID0gdGhpcy5fc2Nyb2xsQmFyLmdldFdpZHRoKCk7XG4gICAgY29uc3QgaXNCb2R5T3ZlcmZsb3dpbmcgPSBzY3JvbGxiYXJXaWR0aCA+IDA7XG4gICAgaWYgKGlzQm9keU92ZXJmbG93aW5nICYmICFpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgIGNvbnN0IHByb3BlcnR5ID0gaXNSVEwoKSA/ICdwYWRkaW5nTGVmdCcgOiAncGFkZGluZ1JpZ2h0JztcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbcHJvcGVydHldID0gYCR7c2Nyb2xsYmFyV2lkdGh9cHhgO1xuICAgIH1cbiAgICBpZiAoIWlzQm9keU92ZXJmbG93aW5nICYmIGlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSBpc1JUTCgpID8gJ3BhZGRpbmdSaWdodCcgOiAncGFkZGluZ0xlZnQnO1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSBgJHtzY3JvbGxiYXJXaWR0aH1weGA7XG4gICAgfVxuICB9XG4gIF9yZXNldEFkanVzdG1lbnRzKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSAnJztcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnLCByZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gTW9kYWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgfVxuICAgICAgZGF0YVtjb25maWddKHJlbGF0ZWRUYXJnZXQpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAqL1xuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDIsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDIsIGZ1bmN0aW9uIChldmVudCkge1xuICBjb25zdCB0YXJnZXQgPSBTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpO1xuICBpZiAoWydBJywgJ0FSRUEnXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBFdmVudEhhbmRsZXIub25lKHRhcmdldCwgRVZFTlRfU0hPVyQ0LCBzaG93RXZlbnQgPT4ge1xuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgLy8gb25seSByZWdpc3RlciBmb2N1cyByZXN0b3JlciBpZiBtb2RhbCB3aWxsIGFjdHVhbGx5IGdldCBzaG93blxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBFdmVudEhhbmRsZXIub25lKHRhcmdldCwgRVZFTlRfSElEREVOJDQsICgpID0+IHtcbiAgICAgIGlmIChpc1Zpc2libGUodGhpcykpIHtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyBhdm9pZCBjb25mbGljdCB3aGVuIGNsaWNraW5nIG1vZGFsIHRvZ2dsZXIgd2hpbGUgYW5vdGhlciBvbmUgaXMgb3BlblxuICBjb25zdCBhbHJlYWR5T3BlbiA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoT1BFTl9TRUxFQ1RPUiQxKTtcbiAgaWYgKGFscmVhZHlPcGVuKSB7XG4gICAgTW9kYWwuZ2V0SW5zdGFuY2UoYWxyZWFkeU9wZW4pLmhpZGUoKTtcbiAgfVxuICBjb25zdCBkYXRhID0gTW9kYWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpO1xuICBkYXRhLnRvZ2dsZSh0aGlzKTtcbn0pO1xuZW5hYmxlRGlzbWlzc1RyaWdnZXIoTW9kYWwpO1xuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihNb2RhbCk7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCBvZmZjYW52YXMuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTkFNRSQ2ID0gJ29mZmNhbnZhcyc7XG5jb25zdCBEQVRBX0tFWSQzID0gJ2JzLm9mZmNhbnZhcyc7XG5jb25zdCBFVkVOVF9LRVkkMyA9IGAuJHtEQVRBX0tFWSQzfWA7XG5jb25zdCBEQVRBX0FQSV9LRVkkMSA9ICcuZGF0YS1hcGknO1xuY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSQyID0gYGxvYWQke0VWRU5UX0tFWSQzfSR7REFUQV9BUElfS0VZJDF9YDtcbmNvbnN0IEVTQ0FQRV9LRVkgPSAnRXNjYXBlJztcbmNvbnN0IENMQVNTX05BTUVfU0hPVyQzID0gJ3Nob3cnO1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XSU5HJDEgPSAnc2hvd2luZyc7XG5jb25zdCBDTEFTU19OQU1FX0hJRElORyA9ICdoaWRpbmcnO1xuY29uc3QgQ0xBU1NfTkFNRV9CQUNLRFJPUCA9ICdvZmZjYW52YXMtYmFja2Ryb3AnO1xuY29uc3QgT1BFTl9TRUxFQ1RPUiA9ICcub2ZmY2FudmFzLnNob3cnO1xuY29uc3QgRVZFTlRfU0hPVyQzID0gYHNob3cke0VWRU5UX0tFWSQzfWA7XG5jb25zdCBFVkVOVF9TSE9XTiQzID0gYHNob3duJHtFVkVOVF9LRVkkM31gO1xuY29uc3QgRVZFTlRfSElERSQzID0gYGhpZGUke0VWRU5UX0tFWSQzfWA7XG5jb25zdCBFVkVOVF9ISURFX1BSRVZFTlRFRCA9IGBoaWRlUHJldmVudGVkJHtFVkVOVF9LRVkkM31gO1xuY29uc3QgRVZFTlRfSElEREVOJDMgPSBgaGlkZGVuJHtFVkVOVF9LRVkkM31gO1xuY29uc3QgRVZFTlRfUkVTSVpFID0gYHJlc2l6ZSR7RVZFTlRfS0VZJDN9YDtcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDEgPSBgY2xpY2ske0VWRU5UX0tFWSQzfSR7REFUQV9BUElfS0VZJDF9YDtcbmNvbnN0IEVWRU5UX0tFWURPV05fRElTTUlTUyA9IGBrZXlkb3duLmRpc21pc3Mke0VWRU5UX0tFWSQzfWA7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxID0gJ1tkYXRhLWJzLXRvZ2dsZT1cIm9mZmNhbnZhc1wiXSc7XG5jb25zdCBEZWZhdWx0JDUgPSB7XG4gIGJhY2tkcm9wOiB0cnVlLFxuICBrZXlib2FyZDogdHJ1ZSxcbiAgc2Nyb2xsOiBmYWxzZVxufTtcbmNvbnN0IERlZmF1bHRUeXBlJDUgPSB7XG4gIGJhY2tkcm9wOiAnKGJvb2xlYW58c3RyaW5nKScsXG4gIGtleWJvYXJkOiAnYm9vbGVhbicsXG4gIHNjcm9sbDogJ2Jvb2xlYW4nXG59O1xuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBPZmZjYW52YXMgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcbiAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG4gICAgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKTtcbiAgICB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCk7XG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0JDU7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGUkNTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUUkNjtcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICB0b2dnbGUocmVsYXRlZFRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3cocmVsYXRlZFRhcmdldCk7XG4gIH1cbiAgc2hvdyhyZWxhdGVkVGFyZ2V0KSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQzLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0XG4gICAgfSk7XG4gICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xuICAgIHRoaXMuX2JhY2tkcm9wLnNob3coKTtcbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwpIHtcbiAgICAgIG5ldyBTY3JvbGxCYXJIZWxwZXIoKS5oaWRlKCk7XG4gICAgfVxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgdHJ1ZSk7XG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZGlhbG9nJyk7XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPV0lORyQxKTtcbiAgICBjb25zdCBjb21wbGV0ZUNhbGxCYWNrID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9jb25maWcuc2Nyb2xsIHx8IHRoaXMuX2NvbmZpZy5iYWNrZHJvcCkge1xuICAgICAgICB0aGlzLl9mb2N1c3RyYXAuYWN0aXZhdGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckMyk7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XSU5HJDEpO1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04kMywge1xuICAgICAgICByZWxhdGVkVGFyZ2V0XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsQmFjaywgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzU2hvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQzKTtcbiAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKTtcbiAgICB0aGlzLl9lbGVtZW50LmJsdXIoKTtcbiAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfSElESU5HKTtcbiAgICB0aGlzLl9iYWNrZHJvcC5oaWRlKCk7XG4gICAgY29uc3QgY29tcGxldGVDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckMywgQ0xBU1NfTkFNRV9ISURJTkcpO1xuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwpIHtcbiAgICAgICAgbmV3IFNjcm9sbEJhckhlbHBlcigpLnJlc2V0KCk7XG4gICAgICB9XG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kMyk7XG4gICAgfTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlQ2FsbGJhY2ssIHRoaXMuX2VsZW1lbnQsIHRydWUpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpO1xuICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgIGNvbnN0IGNsaWNrQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAnc3RhdGljJykge1xuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFX1BSRVZFTlRFRCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH07XG5cbiAgICAvLyAnc3RhdGljJyBvcHRpb24gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRydWUsIGFuZCBib29sZWFucyB3aWxsIGtlZXAgdGhlaXIgdmFsdWVcbiAgICBjb25zdCBpc1Zpc2libGUgPSBCb29sZWFuKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCk7XG4gICAgcmV0dXJuIG5ldyBCYWNrZHJvcCh7XG4gICAgICBjbGFzc05hbWU6IENMQVNTX05BTUVfQkFDS0RST1AsXG4gICAgICBpc1Zpc2libGUsXG4gICAgICBpc0FuaW1hdGVkOiB0cnVlLFxuICAgICAgcm9vdEVsZW1lbnQ6IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgIGNsaWNrQ2FsbGJhY2s6IGlzVmlzaWJsZSA/IGNsaWNrQ2FsbGJhY2sgOiBudWxsXG4gICAgfSk7XG4gIH1cbiAgX2luaXRpYWxpemVGb2N1c1RyYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBGb2N1c1RyYXAoe1xuICAgICAgdHJhcEVsZW1lbnQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9KTtcbiAgfVxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV05fRElTTUlTUywgZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LmtleSAhPT0gRVNDQVBFX0tFWSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFX1BSRVZFTlRFRCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBPZmZjYW52YXMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgfVxuICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAqL1xuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDEsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDEsIGZ1bmN0aW9uIChldmVudCkge1xuICBjb25zdCB0YXJnZXQgPSBTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpO1xuICBpZiAoWydBJywgJ0FSRUEnXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBFdmVudEhhbmRsZXIub25lKHRhcmdldCwgRVZFTlRfSElEREVOJDMsICgpID0+IHtcbiAgICAvLyBmb2N1cyBvbiB0cmlnZ2VyIHdoZW4gaXQgaXMgY2xvc2VkXG4gICAgaWYgKGlzVmlzaWJsZSh0aGlzKSkge1xuICAgICAgdGhpcy5mb2N1cygpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYXZvaWQgY29uZmxpY3Qgd2hlbiBjbGlja2luZyBhIHRvZ2dsZXIgb2YgYW4gb2ZmY2FudmFzLCB3aGlsZSBhbm90aGVyIGlzIG9wZW5cbiAgY29uc3QgYWxyZWFkeU9wZW4gPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKE9QRU5fU0VMRUNUT1IpO1xuICBpZiAoYWxyZWFkeU9wZW4gJiYgYWxyZWFkeU9wZW4gIT09IHRhcmdldCkge1xuICAgIE9mZmNhbnZhcy5nZXRJbnN0YW5jZShhbHJlYWR5T3BlbikuaGlkZSgpO1xuICB9XG4gIGNvbnN0IGRhdGEgPSBPZmZjYW52YXMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpO1xuICBkYXRhLnRvZ2dsZSh0aGlzKTtcbn0pO1xuRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSQyLCAoKSA9PiB7XG4gIGZvciAoY29uc3Qgc2VsZWN0b3Igb2YgU2VsZWN0b3JFbmdpbmUuZmluZChPUEVOX1NFTEVDVE9SKSkge1xuICAgIE9mZmNhbnZhcy5nZXRPckNyZWF0ZUluc3RhbmNlKHNlbGVjdG9yKS5zaG93KCk7XG4gIH1cbn0pO1xuRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfUkVTSVpFLCAoKSA9PiB7XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBTZWxlY3RvckVuZ2luZS5maW5kKCdbYXJpYS1tb2RhbF1bY2xhc3MqPXNob3ddW2NsYXNzKj1vZmZjYW52YXMtXScpKSB7XG4gICAgaWYgKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gIT09ICdmaXhlZCcpIHtcbiAgICAgIE9mZmNhbnZhcy5nZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQpLmhpZGUoKTtcbiAgICB9XG4gIH1cbn0pO1xuZW5hYmxlRGlzbWlzc1RyaWdnZXIoT2ZmY2FudmFzKTtcblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oT2ZmY2FudmFzKTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwIHV0aWwvc2FuaXRpemVyLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLy8ganMtZG9jcy1zdGFydCBhbGxvdy1saXN0XG5jb25zdCBBUklBX0FUVFJJQlVURV9QQVRURVJOID0gL15hcmlhLVtcXHctXSokL2k7XG5jb25zdCBEZWZhdWx0QWxsb3dsaXN0ID0ge1xuICAvLyBHbG9iYWwgYXR0cmlidXRlcyBhbGxvd2VkIG9uIGFueSBzdXBwbGllZCBlbGVtZW50IGJlbG93LlxuICAnKic6IFsnY2xhc3MnLCAnZGlyJywgJ2lkJywgJ2xhbmcnLCAncm9sZScsIEFSSUFfQVRUUklCVVRFX1BBVFRFUk5dLFxuICBhOiBbJ3RhcmdldCcsICdocmVmJywgJ3RpdGxlJywgJ3JlbCddLFxuICBhcmVhOiBbXSxcbiAgYjogW10sXG4gIGJyOiBbXSxcbiAgY29sOiBbXSxcbiAgY29kZTogW10sXG4gIGRkOiBbXSxcbiAgZGl2OiBbXSxcbiAgZGw6IFtdLFxuICBkdDogW10sXG4gIGVtOiBbXSxcbiAgaHI6IFtdLFxuICBoMTogW10sXG4gIGgyOiBbXSxcbiAgaDM6IFtdLFxuICBoNDogW10sXG4gIGg1OiBbXSxcbiAgaDY6IFtdLFxuICBpOiBbXSxcbiAgaW1nOiBbJ3NyYycsICdzcmNzZXQnLCAnYWx0JywgJ3RpdGxlJywgJ3dpZHRoJywgJ2hlaWdodCddLFxuICBsaTogW10sXG4gIG9sOiBbXSxcbiAgcDogW10sXG4gIHByZTogW10sXG4gIHM6IFtdLFxuICBzbWFsbDogW10sXG4gIHNwYW46IFtdLFxuICBzdWI6IFtdLFxuICBzdXA6IFtdLFxuICBzdHJvbmc6IFtdLFxuICB1OiBbXSxcbiAgdWw6IFtdXG59O1xuLy8ganMtZG9jcy1lbmQgYWxsb3ctbGlzdFxuXG5jb25zdCB1cmlBdHRyaWJ1dGVzID0gbmV3IFNldChbJ2JhY2tncm91bmQnLCAnY2l0ZScsICdocmVmJywgJ2l0ZW10eXBlJywgJ2xvbmdkZXNjJywgJ3Bvc3RlcicsICdzcmMnLCAneGxpbms6aHJlZiddKTtcblxuLyoqXG4gKiBBIHBhdHRlcm4gdGhhdCByZWNvZ25pemVzIFVSTHMgdGhhdCBhcmUgc2FmZSB3cnQuIFhTUyBpbiBVUkwgbmF2aWdhdGlvblxuICogY29udGV4dHMuXG4gKlxuICogU2hvdXQtb3V0IHRvIEFuZ3VsYXIgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzE1LjIuOC9wYWNrYWdlcy9jb3JlL3NyYy9zYW5pdGl6YXRpb24vdXJsX3Nhbml0aXplci50cyNMMzhcbiAqL1xuY29uc3QgU0FGRV9VUkxfUEFUVEVSTiA9IC9eKD8hamF2YXNjcmlwdDopKD86W2EtejAtOSsuLV0rOnxbXiY6Lz8jXSooPzpbLz8jXXwkKSkvaTtcbmNvbnN0IGFsbG93ZWRBdHRyaWJ1dGUgPSAoYXR0cmlidXRlLCBhbGxvd2VkQXR0cmlidXRlTGlzdCkgPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChhbGxvd2VkQXR0cmlidXRlTGlzdC5pbmNsdWRlcyhhdHRyaWJ1dGVOYW1lKSkge1xuICAgIGlmICh1cmlBdHRyaWJ1dGVzLmhhcyhhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4oU0FGRV9VUkxfUEFUVEVSTi50ZXN0KGF0dHJpYnV0ZS5ub2RlVmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBDaGVjayBpZiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB2YWxpZGF0ZXMgdGhlIGF0dHJpYnV0ZS5cbiAgcmV0dXJuIGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmZpbHRlcihhdHRyaWJ1dGVSZWdleCA9PiBhdHRyaWJ1dGVSZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCkuc29tZShyZWdleCA9PiByZWdleC50ZXN0KGF0dHJpYnV0ZU5hbWUpKTtcbn07XG5mdW5jdGlvbiBzYW5pdGl6ZUh0bWwodW5zYWZlSHRtbCwgYWxsb3dMaXN0LCBzYW5pdGl6ZUZ1bmN0aW9uKSB7XG4gIGlmICghdW5zYWZlSHRtbC5sZW5ndGgpIHtcbiAgICByZXR1cm4gdW5zYWZlSHRtbDtcbiAgfVxuICBpZiAoc2FuaXRpemVGdW5jdGlvbiAmJiB0eXBlb2Ygc2FuaXRpemVGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzYW5pdGl6ZUZ1bmN0aW9uKHVuc2FmZUh0bWwpO1xuICB9XG4gIGNvbnN0IGRvbVBhcnNlciA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCk7XG4gIGNvbnN0IGNyZWF0ZWREb2N1bWVudCA9IGRvbVBhcnNlci5wYXJzZUZyb21TdHJpbmcodW5zYWZlSHRtbCwgJ3RleHQvaHRtbCcpO1xuICBjb25zdCBlbGVtZW50cyA9IFtdLmNvbmNhdCguLi5jcmVhdGVkRG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yQWxsKCcqJykpO1xuICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICBjb25zdCBlbGVtZW50TmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKGFsbG93TGlzdCkuaW5jbHVkZXMoZWxlbWVudE5hbWUpKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZSgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGF0dHJpYnV0ZUxpc3QgPSBbXS5jb25jYXQoLi4uZWxlbWVudC5hdHRyaWJ1dGVzKTtcbiAgICBjb25zdCBhbGxvd2VkQXR0cmlidXRlcyA9IFtdLmNvbmNhdChhbGxvd0xpc3RbJyonXSB8fCBbXSwgYWxsb3dMaXN0W2VsZW1lbnROYW1lXSB8fCBbXSk7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlTGlzdCkge1xuICAgICAgaWYgKCFhbGxvd2VkQXR0cmlidXRlKGF0dHJpYnV0ZSwgYWxsb3dlZEF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZS5ub2RlTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVkRG9jdW1lbnQuYm9keS5pbm5lckhUTUw7XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCB1dGlsL3RlbXBsYXRlLWZhY3RvcnkuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTkFNRSQ1ID0gJ1RlbXBsYXRlRmFjdG9yeSc7XG5jb25zdCBEZWZhdWx0JDQgPSB7XG4gIGFsbG93TGlzdDogRGVmYXVsdEFsbG93bGlzdCxcbiAgY29udGVudDoge30sXG4gIC8vIHsgc2VsZWN0b3IgOiB0ZXh0ICwgIHNlbGVjdG9yMiA6IHRleHQyICwgfVxuICBleHRyYUNsYXNzOiAnJyxcbiAgaHRtbDogZmFsc2UsXG4gIHNhbml0aXplOiB0cnVlLFxuICBzYW5pdGl6ZUZuOiBudWxsLFxuICB0ZW1wbGF0ZTogJzxkaXY+PC9kaXY+J1xufTtcbmNvbnN0IERlZmF1bHRUeXBlJDQgPSB7XG4gIGFsbG93TGlzdDogJ29iamVjdCcsXG4gIGNvbnRlbnQ6ICdvYmplY3QnLFxuICBleHRyYUNsYXNzOiAnKHN0cmluZ3xmdW5jdGlvbiknLFxuICBodG1sOiAnYm9vbGVhbicsXG4gIHNhbml0aXplOiAnYm9vbGVhbicsXG4gIHNhbml0aXplRm46ICcobnVsbHxmdW5jdGlvbiknLFxuICB0ZW1wbGF0ZTogJ3N0cmluZydcbn07XG5jb25zdCBEZWZhdWx0Q29udGVudFR5cGUgPSB7XG4gIGVudHJ5OiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9ufG51bGwpJyxcbiAgc2VsZWN0b3I6ICcoc3RyaW5nfGVsZW1lbnQpJ1xufTtcblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgVGVtcGxhdGVGYWN0b3J5IGV4dGVuZHMgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0JDQ7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGUkNDtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUUkNTtcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICBnZXRDb250ZW50KCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX2NvbmZpZy5jb250ZW50KS5tYXAoY29uZmlnID0+IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGNvbmZpZykpLmZpbHRlcihCb29sZWFuKTtcbiAgfVxuICBoYXNDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldENvbnRlbnQoKS5sZW5ndGggPiAwO1xuICB9XG4gIGNoYW5nZUNvbnRlbnQoY29udGVudCkge1xuICAgIHRoaXMuX2NoZWNrQ29udGVudChjb250ZW50KTtcbiAgICB0aGlzLl9jb25maWcuY29udGVudCA9IHtcbiAgICAgIC4uLnRoaXMuX2NvbmZpZy5jb250ZW50LFxuICAgICAgLi4uY29udGVudFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdG9IdG1sKCkge1xuICAgIGNvbnN0IHRlbXBsYXRlV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRlbXBsYXRlV3JhcHBlci5pbm5lckhUTUwgPSB0aGlzLl9tYXliZVNhbml0aXplKHRoaXMuX2NvbmZpZy50ZW1wbGF0ZSk7XG4gICAgZm9yIChjb25zdCBbc2VsZWN0b3IsIHRleHRdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuX2NvbmZpZy5jb250ZW50KSkge1xuICAgICAgdGhpcy5fc2V0Q29udGVudCh0ZW1wbGF0ZVdyYXBwZXIsIHRleHQsIHNlbGVjdG9yKTtcbiAgICB9XG4gICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZVdyYXBwZXIuY2hpbGRyZW5bMF07XG4gICAgY29uc3QgZXh0cmFDbGFzcyA9IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5leHRyYUNsYXNzKTtcbiAgICBpZiAoZXh0cmFDbGFzcykge1xuICAgICAgdGVtcGxhdGUuY2xhc3NMaXN0LmFkZCguLi5leHRyYUNsYXNzLnNwbGl0KCcgJykpO1xuICAgIH1cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF90eXBlQ2hlY2tDb25maWcoY29uZmlnKSB7XG4gICAgc3VwZXIuX3R5cGVDaGVja0NvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX2NoZWNrQ29udGVudChjb25maWcuY29udGVudCk7XG4gIH1cbiAgX2NoZWNrQ29udGVudChhcmcpIHtcbiAgICBmb3IgKGNvbnN0IFtzZWxlY3RvciwgY29udGVudF0gb2YgT2JqZWN0LmVudHJpZXMoYXJnKSkge1xuICAgICAgc3VwZXIuX3R5cGVDaGVja0NvbmZpZyh7XG4gICAgICAgIHNlbGVjdG9yLFxuICAgICAgICBlbnRyeTogY29udGVudFxuICAgICAgfSwgRGVmYXVsdENvbnRlbnRUeXBlKTtcbiAgICB9XG4gIH1cbiAgX3NldENvbnRlbnQodGVtcGxhdGUsIGNvbnRlbnQsIHNlbGVjdG9yKSB7XG4gICAgY29uc3QgdGVtcGxhdGVFbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShzZWxlY3RvciwgdGVtcGxhdGUpO1xuICAgIGlmICghdGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRlbnQgPSB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihjb250ZW50KTtcbiAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgIHRlbXBsYXRlRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudChjb250ZW50KSkge1xuICAgICAgdGhpcy5fcHV0RWxlbWVudEluVGVtcGxhdGUoZ2V0RWxlbWVudChjb250ZW50KSwgdGVtcGxhdGVFbGVtZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5odG1sKSB7XG4gICAgICB0ZW1wbGF0ZUVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5fbWF5YmVTYW5pdGl6ZShjb250ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGVtcGxhdGVFbGVtZW50LnRleHRDb250ZW50ID0gY29udGVudDtcbiAgfVxuICBfbWF5YmVTYW5pdGl6ZShhcmcpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnNhbml0aXplID8gc2FuaXRpemVIdG1sKGFyZywgdGhpcy5fY29uZmlnLmFsbG93TGlzdCwgdGhpcy5fY29uZmlnLnNhbml0aXplRm4pIDogYXJnO1xuICB9XG4gIF9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZXhlY3V0ZShhcmcsIFt1bmRlZmluZWQsIHRoaXNdKTtcbiAgfVxuICBfcHV0RWxlbWVudEluVGVtcGxhdGUoZWxlbWVudCwgdGVtcGxhdGVFbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5odG1sKSB7XG4gICAgICB0ZW1wbGF0ZUVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICB0ZW1wbGF0ZUVsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0ZW1wbGF0ZUVsZW1lbnQudGV4dENvbnRlbnQgPSBlbGVtZW50LnRleHRDb250ZW50O1xuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCB0b29sdGlwLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkNCA9ICd0b29sdGlwJztcbmNvbnN0IERJU0FMTE9XRURfQVRUUklCVVRFUyA9IG5ldyBTZXQoWydzYW5pdGl6ZScsICdhbGxvd0xpc3QnLCAnc2FuaXRpemVGbiddKTtcbmNvbnN0IENMQVNTX05BTUVfRkFERSQyID0gJ2ZhZGUnO1xuY29uc3QgQ0xBU1NfTkFNRV9NT0RBTCA9ICdtb2RhbCc7XG5jb25zdCBDTEFTU19OQU1FX1NIT1ckMiA9ICdzaG93JztcbmNvbnN0IFNFTEVDVE9SX1RPT0xUSVBfSU5ORVIgPSAnLnRvb2x0aXAtaW5uZXInO1xuY29uc3QgU0VMRUNUT1JfTU9EQUwgPSBgLiR7Q0xBU1NfTkFNRV9NT0RBTH1gO1xuY29uc3QgRVZFTlRfTU9EQUxfSElERSA9ICdoaWRlLmJzLm1vZGFsJztcbmNvbnN0IFRSSUdHRVJfSE9WRVIgPSAnaG92ZXInO1xuY29uc3QgVFJJR0dFUl9GT0NVUyA9ICdmb2N1cyc7XG5jb25zdCBUUklHR0VSX0NMSUNLID0gJ2NsaWNrJztcbmNvbnN0IFRSSUdHRVJfTUFOVUFMID0gJ21hbnVhbCc7XG5jb25zdCBFVkVOVF9ISURFJDIgPSAnaGlkZSc7XG5jb25zdCBFVkVOVF9ISURERU4kMiA9ICdoaWRkZW4nO1xuY29uc3QgRVZFTlRfU0hPVyQyID0gJ3Nob3cnO1xuY29uc3QgRVZFTlRfU0hPV04kMiA9ICdzaG93bic7XG5jb25zdCBFVkVOVF9JTlNFUlRFRCA9ICdpbnNlcnRlZCc7XG5jb25zdCBFVkVOVF9DTElDSyQxID0gJ2NsaWNrJztcbmNvbnN0IEVWRU5UX0ZPQ1VTSU4kMSA9ICdmb2N1c2luJztcbmNvbnN0IEVWRU5UX0ZPQ1VTT1VUJDEgPSAnZm9jdXNvdXQnO1xuY29uc3QgRVZFTlRfTU9VU0VFTlRFUiA9ICdtb3VzZWVudGVyJztcbmNvbnN0IEVWRU5UX01PVVNFTEVBVkUgPSAnbW91c2VsZWF2ZSc7XG5jb25zdCBBdHRhY2htZW50TWFwID0ge1xuICBBVVRPOiAnYXV0bycsXG4gIFRPUDogJ3RvcCcsXG4gIFJJR0hUOiBpc1JUTCgpID8gJ2xlZnQnIDogJ3JpZ2h0JyxcbiAgQk9UVE9NOiAnYm90dG9tJyxcbiAgTEVGVDogaXNSVEwoKSA/ICdyaWdodCcgOiAnbGVmdCdcbn07XG5jb25zdCBEZWZhdWx0JDMgPSB7XG4gIGFsbG93TGlzdDogRGVmYXVsdEFsbG93bGlzdCxcbiAgYW5pbWF0aW9uOiB0cnVlLFxuICBib3VuZGFyeTogJ2NsaXBwaW5nUGFyZW50cycsXG4gIGNvbnRhaW5lcjogZmFsc2UsXG4gIGN1c3RvbUNsYXNzOiAnJyxcbiAgZGVsYXk6IDAsXG4gIGZhbGxiYWNrUGxhY2VtZW50czogWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXSxcbiAgaHRtbDogZmFsc2UsXG4gIG9mZnNldDogWzAsIDZdLFxuICBwbGFjZW1lbnQ6ICd0b3AnLFxuICBwb3BwZXJDb25maWc6IG51bGwsXG4gIHNhbml0aXplOiB0cnVlLFxuICBzYW5pdGl6ZUZuOiBudWxsLFxuICBzZWxlY3RvcjogZmFsc2UsXG4gIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPicgKyAnPGRpdiBjbGFzcz1cInRvb2x0aXAtYXJyb3dcIj48L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJ0b29sdGlwLWlubmVyXCI+PC9kaXY+JyArICc8L2Rpdj4nLFxuICB0aXRsZTogJycsXG4gIHRyaWdnZXI6ICdob3ZlciBmb2N1cydcbn07XG5jb25zdCBEZWZhdWx0VHlwZSQzID0ge1xuICBhbGxvd0xpc3Q6ICdvYmplY3QnLFxuICBhbmltYXRpb246ICdib29sZWFuJyxcbiAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcbiAgY29udGFpbmVyOiAnKHN0cmluZ3xlbGVtZW50fGJvb2xlYW4pJyxcbiAgY3VzdG9tQ2xhc3M6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXG4gIGRlbGF5OiAnKG51bWJlcnxvYmplY3QpJyxcbiAgZmFsbGJhY2tQbGFjZW1lbnRzOiAnYXJyYXknLFxuICBodG1sOiAnYm9vbGVhbicsXG4gIG9mZnNldDogJyhhcnJheXxzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgcGxhY2VtZW50OiAnKHN0cmluZ3xmdW5jdGlvbiknLFxuICBwb3BwZXJDb25maWc6ICcobnVsbHxvYmplY3R8ZnVuY3Rpb24pJyxcbiAgc2FuaXRpemU6ICdib29sZWFuJyxcbiAgc2FuaXRpemVGbjogJyhudWxsfGZ1bmN0aW9uKScsXG4gIHNlbGVjdG9yOiAnKHN0cmluZ3xib29sZWFuKScsXG4gIHRlbXBsYXRlOiAnc3RyaW5nJyxcbiAgdGl0bGU6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJyxcbiAgdHJpZ2dlcjogJ3N0cmluZydcbn07XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgaWYgKHR5cGVvZiBQb3BwZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXCdzIHRvb2x0aXBzIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcvZG9jcy92Mi8pJyk7XG4gICAgfVxuICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XG5cbiAgICAvLyBQcml2YXRlXG4gICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLl90aW1lb3V0ID0gMDtcbiAgICB0aGlzLl9pc0hvdmVyZWQgPSBudWxsO1xuICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXIgPSB7fTtcbiAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xuICAgIHRoaXMuX3RlbXBsYXRlRmFjdG9yeSA9IG51bGw7XG4gICAgdGhpcy5fbmV3Q29udGVudCA9IG51bGw7XG5cbiAgICAvLyBQcm90ZWN0ZWRcbiAgICB0aGlzLnRpcCA9IG51bGw7XG4gICAgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XG4gICAgaWYgKCF0aGlzLl9jb25maWcuc2VsZWN0b3IpIHtcbiAgICAgIHRoaXMuX2ZpeFRpdGxlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHQkMztcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZSQzO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSQ0O1xuICB9XG5cbiAgLy8gUHVibGljXG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG4gIH1cbiAgdG9nZ2xlRW5hYmxlZCgpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSAhdGhpcy5faXNFbmFibGVkO1xuICB9XG4gIHRvZ2dsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5faXNTaG93bigpKSB7XG4gICAgICB0aGlzLl9sZWF2ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9lbnRlcigpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX01PREFMKSwgRVZFTlRfTU9EQUxfSElERSwgdGhpcy5faGlkZU1vZGFsSGFuZGxlcik7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJykpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCd0aXRsZScsIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJykpO1xuICAgIH1cbiAgICB0aGlzLl9kaXNwb3NlUG9wcGVyKCk7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSB1c2Ugc2hvdyBvbiB2aXNpYmxlIGVsZW1lbnRzJyk7XG4gICAgfVxuICAgIGlmICghKHRoaXMuX2lzV2l0aENvbnRlbnQoKSAmJiB0aGlzLl9pc0VuYWJsZWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX1NIT1ckMikpO1xuICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBmaW5kU2hhZG93Um9vdCh0aGlzLl9lbGVtZW50KTtcbiAgICBjb25zdCBpc0luVGhlRG9tID0gKHNoYWRvd1Jvb3QgfHwgdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuY29udGFpbnModGhpcy5fZWxlbWVudCk7XG4gICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkIHx8ICFpc0luVGhlRG9tKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdjYgcmVtb3ZlIHRoaXMgb3IgbWFrZSBpdCBvcHRpb25hbFxuICAgIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKTtcbiAgICBjb25zdCB0aXAgPSB0aGlzLl9nZXRUaXBFbGVtZW50KCk7XG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aXAuZ2V0QXR0cmlidXRlKCdpZCcpKTtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXJcbiAgICB9ID0gdGhpcy5fY29uZmlnO1xuICAgIGlmICghdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh0aGlzLnRpcCkpIHtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmQodGlwKTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0lOU0VSVEVEKSk7XG4gICAgfVxuICAgIHRoaXMuX3BvcHBlciA9IHRoaXMuX2NyZWF0ZVBvcHBlcih0aXApO1xuICAgIHRpcC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQyKTtcblxuICAgIC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSBhZGQgZXh0cmFcbiAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xuICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXG4gICAgLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDE0LzAyL21vdXNlX2V2ZW50X2J1Yi5odG1sXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xuICAgICAgICBFdmVudEhhbmRsZXIub24oZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX1NIT1dOJDIpKTtcbiAgICAgIGlmICh0aGlzLl9pc0hvdmVyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX2xlYXZlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pc0hvdmVyZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMudGlwLCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfSElERSQyKSk7XG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRpcCA9IHRoaXMuX2dldFRpcEVsZW1lbnQoKTtcbiAgICB0aXAuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckMik7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgcmVtb3ZlIHRoZSBleHRyYVxuICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgd2UgYWRkZWQgZm9yIGlPUyBzdXBwb3J0XG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xuICAgICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0NMSUNLXSA9IGZhbHNlO1xuICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9GT0NVU10gPSBmYWxzZTtcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfSE9WRVJdID0gZmFsc2U7XG4gICAgdGhpcy5faXNIb3ZlcmVkID0gbnVsbDsgLy8gaXQgaXMgYSB0cmljayB0byBzdXBwb3J0IG1hbnVhbCB0cmlnZ2VyaW5nXG5cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9pc0hvdmVyZWQpIHtcbiAgICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0hJRERFTiQyKSk7XG4gICAgfTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLnRpcCwgdGhpcy5faXNBbmltYXRlZCgpKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuX3BvcHBlcikge1xuICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFByb3RlY3RlZFxuICBfaXNXaXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9nZXRUaXRsZSgpKTtcbiAgfVxuICBfZ2V0VGlwRWxlbWVudCgpIHtcbiAgICBpZiAoIXRoaXMudGlwKSB7XG4gICAgICB0aGlzLnRpcCA9IHRoaXMuX2NyZWF0ZVRpcEVsZW1lbnQodGhpcy5fbmV3Q29udGVudCB8fCB0aGlzLl9nZXRDb250ZW50Rm9yVGVtcGxhdGUoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRpcDtcbiAgfVxuICBfY3JlYXRlVGlwRWxlbWVudChjb250ZW50KSB7XG4gICAgY29uc3QgdGlwID0gdGhpcy5fZ2V0VGVtcGxhdGVGYWN0b3J5KGNvbnRlbnQpLnRvSHRtbCgpO1xuXG4gICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgY2hlY2sgaW4gdjZcbiAgICBpZiAoIXRpcCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRpcC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfRkFERSQyLCBDTEFTU19OQU1FX1NIT1ckMik7XG4gICAgLy8gVE9ETzogdjYgdGhlIGZvbGxvd2luZyBjYW4gYmUgYWNoaWV2ZWQgd2l0aCBDU1Mgb25seVxuICAgIHRpcC5jbGFzc0xpc3QuYWRkKGBicy0ke3RoaXMuY29uc3RydWN0b3IuTkFNRX0tYXV0b2ApO1xuICAgIGNvbnN0IHRpcElkID0gZ2V0VUlEKHRoaXMuY29uc3RydWN0b3IuTkFNRSkudG9TdHJpbmcoKTtcbiAgICB0aXAuc2V0QXR0cmlidXRlKCdpZCcsIHRpcElkKTtcbiAgICBpZiAodGhpcy5faXNBbmltYXRlZCgpKSB7XG4gICAgICB0aXAuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUkMik7XG4gICAgfVxuICAgIHJldHVybiB0aXA7XG4gIH1cbiAgc2V0Q29udGVudChjb250ZW50KSB7XG4gICAgdGhpcy5fbmV3Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICB9XG4gIF9nZXRUZW1wbGF0ZUZhY3RvcnkoY29udGVudCkge1xuICAgIGlmICh0aGlzLl90ZW1wbGF0ZUZhY3RvcnkpIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlRmFjdG9yeS5jaGFuZ2VDb250ZW50KGNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkgPSBuZXcgVGVtcGxhdGVGYWN0b3J5KHtcbiAgICAgICAgLi4udGhpcy5fY29uZmlnLFxuICAgICAgICAvLyB0aGUgYGNvbnRlbnRgIHZhciBoYXMgdG8gYmUgYWZ0ZXIgYHRoaXMuX2NvbmZpZ2BcbiAgICAgICAgLy8gdG8gb3ZlcnJpZGUgY29uZmlnLmNvbnRlbnQgaW4gY2FzZSBvZiBwb3BvdmVyXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGV4dHJhQ2xhc3M6IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jdXN0b21DbGFzcylcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVGYWN0b3J5O1xuICB9XG4gIF9nZXRDb250ZW50Rm9yVGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTRUxFQ1RPUl9UT09MVElQX0lOTkVSXTogdGhpcy5fZ2V0VGl0bGUoKVxuICAgIH07XG4gIH1cbiAgX2dldFRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcudGl0bGUpIHx8IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJyk7XG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5nZXRPckNyZWF0ZUluc3RhbmNlKGV2ZW50LmRlbGVnYXRlVGFyZ2V0LCB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKTtcbiAgfVxuICBfaXNBbmltYXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmFuaW1hdGlvbiB8fCB0aGlzLnRpcCAmJiB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDIpO1xuICB9XG4gIF9pc1Nob3duKCkge1xuICAgIHJldHVybiB0aGlzLnRpcCAmJiB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDIpO1xuICB9XG4gIF9jcmVhdGVQb3BwZXIodGlwKSB7XG4gICAgY29uc3QgcGxhY2VtZW50ID0gZXhlY3V0ZSh0aGlzLl9jb25maWcucGxhY2VtZW50LCBbdGhpcywgdGlwLCB0aGlzLl9lbGVtZW50XSk7XG4gICAgY29uc3QgYXR0YWNobWVudCA9IEF0dGFjaG1lbnRNYXBbcGxhY2VtZW50LnRvVXBwZXJDYXNlKCldO1xuICAgIHJldHVybiBQb3BwZXIuY3JlYXRlUG9wcGVyKHRoaXMuX2VsZW1lbnQsIHRpcCwgdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKGF0dGFjaG1lbnQpKTtcbiAgfVxuICBfZ2V0T2Zmc2V0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldFxuICAgIH0gPSB0aGlzLl9jb25maWc7XG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gb2Zmc2V0LnNwbGl0KCcsJykubWFwKHZhbHVlID0+IE51bWJlci5wYXJzZUludCh2YWx1ZSwgMTApKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBwb3BwZXJEYXRhID0+IG9mZnNldChwb3BwZXJEYXRhLCB0aGlzLl9lbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuICBfcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGV4ZWN1dGUoYXJnLCBbdGhpcy5fZWxlbWVudCwgdGhpcy5fZWxlbWVudF0pO1xuICB9XG4gIF9nZXRQb3BwZXJDb25maWcoYXR0YWNobWVudCkge1xuICAgIGNvbnN0IGRlZmF1bHRCc1BvcHBlckNvbmZpZyA9IHtcbiAgICAgIHBsYWNlbWVudDogYXR0YWNobWVudCxcbiAgICAgIG1vZGlmaWVyczogW3tcbiAgICAgICAgbmFtZTogJ2ZsaXAnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiB0aGlzLl9jb25maWcuZmFsbGJhY2tQbGFjZW1lbnRzXG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ2Fycm93JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGVsZW1lbnQ6IGAuJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9LWFycm93YFxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdwcmVTZXRQbGFjZW1lbnQnLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBwaGFzZTogJ2JlZm9yZU1haW4nLFxuICAgICAgICBmbjogZGF0YSA9PiB7XG4gICAgICAgICAgLy8gUHJlLXNldCBQb3BwZXIncyBwbGFjZW1lbnQgYXR0cmlidXRlIGluIG9yZGVyIHRvIHJlYWQgdGhlIGFycm93IHNpemVzIHByb3Blcmx5LlxuICAgICAgICAgIC8vIE90aGVyd2lzZSwgUG9wcGVyIG1peGVzIHVwIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGRpbWVuc2lvbnMgc2luY2UgdGhlIGluaXRpYWwgYXJyb3cgc3R5bGUgaXMgZm9yIHRvcCBwbGFjZW1lbnRcbiAgICAgICAgICB0aGlzLl9nZXRUaXBFbGVtZW50KCkuc2V0QXR0cmlidXRlKCdkYXRhLXBvcHBlci1wbGFjZW1lbnQnLCBkYXRhLnN0YXRlLnBsYWNlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1dXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGVmYXVsdEJzUG9wcGVyQ29uZmlnLFxuICAgICAgLi4uZXhlY3V0ZSh0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnLCBbdW5kZWZpbmVkLCBkZWZhdWx0QnNQb3BwZXJDb25maWddKVxuICAgIH07XG4gIH1cbiAgX3NldExpc3RlbmVycygpIHtcbiAgICBjb25zdCB0cmlnZ2VycyA9IHRoaXMuX2NvbmZpZy50cmlnZ2VyLnNwbGl0KCcgJyk7XG4gICAgZm9yIChjb25zdCB0cmlnZ2VyIG9mIHRyaWdnZXJzKSB7XG4gICAgICBpZiAodHJpZ2dlciA9PT0gJ2NsaWNrJykge1xuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfQ0xJQ0skMSksIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQpO1xuICAgICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9DTElDS10gPSAhKGNvbnRleHQuX2lzU2hvd24oKSAmJiBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfQ0xJQ0tdKTtcbiAgICAgICAgICBjb250ZXh0LnRvZ2dsZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodHJpZ2dlciAhPT0gVFJJR0dFUl9NQU5VQUwpIHtcbiAgICAgICAgY29uc3QgZXZlbnRJbiA9IHRyaWdnZXIgPT09IFRSSUdHRVJfSE9WRVIgPyB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9NT1VTRUVOVEVSKSA6IHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0ZPQ1VTSU4kMSk7XG4gICAgICAgIGNvbnN0IGV2ZW50T3V0ID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/IHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX01PVVNFTEVBVkUpIDogdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfRk9DVVNPVVQkMSk7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBldmVudEluLCB0aGlzLl9jb25maWcuc2VsZWN0b3IsIGV2ZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyW2V2ZW50LnR5cGUgPT09ICdmb2N1c2luJyA/IFRSSUdHRVJfRk9DVVMgOiBUUklHR0VSX0hPVkVSXSA9IHRydWU7XG4gICAgICAgICAgY29udGV4dC5fZW50ZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBldmVudE91dCwgdGhpcy5fY29uZmlnLnNlbGVjdG9yLCBldmVudCA9PiB7XG4gICAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCk7XG4gICAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltldmVudC50eXBlID09PSAnZm9jdXNvdXQnID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJdID0gY29udGV4dC5fZWxlbWVudC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgICBjb250ZXh0Ll9sZWF2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faGlkZU1vZGFsSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9NT0RBTCksIEVWRU5UX01PREFMX0hJREUsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpO1xuICB9XG4gIF9maXhUaXRsZSgpIHtcbiAgICBjb25zdCB0aXRsZSA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCd0aXRsZScpO1xuICAgIGlmICghdGl0bGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpICYmICF0aGlzLl9lbGVtZW50LnRleHRDb250ZW50LnRyaW0oKSkge1xuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aXRsZSk7XG4gICAgfVxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJywgdGl0bGUpOyAvLyBETyBOT1QgVVNFIElULiBJcyBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0aXRsZScpO1xuICB9XG4gIF9lbnRlcigpIHtcbiAgICBpZiAodGhpcy5faXNTaG93bigpIHx8IHRoaXMuX2lzSG92ZXJlZCkge1xuICAgICAgdGhpcy5faXNIb3ZlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faXNIb3ZlcmVkID0gdHJ1ZTtcbiAgICB0aGlzLl9zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9pc0hvdmVyZWQpIHtcbiAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5LnNob3cpO1xuICB9XG4gIF9sZWF2ZSgpIHtcbiAgICBpZiAodGhpcy5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2lzSG92ZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3NldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9pc0hvdmVyZWQpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5LmhpZGUpO1xuICB9XG4gIF9zZXRUaW1lb3V0KGhhbmRsZXIsIHRpbWVvdXQpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoaGFuZGxlciwgdGltZW91dCk7XG4gIH1cbiAgX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fYWN0aXZlVHJpZ2dlcikuaW5jbHVkZXModHJ1ZSk7XG4gIH1cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25zdCBkYXRhQXR0cmlidXRlcyA9IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIGZvciAoY29uc3QgZGF0YUF0dHJpYnV0ZSBvZiBPYmplY3Qua2V5cyhkYXRhQXR0cmlidXRlcykpIHtcbiAgICAgIGlmIChESVNBTExPV0VEX0FUVFJJQlVURVMuaGFzKGRhdGFBdHRyaWJ1dGUpKSB7XG4gICAgICAgIGRlbGV0ZSBkYXRhQXR0cmlidXRlc1tkYXRhQXR0cmlidXRlXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uZmlnID0ge1xuICAgICAgLi4uZGF0YUF0dHJpYnV0ZXMsXG4gICAgICAuLi4odHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pXG4gICAgfTtcbiAgICBjb25maWcgPSB0aGlzLl9tZXJnZUNvbmZpZ09iaihjb25maWcpO1xuICAgIGNvbmZpZyA9IHRoaXMuX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKTtcbiAgICB0aGlzLl90eXBlQ2hlY2tDb25maWcoY29uZmlnKTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG4gIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xuICAgIGNvbmZpZy5jb250YWluZXIgPSBjb25maWcuY29udGFpbmVyID09PSBmYWxzZSA/IGRvY3VtZW50LmJvZHkgOiBnZXRFbGVtZW50KGNvbmZpZy5jb250YWluZXIpO1xuICAgIGlmICh0eXBlb2YgY29uZmlnLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgY29uZmlnLmRlbGF5ID0ge1xuICAgICAgICBzaG93OiBjb25maWcuZGVsYXksXG4gICAgICAgIGhpZGU6IGNvbmZpZy5kZWxheVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25maWcudGl0bGUgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25maWcudGl0bGUgPSBjb25maWcudGl0bGUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25maWcuY29udGVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbmZpZy5jb250ZW50ID0gY29uZmlnLmNvbnRlbnQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuICBfZ2V0RGVsZWdhdGVDb25maWcoKSB7XG4gICAgY29uc3QgY29uZmlnID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5fY29uZmlnKSkge1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtrZXldICE9PSB2YWx1ZSkge1xuICAgICAgICBjb25maWdba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25maWcuc2VsZWN0b3IgPSBmYWxzZTtcbiAgICBjb25maWcudHJpZ2dlciA9ICdtYW51YWwnO1xuXG4gICAgLy8gSW4gdGhlIGZ1dHVyZSBjYW4gYmUgcmVwbGFjZWQgd2l0aDpcbiAgICAvLyBjb25zdCBrZXlzV2l0aERpZmZlcmVudFZhbHVlcyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuX2NvbmZpZykuZmlsdGVyKGVudHJ5ID0+IHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtlbnRyeVswXV0gIT09IHRoaXMuX2NvbmZpZ1tlbnRyeVswXV0pXG4gICAgLy8gYE9iamVjdC5mcm9tRW50cmllcyhrZXlzV2l0aERpZmZlcmVudFZhbHVlcylgXG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuICBfZGlzcG9zZVBvcHBlcigpIHtcbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMudGlwKSB7XG4gICAgICB0aGlzLnRpcC5yZW1vdmUoKTtcbiAgICAgIHRoaXMudGlwID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBUb29sdGlwLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgIH1cbiAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogalF1ZXJ5XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKFRvb2x0aXApO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgcG9wb3Zlci5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FJDMgPSAncG9wb3Zlcic7XG5jb25zdCBTRUxFQ1RPUl9USVRMRSA9ICcucG9wb3Zlci1oZWFkZXInO1xuY29uc3QgU0VMRUNUT1JfQ09OVEVOVCA9ICcucG9wb3Zlci1ib2R5JztcbmNvbnN0IERlZmF1bHQkMiA9IHtcbiAgLi4uVG9vbHRpcC5EZWZhdWx0LFxuICBjb250ZW50OiAnJyxcbiAgb2Zmc2V0OiBbMCwgOF0sXG4gIHBsYWNlbWVudDogJ3JpZ2h0JyxcbiAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwicG9wb3ZlclwiIHJvbGU9XCJ0b29sdGlwXCI+JyArICc8ZGl2IGNsYXNzPVwicG9wb3Zlci1hcnJvd1wiPjwvZGl2PicgKyAnPGgzIGNsYXNzPVwicG9wb3Zlci1oZWFkZXJcIj48L2gzPicgKyAnPGRpdiBjbGFzcz1cInBvcG92ZXItYm9keVwiPjwvZGl2PicgKyAnPC9kaXY+JyxcbiAgdHJpZ2dlcjogJ2NsaWNrJ1xufTtcbmNvbnN0IERlZmF1bHRUeXBlJDIgPSB7XG4gIC4uLlRvb2x0aXAuRGVmYXVsdFR5cGUsXG4gIGNvbnRlbnQ6ICcobnVsbHxzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknXG59O1xuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBQb3BvdmVyIGV4dGVuZHMgVG9vbHRpcCB7XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0JDI7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGUkMjtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUUkMztcbiAgfVxuXG4gIC8vIE92ZXJyaWRlc1xuICBfaXNXaXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VGl0bGUoKSB8fCB0aGlzLl9nZXRDb250ZW50KCk7XG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9nZXRDb250ZW50Rm9yVGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTRUxFQ1RPUl9USVRMRV06IHRoaXMuX2dldFRpdGxlKCksXG4gICAgICBbU0VMRUNUT1JfQ09OVEVOVF06IHRoaXMuX2dldENvbnRlbnQoKVxuICAgIH07XG4gIH1cbiAgX2dldENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jb250ZW50KTtcbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IFBvcG92ZXIuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgfVxuICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oUG9wb3Zlcik7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCBzY3JvbGxzcHkuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTkFNRSQyID0gJ3Njcm9sbHNweSc7XG5jb25zdCBEQVRBX0tFWSQyID0gJ2JzLnNjcm9sbHNweSc7XG5jb25zdCBFVkVOVF9LRVkkMiA9IGAuJHtEQVRBX0tFWSQyfWA7XG5jb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbmNvbnN0IEVWRU5UX0FDVElWQVRFID0gYGFjdGl2YXRlJHtFVkVOVF9LRVkkMn1gO1xuY29uc3QgRVZFTlRfQ0xJQ0sgPSBgY2xpY2ske0VWRU5UX0tFWSQyfWA7XG5jb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJJDEgPSBgbG9hZCR7RVZFTlRfS0VZJDJ9JHtEQVRBX0FQSV9LRVl9YDtcbmNvbnN0IENMQVNTX05BTUVfRFJPUERPV05fSVRFTSA9ICdkcm9wZG93bi1pdGVtJztcbmNvbnN0IENMQVNTX05BTUVfQUNUSVZFJDEgPSAnYWN0aXZlJztcbmNvbnN0IFNFTEVDVE9SX0RBVEFfU1BZID0gJ1tkYXRhLWJzLXNweT1cInNjcm9sbFwiXSc7XG5jb25zdCBTRUxFQ1RPUl9UQVJHRVRfTElOS1MgPSAnW2hyZWZdJztcbmNvbnN0IFNFTEVDVE9SX05BVl9MSVNUX0dST1VQID0gJy5uYXYsIC5saXN0LWdyb3VwJztcbmNvbnN0IFNFTEVDVE9SX05BVl9MSU5LUyA9ICcubmF2LWxpbmsnO1xuY29uc3QgU0VMRUNUT1JfTkFWX0lURU1TID0gJy5uYXYtaXRlbSc7XG5jb25zdCBTRUxFQ1RPUl9MSVNUX0lURU1TID0gJy5saXN0LWdyb3VwLWl0ZW0nO1xuY29uc3QgU0VMRUNUT1JfTElOS19JVEVNUyA9IGAke1NFTEVDVE9SX05BVl9MSU5LU30sICR7U0VMRUNUT1JfTkFWX0lURU1TfSA+ICR7U0VMRUNUT1JfTkFWX0xJTktTfSwgJHtTRUxFQ1RPUl9MSVNUX0lURU1TfWA7XG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTiA9ICcuZHJvcGRvd24nO1xuY29uc3QgU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFJDEgPSAnLmRyb3Bkb3duLXRvZ2dsZSc7XG5jb25zdCBEZWZhdWx0JDEgPSB7XG4gIG9mZnNldDogbnVsbCxcbiAgLy8gVE9ETzogdjYgQGRlcHJlY2F0ZWQsIGtlZXAgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnNcbiAgcm9vdE1hcmdpbjogJzBweCAwcHggLTI1JScsXG4gIHNtb290aFNjcm9sbDogZmFsc2UsXG4gIHRhcmdldDogbnVsbCxcbiAgdGhyZXNob2xkOiBbMC4xLCAwLjUsIDFdXG59O1xuY29uc3QgRGVmYXVsdFR5cGUkMSA9IHtcbiAgb2Zmc2V0OiAnKG51bWJlcnxudWxsKScsXG4gIC8vIFRPRE8gdjYgQGRlcHJlY2F0ZWQsIGtlZXAgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnNcbiAgcm9vdE1hcmdpbjogJ3N0cmluZycsXG4gIHNtb290aFNjcm9sbDogJ2Jvb2xlYW4nLFxuICB0YXJnZXQ6ICdlbGVtZW50JyxcbiAgdGhyZXNob2xkOiAnYXJyYXknXG59O1xuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBTY3JvbGxTcHkgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcblxuICAgIC8vIHRoaXMuX2VsZW1lbnQgaXMgdGhlIG9ic2VydmFibGVzQ29udGFpbmVyIGFuZCBjb25maWcudGFyZ2V0IHRoZSBtZW51IGxpbmtzIHdyYXBwZXJcbiAgICB0aGlzLl90YXJnZXRMaW5rcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnQpLm92ZXJmbG93WSA9PT0gJ3Zpc2libGUnID8gbnVsbCA6IHRoaXMuX2VsZW1lbnQ7XG4gICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLl9vYnNlcnZlciA9IG51bGw7XG4gICAgdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhID0ge1xuICAgICAgdmlzaWJsZUVudHJ5VG9wOiAwLFxuICAgICAgcGFyZW50U2Nyb2xsVG9wOiAwXG4gICAgfTtcbiAgICB0aGlzLnJlZnJlc2goKTsgLy8gaW5pdGlhbGl6ZVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHQkMTtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZSQxO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSQyO1xuICB9XG5cbiAgLy8gUHVibGljXG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZVRhcmdldHNBbmRPYnNlcnZhYmxlcygpO1xuICAgIHRoaXMuX21heWJlRW5hYmxlU21vb3RoU2Nyb2xsKCk7XG4gICAgaWYgKHRoaXMuX29ic2VydmVyKSB7XG4gICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29ic2VydmVyID0gdGhpcy5fZ2V0TmV3T2JzZXJ2ZXIoKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzZWN0aW9uIG9mIHRoaXMuX29ic2VydmFibGVTZWN0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZShzZWN0aW9uKTtcbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcbiAgICAvLyBUT0RPOiBvbiB2NiB0YXJnZXQgc2hvdWxkIGJlIGdpdmVuIGV4cGxpY2l0bHkgJiByZW1vdmUgdGhlIHt0YXJnZXQ6ICdzcy10YXJnZXQnfSBjYXNlXG4gICAgY29uZmlnLnRhcmdldCA9IGdldEVsZW1lbnQoY29uZmlnLnRhcmdldCkgfHwgZG9jdW1lbnQuYm9keTtcblxuICAgIC8vIFRPRE86IHY2IE9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnMuIFVzZSByb290TWFyZ2luIG9ubHlcbiAgICBjb25maWcucm9vdE1hcmdpbiA9IGNvbmZpZy5vZmZzZXQgPyBgJHtjb25maWcub2Zmc2V0fXB4IDBweCAtMzAlYCA6IGNvbmZpZy5yb290TWFyZ2luO1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnRocmVzaG9sZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbmZpZy50aHJlc2hvbGQgPSBjb25maWcudGhyZXNob2xkLnNwbGl0KCcsJykubWFwKHZhbHVlID0+IE51bWJlci5wYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiBjb25maWc7XG4gIH1cbiAgX21heWJlRW5hYmxlU21vb3RoU2Nyb2xsKCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLnNtb290aFNjcm9sbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHVucmVnaXN0ZXIgYW55IHByZXZpb3VzIGxpc3RlbmVyc1xuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fY29uZmlnLnRhcmdldCwgRVZFTlRfQ0xJQ0spO1xuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9jb25maWcudGFyZ2V0LCBFVkVOVF9DTElDSywgU0VMRUNUT1JfVEFSR0VUX0xJTktTLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBvYnNlcnZhYmxlU2VjdGlvbiA9IHRoaXMuX29ic2VydmFibGVTZWN0aW9ucy5nZXQoZXZlbnQudGFyZ2V0Lmhhc2gpO1xuICAgICAgaWYgKG9ic2VydmFibGVTZWN0aW9uKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLl9yb290RWxlbWVudCB8fCB3aW5kb3c7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IG9ic2VydmFibGVTZWN0aW9uLm9mZnNldFRvcCAtIHRoaXMuX2VsZW1lbnQub2Zmc2V0VG9wO1xuICAgICAgICBpZiAocm9vdC5zY3JvbGxUbykge1xuICAgICAgICAgIHJvb3Quc2Nyb2xsVG8oe1xuICAgICAgICAgICAgdG9wOiBoZWlnaHQsXG4gICAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaHJvbWUgNjAgZG9lc24ndCBzdXBwb3J0IGBzY3JvbGxUb2BcbiAgICAgICAgcm9vdC5zY3JvbGxUb3AgPSBoZWlnaHQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2dldE5ld09ic2VydmVyKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICByb290OiB0aGlzLl9yb290RWxlbWVudCxcbiAgICAgIHRocmVzaG9sZDogdGhpcy5fY29uZmlnLnRocmVzaG9sZCxcbiAgICAgIHJvb3RNYXJnaW46IHRoaXMuX2NvbmZpZy5yb290TWFyZ2luXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4gdGhpcy5fb2JzZXJ2ZXJDYWxsYmFjayhlbnRyaWVzKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBUaGUgbG9naWMgb2Ygc2VsZWN0aW9uXG4gIF9vYnNlcnZlckNhbGxiYWNrKGVudHJpZXMpIHtcbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gZW50cnkgPT4gdGhpcy5fdGFyZ2V0TGlua3MuZ2V0KGAjJHtlbnRyeS50YXJnZXQuaWR9YCk7XG4gICAgY29uc3QgYWN0aXZhdGUgPSBlbnRyeSA9PiB7XG4gICAgICB0aGlzLl9wcmV2aW91c1Njcm9sbERhdGEudmlzaWJsZUVudHJ5VG9wID0gZW50cnkudGFyZ2V0Lm9mZnNldFRvcDtcbiAgICAgIHRoaXMuX3Byb2Nlc3ModGFyZ2V0RWxlbWVudChlbnRyeSkpO1xuICAgIH07XG4gICAgY29uc3QgcGFyZW50U2Nyb2xsVG9wID0gKHRoaXMuX3Jvb3RFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuc2Nyb2xsVG9wO1xuICAgIGNvbnN0IHVzZXJTY3JvbGxzRG93biA9IHBhcmVudFNjcm9sbFRvcCA+PSB0aGlzLl9wcmV2aW91c1Njcm9sbERhdGEucGFyZW50U2Nyb2xsVG9wO1xuICAgIHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS5wYXJlbnRTY3JvbGxUb3AgPSBwYXJlbnRTY3JvbGxUb3A7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICBpZiAoIWVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NsZWFyQWN0aXZlQ2xhc3ModGFyZ2V0RWxlbWVudChlbnRyeSkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVudHJ5SXNMb3dlclRoYW5QcmV2aW91cyA9IGVudHJ5LnRhcmdldC5vZmZzZXRUb3AgPj0gdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnZpc2libGVFbnRyeVRvcDtcbiAgICAgIC8vIGlmIHdlIGFyZSBzY3JvbGxpbmcgZG93biwgcGljayB0aGUgYmlnZ2VyIG9mZnNldFRvcFxuICAgICAgaWYgKHVzZXJTY3JvbGxzRG93biAmJiBlbnRyeUlzTG93ZXJUaGFuUHJldmlvdXMpIHtcbiAgICAgICAgYWN0aXZhdGUoZW50cnkpO1xuICAgICAgICAvLyBpZiBwYXJlbnQgaXNuJ3Qgc2Nyb2xsZWQsIGxldCdzIGtlZXAgdGhlIGZpcnN0IHZpc2libGUgaXRlbSwgYnJlYWtpbmcgdGhlIGl0ZXJhdGlvblxuICAgICAgICBpZiAoIXBhcmVudFNjcm9sbFRvcCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgd2UgYXJlIHNjcm9sbGluZyB1cCwgcGljayB0aGUgc21hbGxlc3Qgb2Zmc2V0VG9wXG4gICAgICBpZiAoIXVzZXJTY3JvbGxzRG93biAmJiAhZW50cnlJc0xvd2VyVGhhblByZXZpb3VzKSB7XG4gICAgICAgIGFjdGl2YXRlKGVudHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2luaXRpYWxpemVUYXJnZXRzQW5kT2JzZXJ2YWJsZXMoKSB7XG4gICAgdGhpcy5fdGFyZ2V0TGlua3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHRhcmdldExpbmtzID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9UQVJHRVRfTElOS1MsIHRoaXMuX2NvbmZpZy50YXJnZXQpO1xuICAgIGZvciAoY29uc3QgYW5jaG9yIG9mIHRhcmdldExpbmtzKSB7XG4gICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgYW5jaG9yIGhhcyBhbiBpZCBhbmQgaXMgbm90IGRpc2FibGVkXG4gICAgICBpZiAoIWFuY2hvci5oYXNoIHx8IGlzRGlzYWJsZWQoYW5jaG9yKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9ic2VydmFibGVTZWN0aW9uID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShkZWNvZGVVUkkoYW5jaG9yLmhhc2gpLCB0aGlzLl9lbGVtZW50KTtcblxuICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIG9ic2VydmFibGVTZWN0aW9uIGV4aXN0cyAmIGlzIHZpc2libGVcbiAgICAgIGlmIChpc1Zpc2libGUob2JzZXJ2YWJsZVNlY3Rpb24pKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldExpbmtzLnNldChkZWNvZGVVUkkoYW5jaG9yLmhhc2gpLCBhbmNob3IpO1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMuc2V0KGFuY2hvci5oYXNoLCBvYnNlcnZhYmxlU2VjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9wcm9jZXNzKHRhcmdldCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgPT09IHRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jbGVhckFjdGl2ZUNsYXNzKHRoaXMuX2NvbmZpZy50YXJnZXQpO1xuICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHRhcmdldDtcbiAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQxKTtcbiAgICB0aGlzLl9hY3RpdmF0ZVBhcmVudHModGFyZ2V0KTtcbiAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9BQ1RJVkFURSwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGFyZ2V0XG4gICAgfSk7XG4gIH1cbiAgX2FjdGl2YXRlUGFyZW50cyh0YXJnZXQpIHtcbiAgICAvLyBBY3RpdmF0ZSBkcm9wZG93biBwYXJlbnRzXG4gICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNKSkge1xuICAgICAgU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUkMSwgdGFyZ2V0LmNsb3Nlc3QoU0VMRUNUT1JfRFJPUERPV04pKS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGxpc3RHcm91cCBvZiBTZWxlY3RvckVuZ2luZS5wYXJlbnRzKHRhcmdldCwgU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVApKSB7XG4gICAgICAvLyBTZXQgdHJpZ2dlcmVkIGxpbmtzIHBhcmVudHMgYXMgYWN0aXZlXG4gICAgICAvLyBXaXRoIGJvdGggPHVsPiBhbmQgPG5hdj4gbWFya3VwIGEgcGFyZW50IGlzIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIGFueSBuYXYgYW5jZXN0b3JcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBTZWxlY3RvckVuZ2luZS5wcmV2KGxpc3RHcm91cCwgU0VMRUNUT1JfTElOS19JVEVNUykpIHtcbiAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfY2xlYXJBY3RpdmVDbGFzcyhwYXJlbnQpIHtcbiAgICBwYXJlbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSQxKTtcbiAgICBjb25zdCBhY3RpdmVOb2RlcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoYCR7U0VMRUNUT1JfVEFSR0VUX0xJTktTfS4ke0NMQVNTX05BTUVfQUNUSVZFJDF9YCwgcGFyZW50KTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgYWN0aXZlTm9kZXMpIHtcbiAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSQxKTtcbiAgICB9XG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBTY3JvbGxTcHkuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgfVxuICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG5cbkV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEkkMSwgKCkgPT4ge1xuICBmb3IgKGNvbnN0IHNweSBvZiBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfU1BZKSkge1xuICAgIFNjcm9sbFNweS5nZXRPckNyZWF0ZUluc3RhbmNlKHNweSk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihTY3JvbGxTcHkpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgdGFiLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUkMSA9ICd0YWInO1xuY29uc3QgREFUQV9LRVkkMSA9ICdicy50YWInO1xuY29uc3QgRVZFTlRfS0VZJDEgPSBgLiR7REFUQV9LRVkkMX1gO1xuY29uc3QgRVZFTlRfSElERSQxID0gYGhpZGUke0VWRU5UX0tFWSQxfWA7XG5jb25zdCBFVkVOVF9ISURERU4kMSA9IGBoaWRkZW4ke0VWRU5UX0tFWSQxfWA7XG5jb25zdCBFVkVOVF9TSE9XJDEgPSBgc2hvdyR7RVZFTlRfS0VZJDF9YDtcbmNvbnN0IEVWRU5UX1NIT1dOJDEgPSBgc2hvd24ke0VWRU5UX0tFWSQxfWA7XG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSA9IGBjbGljayR7RVZFTlRfS0VZJDF9YDtcbmNvbnN0IEVWRU5UX0tFWURPV04gPSBga2V5ZG93biR7RVZFTlRfS0VZJDF9YDtcbmNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkgPSBgbG9hZCR7RVZFTlRfS0VZJDF9YDtcbmNvbnN0IEFSUk9XX0xFRlRfS0VZID0gJ0Fycm93TGVmdCc7XG5jb25zdCBBUlJPV19SSUdIVF9LRVkgPSAnQXJyb3dSaWdodCc7XG5jb25zdCBBUlJPV19VUF9LRVkgPSAnQXJyb3dVcCc7XG5jb25zdCBBUlJPV19ET1dOX0tFWSA9ICdBcnJvd0Rvd24nO1xuY29uc3QgSE9NRV9LRVkgPSAnSG9tZSc7XG5jb25zdCBFTkRfS0VZID0gJ0VuZCc7XG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSA9ICdhY3RpdmUnO1xuY29uc3QgQ0xBU1NfTkFNRV9GQURFJDEgPSAnZmFkZSc7XG5jb25zdCBDTEFTU19OQU1FX1NIT1ckMSA9ICdzaG93JztcbmNvbnN0IENMQVNTX0RST1BET1dOID0gJ2Ryb3Bkb3duJztcbmNvbnN0IFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSA9ICcuZHJvcGRvd24tdG9nZ2xlJztcbmNvbnN0IFNFTEVDVE9SX0RST1BET1dOX01FTlUgPSAnLmRyb3Bkb3duLW1lbnUnO1xuY29uc3QgTk9UX1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRSA9IGA6bm90KCR7U0VMRUNUT1JfRFJPUERPV05fVE9HR0xFfSlgO1xuY29uc3QgU0VMRUNUT1JfVEFCX1BBTkVMID0gJy5saXN0LWdyb3VwLCAubmF2LCBbcm9sZT1cInRhYmxpc3RcIl0nO1xuY29uc3QgU0VMRUNUT1JfT1VURVIgPSAnLm5hdi1pdGVtLCAubGlzdC1ncm91cC1pdGVtJztcbmNvbnN0IFNFTEVDVE9SX0lOTkVSID0gYC5uYXYtbGluayR7Tk9UX1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRX0sIC5saXN0LWdyb3VwLWl0ZW0ke05PVF9TRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEV9LCBbcm9sZT1cInRhYlwiXSR7Tk9UX1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRX1gO1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUgPSAnW2RhdGEtYnMtdG9nZ2xlPVwidGFiXCJdLCBbZGF0YS1icy10b2dnbGU9XCJwaWxsXCJdLCBbZGF0YS1icy10b2dnbGU9XCJsaXN0XCJdJzsgLy8gVE9ETzogY291bGQgb25seSBiZSBgdGFiYCBpbiB2NlxuY29uc3QgU0VMRUNUT1JfSU5ORVJfRUxFTSA9IGAke1NFTEVDVE9SX0lOTkVSfSwgJHtTRUxFQ1RPUl9EQVRBX1RPR0dMRX1gO1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEVfQUNUSVZFID0gYC4ke0NMQVNTX05BTUVfQUNUSVZFfVtkYXRhLWJzLXRvZ2dsZT1cInRhYlwiXSwgLiR7Q0xBU1NfTkFNRV9BQ1RJVkV9W2RhdGEtYnMtdG9nZ2xlPVwicGlsbFwiXSwgLiR7Q0xBU1NfTkFNRV9BQ1RJVkV9W2RhdGEtYnMtdG9nZ2xlPVwibGlzdFwiXWA7XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIFRhYiBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudCk7XG4gICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX1RBQl9QQU5FTCk7XG4gICAgaWYgKCF0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICAgIC8vIFRPRE86IHNob3VsZCB0aHJvdyBleGNlcHRpb24gaW4gdjZcbiAgICAgIC8vIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZWxlbWVudC5vdXRlckhUTUx9IGhhcyBub3QgYSB2YWxpZCBwYXJlbnQgJHtTRUxFQ1RPUl9JTk5FUl9FTEVNfWApXG4gICAgfVxuXG4gICAgLy8gU2V0IHVwIGluaXRpYWwgYXJpYSBhdHRyaWJ1dGVzXG4gICAgdGhpcy5fc2V0SW5pdGlhbEF0dHJpYnV0ZXModGhpcy5fcGFyZW50LCB0aGlzLl9nZXRDaGlsZHJlbigpKTtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZRE9XTiwgZXZlbnQgPT4gdGhpcy5fa2V5ZG93bihldmVudCkpO1xuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUUkMTtcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICBzaG93KCkge1xuICAgIC8vIFNob3dzIHRoaXMgZWxlbSBhbmQgZGVhY3RpdmF0ZSB0aGUgYWN0aXZlIHNpYmxpbmcgaWYgZXhpc3RzXG4gICAgY29uc3QgaW5uZXJFbGVtID0gdGhpcy5fZWxlbWVudDtcbiAgICBpZiAodGhpcy5fZWxlbUlzQWN0aXZlKGlubmVyRWxlbSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTZWFyY2ggZm9yIGFjdGl2ZSB0YWIgb24gc2FtZSBwYXJlbnQgdG8gZGVhY3RpdmF0ZSBpdFxuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW0oKTtcbiAgICBjb25zdCBoaWRlRXZlbnQgPSBhY3RpdmUgPyBFdmVudEhhbmRsZXIudHJpZ2dlcihhY3RpdmUsIEVWRU5UX0hJREUkMSwge1xuICAgICAgcmVsYXRlZFRhcmdldDogaW5uZXJFbGVtXG4gICAgfSkgOiBudWxsO1xuICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKGlubmVyRWxlbSwgRVZFTlRfU0hPVyQxLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiBhY3RpdmVcbiAgICB9KTtcbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgaGlkZUV2ZW50ICYmIGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RlYWN0aXZhdGUoYWN0aXZlLCBpbm5lckVsZW0pO1xuICAgIHRoaXMuX2FjdGl2YXRlKGlubmVyRWxlbSwgYWN0aXZlKTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2FjdGl2YXRlKGVsZW1lbnQsIHJlbGF0ZWRFbGVtKSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSk7XG4gICAgdGhpcy5fYWN0aXZhdGUoU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KSk7IC8vIFNlYXJjaCBhbmQgYWN0aXZhdGUvc2hvdyB0aGUgcHJvcGVyIHNlY3Rpb25cblxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJykgIT09ICd0YWInKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKTtcbiAgICAgIHRoaXMuX3RvZ2dsZURyb3BEb3duKGVsZW1lbnQsIHRydWUpO1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIoZWxlbWVudCwgRVZFTlRfU0hPV04kMSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkRWxlbVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCBlbGVtZW50LCBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMSkpO1xuICB9XG4gIF9kZWFjdGl2YXRlKGVsZW1lbnQsIHJlbGF0ZWRFbGVtKSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSk7XG4gICAgZWxlbWVudC5ibHVyKCk7XG4gICAgdGhpcy5fZGVhY3RpdmF0ZShTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKGVsZW1lbnQpKTsgLy8gU2VhcmNoIGFuZCBkZWFjdGl2YXRlIHRoZSBzaG93biBzZWN0aW9uIHRvb1xuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSAhPT0gJ3RhYicpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIHRoaXMuX3RvZ2dsZURyb3BEb3duKGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKGVsZW1lbnQsIEVWRU5UX0hJRERFTiQxLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRFbGVtXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIGVsZW1lbnQsIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQxKSk7XG4gIH1cbiAgX2tleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoIVtBUlJPV19MRUZUX0tFWSwgQVJST1dfUklHSFRfS0VZLCBBUlJPV19VUF9LRVksIEFSUk9XX0RPV05fS0VZLCBIT01FX0tFWSwgRU5EX0tFWV0uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gc3RvcFByb3BhZ2F0aW9uL3ByZXZlbnREZWZhdWx0IGJvdGggYWRkZWQgdG8gc3VwcG9ydCB1cC9kb3duIGtleXMgd2l0aG91dCBzY3JvbGxpbmcgdGhlIHBhZ2VcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fZ2V0Q2hpbGRyZW4oKS5maWx0ZXIoZWxlbWVudCA9PiAhaXNEaXNhYmxlZChlbGVtZW50KSk7XG4gICAgbGV0IG5leHRBY3RpdmVFbGVtZW50O1xuICAgIGlmIChbSE9NRV9LRVksIEVORF9LRVldLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgIG5leHRBY3RpdmVFbGVtZW50ID0gY2hpbGRyZW5bZXZlbnQua2V5ID09PSBIT01FX0tFWSA/IDAgOiBjaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXNOZXh0ID0gW0FSUk9XX1JJR0hUX0tFWSwgQVJST1dfRE9XTl9LRVldLmluY2x1ZGVzKGV2ZW50LmtleSk7XG4gICAgICBuZXh0QWN0aXZlRWxlbWVudCA9IGdldE5leHRBY3RpdmVFbGVtZW50KGNoaWxkcmVuLCBldmVudC50YXJnZXQsIGlzTmV4dCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChuZXh0QWN0aXZlRWxlbWVudCkge1xuICAgICAgbmV4dEFjdGl2ZUVsZW1lbnQuZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKG5leHRBY3RpdmVFbGVtZW50KS5zaG93KCk7XG4gICAgfVxuICB9XG4gIF9nZXRDaGlsZHJlbigpIHtcbiAgICAvLyBjb2xsZWN0aW9uIG9mIGlubmVyIGVsZW1lbnRzXG4gICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfSU5ORVJfRUxFTSwgdGhpcy5fcGFyZW50KTtcbiAgfVxuICBfZ2V0QWN0aXZlRWxlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2hpbGRyZW4oKS5maW5kKGNoaWxkID0+IHRoaXMuX2VsZW1Jc0FjdGl2ZShjaGlsZCkpIHx8IG51bGw7XG4gIH1cbiAgX3NldEluaXRpYWxBdHRyaWJ1dGVzKHBhcmVudCwgY2hpbGRyZW4pIHtcbiAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyhwYXJlbnQsICdyb2xlJywgJ3RhYmxpc3QnKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICB0aGlzLl9zZXRJbml0aWFsQXR0cmlidXRlc09uQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBfc2V0SW5pdGlhbEF0dHJpYnV0ZXNPbkNoaWxkKGNoaWxkKSB7XG4gICAgY2hpbGQgPSB0aGlzLl9nZXRJbm5lckVsZW1lbnQoY2hpbGQpO1xuICAgIGNvbnN0IGlzQWN0aXZlID0gdGhpcy5fZWxlbUlzQWN0aXZlKGNoaWxkKTtcbiAgICBjb25zdCBvdXRlckVsZW0gPSB0aGlzLl9nZXRPdXRlckVsZW1lbnQoY2hpbGQpO1xuICAgIGNoaWxkLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGlzQWN0aXZlKTtcbiAgICBpZiAob3V0ZXJFbGVtICE9PSBjaGlsZCkge1xuICAgICAgdGhpcy5fc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMob3V0ZXJFbGVtLCAncm9sZScsICdwcmVzZW50YXRpb24nKTtcbiAgICB9XG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyhjaGlsZCwgJ3JvbGUnLCAndGFiJyk7XG5cbiAgICAvLyBzZXQgYXR0cmlidXRlcyB0byB0aGUgcmVsYXRlZCBwYW5lbCB0b29cbiAgICB0aGlzLl9zZXRJbml0aWFsQXR0cmlidXRlc09uVGFyZ2V0UGFuZWwoY2hpbGQpO1xuICB9XG4gIF9zZXRJbml0aWFsQXR0cmlidXRlc09uVGFyZ2V0UGFuZWwoY2hpbGQpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKGNoaWxkKTtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyh0YXJnZXQsICdyb2xlJywgJ3RhYnBhbmVsJyk7XG4gICAgaWYgKGNoaWxkLmlkKSB7XG4gICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyh0YXJnZXQsICdhcmlhLWxhYmVsbGVkYnknLCBgJHtjaGlsZC5pZH1gKTtcbiAgICB9XG4gIH1cbiAgX3RvZ2dsZURyb3BEb3duKGVsZW1lbnQsIG9wZW4pIHtcbiAgICBjb25zdCBvdXRlckVsZW0gPSB0aGlzLl9nZXRPdXRlckVsZW1lbnQoZWxlbWVudCk7XG4gICAgaWYgKCFvdXRlckVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX0RST1BET1dOKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0b2dnbGUgPSAoc2VsZWN0b3IsIGNsYXNzTmFtZSkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoc2VsZWN0b3IsIG91dGVyRWxlbSk7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lLCBvcGVuKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRvZ2dsZShTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUsIENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICB0b2dnbGUoU0VMRUNUT1JfRFJPUERPV05fTUVOVSwgQ0xBU1NfTkFNRV9TSE9XJDEpO1xuICAgIG91dGVyRWxlbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBvcGVuKTtcbiAgfVxuICBfc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlKSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIF9lbGVtSXNBY3RpdmUoZWxlbSkge1xuICAgIHJldHVybiBlbGVtLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0FDVElWRSk7XG4gIH1cblxuICAvLyBUcnkgdG8gZ2V0IHRoZSBpbm5lciBlbGVtZW50ICh1c3VhbGx5IHRoZSAubmF2LWxpbmspXG4gIF9nZXRJbm5lckVsZW1lbnQoZWxlbSkge1xuICAgIHJldHVybiBlbGVtLm1hdGNoZXMoU0VMRUNUT1JfSU5ORVJfRUxFTSkgPyBlbGVtIDogU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9JTk5FUl9FTEVNLCBlbGVtKTtcbiAgfVxuXG4gIC8vIFRyeSB0byBnZXQgdGhlIG91dGVyIGVsZW1lbnQgKHVzdWFsbHkgdGhlIC5uYXYtaXRlbSlcbiAgX2dldE91dGVyRWxlbWVudChlbGVtKSB7XG4gICAgcmV0dXJuIGVsZW0uY2xvc2VzdChTRUxFQ1RPUl9PVVRFUikgfHwgZWxlbTtcbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgfVxuICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgaWYgKGlzRGlzYWJsZWQodGhpcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykuc2hvdygpO1xufSk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBvbiBmb2N1c1xuICovXG5FdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJLCAoKSA9PiB7XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFX0FDVElWRSkpIHtcbiAgICBUYWIuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50KTtcbiAgfVxufSk7XG4vKipcbiAqIGpRdWVyeVxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihUYWIpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgdG9hc3QuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTkFNRSA9ICd0b2FzdCc7XG5jb25zdCBEQVRBX0tFWSA9ICdicy50b2FzdCc7XG5jb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YDtcbmNvbnN0IEVWRU5UX01PVVNFT1ZFUiA9IGBtb3VzZW92ZXIke0VWRU5UX0tFWX1gO1xuY29uc3QgRVZFTlRfTU9VU0VPVVQgPSBgbW91c2VvdXQke0VWRU5UX0tFWX1gO1xuY29uc3QgRVZFTlRfRk9DVVNJTiA9IGBmb2N1c2luJHtFVkVOVF9LRVl9YDtcbmNvbnN0IEVWRU5UX0ZPQ1VTT1VUID0gYGZvY3Vzb3V0JHtFVkVOVF9LRVl9YDtcbmNvbnN0IEVWRU5UX0hJREUgPSBgaGlkZSR7RVZFTlRfS0VZfWA7XG5jb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YDtcbmNvbnN0IEVWRU5UX1NIT1cgPSBgc2hvdyR7RVZFTlRfS0VZfWA7XG5jb25zdCBFVkVOVF9TSE9XTiA9IGBzaG93biR7RVZFTlRfS0VZfWA7XG5jb25zdCBDTEFTU19OQU1FX0ZBREUgPSAnZmFkZSc7XG5jb25zdCBDTEFTU19OQU1FX0hJREUgPSAnaGlkZSc7IC8vIEBkZXByZWNhdGVkIC0ga2VwdCBoZXJlIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5jb25zdCBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdyc7XG5jb25zdCBDTEFTU19OQU1FX1NIT1dJTkcgPSAnc2hvd2luZyc7XG5jb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgYW5pbWF0aW9uOiAnYm9vbGVhbicsXG4gIGF1dG9oaWRlOiAnYm9vbGVhbicsXG4gIGRlbGF5OiAnbnVtYmVyJ1xufTtcbmNvbnN0IERlZmF1bHQgPSB7XG4gIGFuaW1hdGlvbjogdHJ1ZSxcbiAgYXV0b2hpZGU6IHRydWUsXG4gIGRlbGF5OiA1MDAwXG59O1xuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBUb2FzdCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICAgIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSBmYWxzZTtcbiAgICB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdDtcbiAgfVxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUU7XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgc2hvdygpIHtcbiAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XKTtcbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5hbmltYXRpb24pIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUpO1xuICAgIH1cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1dJTkcpO1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04pO1xuICAgICAgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKTtcbiAgICB9O1xuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0hJREUpOyAvLyBAZGVwcmVjYXRlZFxuICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KTtcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XLCBDTEFTU19OQU1FX1NIT1dJTkcpO1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzU2hvd24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFKTtcbiAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9ISURFKTsgLy8gQGRlcHJlY2F0ZWRcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1dJTkcsIENMQVNTX05BTUVfU0hPVyk7XG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4pO1xuICAgIH07XG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPV0lORyk7XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbik7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgICBpZiAodGhpcy5pc1Nob3duKCkpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1cpO1xuICAgIH1cbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgaXNTaG93bigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX21heWJlU2NoZWR1bGVIaWRlKCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLmF1dG9oaWRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uIHx8IHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5KTtcbiAgfVxuICBfb25JbnRlcmFjdGlvbihldmVudCwgaXNJbnRlcmFjdGluZykge1xuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSBpc0ludGVyYWN0aW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdmb2N1c2luJzpcbiAgICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBpc0ludGVyYWN0aW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0ludGVyYWN0aW5nKSB7XG4gICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV4dEVsZW1lbnQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIGlmICh0aGlzLl9lbGVtZW50ID09PSBuZXh0RWxlbWVudCB8fCB0aGlzLl9lbGVtZW50LmNvbnRhaW5zKG5leHRFbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tYXliZVNjaGVkdWxlSGlkZSgpO1xuICB9XG4gIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFT1ZFUiwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgdHJ1ZSkpO1xuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRU9VVCwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgZmFsc2UpKTtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfRk9DVVNJTiwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgdHJ1ZSkpO1xuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9GT0NVU09VVCwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgZmFsc2UpKTtcbiAgfVxuICBfY2xlYXJUaW1lb3V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IFRvYXN0LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXSh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cblxuZW5hYmxlRGlzbWlzc1RyaWdnZXIoVG9hc3QpO1xuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihUb2FzdCk7XG5cbmV4cG9ydCB7IEFsZXJ0LCBCdXR0b24sIENhcm91c2VsLCBDb2xsYXBzZSwgRHJvcGRvd24sIE1vZGFsLCBPZmZjYW52YXMsIFBvcG92ZXIsIFNjcm9sbFNweSwgVGFiLCBUb2FzdCwgVG9vbHRpcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vdHN0cmFwLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bootstrap/dist/js/bootstrap.esm.js\n\n}");

/***/ }),

/***/ "./resources/css/auth.scss":
/*!*********************************!*\
  !*** ./resources/css/auth.scss ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvY3NzL2F1dGguc2NzcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vcmVzb3VyY2VzL2Nzcy9hdXRoLnNjc3M/MmIzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/css/auth.scss\n\n}");

/***/ }),

/***/ "./resources/css/panel.scss":
/*!**********************************!*\
  !*** ./resources/css/panel.scss ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvY3NzL3BhbmVsLnNjc3MiLCJtYXBwaW5ncyI6IjtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL3Jlc291cmNlcy9jc3MvcGFuZWwuc2Nzcz8yOGYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/css/panel.scss\n\n}");

/***/ }),

/***/ "./resources/js/Editor/BlockEditor.js":
/*!********************************************!*\
  !*** ./resources/js/Editor/BlockEditor.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _editorjs_editorjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @editorjs/editorjs */ \"./node_modules/@editorjs/editorjs/dist/editorjs.mjs\");\n/* harmony import */ var _editorjs_delimiter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @editorjs/delimiter */ \"./node_modules/@editorjs/delimiter/dist/delimiter.mjs\");\n/* harmony import */ var _editorjs_underline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @editorjs/underline */ \"./node_modules/@editorjs/underline/dist/underline.mjs\");\n/* harmony import */ var _editorjs_code__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @editorjs/code */ \"./node_modules/@editorjs/code/dist/code.mjs\");\n/* harmony import */ var _Plugins_Config_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Plugins/Config.js */ \"./resources/js/Editor/Plugins/Config.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2)); }, _regeneratorDefine2(e, r, n, t); }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n\nvar BlockEditor = /*#__PURE__*/function () {\n  function BlockEditor(selector) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$tools = _ref.tools,\n      tools = _ref$tools === void 0 ? {} : _ref$tools,\n      _ref$data = _ref.data,\n      data = _ref$data === void 0 ? {} : _ref$data,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,\n      _ref$onSave = _ref.onSave,\n      onSave = _ref$onSave === void 0 ? function () {} : _ref$onSave;\n    _classCallCheck(this, BlockEditor);\n    this.selector = selector;\n    this.tools = _objectSpread({\n      header: _Plugins_Config_js__WEBPACK_IMPORTED_MODULE_4__.header,\n      paragraph: _Plugins_Config_js__WEBPACK_IMPORTED_MODULE_4__.paragraph,\n      quote: _Plugins_Config_js__WEBPACK_IMPORTED_MODULE_4__.quote,\n      delimiter: _editorjs_delimiter__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n      List: _Plugins_Config_js__WEBPACK_IMPORTED_MODULE_4__.list,\n      underline: _editorjs_underline__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n      code: _editorjs_code__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n      image: _Plugins_Config_js__WEBPACK_IMPORTED_MODULE_4__.image\n    }, tools);\n    this.onChangeCallback = onChange;\n    this.onSaveCallback = onSave;\n    this.init(data);\n  }\n  return _createClass(BlockEditor, [{\n    key: \"init\",\n    value: function init(initialData) {\n      var _this = this;\n      this.editor = new _editorjs_editorjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n        holder: this.selector,\n        tools: this.tools,\n        data: initialData,\n        autofocus: true,\n        placeholder: \"Start writing your content here...\",\n        onChange: function () {\n          var _onChange = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {\n            var content, _t;\n            return _regenerator().w(function (_context) {\n              while (1) switch (_context.p = _context.n) {\n                case 0:\n                  _context.p = 0;\n                  _context.n = 1;\n                  return _this.editor.save();\n                case 1:\n                  content = _context.v;\n                  _this.onChangeCallback(content);\n                  _context.n = 3;\n                  break;\n                case 2:\n                  _context.p = 2;\n                  _t = _context.v;\n                  console.error(\"Editor change capture failed :: \", _t);\n                case 3:\n                  return _context.a(2);\n              }\n            }, _callee, null, [[0, 2]]);\n          }));\n          function onChange() {\n            return _onChange.apply(this, arguments);\n          }\n          return onChange;\n        }()\n      });\n    }\n  }, {\n    key: \"attachContentHandler\",\n    value: function attachContentHandler(element) {\n      var editor = this.editor;\n      editor.isReady.then(function () {\n        var raw = element.value;\n        if (!raw) return;\n        try {\n          var parsed = JSON.parse(raw);\n          return editor.render(parsed);\n        } catch (err) {\n          console.log(\"Inavlid JSON in editor field :: \", err);\n        }\n      })[\"catch\"](function (err) {\n        console.error(\"Error loading saved content: \", err);\n      });\n    }\n  }, {\n    key: \"saveContent\",\n    value: function () {\n      var _saveContent = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(outputId) {\n        var savedData, _t2;\n        return _regenerator().w(function (_context2) {\n          while (1) switch (_context2.p = _context2.n) {\n            case 0:\n              _context2.p = 0;\n              _context2.n = 1;\n              return this.editor.save();\n            case 1:\n              savedData = _context2.v;\n              document.getElementById(outputId).textContent = JSON.stringify(savedData, null, 2);\n              _context2.n = 3;\n              break;\n            case 2:\n              _context2.p = 2;\n              _t2 = _context2.v;\n              console.error(\"Save failed :: \", _t2);\n            case 3:\n              return _context2.a(2);\n          }\n        }, _callee2, this, [[0, 2]]);\n      }));\n      function saveContent(_x) {\n        return _saveContent.apply(this, arguments);\n      }\n      return saveContent;\n    }()\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BlockEditor);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU8sQ0FBQ0MsS0FBSyxDQUFDLGlCQUFpQixFQUFBZSxHQUFLLENBQUM7WUFBQztjQUFBLE9BQUFDLFNBQUEsQ0FBQS9HLENBQUE7VUFBQTtRQUFBLEdBQUEyRyxRQUFBO01BQUEsQ0FFN0M7TUFBQSxTQVBLUyxXQUFXQSxDQUFBQyxFQUFBO1FBQUEsT0FBQVgsWUFBQSxDQUFBNUUsS0FBQSxPQUFBRCxTQUFBO01BQUE7TUFBQSxPQUFYdUYsV0FBVztJQUFBO0VBQUE7QUFBQTtBQVVyQixpRUFBZXJELFdBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vcmVzb3VyY2VzL2pzL0VkaXRvci9CbG9ja0VkaXRvci5qcz9iMWU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFZGl0b3JKUyBmcm9tIFwiQGVkaXRvcmpzL2VkaXRvcmpzXCI7XHJcbmltcG9ydCBEZWxpbWl0ZXIgZnJvbSBcIkBlZGl0b3Jqcy9kZWxpbWl0ZXJcIjtcclxuaW1wb3J0IFVuZGVybGluZSBmcm9tIFwiQGVkaXRvcmpzL3VuZGVybGluZVwiO1xyXG5pbXBvcnQgQ29kZVRvb2wgZnJvbSBcIkBlZGl0b3Jqcy9jb2RlXCI7XHJcbmltcG9ydCB7XHJcbiAgICBoZWFkZXIsXHJcbiAgICBwYXJhZ3JhcGgsXHJcbiAgICBxdW90ZSxcclxuICAgIGxpc3QsXHJcbiAgICBpbWFnZVxyXG59IGZyb20gXCIuL1BsdWdpbnMvQ29uZmlnLmpzXCI7XHJcblxyXG5jbGFzcyBCbG9ja0VkaXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZWxlY3Rvciwge1xyXG4gICAgICAgIHRvb2xzID0ge30sXHJcbiAgICAgICAgZGF0YSA9IHt9LFxyXG4gICAgICAgIG9uQ2hhbmdlID0gKCkgPT4ge30sXHJcbiAgICAgICAgb25TYXZlID0gKCkgPT4ge31cclxuICAgIH0gPSB7fSkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcclxuICAgICAgICB0aGlzLnRvb2xzID0ge1xyXG4gICAgICAgICAgICBoZWFkZXI6IGhlYWRlcixcclxuICAgICAgICAgICAgcGFyYWdyYXBoOiBwYXJhZ3JhcGgsXHJcbiAgICAgICAgICAgIHF1b3RlOiBxdW90ZSxcclxuICAgICAgICAgICAgZGVsaW1pdGVyOiBEZWxpbWl0ZXIsXHJcbiAgICAgICAgICAgIExpc3Q6IGxpc3QsXHJcbiAgICAgICAgICAgIHVuZGVybGluZTogVW5kZXJsaW5lLFxyXG4gICAgICAgICAgICBjb2RlOiBDb2RlVG9vbCxcclxuICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxyXG4gICAgICAgICAgICAuLi50b29sc1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gb25DaGFuZ2U7XHJcbiAgICAgICAgdGhpcy5vblNhdmVDYWxsYmFjayA9IG9uU2F2ZTtcclxuICAgICAgICB0aGlzLmluaXQoZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdChpbml0aWFsRGF0YSkge1xyXG4gICAgICAgIHRoaXMuZWRpdG9yID0gbmV3IEVkaXRvckpTKHtcclxuICAgICAgICAgICAgaG9sZGVyOiB0aGlzLnNlbGVjdG9yLFxyXG4gICAgICAgICAgICB0b29sczogdGhpcy50b29scyxcclxuICAgICAgICAgICAgZGF0YTogaW5pdGlhbERhdGEsXHJcbiAgICAgICAgICAgIGF1dG9mb2N1czogdHJ1ZSxcclxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiU3RhcnQgd3JpdGluZyB5b3VyIGNvbnRlbnQgaGVyZS4uLlwiLFxyXG4gICAgICAgICAgICBvbkNoYW5nZTogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5lZGl0b3Iuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayhjb250ZW50KTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFZGl0b3IgY2hhbmdlIGNhcHR1cmUgZmFpbGVkIDo6IFwiLCBlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgYXR0YWNoQ29udGVudEhhbmRsZXIoZWxlbWVudCkge1xyXG4gICAgICAgIGxldCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcclxuICAgICAgICBlZGl0b3IuaXNSZWFkeVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByYXcgPSBlbGVtZW50LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYoIXJhdykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShyYXcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlZGl0b3IucmVuZGVyKHBhcnNlZCk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkluYXZsaWQgSlNPTiBpbiBlZGl0b3IgZmllbGQgOjogXCIsIGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgbG9hZGluZyBzYXZlZCBjb250ZW50OiBcIiwgZXJyKTtcclxuICAgICAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBzYXZlQ29udGVudChvdXRwdXRJZCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNhdmVkRGF0YSA9IGF3YWl0IHRoaXMuZWRpdG9yLnNhdmUoKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3V0cHV0SWQpLnRleHRDb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoc2F2ZWREYXRhLCBudWxsLCAyKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlNhdmUgZmFpbGVkIDo6IFwiLCBlcnIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQmxvY2tFZGl0b3I7XHJcbiJdLCJuYW1lcyI6WyJlIiwidCIsInIiLCJTeW1ib2wiLCJuIiwiaXRlcmF0b3IiLCJvIiwidG9TdHJpbmdUYWciLCJpIiwiYyIsInByb3RvdHlwZSIsIkdlbmVyYXRvciIsInUiLCJPYmplY3QiLCJjcmVhdGUiLCJfcmVnZW5lcmF0b3JEZWZpbmUyIiwiZiIsInAiLCJ5IiwiRyIsInYiLCJhIiwiZCIsImJpbmQiLCJsZW5ndGgiLCJsIiwiVHlwZUVycm9yIiwiY2FsbCIsImRvbmUiLCJ2YWx1ZSIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiZGlzcGxheU5hbWUiLCJfcmVnZW5lcmF0b3IiLCJ3IiwibSIsImRlZmluZVByb3BlcnR5IiwiX3JlZ2VuZXJhdG9yRGVmaW5lIiwiX2ludm9rZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImFzeW5jR2VuZXJhdG9yU3RlcCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsIl9hc3luY1RvR2VuZXJhdG9yIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJfbmV4dCIsIl90aHJvdyIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicHVzaCIsIl9vYmplY3RTcHJlYWQiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfdG9Qcm9wZXJ0eUtleSIsIl9jbGFzc0NhbGxDaGVjayIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwiX3RvUHJpbWl0aXZlIiwiX3R5cGVvZiIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiRWRpdG9ySlMiLCJEZWxpbWl0ZXIiLCJVbmRlcmxpbmUiLCJDb2RlVG9vbCIsImhlYWRlciIsInBhcmFncmFwaCIsInF1b3RlIiwibGlzdCIsImltYWdlIiwiQmxvY2tFZGl0b3IiLCJzZWxlY3RvciIsIl9yZWYiLCJ1bmRlZmluZWQiLCJfcmVmJHRvb2xzIiwidG9vbHMiLCJfcmVmJGRhdGEiLCJkYXRhIiwiX3JlZiRvbkNoYW5nZSIsIm9uQ2hhbmdlIiwiX3JlZiRvblNhdmUiLCJvblNhdmUiLCJkZWxpbWl0ZXIiLCJMaXN0IiwidW5kZXJsaW5lIiwiY29kZSIsIm9uQ2hhbmdlQ2FsbGJhY2siLCJvblNhdmVDYWxsYmFjayIsImluaXQiLCJpbml0aWFsRGF0YSIsIl90aGlzIiwiZWRpdG9yIiwiaG9sZGVyIiwiYXV0b2ZvY3VzIiwicGxhY2Vob2xkZXIiLCJfb25DaGFuZ2UiLCJfY2FsbGVlIiwiY29udGVudCIsIl90IiwiX2NvbnRleHQiLCJzYXZlIiwiY29uc29sZSIsImVycm9yIiwiYXR0YWNoQ29udGVudEhhbmRsZXIiLCJlbGVtZW50IiwiaXNSZWFkeSIsInJhdyIsInBhcnNlZCIsIkpTT04iLCJwYXJzZSIsInJlbmRlciIsImVyciIsImxvZyIsIl9zYXZlQ29udGVudCIsIl9jYWxsZWUyIiwib3V0cHV0SWQiLCJzYXZlZERhdGEiLCJfdDIiLCJfY29udGV4dDIiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwidGV4dENvbnRlbnQiLCJzdHJpbmdpZnkiLCJzYXZlQ29udGVudCIsIl94Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/Editor/BlockEditor.js\n\n}");

/***/ }),

/***/ "./resources/js/Editor/Plugins/Config.js":
/*!***********************************************!*\
  !*** ./resources/js/Editor/Plugins/Config.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   header: () => (/* binding */ header),\n/* harmony export */   image: () => (/* binding */ image),\n/* harmony export */   list: () => (/* binding */ list),\n/* harmony export */   paragraph: () => (/* binding */ paragraph),\n/* harmony export */   quote: () => (/* binding */ quote)\n/* harmony export */ });\n/* harmony import */ var _editorjs_header__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @editorjs/header */ \"./node_modules/@editorjs/header/dist/header.mjs\");\n/* harmony import */ var _editorjs_paragraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @editorjs/paragraph */ \"./node_modules/@editorjs/paragraph/dist/paragraph.mjs\");\n/* harmony import */ var _editorjs_quote__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @editorjs/quote */ \"./node_modules/@editorjs/quote/dist/quote.mjs\");\n/* harmony import */ var _editorjs_list__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @editorjs/list */ \"./node_modules/@editorjs/list/dist/editorjs-list.mjs\");\n/* harmony import */ var _editorjs_image__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @editorjs/image */ \"./node_modules/@editorjs/image/dist/image.mjs\");\n\n\n\n\n\nvar header = {\n  \"class\": _editorjs_header__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  inlineToolbar: true,\n  levels: [1, 2, 3, 4, 5, 6],\n  defaultLevel: 2\n};\nvar paragraph = {\n  \"class\": _editorjs_paragraph__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  inlineToolbar: true\n};\nvar quote = {\n  \"class\": _editorjs_quote__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n  inlineToolbar: true,\n  config: {\n    quotePlaceholder: \"Enter a quote\",\n    captionPlaceholder: \"Quote's author\"\n  }\n};\nvar list = {\n  \"class\": _editorjs_list__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n  inlineToolbar: true,\n  config: {\n    defaultStyle: 'unordered'\n  }\n};\nvar image = {\n  \"class\": _editorjs_image__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n  config: {\n    endpoints: {\n      byFile: \"/api/upload/image\"\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvRWRpdG9yL1BsdWdpbnMvQ29uZmlnLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBc0M7QUFDTTtBQUNSO0FBQ007QUFDRjtBQUVqQyxJQUFNSyxNQUFNLEdBQUc7RUFDbEIsU0FBT0wsd0RBQU07RUFDYk0sYUFBYSxFQUFFLElBQUk7RUFDbkJDLE1BQU0sRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0VBQzFCQyxZQUFZLEVBQUU7QUFDbEIsQ0FBQztBQUVNLElBQU1DLFNBQVMsR0FBRztFQUNyQixTQUFPUiwyREFBUztFQUNoQkssYUFBYSxFQUFFO0FBQ25CLENBQUM7QUFFTSxJQUFNSSxLQUFLLEdBQUc7RUFDakIsU0FBT1IsdURBQUs7RUFDWkksYUFBYSxFQUFFLElBQUk7RUFDbkJLLE1BQU0sRUFBRTtJQUNKQyxnQkFBZ0IsRUFBRSxlQUFlO0lBQ2pDQyxrQkFBa0IsRUFBRTtFQUN4QjtBQUNKLENBQUM7QUFFTSxJQUFNQyxJQUFJLEdBQUc7RUFDaEIsU0FBT1gsc0RBQVk7RUFDbkJHLGFBQWEsRUFBRSxJQUFJO0VBQ25CSyxNQUFNLEVBQUU7SUFDSkksWUFBWSxFQUFFO0VBQ2xCO0FBQ0osQ0FBQztBQUVNLElBQU1DLEtBQUssR0FBRztFQUNqQixTQUFPWix1REFBUztFQUNoQk8sTUFBTSxFQUFFO0lBQ0pNLFNBQVMsRUFBRTtNQUNQQyxNQUFNLEVBQUU7SUFDWjtFQUNKO0FBQ0osQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9yZXNvdXJjZXMvanMvRWRpdG9yL1BsdWdpbnMvQ29uZmlnLmpzP2E0ODYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEhlYWRlciBmcm9tIFwiQGVkaXRvcmpzL2hlYWRlclwiO1xyXG5pbXBvcnQgUGFyYWdyYXBoIGZyb20gXCJAZWRpdG9yanMvcGFyYWdyYXBoXCI7XHJcbmltcG9ydCBRdW90ZSBmcm9tIFwiQGVkaXRvcmpzL3F1b3RlXCI7XHJcbmltcG9ydCBFZGl0b3Jqc0xpc3QgZnJvbSBcIkBlZGl0b3Jqcy9saXN0XCI7XHJcbmltcG9ydCBJbWFnZVRvb2wgZnJvbSBcIkBlZGl0b3Jqcy9pbWFnZVwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGhlYWRlciA9IHtcclxuICAgIGNsYXNzOiBIZWFkZXIsXHJcbiAgICBpbmxpbmVUb29sYmFyOiB0cnVlLFxyXG4gICAgbGV2ZWxzOiBbMSwgMiwgMywgNCwgNSwgNl0sXHJcbiAgICBkZWZhdWx0TGV2ZWw6IDJcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHBhcmFncmFwaCA9IHtcclxuICAgIGNsYXNzOiBQYXJhZ3JhcGgsXHJcbiAgICBpbmxpbmVUb29sYmFyOiB0cnVlXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBxdW90ZSA9IHtcclxuICAgIGNsYXNzOiBRdW90ZSxcclxuICAgIGlubGluZVRvb2xiYXI6IHRydWUsXHJcbiAgICBjb25maWc6IHtcclxuICAgICAgICBxdW90ZVBsYWNlaG9sZGVyOiBcIkVudGVyIGEgcXVvdGVcIixcclxuICAgICAgICBjYXB0aW9uUGxhY2Vob2xkZXI6IFwiUXVvdGUncyBhdXRob3JcIlxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgbGlzdCA9IHtcclxuICAgIGNsYXNzOiBFZGl0b3Jqc0xpc3QsXHJcbiAgICBpbmxpbmVUb29sYmFyOiB0cnVlLFxyXG4gICAgY29uZmlnOiB7XHJcbiAgICAgICAgZGVmYXVsdFN0eWxlOiAndW5vcmRlcmVkJ1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgaW1hZ2UgPSB7XHJcbiAgICBjbGFzczogSW1hZ2VUb29sLFxyXG4gICAgY29uZmlnOiB7XHJcbiAgICAgICAgZW5kcG9pbnRzOiB7XHJcbiAgICAgICAgICAgIGJ5RmlsZTogXCIvYXBpL3VwbG9hZC9pbWFnZVwiXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJIZWFkZXIiLCJQYXJhZ3JhcGgiLCJRdW90ZSIsIkVkaXRvcmpzTGlzdCIsIkltYWdlVG9vbCIsImhlYWRlciIsImlubGluZVRvb2xiYXIiLCJsZXZlbHMiLCJkZWZhdWx0TGV2ZWwiLCJwYXJhZ3JhcGgiLCJxdW90ZSIsImNvbmZpZyIsInF1b3RlUGxhY2Vob2xkZXIiLCJjYXB0aW9uUGxhY2Vob2xkZXIiLCJsaXN0IiwiZGVmYXVsdFN0eWxlIiwiaW1hZ2UiLCJlbmRwb2ludHMiLCJieUZpbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/Editor/Plugins/Config.js\n\n}");

/***/ }),

/***/ "./resources/js/Panel/Article.js":
/*!***************************************!*\
  !*** ./resources/js/Panel/Article.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./resources/js/Panel/utils.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _readOnlyError(r) { throw new TypeError('\"' + r + '\" is read-only'); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar Article = /*#__PURE__*/function () {\n  function Article() {\n    _classCallCheck(this, Article);\n  }\n  return _createClass(Article, [{\n    key: \"init\",\n    value: function init() {\n      var form = document.getElementById(\"article-form\");\n      if (form) {\n        this.processSlug();\n        this.bannerPreview();\n      }\n    }\n  }, {\n    key: \"processSlug\",\n    value: function processSlug() {\n      var titleInput = document.getElementById(\"title\");\n      var slugInput = document.getElementById(\"slug\");\n      titleInput.addEventListener(\"change\", function (e) {\n        var slug = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.makeSlug)(e.target.value);\n        slugInput.value = slug;\n      });\n    }\n  }, {\n    key: \"bannerPreview\",\n    value: function bannerPreview() {\n      var bannerInput = document.getElementById(\"banner-image\");\n      var bannerPreview = document.getElementById(\"banner-preview\");\n      bannerInput.addEventListener(\"change\", function (e) {\n        var file = e.target.files[0];\n        var preview = bannerPreview.querySelector(\"img\");\n        if (file && file.type.startsWith(\"image/\")) {\n          var reader = new FileReader();\n          reader.onload = function (event) {\n            preview.src = event.target.result;\n            bannerPreview.style.display = \"block\";\n          };\n          reader.readAsDataURL(file);\n        } else {\n          preview.src = \"\";\n          bannerPreview.style.display = \"none\";\n        }\n      });\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Article);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvUGFuZWwvQXJ0aWNsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFb0I7QUFBQSxJQUVkQyxPQUFPO0VBQUEsU0FBQUEsUUFBQTtJQUFBQyxlQUFBLE9BQUFELE9BQUE7RUFBQTtFQUFBLE9BQUFFLFlBQUEsQ0FBQUYsT0FBQTtJQUFBRyxHQUFBO0lBQUFDLEtBQUEsRUFDVCxTQUFBQyxJQUFJQSxDQUFBLEVBQUc7TUFDSCxJQUFNQyxJQUFJLEdBQUdDLFFBQVEsQ0FBQ0MsY0FBYyxDQUFDLGNBQWMsQ0FBQztNQUNwRCxJQUFHRixJQUFJLEVBQUU7UUFDTCxJQUFJLENBQUNHLFdBQVcsQ0FBQyxDQUFDO1FBQ2xCLElBQUksQ0FBQ0MsYUFBYSxDQUFDLENBQUM7TUFDeEI7SUFDSjtFQUFDO0lBQUFQLEdBQUE7SUFBQUMsS0FBQSxFQUVELFNBQUFLLFdBQVdBLENBQUEsRUFBRztNQUNWLElBQU1FLFVBQVUsR0FBR0osUUFBUSxDQUFDQyxjQUFjLENBQUMsT0FBTyxDQUFDO01BQ25ELElBQU1JLFNBQVMsR0FBR0wsUUFBUSxDQUFDQyxjQUFjLENBQUMsTUFBTSxDQUFDO01BQ2pERyxVQUFVLENBQUNFLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxVQUFTQyxDQUFDLEVBQUU7UUFDOUMsSUFBSUMsSUFBSSxHQUFHaEIsbURBQVEsQ0FBQ2UsQ0FBQyxDQUFDRSxNQUFNLENBQUNaLEtBQUssQ0FBQztRQUNuQ1EsU0FBUyxDQUFDUixLQUFLLEdBQUdXLElBQUk7TUFDMUIsQ0FBQyxDQUFDO0lBQ047RUFBQztJQUFBWixHQUFBO0lBQUFDLEtBQUEsRUFFRCxTQUFBTSxhQUFhQSxDQUFBLEVBQUc7TUFDWixJQUFNTyxXQUFXLEdBQUdWLFFBQVEsQ0FBQ0MsY0FBYyxDQUFDLGNBQWMsQ0FBQztNQUMzRCxJQUFNRSxhQUFhLEdBQUdILFFBQVEsQ0FBQ0MsY0FBYyxDQUFDLGdCQUFnQixDQUFDO01BRS9EUyxXQUFXLENBQUNKLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxVQUFDQyxDQUFDLEVBQUs7UUFDMUMsSUFBTUksSUFBSSxHQUFHSixDQUFDLENBQUNFLE1BQU0sQ0FBQ0csS0FBSyxDQUFDLENBQUMsQ0FBQztRQUM5QixJQUFNQyxPQUFPLEdBQUdWLGFBQWEsQ0FBQ1csYUFBYSxDQUFDLEtBQUssQ0FBQztRQUVsRCxJQUFHSCxJQUFJLElBQUlBLElBQUksQ0FBQ0ksSUFBSSxDQUFDQyxVQUFVLENBQUMsUUFBUSxDQUFDLEVBQUU7VUFDdkMsSUFBTUMsTUFBTSxHQUFHLElBQUlDLFVBQVUsQ0FBQyxDQUFDO1VBRS9CRCxNQUFNLENBQUNFLE1BQU0sR0FBRyxVQUFTQyxLQUFLLEVBQUU7WUFDNUJQLE9BQU8sQ0FBQ1EsR0FBRyxHQUFHRCxLQUFLLENBQUNYLE1BQU0sQ0FBQ2EsTUFBTTtZQUNqQ25CLGFBQWEsQ0FBQ29CLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLE9BQU87VUFDekMsQ0FBQztVQUVEUCxNQUFNLENBQUNRLGFBQWEsQ0FBQ2QsSUFBSSxDQUFDO1FBQzlCLENBQUMsTUFBTTtVQUNIRSxPQUFPLENBQUNRLEdBQUcsR0FBRyxFQUFFO1VBQ2hCbEIsYUFBYSxDQUFDb0IsS0FBSyxDQUFDQyxPQUFPLEdBQUcsTUFBTTtRQUN4QztNQUNKLENBQUMsQ0FBQztJQUNOO0VBQUM7QUFBQTtBQUdMLGlFQUFlL0IsT0FBTyIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9yZXNvdXJjZXMvanMvUGFuZWwvQXJ0aWNsZS5qcz9hZDcxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgICBtYWtlU2x1Z1xyXG59IGZyb20gXCIuL3V0aWxzLmpzXCI7XHJcblxyXG5jbGFzcyBBcnRpY2xlIHtcclxuICAgIGluaXQoKSB7XHJcbiAgICAgICAgY29uc3QgZm9ybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYXJ0aWNsZS1mb3JtXCIpO1xyXG4gICAgICAgIGlmKGZvcm0pIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzU2x1ZygpO1xyXG4gICAgICAgICAgICB0aGlzLmJhbm5lclByZXZpZXcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJvY2Vzc1NsdWcoKSB7XHJcbiAgICAgICAgY29uc3QgdGl0bGVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGl0bGVcIik7XHJcbiAgICAgICAgY29uc3Qgc2x1Z0lucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzbHVnXCIpO1xyXG4gICAgICAgIHRpdGxlSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGxldCBzbHVnID0gbWFrZVNsdWcoZS50YXJnZXQudmFsdWUpO1xyXG4gICAgICAgICAgICBzbHVnSW5wdXQudmFsdWUgPSBzbHVnO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgYmFubmVyUHJldmlldygpIHtcclxuICAgICAgICBjb25zdCBiYW5uZXJJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYmFubmVyLWltYWdlXCIpO1xyXG4gICAgICAgIGNvbnN0IGJhbm5lclByZXZpZXcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImJhbm5lci1wcmV2aWV3XCIpO1xyXG5cclxuICAgICAgICBiYW5uZXJJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBlLnRhcmdldC5maWxlc1swXTtcclxuICAgICAgICAgICAgY29uc3QgcHJldmlldyA9IGJhbm5lclByZXZpZXcucXVlcnlTZWxlY3RvcihcImltZ1wiKTtcclxuXHJcbiAgICAgICAgICAgIGlmKGZpbGUgJiYgZmlsZS50eXBlLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmlldy5zcmMgPSBldmVudC50YXJnZXQucmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJhbm5lclByZXZpZXcuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHByZXZpZXcuc3JjID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGJhbm5lclByZXZpZXcuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQXJ0aWNsZTtcclxuIl0sIm5hbWVzIjpbIm1ha2VTbHVnIiwiQXJ0aWNsZSIsIl9jbGFzc0NhbGxDaGVjayIsIl9jcmVhdGVDbGFzcyIsImtleSIsInZhbHVlIiwiaW5pdCIsImZvcm0iLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwicHJvY2Vzc1NsdWciLCJiYW5uZXJQcmV2aWV3IiwidGl0bGVJbnB1dCIsInNsdWdJbnB1dCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwic2x1ZyIsInRhcmdldCIsImJhbm5lcklucHV0IiwiZmlsZSIsImZpbGVzIiwicHJldmlldyIsInF1ZXJ5U2VsZWN0b3IiLCJ0eXBlIiwic3RhcnRzV2l0aCIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJldmVudCIsInNyYyIsInJlc3VsdCIsInN0eWxlIiwiZGlzcGxheSIsInJlYWRBc0RhdGFVUkwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/Panel/Article.js\n\n}");

/***/ }),

/***/ "./resources/js/Panel/Components/Accordion.js":
/*!****************************************************!*\
  !*** ./resources/js/Panel/Components/Accordion.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var bootstrap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bootstrap */ \"./node_modules/bootstrap/dist/js/bootstrap.esm.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar Accordion = /*#__PURE__*/function () {\n  function Accordion() {\n    _classCallCheck(this, Accordion);\n  }\n  return _createClass(Accordion, [{\n    key: \"init\",\n    value: function init() {\n      this.processAccordions();\n    }\n  }, {\n    key: \"processAccordions\",\n    value: function processAccordions() {\n      var accordions = document.querySelectorAll(\".accordion\");\n      var self = this;\n      if (accordions.length > 0) {\n        accordions.forEach(function (accordion) {\n          self.initiateAccordion(accordion);\n        });\n      }\n    }\n  }, {\n    key: \"initiateAccordion\",\n    value: function initiateAccordion(accordion) {\n      var header = accordion.querySelector(\".accordion-header\");\n      var body = accordion.querySelector(\".accordion-body\");\n      var collapse = new bootstrap__WEBPACK_IMPORTED_MODULE_0__.Collapse(body, {\n        toggle: false\n      });\n      header.addEventListener(\"click\", function () {\n        collapse.toggle();\n      });\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Accordion);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvUGFuZWwvQ29tcG9uZW50cy9BY2NvcmRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBcUM7QUFBQSxJQUUvQkMsU0FBUztFQUFBLFNBQUFBLFVBQUE7SUFBQUMsZUFBQSxPQUFBRCxTQUFBO0VBQUE7RUFBQSxPQUFBRSxZQUFBLENBQUFGLFNBQUE7SUFBQUcsR0FBQTtJQUFBQyxLQUFBLEVBQ1gsU0FBQUMsSUFBSUEsQ0FBQSxFQUFHO01BQ0gsSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQzVCO0VBQUM7SUFBQUgsR0FBQTtJQUFBQyxLQUFBLEVBRUQsU0FBQUUsaUJBQWlCQSxDQUFBLEVBQUc7TUFDaEIsSUFBTUMsVUFBVSxHQUFHQyxRQUFRLENBQUNDLGdCQUFnQixDQUFDLFlBQVksQ0FBQztNQUMxRCxJQUFNQyxJQUFJLEdBQUcsSUFBSTtNQUNqQixJQUFHSCxVQUFVLENBQUNJLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFDdEJKLFVBQVUsQ0FBQ0ssT0FBTyxDQUFDLFVBQUFDLFNBQVMsRUFBSTtVQUM1QkgsSUFBSSxDQUFDSSxpQkFBaUIsQ0FBQ0QsU0FBUyxDQUFDO1FBQ3JDLENBQUMsQ0FBQztNQUNOO0lBQ0o7RUFBQztJQUFBVixHQUFBO0lBQUFDLEtBQUEsRUFFRCxTQUFBVSxpQkFBaUJBLENBQUNELFNBQVMsRUFBRTtNQUN6QixJQUFNRSxNQUFNLEdBQUdGLFNBQVMsQ0FBQ0csYUFBYSxDQUFDLG1CQUFtQixDQUFDO01BQzNELElBQU1DLElBQUksR0FBR0osU0FBUyxDQUFDRyxhQUFhLENBQUMsaUJBQWlCLENBQUM7TUFDdkQsSUFBTUUsUUFBUSxHQUFHLElBQUluQiwrQ0FBUSxDQUFDa0IsSUFBSSxFQUFFO1FBQ2hDRSxNQUFNLEVBQUU7TUFDWixDQUFDLENBQUM7TUFFRkosTUFBTSxDQUFDSyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsWUFBTTtRQUNuQ0YsUUFBUSxDQUFDQyxNQUFNLENBQUMsQ0FBQztNQUNyQixDQUFDLENBQUM7SUFDTjtFQUFDO0FBQUE7QUFHTCxpRUFBZW5CLFNBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vcmVzb3VyY2VzL2pzL1BhbmVsL0NvbXBvbmVudHMvQWNjb3JkaW9uLmpzPzY4NmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29sbGFwc2UgfSBmcm9tIFwiYm9vdHN0cmFwXCI7XHJcblxyXG5jbGFzcyBBY2NvcmRpb24ge1xyXG4gICAgaW5pdCgpIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NBY2NvcmRpb25zKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvY2Vzc0FjY29yZGlvbnMoKSB7XHJcbiAgICAgICAgY29uc3QgYWNjb3JkaW9ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYWNjb3JkaW9uXCIpO1xyXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGlmKGFjY29yZGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBhY2NvcmRpb25zLmZvckVhY2goYWNjb3JkaW9uID0+IHtcclxuICAgICAgICAgICAgICAgIHNlbGYuaW5pdGlhdGVBY2NvcmRpb24oYWNjb3JkaW9uKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdGlhdGVBY2NvcmRpb24oYWNjb3JkaW9uKSB7XHJcbiAgICAgICAgY29uc3QgaGVhZGVyID0gYWNjb3JkaW9uLnF1ZXJ5U2VsZWN0b3IoXCIuYWNjb3JkaW9uLWhlYWRlclwiKTtcclxuICAgICAgICBjb25zdCBib2R5ID0gYWNjb3JkaW9uLnF1ZXJ5U2VsZWN0b3IoXCIuYWNjb3JkaW9uLWJvZHlcIik7XHJcbiAgICAgICAgY29uc3QgY29sbGFwc2UgPSBuZXcgQ29sbGFwc2UoYm9keSwge1xyXG4gICAgICAgICAgICB0b2dnbGU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGhlYWRlci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb2xsYXBzZS50b2dnbGUoKTtcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBY2NvcmRpb247XHJcbiJdLCJuYW1lcyI6WyJDb2xsYXBzZSIsIkFjY29yZGlvbiIsIl9jbGFzc0NhbGxDaGVjayIsIl9jcmVhdGVDbGFzcyIsImtleSIsInZhbHVlIiwiaW5pdCIsInByb2Nlc3NBY2NvcmRpb25zIiwiYWNjb3JkaW9ucyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsInNlbGYiLCJsZW5ndGgiLCJmb3JFYWNoIiwiYWNjb3JkaW9uIiwiaW5pdGlhdGVBY2NvcmRpb24iLCJoZWFkZXIiLCJxdWVyeVNlbGVjdG9yIiwiYm9keSIsImNvbGxhcHNlIiwidG9nZ2xlIiwiYWRkRXZlbnRMaXN0ZW5lciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/Panel/Components/Accordion.js\n\n}");

/***/ }),

/***/ "./resources/js/Panel/Primitives.js":
/*!******************************************!*\
  !*** ./resources/js/Panel/Primitives.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Primitives = /*#__PURE__*/function () {\n  function Primitives() {\n    _classCallCheck(this, Primitives);\n  }\n  return _createClass(Primitives, [{\n    key: \"init\",\n    value: function init() {\n      this.handleAlerts();\n    }\n  }, {\n    key: \"handleAlerts\",\n    value: function handleAlerts() {\n      var alerts = document.querySelectorAll(\".alert\");\n      if (alerts) {\n        alerts.forEach(function (alert) {\n          alert.querySelector(\".alert-dismissable\").addEventListener(\"click\", function () {\n            alert.remove();\n          });\n        });\n      }\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Primitives);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvUGFuZWwvUHJpbWl0aXZlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0lBQU1BLFVBQVU7RUFBQSxTQUFBQSxXQUFBO0lBQUFDLGVBQUEsT0FBQUQsVUFBQTtFQUFBO0VBQUEsT0FBQUUsWUFBQSxDQUFBRixVQUFBO0lBQUFHLEdBQUE7SUFBQUMsS0FBQSxFQUNaLFNBQUFDLElBQUlBLENBQUEsRUFBRztNQUNILElBQUksQ0FBQ0MsWUFBWSxDQUFDLENBQUM7SUFDdkI7RUFBQztJQUFBSCxHQUFBO0lBQUFDLEtBQUEsRUFFRCxTQUFBRSxZQUFZQSxDQUFBLEVBQUc7TUFDWCxJQUFNQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQ0MsZ0JBQWdCLENBQUMsUUFBUSxDQUFDO01BQ2xELElBQUdGLE1BQU0sRUFBRTtRQUNQQSxNQUFNLENBQUNHLE9BQU8sQ0FBQyxVQUFDQyxLQUFLLEVBQUs7VUFDdEJBLEtBQUssQ0FBQ0MsYUFBYSxDQUFDLG9CQUFvQixDQUFDLENBQUNDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxZQUFNO1lBQ3RFRixLQUFLLENBQUNHLE1BQU0sQ0FBQyxDQUFDO1VBQ2xCLENBQUMsQ0FBQztRQUNOLENBQUMsQ0FBQztNQUNOO0lBQ0o7RUFBQztBQUFBO0FBR0wsaUVBQWVkLFVBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9odG1sLy4vcmVzb3VyY2VzL2pzL1BhbmVsL1ByaW1pdGl2ZXMuanM/Mzg4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBQcmltaXRpdmVzIHtcclxuICAgIGluaXQoKSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVBbGVydHMoKTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVBbGVydHMoKSB7XHJcbiAgICAgICAgY29uc3QgYWxlcnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5hbGVydFwiKTtcclxuICAgICAgICBpZihhbGVydHMpIHtcclxuICAgICAgICAgICAgYWxlcnRzLmZvckVhY2goKGFsZXJ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhbGVydC5xdWVyeVNlbGVjdG9yKFwiLmFsZXJ0LWRpc21pc3NhYmxlXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUHJpbWl0aXZlczsiXSwibmFtZXMiOlsiUHJpbWl0aXZlcyIsIl9jbGFzc0NhbGxDaGVjayIsIl9jcmVhdGVDbGFzcyIsImtleSIsInZhbHVlIiwiaW5pdCIsImhhbmRsZUFsZXJ0cyIsImFsZXJ0cyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJhbGVydCIsInF1ZXJ5U2VsZWN0b3IiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/Panel/Primitives.js\n\n}");

/***/ }),

/***/ "./resources/js/Panel/default.js":
/*!***************************************!*\
  !*** ./resources/js/Panel/default.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   panel: () => (/* binding */ panel)\n/* harmony export */ });\nvar panel = {\n  isMobile: function isMobile() {\n    return window.innerWidth <= 768;\n  },\n  toggleMenu: function toggleMenu() {\n    var isMobile = panel.isMobile;\n    panel.menuToggle.addEventListener('click', function () {\n      if (isMobile()) {\n        panel.sidebar.classList.toggle('mobile-open');\n        panel.sidebarOverlay.classList.toggle('active');\n      } else {\n        panel.sidebar.classList.toggle('collapsed');\n        panel.mainContent.classList.toggle('expanded');\n      }\n    });\n    panel.sidebarOverlay.addEventListener('click', function () {\n      panel.sidebar.classList.remove('mobile-open');\n      panel.sidebarOverlay.classList.remove('active');\n    });\n    window.addEventListener('resize', function () {\n      if (!isMobile()) {\n        panel.sidebar.classList.remove('mobile-open');\n        panel.sidebarOverlay.classList.remove('active');\n      }\n    });\n  },\n  setupUserDropdown: function setupUserDropdown() {\n    panel.userAvatar.addEventListener('click', function (e) {\n      e.stopPropagation();\n      panel.userDropdown.classList.toggle('active');\n    });\n    document.addEventListener('click', function () {\n      panel.userDropdown.classList.remove('active');\n    });\n    panel.userDropdown.addEventListener('click', function (e) {\n      e.stopPropagation();\n    });\n  },\n  setupSubmenus: function setupSubmenus() {\n    document.querySelectorAll('[data-submenu]').forEach(function (link) {\n      link.addEventListener('click', function (e) {\n        e.preventpanel();\n        var submenuId = this.getAttribute('data-submenu') + '-submenu';\n        var submenu = document.getElementById(submenuId);\n        var parentItem = this.closest('.nav-item');\n        submenu.classList.toggle('active');\n        parentItem.classList.toggle('expanded');\n      });\n    });\n  },\n  setupActiveNavLinks: function setupActiveNavLinks() {\n    document.querySelectorAll('.sidebar-nav .nav-link').forEach(function (link) {\n      link.addEventListener('click', function (e) {\n        if (this.hasAttribute('data-submenu')) return;\n        document.querySelectorAll('.sidebar-nav .nav-link').forEach(function (l) {\n          l.classList.remove('active');\n        });\n        this.classList.add('active');\n        if (panel.isMobile()) {\n          panel.sidebar.classList.remove('mobile-open');\n          panel.sidebarOverlay.classList.remove('active');\n        }\n      });\n    });\n  },\n  init: function init() {\n    // DOM Elements\n    panel.menuToggle = document.getElementById('menuToggle');\n    panel.sidebar = document.getElementById('sidebar');\n    panel.mainContent = document.getElementById('app');\n    panel.sidebarOverlay = document.getElementById('sidebarOverlay');\n    panel.userAvatar = document.getElementById('userAvatar');\n    panel.userDropdown = document.getElementById('userDropdown');\n    panel.toggleMenu();\n    panel.setupUserDropdown();\n    panel.setupSubmenus();\n    panel.setupActiveNavLinks();\n\n    // Set global scroll behavior\n    document.documentElement.style.scrollBehavior = 'smooth';\n    console.log('Custom Admin Panel Loaded Successfully!');\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YyxDQUFDLFlBQVksQ0FBQztJQUN4RDNCLEtBQUssQ0FBQ08sT0FBTyxHQUFHVyxRQUFRLENBQUNTLGNBQWMsQ0FBQyxTQUFTLENBQUM7SUFDbEQzQixLQUFLLENBQUNXLFdBQVcsR0FBR08sUUFBUSxDQUFDUyxjQUFjLENBQUMsS0FBSyxDQUFDO0lBQ2xEM0IsS0FBSyxDQUFDVSxjQUFjLEdBQUdRLFFBQVEsQ0FBQ1MsY0FBYyxDQUFDLGdCQUFnQixDQUFDO0lBQ2hFM0IsS0FBSyxDQUFDYyxVQUFVLEdBQUdJLFFBQVEsQ0FBQ1MsY0FBYyxDQUFDLFlBQVksQ0FBQztJQUN4RDNCLEtBQUssQ0FBQ2lCLFlBQVksR0FBR0MsUUFBUSxDQUFDUyxjQUFjLENBQUMsY0FBYyxDQUFDO0lBRTVEM0IsS0FBSyxDQUFDSSxVQUFVLENBQUMsQ0FBQztJQUNsQkosS0FBSyxDQUFDYSxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3pCYixLQUFLLENBQUNtQixhQUFhLENBQUMsQ0FBQztJQUNyQm5CLEtBQUssQ0FBQzhCLG1CQUFtQixDQUFDLENBQUM7O0lBRTNCO0lBQ0FaLFFBQVEsQ0FBQ2lCLGVBQWUsQ0FBQ0MsS0FBSyxDQUFDQyxjQUFjLEdBQUcsUUFBUTtJQUV4REMsT0FBTyxDQUFDQyxHQUFHLENBQUMseUNBQXlDLENBQUM7RUFDMUQ7QUFDSixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL3Jlc291cmNlcy9qcy9QYW5lbC9kZWZhdWx0LmpzPzIzMzciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHBhbmVsID0ge1xyXG4gICAgaXNNb2JpbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoIDw9IDc2ODtcclxuICAgIH0sXHJcblxyXG4gICAgdG9nZ2xlTWVudSgpIHtcclxuICAgICAgICBjb25zdCB7IGlzTW9iaWxlIH0gPSBwYW5lbDtcclxuXHJcbiAgICAgICAgcGFuZWwubWVudVRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGlzTW9iaWxlKCkpIHtcclxuICAgICAgICAgICAgICAgIHBhbmVsLnNpZGViYXIuY2xhc3NMaXN0LnRvZ2dsZSgnbW9iaWxlLW9wZW4nKTtcclxuICAgICAgICAgICAgICAgIHBhbmVsLnNpZGViYXJPdmVybGF5LmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFuZWwuc2lkZWJhci5jbGFzc0xpc3QudG9nZ2xlKCdjb2xsYXBzZWQnKTtcclxuICAgICAgICAgICAgICAgIHBhbmVsLm1haW5Db250ZW50LmNsYXNzTGlzdC50b2dnbGUoJ2V4cGFuZGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcGFuZWwuc2lkZWJhck92ZXJsYXkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHBhbmVsLnNpZGViYXIuY2xhc3NMaXN0LnJlbW92ZSgnbW9iaWxlLW9wZW4nKTtcclxuICAgICAgICAgICAgcGFuZWwuc2lkZWJhck92ZXJsYXkuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNNb2JpbGUoKSkge1xyXG4gICAgICAgICAgICAgICAgcGFuZWwuc2lkZWJhci5jbGFzc0xpc3QucmVtb3ZlKCdtb2JpbGUtb3BlbicpO1xyXG4gICAgICAgICAgICAgICAgcGFuZWwuc2lkZWJhck92ZXJsYXkuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0dXBVc2VyRHJvcGRvd24oKSB7XHJcbiAgICAgICAgcGFuZWwudXNlckF2YXRhci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIHBhbmVsLnVzZXJEcm9wZG93bi5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHBhbmVsLnVzZXJEcm9wZG93bi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcGFuZWwudXNlckRyb3Bkb3duLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgc2V0dXBTdWJtZW51cygpIHtcclxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zdWJtZW51XScpLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcclxuICAgICAgICAgICAgbGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnRwYW5lbCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3VibWVudUlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3VibWVudScpICsgJy1zdWJtZW51JztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN1Ym1lbnUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzdWJtZW51SWQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50SXRlbSA9IHRoaXMuY2xvc2VzdCgnLm5hdi1pdGVtJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgc3VibWVudS5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudEl0ZW0uY2xhc3NMaXN0LnRvZ2dsZSgnZXhwYW5kZWQnKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldHVwQWN0aXZlTmF2TGlua3MoKSB7XHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnNpZGViYXItbmF2IC5uYXYtbGluaycpLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcclxuICAgICAgICAgICAgbGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2RhdGEtc3VibWVudScpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnNpZGViYXItbmF2IC5uYXYtbGluaycpLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocGFuZWwuaXNNb2JpbGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhbmVsLnNpZGViYXIuY2xhc3NMaXN0LnJlbW92ZSgnbW9iaWxlLW9wZW4nKTtcclxuICAgICAgICAgICAgICAgICAgICBwYW5lbC5zaWRlYmFyT3ZlcmxheS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGluaXQoKSB7XHJcbiAgICAgICAgLy8gRE9NIEVsZW1lbnRzXHJcbiAgICAgICAgcGFuZWwubWVudVRvZ2dsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtZW51VG9nZ2xlJyk7XHJcbiAgICAgICAgcGFuZWwuc2lkZWJhciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaWRlYmFyJyk7XHJcbiAgICAgICAgcGFuZWwubWFpbkNvbnRlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwJyk7XHJcbiAgICAgICAgcGFuZWwuc2lkZWJhck92ZXJsYXkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2lkZWJhck92ZXJsYXknKTtcclxuICAgICAgICBwYW5lbC51c2VyQXZhdGFyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3VzZXJBdmF0YXInKTtcclxuICAgICAgICBwYW5lbC51c2VyRHJvcGRvd24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndXNlckRyb3Bkb3duJyk7XHJcblxyXG4gICAgICAgIHBhbmVsLnRvZ2dsZU1lbnUoKTtcclxuICAgICAgICBwYW5lbC5zZXR1cFVzZXJEcm9wZG93bigpO1xyXG4gICAgICAgIHBhbmVsLnNldHVwU3VibWVudXMoKTtcclxuICAgICAgICBwYW5lbC5zZXR1cEFjdGl2ZU5hdkxpbmtzKCk7XHJcblxyXG4gICAgICAgIC8vIFNldCBnbG9iYWwgc2Nyb2xsIGJlaGF2aW9yXHJcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gJ3Ntb290aCc7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdDdXN0b20gQWRtaW4gUGFuZWwgTG9hZGVkIFN1Y2Nlc3NmdWxseSEnKTtcclxuICAgIH1cclxufTtcclxuXHJcbiJdLCJuYW1lcyI6WyJwYW5lbCIsImlzTW9iaWxlIiwid2luZG93IiwiaW5uZXJXaWR0aCIsInRvZ2dsZU1lbnUiLCJtZW51VG9nZ2xlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNpZGViYXIiLCJjbGFzc0xpc3QiLCJ0b2dnbGUiLCJzaWRlYmFyT3ZlcmxheSIsIm1haW5Db250ZW50IiwicmVtb3ZlIiwic2V0dXBVc2VyRHJvcGRvd24iLCJ1c2VyQXZhdGFyIiwiZSIsInN0b3BQcm9wYWdhdGlvbiIsInVzZXJEcm9wZG93biIsImRvY3VtZW50Iiwic2V0dXBTdWJtZW51cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwibGluayIsInByZXZlbnRwYW5lbCIsInN1Ym1lbnVJZCIsImdldEF0dHJpYnV0ZSIsInN1Ym1lbnUiLCJnZXRFbGVtZW50QnlJZCIsInBhcmVudEl0ZW0iLCJjbG9zZXN0Iiwic2V0dXBBY3RpdmVOYXZMaW5rcyIsImhhc0F0dHJpYnV0ZSIsImwiLCJhZGQiLCJpbml0IiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJzY3JvbGxCZWhhdmlvciIsImNvbnNvbGUiLCJsb2ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/Panel/default.js\n\n}");

/***/ }),

/***/ "./resources/js/Panel/utils.js":
/*!*************************************!*\
  !*** ./resources/js/Panel/utils.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeSlug: () => (/* binding */ makeSlug)\n/* harmony export */ });\nfunction makeSlug(text) {\n  text = text.toLowerCase();\n  text = text.replaceAll(\" \", \"-\");\n  return text;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvUGFuZWwvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLFNBQVNBLFFBQVFBLENBQUNDLElBQUksRUFBRTtFQUMzQkEsSUFBSSxHQUFHQSxJQUFJLENBQUNDLFdBQVcsQ0FBQyxDQUFDO0VBQ3pCRCxJQUFJLEdBQUdBLElBQUksQ0FBQ0UsVUFBVSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUM7RUFFaEMsT0FBT0YsSUFBSTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHRtbC8uL3Jlc291cmNlcy9qcy9QYW5lbC91dGlscy5qcz9lYzg0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBtYWtlU2x1Zyh0ZXh0KSB7XHJcbiAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbChcIiBcIiwgXCItXCIpO1xyXG5cclxuICAgIHJldHVybiB0ZXh0O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJtYWtlU2x1ZyIsInRleHQiLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2VBbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/Panel/utils.js\n\n}");

/***/ }),

/***/ "./resources/js/panel.js":
/*!*******************************!*\
  !*** ./resources/js/panel.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Panel_default_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Panel/default.js */ \"./resources/js/Panel/default.js\");\n/* harmony import */ var _Editor_BlockEditor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Editor/BlockEditor */ \"./resources/js/Editor/BlockEditor.js\");\n/* harmony import */ var _Panel_Article_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Panel/Article.js */ \"./resources/js/Panel/Article.js\");\n/* harmony import */ var _Panel_Components_Accordion_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Panel/Components/Accordion.js */ \"./resources/js/Panel/Components/Accordion.js\");\n/* harmony import */ var _Panel_Primitives_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Panel/Primitives.js */ \"./resources/js/Panel/Primitives.js\");\n\n\n\n\n\n\n// Initiate Panel\n// Run after DOM Loaded\ndocument.addEventListener(\"DOMContentLoaded\", _Panel_default_js__WEBPACK_IMPORTED_MODULE_0__.panel.init);\n\n// const accordion = new Accordion();\n// accordion.init();\n\nvar primitives = new _Panel_Primitives_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]();\nprimitives.init();\n\n// Editor JS Setup\nvar content = document.getElementById(\"editor-content\");\nvar editor = new _Editor_BlockEditor__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"editor-container\", {\n  onChange: function onChange(data) {\n    content.value = JSON.stringify(data);\n  }\n});\neditor.attachContentHandler(content);\n\n// Initiate operations in article module\nvar article = new _Panel_Article_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\narticle.init();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvcGFuZWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBDO0FBQ0s7QUFDTjtBQUNlO0FBQ1Q7O0FBRS9DO0FBQ0E7QUFDQUssUUFBUSxDQUFDQyxnQkFBZ0IsQ0FBQyxrQkFBa0IsRUFBRU4sb0RBQUssQ0FBQ08sSUFBSSxDQUFDOztBQUV6RDtBQUNBOztBQUVBLElBQU1DLFVBQVUsR0FBRyxJQUFJSiw0REFBVSxDQUFDLENBQUM7QUFDbkNJLFVBQVUsQ0FBQ0QsSUFBSSxDQUFDLENBQUM7O0FBRWpCO0FBQ0EsSUFBTUUsT0FBTyxHQUFHSixRQUFRLENBQUNLLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQztBQUN6RCxJQUFNQyxNQUFNLEdBQUcsSUFBSVYsMkRBQVcsQ0FBQyxrQkFBa0IsRUFBRTtFQUMvQ1csUUFBUSxFQUFFLFNBQVZBLFFBQVFBLENBQVdDLElBQUksRUFBRTtJQUNyQkosT0FBTyxDQUFDSyxLQUFLLEdBQUdDLElBQUksQ0FBQ0MsU0FBUyxDQUFDSCxJQUFJLENBQUM7RUFDeEM7QUFDSixDQUFDLENBQUM7QUFDRkYsTUFBTSxDQUFDTSxvQkFBb0IsQ0FBQ1IsT0FBTyxDQUFDOztBQUVwQztBQUNBLElBQU1TLE9BQU8sR0FBRyxJQUFJaEIseURBQU8sQ0FBQyxDQUFDO0FBQzdCZ0IsT0FBTyxDQUFDWCxJQUFJLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2h0bWwvLi9yZXNvdXJjZXMvanMvcGFuZWwuanM/YTA2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYW5lbCB9IGZyb20gXCIuL1BhbmVsL2RlZmF1bHQuanNcIlxyXG5pbXBvcnQgQmxvY2tFZGl0b3IgZnJvbSBcIi4vRWRpdG9yL0Jsb2NrRWRpdG9yXCI7XHJcbmltcG9ydCBBcnRpY2xlIGZyb20gXCIuL1BhbmVsL0FydGljbGUuanNcIjtcclxuaW1wb3J0IEFjY29yZGlvbiBmcm9tIFwiLi9QYW5lbC9Db21wb25lbnRzL0FjY29yZGlvbi5qc1wiO1xyXG5pbXBvcnQgUHJpbWl0aXZlcyBmcm9tIFwiLi9QYW5lbC9QcmltaXRpdmVzLmpzXCI7XHJcblxyXG4vLyBJbml0aWF0ZSBQYW5lbFxyXG4vLyBSdW4gYWZ0ZXIgRE9NIExvYWRlZFxyXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBwYW5lbC5pbml0KTtcclxuXHJcbi8vIGNvbnN0IGFjY29yZGlvbiA9IG5ldyBBY2NvcmRpb24oKTtcclxuLy8gYWNjb3JkaW9uLmluaXQoKTtcclxuXHJcbmNvbnN0IHByaW1pdGl2ZXMgPSBuZXcgUHJpbWl0aXZlcygpO1xyXG5wcmltaXRpdmVzLmluaXQoKTtcclxuXHJcbi8vIEVkaXRvciBKUyBTZXR1cFxyXG5jb25zdCBjb250ZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJlZGl0b3ItY29udGVudFwiKTtcclxuY29uc3QgZWRpdG9yID0gbmV3IEJsb2NrRWRpdG9yKFwiZWRpdG9yLWNvbnRhaW5lclwiLCB7XHJcbiAgICBvbkNoYW5nZTogZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgIGNvbnRlbnQudmFsdWUgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxuICAgIH1cclxufSk7XHJcbmVkaXRvci5hdHRhY2hDb250ZW50SGFuZGxlcihjb250ZW50KTtcclxuXHJcbi8vIEluaXRpYXRlIG9wZXJhdGlvbnMgaW4gYXJ0aWNsZSBtb2R1bGVcclxuY29uc3QgYXJ0aWNsZSA9IG5ldyBBcnRpY2xlKCk7XHJcbmFydGljbGUuaW5pdCgpO1xyXG4iXSwibmFtZXMiOlsicGFuZWwiLCJCbG9ja0VkaXRvciIsIkFydGljbGUiLCJBY2NvcmRpb24iLCJQcmltaXRpdmVzIiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiaW5pdCIsInByaW1pdGl2ZXMiLCJjb250ZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJlZGl0b3IiLCJvbkNoYW5nZSIsImRhdGEiLCJ2YWx1ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJhdHRhY2hDb250ZW50SGFuZGxlciIsImFydGljbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/panel.js\n\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/public/resources/js/panel": 0,
/******/ 			"public/resources/css/auth": 0,
/******/ 			"public/resources/css/panel": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkhtml"] = self["webpackChunkhtml"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["public/resources/css/auth","public/resources/css/panel"], () => (__webpack_require__("./resources/js/panel.js")))
/******/ 	__webpack_require__.O(undefined, ["public/resources/css/auth","public/resources/css/panel"], () => (__webpack_require__("./resources/css/panel.scss")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["public/resources/css/auth","public/resources/css/panel"], () => (__webpack_require__("./resources/css/auth.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;